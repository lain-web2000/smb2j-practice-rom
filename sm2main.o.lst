ca65 V2.18 - Ubuntu 2.19-1
Main file   : sm2main.asm
Current file: sm2main.asm

000000r 1               .include "defines.inc"
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;DEFINES
000000r 2               
000000r 2               ;NES specific hardware defines
000000r 2               
000000r 2               PPU_CTRL              = $2000
000000r 2               PPU_CTRL_REG1         = $2000
000000r 2               PPU_MASK              = $2001
000000r 2               PPU_CTRL_REG2         = $2001
000000r 2               PPU_STATUS            = $2002
000000r 2               PPU_SPR_ADDR          = $2003
000000r 2               PPU_SPR_DATA          = $2004
000000r 2               PPU_SCROLL            = $2005
000000r 2               PPU_SCROLL_REG        = $2005
000000r 2               PPU_ADDRESS           = $2006
000000r 2               PPU_DATA              = $2007
000000r 2               
000000r 2               SND_REGISTER          = $4000
000000r 2               SND_SQUARE1_REG       = $4000
000000r 2               SND_SQUARE2_REG       = $4004
000000r 2               SND_TRIANGLE_REG      = $4008
000000r 2               SND_NOISE_REG         = $400c
000000r 2               SND_DELTA_REG         = $4010
000000r 2               SND_MASTERCTRL_REG    = $4015
000000r 2               
000000r 2               SPR_DMA               = $4014
000000r 2               JOYPAD_PORT           = $4016
000000r 2               JOYPAD_PORT1          = $4016
000000r 2               JOYPAD_PORT2          = $4017
000000r 2               
000000r 2               ; GAME SPECIFIC DEFINES
000000r 2               
000000r 2               ObjectOffset          = $08
000000r 2               
000000r 2               FrameCounter          = $09
000000r 2               
000000r 2               SavedJoypadBits       = $06fc
000000r 2               SavedJoypad1Bits      = $06fc
000000r 2               SavedJoypad2Bits      = $06fd
000000r 2               JoypadBitMask         = $074a
000000r 2               JoypadOverride        = $0758
000000r 2               
000000r 2               A_B_Buttons           = $0a
000000r 2               PreviousA_B_Buttons   = $0d
000000r 2               Up_Down_Buttons       = $0b
000000r 2               Left_Right_Buttons    = $0c
000000r 2               
000000r 2               GameEngineSubroutine  = $0e
000000r 2               
000000r 2               Mirror_PPU_CTRL       = $0778
000000r 2               Mirror_PPU_CTRL_REG1  = $0778
000000r 2               Mirror_PPU_MASK       = $0779
000000r 2               Mirror_PPU_CTRL_REG2  = $0779
000000r 2               Mirror_FDS_CTRL_REG   = $fa
000000r 2               NameTableSelect       = $077a
000000r 2               FileListNumber        = $07f7
000000r 2               
000000r 2               OperMode              = $0770
000000r 2               OperMode_Task         = $0772
000000r 2               ScreenRoutineTask     = $073c
000000r 2               
000000r 2               DiskIOTask            = $07fc
000000r 2               NotColdFlag           = $07fd
000000r 2               
000000r 2               GamePauseStatus       = $0776
000000r 2               GamePauseTimer        = $0777
000000r 2               
000000r 2               DemoAction            = $0717
000000r 2               DemoActionTimer       = $0718
000000r 2               
000000r 2               TimerControl          = $0747
000000r 2               IntervalTimerControl  = $077f
000000r 2               
000000r 2               Timers                = $0780
000000r 2               SelectTimer           = $0780
000000r 2               PlayerAnimTimer       = $0781
000000r 2               JumpSwimTimer         = $0782
000000r 2               RunningTimer          = $0783
000000r 2               BlockBounceTimer      = $0784
000000r 2               SideCollisionTimer    = $0785
000000r 2               JumpspringTimer       = $0786
000000r 2               GameTimerCtrlTimer    = $0787
000000r 2               ClimbSideTimer        = $0789
000000r 2               EnemyFrameTimer       = $078a
000000r 2               FrenzyEnemyTimer      = $078f
000000r 2               BowserFireBreathTimer = $0790
000000r 2               StompTimer            = $0791
000000r 2               AirBubbleTimer        = $0792
000000r 2               ScrollIntervalTimer   = $0795
000000r 2               EnemyIntervalTimer    = $0796
000000r 2               BrickCoinTimer        = $079d
000000r 2               InjuryTimer           = $079e
000000r 2               StarInvincibleTimer   = $079f
000000r 2               ScreenTimer           = $07a0
000000r 2               WorldEndTimer         = $07a1
000000r 2               DemoTimer             = $07a2
000000r 2               FantasyW9MsgFlag      = $07f5
000000r 2               
000000r 2               SpriteLen = $4
000000r 2               Sprite_Data           = $0200
000000r 2               Sprite_Y_Position     = $0200
000000r 2               Sprite_Tilenumber     = $0201
000000r 2               Sprite_Attributes     = $0202
000000r 2               Sprite_X_Position     = $0203
000000r 2               
000000r 2               ScreenEdge_PageLoc    = $071a
000000r 2               ScreenEdge_X_Pos      = $071c
000000r 2               ScreenLeft_PageLoc    = $071a
000000r 2               ScreenRight_PageLoc   = $071b
000000r 2               ScreenLeft_X_Pos      = $071c
000000r 2               ScreenRight_X_Pos     = $071d
000000r 2               
000000r 2               PlayerFacingDir       = $33
000000r 2               DestinationPageLoc    = $34
000000r 2               VictoryWalkControl    = $35
000000r 2               ScrollFractional      = $0768
000000r 2               SecondaryMsgCounter   = $0749
000000r 2               MsgCounter            = $0719
000000r 2               MsgFractional         = $0749
000000r 2               
000000r 2               EndControlCntr        = $0761
000000r 2               BlueColorOfs          = $0762
000000r 2               BlueDelayFlag         = $0763
000000r 2               MushroomRetDelay      = $0764
000000r 2               MRetainerOffset       = $0762
000000r 2               CurrentFlashMRet      = $0763
000000r 2               
000000r 2               HorizontalScroll      = $073f
000000r 2               VerticalScroll        = $0740
000000r 2               ScrollLock            = $0723
000000r 2               ScrollThirtyTwo       = $073d
000000r 2               Player_X_Scroll       = $06ff
000000r 2               Player_Pos_ForScroll  = $0755
000000r 2               ScrollAmount          = $0775
000000r 2               
000000r 2               AreaData              = $e7
000000r 2               AreaDataLow           = $e7
000000r 2               AreaDataHigh          = $e8
000000r 2               EnemyData             = $e9
000000r 2               EnemyDataLow          = $e9
000000r 2               EnemyDataHigh         = $ea
000000r 2               AreaDataCopy          = $6010
000000r 2               EnemyDataCopy         = $6110
000000r 2               
000000r 2               AreaParserTaskNum     = $071f
000000r 2               ColumnSets            = $071e
000000r 2               CurrentPageLoc        = $0725
000000r 2               CurrentColumnPos      = $0726
000000r 2               BackloadingFlag       = $0728
000000r 2               BehindAreaParserFlag  = $0729
000000r 2               AreaObjectPageLoc     = $072a
000000r 2               AreaObjectPageSel     = $072b
000000r 2               AreaDataOffset        = $072c
000000r 2               AreaObjOffsetBuffer   = $072d
000000r 2               AreaObjectLength      = $0730
000000r 2               StaircaseControl      = $0734
000000r 2               AreaObjectHeight      = $0735
000000r 2               MushroomLedgeHalfLen  = $0736
000000r 2               EnemyDataOffset       = $0739
000000r 2               EnemyObjectPageLoc    = $073a
000000r 2               EnemyObjectPageSel    = $073b
000000r 2               MetatileBuffer        = $06a1
000000r 2               BlockBufferColumnPos  = $06a0
000000r 2               CurrentNTAddr_Low     = $0721
000000r 2               CurrentNTAddr_High    = $0720
000000r 2               AttributeBuffer       = $03f9
000000r 2               
000000r 2               LoopCommand           = $0745
000000r 2               
000000r 2               DisplayDigits         = $07d7
000000r 2               TopScoreDisplay       = $07d7
000000r 2               ScoreAndCoinDisplay   = $07dd
000000r 2               PlayerScoreDisplay    = $07dd
000000r 2               GameTimerDisplay      = $07ec
000000r 2               CoinDisplay           = $07e7
000000r 2               DigitModifier         = $0134
000000r 2               
000000r 2               VerticalFlipFlag      = $0109
000000r 2               FloateyNum_Control    = $0110
000000r 2               ShellChainCounter     = $0125
000000r 2               FloateyNum_Timer      = $012c
000000r 2               FloateyNum_X_Pos      = $0117
000000r 2               FloateyNum_Y_Pos      = $011e
000000r 2               FlagpoleFNum_Y_Pos    = $010d
000000r 2               FlagpoleFNum_YMFDummy = $010e
000000r 2               FlagpoleScore         = $010f
000000r 2               FlagpoleCollisionYPos = $070f
000000r 2               StompChainCounter     = $0484
000000r 2               FlagpoleMusicFlag     = $07f6
000000r 2               
000000r 2               VRAM_Buffer1_Offset   = $0300
000000r 2               VRAM_Buffer1          = $0301
000000r 2               VRAM_Buffer2_Offset   = $0340
000000r 2               VRAM_Buffer2          = $0341
000000r 2               VRAM_Buffer_AddrCtrl  = $0773
000000r 2               IRQAckFlag			  = $077b
000000r 2               IRQUpdateFlag  		  = $0722
000000r 2               DisableScreenFlag     = $0774
000000r 2               DisableIntermediate   = $0769
000000r 2               ColorRotateOffset     = $06d4
000000r 2               
000000r 2               TerrainControl        = $0727
000000r 2               AreaStyle             = $0733
000000r 2               ForegroundScenery     = $0741
000000r 2               BackgroundScenery     = $0742
000000r 2               CloudTypeOverride     = $0743
000000r 2               BackgroundColorCtrl   = $0744
000000r 2               AreaType              = $074e
000000r 2               AreaAddrsLOffset      = $074f
000000r 2               AreaPointer           = $0750
000000r 2               
000000r 2               PlayerEntranceCtrl    = $0710
000000r 2               GameTimerSetting      = $0715
000000r 2               AltEntranceControl    = $0752
000000r 2               EntrancePage          = $0751
000000r 2               WarpZoneControl       = $06d6
000000r 2               ChangeAreaTimer       = $06de
000000r 2               
000000r 2               MultiLoopCorrectCntr  = $06d9
000000r 2               MultiLoopPassCntr     = $06da
000000r 2               
000000r 2               FetchNewGameTimerFlag = $0757
000000r 2               GameTimerExpiredFlag  = $0759
000000r 2               
000000r 2               PrimaryHardMode       = $076a
000000r 2               SecondaryHardMode     = $06cc
000000r 2               WorldSelectNumber     = $076b
000000r 2               CompletedWorlds       = $07fa
000000r 2               HardWorldFlag         = $07fb
000000r 2               ContinueMenuSelect    = $07f8
000000r 2               
000000r 2               SelectedPlayer        = $0753
000000r 2               PlayerSize            = $0754
000000r 2               PlayerStatus          = $0756
000000r 2               
000000r 2               OnscreenPlayerInfo    = $075a
000000r 2               NumberofLives         = $075a ;used by current player
000000r 2               HalfwayPage           = $075b
000000r 2               LevelNumber           = $075c ;the actual dash number
000000r 2               Hidden1UpFlag         = $075d
000000r 2               CoinTally             = $075e
000000r 2               WorldNumber           = $075f
000000r 2               AreaNumber            = $0760 ;internal number used to find areas
000000r 2               
000000r 2               CoinTallyFor1Ups      = $0748
000000r 2               
000000r 2               BalPlatformAlignment  = $03a0
000000r 2               Platform_X_Scroll     = $03a1
000000r 2               PlatformCollisionFlag = $03a2
000000r 2               YPlatformTopYPos      = $0401
000000r 2               YPlatformCenterYPos   = $58
000000r 2               
000000r 2               BrickCoinTimerFlag    = $06bc
000000r 2               StarFlagTaskControl   = $0746
000000r 2               
000000r 2               PseudoRandomBitReg    = $07a7
000000r 2               WarmBootValidation    = $07ff
000000r 2               
000000r 2               SprShuffleAmtOffset   = $06e0
000000r 2               SprShuffleAmt         = $06e1
000000r 2               SprDataOffset         = $06e4
000000r 2               Player_SprDataOffset  = $06e4
000000r 2               Enemy_SprDataOffset   = $06e5
000000r 2               Block_SprDataOffset   = $06ec
000000r 2               Alt_SprDataOffset     = $06ec
000000r 2               Bubble_SprDataOffset  = $06ee
000000r 2               FBall_SprDataOffset   = $06f1
000000r 2               Misc_SprDataOffset    = $06f3
000000r 2               SprDataOffset_Ctrl    = $03ee
000000r 2               
000000r 2               Player_State          = $1d
000000r 2               Enemy_State           = $1e
000000r 2               Fireball_State        = $24
000000r 2               Block_State           = $26
000000r 2               Misc_State            = $2a
000000r 2               
000000r 2               Player_MovingDir      = $45
000000r 2               Enemy_MovingDir       = $46
000000r 2               
000000r 2               SprObject_X_Speed     = $57
000000r 2               Player_X_Speed        = $57
000000r 2               Enemy_X_Speed         = $58
000000r 2               Fireball_X_Speed      = $5e
000000r 2               Block_X_Speed         = $60
000000r 2               Misc_X_Speed          = $64
000000r 2               
000000r 2               Jumpspring_FixedYPos  = $58
000000r 2               JumpspringAnimCtrl    = $070e
000000r 2               JumpspringForce       = $06db
000000r 2               
000000r 2               SprObject_PageLoc     = $6d
000000r 2               Player_PageLoc        = $6d
000000r 2               Enemy_PageLoc         = $6e
000000r 2               Fireball_PageLoc      = $74
000000r 2               Block_PageLoc         = $76
000000r 2               Misc_PageLoc          = $7a
000000r 2               Bubble_PageLoc        = $83
000000r 2               
000000r 2               SprObject_X_Position  = $86
000000r 2               Player_X_Position     = $86
000000r 2               Enemy_X_Position      = $87
000000r 2               Fireball_X_Position   = $8d
000000r 2               Block_X_Position      = $8f
000000r 2               Misc_X_Position       = $93
000000r 2               Bubble_X_Position     = $9c
000000r 2               
000000r 2               SprObject_Y_Speed     = $9f
000000r 2               Player_Y_Speed        = $9f
000000r 2               Enemy_Y_Speed         = $a0
000000r 2               Fireball_Y_Speed      = $a6
000000r 2               Block_Y_Speed         = $a8
000000r 2               Misc_Y_Speed          = $ac
000000r 2               
000000r 2               SprObject_Y_HighPos   = $b5
000000r 2               Player_Y_HighPos      = $b5
000000r 2               Enemy_Y_HighPos       = $b6
000000r 2               Fireball_Y_HighPos    = $bc
000000r 2               Block_Y_HighPos       = $be
000000r 2               Misc_Y_HighPos        = $c2
000000r 2               Bubble_Y_HighPos      = $cb
000000r 2               
000000r 2               SprObject_Y_Position  = $ce
000000r 2               Player_Y_Position     = $ce
000000r 2               Enemy_Y_Position      = $cf
000000r 2               Fireball_Y_Position   = $d5
000000r 2               Block_Y_Position      = $d7
000000r 2               Misc_Y_Position       = $db
000000r 2               Bubble_Y_Position     = $e4
000000r 2               
000000r 2               SprObject_Rel_XPos    = $03ad
000000r 2               Player_Rel_XPos       = $03ad
000000r 2               Enemy_Rel_XPos        = $03ae
000000r 2               Fireball_Rel_XPos     = $03af
000000r 2               Bubble_Rel_XPos       = $03b0
000000r 2               Block_Rel_XPos        = $03b1
000000r 2               Misc_Rel_XPos         = $03b3
000000r 2               
000000r 2               SprObject_Rel_YPos    = $03b8
000000r 2               Player_Rel_YPos       = $03b8
000000r 2               Enemy_Rel_YPos        = $03b9
000000r 2               Fireball_Rel_YPos     = $03ba
000000r 2               Bubble_Rel_YPos       = $03bb
000000r 2               Block_Rel_YPos        = $03bc
000000r 2               Misc_Rel_YPos         = $03be
000000r 2               
000000r 2               SprObject_SprAttrib   = $03c4
000000r 2               Player_SprAttrib      = $03c4
000000r 2               Enemy_SprAttrib       = $03c5
000000r 2               
000000r 2               SprObject_X_MoveForce = $0400
000000r 2               Enemy_X_MoveForce     = $0401
000000r 2               
000000r 2               SprObject_YMF_Dummy   = $0416
000000r 2               Player_YMF_Dummy      = $0416
000000r 2               Enemy_YMF_Dummy       = $0417
000000r 2               Bubble_YMF_Dummy      = $042c
000000r 2               
000000r 2               SprObject_Y_MoveForce = $0433
000000r 2               Player_Y_MoveForce    = $0433
000000r 2               Enemy_Y_MoveForce     = $0434
000000r 2               Block_Y_MoveForce     = $043c
000000r 2               
000000r 2               DisableCollisionDet   = $0716
000000r 2               Player_CollisionBits  = $0490
000000r 2               Enemy_CollisionBits   = $0491
000000r 2               
000000r 2               SprObj_BoundBoxCtrl   = $0499
000000r 2               Player_BoundBoxCtrl   = $0499
000000r 2               Enemy_BoundBoxCtrl    = $049a
000000r 2               Fireball_BoundBoxCtrl = $04a0
000000r 2               Misc_BoundBoxCtrl     = $04a2
000000r 2               
000000r 2               EnemyFrenzyBuffer     = $06cb
000000r 2               EnemyFrenzyQueue      = $06cd
000000r 2               Enemy_Flag            = $0f
000000r 2               Enemy_ID              = $16
000000r 2               
000000r 2               PlayerGfxOffset       = $06d5
000000r 2               Player_XSpeedAbsolute = $0700
000000r 2               FrictionAdderHigh     = $0701
000000r 2               FrictionAdderLow      = $0702
000000r 2               RunningSpeed          = $0703
000000r 2               SwimmingFlag          = $0704
000000r 2               Player_X_MoveForce    = $0705
000000r 2               DiffToHaltJump        = $0706
000000r 2               JumpOrigin_Y_HighPos  = $0707
000000r 2               JumpOrigin_Y_Position = $0708
000000r 2               VerticalForce         = $0709
000000r 2               VerticalForceDown     = $070a
000000r 2               PlayerChangeSizeFlag  = $070b
000000r 2               PlayerAnimTimerSet    = $070c
000000r 2               PlayerAnimCtrl        = $070d
000000r 2               DeathMusicLoaded      = $0712
000000r 2               FlagpoleSoundQueue    = $0713
000000r 2               CrouchingFlag         = $0714
000000r 2               MaximumLeftSpeed      = $0450
000000r 2               MaximumRightSpeed     = $0456
000000r 2               
000000r 2               WindFlag              = $07f9
000000r 2               
000000r 2               SprObject_OffscrBits  = $03d0
000000r 2               Player_OffscreenBits  = $03d0
000000r 2               Enemy_OffscreenBits   = $03d1
000000r 2               FBall_OffscreenBits   = $03d2
000000r 2               Bubble_OffscreenBits  = $03d3
000000r 2               Block_OffscreenBits   = $03d4
000000r 2               Misc_OffscreenBits    = $03d6
000000r 2               EnemyOffscrBitsMasked = $03d8
000000r 2               
000000r 2               Cannon_Offset         = $046a
000000r 2               Cannon_PageLoc        = $046b
000000r 2               Cannon_X_Position     = $0471
000000r 2               Cannon_Y_Position     = $0477
000000r 2               Cannon_Timer          = $047d
000000r 2               
000000r 2               Whirlpool_Offset      = $046a
000000r 2               Whirlpool_PageLoc     = $046b
000000r 2               Whirlpool_LeftExtent  = $0471
000000r 2               Whirlpool_Length      = $0477
000000r 2               Whirlpool_Flag        = $047d
000000r 2               
000000r 2               VineFlagOffset        = $0398
000000r 2               VineHeight            = $0399
000000r 2               VineObjOffset         = $039a
000000r 2               VineStart_Y_Position  = $039d
000000r 2               
000000r 2               Block_Orig_YPos       = $03e4
000000r 2               Block_BBuf_Low        = $03e6
000000r 2               Block_Metatile        = $03e8
000000r 2               Block_PageLoc2        = $03ea
000000r 2               Block_RepFlag         = $03ec
000000r 2               Block_ResidualCounter = $03f0
000000r 2               Block_Orig_XPos       = $03f1
000000r 2               
000000r 2               BoundingBox_UL_XPos   = $04ac
000000r 2               BoundingBox_UL_YPos   = $04ad
000000r 2               BoundingBox_DR_XPos   = $04ae
000000r 2               BoundingBox_DR_YPos   = $04af
000000r 2               BoundingBox_UL_Corner = $04ac
000000r 2               BoundingBox_LR_Corner = $04ae
000000r 2               EnemyBoundingBoxCoord = $04b0
000000r 2               
000000r 2               PowerUpType           = $39
000000r 2               
000000r 2               FireballBouncingFlag  = $3a
000000r 2               FireballCounter       = $06ce
000000r 2               FireballThrowingTimer = $0711
000000r 2               
000000r 2               HammerEnemyOffset     = $06ae
000000r 2               JumpCoinMiscOffset    = $06b7
000000r 2               
000000r 2               Block_Buffer_1        = $0500
000000r 2               Block_Buffer_2        = $05d0
000000r 2               
000000r 2               HammerThrowingTimer   = $03a2
000000r 2               HammerBroJumpTimer    = $3c
000000r 2               Misc_Collision_Flag   = $06be
000000r 2               
000000r 2               RedPTroopaOrigXPos    = $0401
000000r 2               RedPTroopaCenterYPos  = $58
000000r 2               
000000r 2               XMovePrimaryCounter   = $a0
000000r 2               XMoveSecondaryCounter = $58
000000r 2               
000000r 2               CheepCheepMoveMFlag   = $58
000000r 2               CheepCheepOrigYPos    = $0434
000000r 2               BitMFilter            = $06dd
000000r 2               
000000r 2               LakituReappearTimer   = $06d1
000000r 2               LakituMoveSpeed       = $58
000000r 2               LakituMoveDirection   = $a0
000000r 2               
000000r 2               FirebarSpinState_Low  = $58
000000r 2               FirebarSpinState_High = $a0
000000r 2               FirebarSpinSpeed      = $0388
000000r 2               FirebarSpinDirection  = $34
000000r 2               
000000r 2               DuplicateObj_Offset   = $06cf
000000r 2               NumberofGroupEnemies  = $06d3
000000r 2               
000000r 2               BlooperMoveCounter    = $a0
000000r 2               BlooperMoveSpeed      = $58
000000r 2               
000000r 2               BowserBodyControls    = $0363
000000r 2               BowserFeetCounter     = $0364
000000r 2               BowserMovementSpeed   = $0365
000000r 2               BowserOrigXPos        = $0366
000000r 2               BowserFlameTimerCtrl  = $0367
000000r 2               BowserFront_Offset    = $0368
000000r 2               BridgeCollapseOffset  = $0369
000000r 2               BowserGfxFlag         = $036a
000000r 2               BowserHitPoints       = $0483
000000r 2               MaxRangeFromOrigin    = $06dc
000000r 2               
000000r 2               BowserFlamePRandomOfs = $0417
000000r 2               
000000r 2               PiranhaPlantUpYPos    = $0417
000000r 2               PiranhaPlantDownYPos  = $0434
000000r 2               PiranhaPlant_Y_Speed  = $58
000000r 2               PiranhaPlant_MoveFlag = $a0
000000r 2               
000000r 2               FireworksCounter      = $06d7
000000r 2               ExplosionGfxCounter   = $58
000000r 2               ExplosionTimerCounter = $a0
000000r 2               
000000r 2               LeavesXPosCopy        = $6210
000000r 2               LeavesYPosCopy        = $621c
000000r 2               
000000r 2               SaveDataHeader        = $6000
000000r 2               GamesBeatenCount      = $6007
000000r 2               
000000r 2               IncrementRNG          = $6008
000000r 2               
000000r 2               ;sound related defines
000000r 2               Squ2_NoteLenBuffer    = $07b3
000000r 2               Squ2_NoteLenCounter   = $07b4
000000r 2               Squ2_EnvelopeDataCtrl = $07b5
000000r 2               Squ1_NoteLenCounter   = $07b6
000000r 2               Squ1_EnvelopeDataCtrl = $07b7
000000r 2               Tri_NoteLenBuffer     = $07b8
000000r 2               Tri_NoteLenCounter    = $07b9
000000r 2               Noise_BeatLenCounter  = $07ba
000000r 2               Squ1_SfxLenCounter    = $07bb
000000r 2               Squ2_SfxLenCounter    = $07bd
000000r 2               Sfx_SecondaryCounter  = $07be
000000r 2               Noise_SfxLenCounter   = $07bf
000000r 2               
000000r 2               PauseSoundQueue       = $fa
000000r 2               Square1SoundQueue     = $ff
000000r 2               Square2SoundQueue     = $fe
000000r 2               NoiseSoundQueue       = $fd
000000r 2               AreaMusicQueue        = $fb
000000r 2               EventMusicQueue       = $fc
000000r 2               
000000r 2               Square1SoundBuffer    = $f1
000000r 2               Square2SoundBuffer    = $f2
000000r 2               NoiseSoundBuffer      = $f3
000000r 2               AreaMusicBuffer       = $f4
000000r 2               EventMusicBuffer      = $07b1
000000r 2               PauseSoundBuffer      = $07b2
000000r 2               
000000r 2               PatternNumber         = $061d
000000r 2               
000000r 2               MusicData             = $f5
000000r 2               MusicDataLow          = $f5
000000r 2               MusicDataHigh         = $f6
000000r 2               MusicOffset_Square2   = $f7
000000r 2               MusicOffset_Square1   = $f8
000000r 2               MusicOffset_Triangle  = $f9
000000r 2               MusicOffset_Noise     = $07b0
000000r 2               
000000r 2               NoteLenLookupTblOfs   = $f0
000000r 2               DAC_Counter           = $07c0
000000r 2               NoiseDataLoopbackOfs  = $07c1
000000r 2               NoteLengthTblAdder    = $07c4
000000r 2               AreaMusicBuffer_Alt   = $07c5
000000r 2               PauseModeFlag         = $07c6
000000r 2               GroundMusicHeaderOfs  = $07c7
000000r 2               AltRegContentFlag     = $07ca
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;CONSTANTS
000000r 2               
000000r 2               ;sound effects constants
000000r 2               Sfx_SmallJump         = %10000000
000000r 2               Sfx_Flagpole          = %01000000
000000r 2               Sfx_Fireball          = %00100000
000000r 2               Sfx_PipeDown_Injury   = %00010000
000000r 2               Sfx_EnemySmack        = %00001000
000000r 2               Sfx_EnemyStomp        = %00000100
000000r 2               Sfx_Bump              = %00000010
000000r 2               Sfx_BigJump           = %00000001
000000r 2               
000000r 2               Sfx_BowserFall        = %10000000
000000r 2               Sfx_ExtraLife         = %01000000
000000r 2               Sfx_PowerUpGrab       = %00100000
000000r 2               Sfx_TimerTick         = %00010000
000000r 2               Sfx_Blast             = %00001000
000000r 2               Sfx_GrowVine          = %00000100
000000r 2               Sfx_GrowPowerUp       = %00000010
000000r 2               Sfx_CoinGrab          = %00000001
000000r 2               
000000r 2               Sfx_BowserFlame       = %00000010
000000r 2               Sfx_BrickShatter      = %00000001
000000r 2               
000000r 2               ;music constants
000000r 2               Silence               = %10000000
000000r 2               
000000r 2               StarPowerMusic        = %01000000
000000r 2               PipeIntroMusic        = %00100000
000000r 2               CloudMusic            = %00010000
000000r 2               CastleMusic           = %00001000
000000r 2               UndergroundMusic      = %00000100
000000r 2               WaterMusic            = %00000010
000000r 2               GroundMusic           = %00000001
000000r 2               
000000r 2               TimeRunningOutMusic   = %01000000
000000r 2               EndOfLevelMusic       = %00100000
000000r 2               AltGameOverMusic      = %00010000
000000r 2               EndOfCastleMusic      = %00001000
000000r 2               VictoryMusic          = %00000100
000000r 2               GameOverMusic         = %00000010
000000r 2               DeathMusic            = %00000001
000000r 2               
000000r 2               ;enemy object constants
000000r 2               GreenKoopa            = $00
000000r 2               BuzzyBeetle           = $02
000000r 2               RedKoopa              = $03
000000r 2               HammerBro             = $05
000000r 2               Goomba                = $06
000000r 2               Bloober               = $07
000000r 2               BulletBill_FrenzyVar  = $08
000000r 2               GreyCheepCheep        = $0a
000000r 2               RedCheepCheep         = $0b
000000r 2               Podoboo               = $0c
000000r 2               PiranhaPlant          = $0d
000000r 2               GreenParatroopaJump   = $0e
000000r 2               RedParatroopa         = $0f
000000r 2               GreenParatroopaFly    = $10
000000r 2               Lakitu                = $11
000000r 2               Spiny                 = $12
000000r 2               FlyCheepCheepFrenzy   = $14
000000r 2               FlyingCheepCheep      = $14
000000r 2               BowserFlame           = $15
000000r 2               Fireworks             = $16
000000r 2               BBill_CCheep_Frenzy   = $17
000000r 2               Stop_Frenzy           = $18
000000r 2               Bowser                = $2d
000000r 2               PowerUpObject         = $2e
000000r 2               VineObject            = $2f
000000r 2               FlagpoleFlagObject    = $30
000000r 2               StarFlagObject        = $31
000000r 2               JumpspringObject      = $32
000000r 2               BulletBill_CannonVar  = $33
000000r 2               RetainerObject        = $35
000000r 2               TallEnemy             = $09
000000r 2               UpsideDownPiranhaP    = $04
000000r 2               
000000r 2               ;other constants
000000r 2               World1 = 0
000000r 2               World2 = 1
000000r 2               World3 = 2
000000r 2               World4 = 3
000000r 2               World5 = 4
000000r 2               World6 = 5
000000r 2               World7 = 6
000000r 2               World8 = 7
000000r 2               World9 = 8
000000r 2               Level1 = 0
000000r 2               Level2 = 1
000000r 2               Level3 = 2
000000r 2               Level4 = 3
000000r 2               
000000r 2               WarmBootOffset        = <$07d6
000000r 2               ColdBootOffset        = <$07fe
000000r 2               SoundMemory           = $07b0
000000r 2               
000000r 2               A_Button              = %10000000
000000r 2               B_Button              = %01000000
000000r 2               Select_Button         = %00100000
000000r 2               Start_Button          = %00010000
000000r 2               Up_Dir                = %00001000
000000r 2               Down_Dir              = %00000100
000000r 2               Left_Dir              = %00000010
000000r 2               Right_Dir             = %00000001
000000r 2               
000000r 2               AttractMode           = 0
000000r 2               GameMode              = 1
000000r 2               VictoryMode           = 2
000000r 2               GameOverMode          = 3
000000r 2               
000000r 2               PractiseBank          = $80
000000r 2               SoundBank             = $88
000000r 2               LevelsBank            = $8a
000000r 2               GameBank              = $8c
000000r 2               FixedBank             = $8e
000000r 2               
000000r 2               MMC3_BankSelect		  = $8000
000000r 2               MMC3_BankData		  = $8001
000000r 2               MMC3_Mirroring		  = $a000
000000r 2               MMC3_PRGRAMProtect    = $a001
000000r 2               
000000r 2               MMC3_IRQLatch		  = $c000
000000r 2               MMC3_IRQReload		  = $c001
000000r 2               MMC3_IRQDisable		  = $e000
000000r 2               MMC3_IRQEnable		  = $e001
000000r 2               
000000r 2               BG_MainBank           = $80
000000r 2               Spr_MainBank          = $84
000000r 2               Spr_EndingBank        = $88
000000r 2               
000000r 1               SwimTileRepOffset     = PlayerGraphicsTable + $9e
000000r 1               
000000r 1               ;-------------------------------------------------------------------------------------
000000r 1               ;DIRECTIVES
000000r 1               
000000r 1               ;.segment "INES"
000000r 1               ;"INESHDR"
000000r 1               ;  .byte $4E,$45,$53,$1A                           ;  magic signature
000000r 1               ;  .byte 4                                         ;  PRG ROM size in 16384 byte units
000000r 1               ;  .byte 2                                         ;  CHR
000000r 1               ;  .byte $43                                       ;  mirroring type and mapper number lower nibble
000000r 1               ;  .byte $00                                       ;  mapper number upper nibble
000000r 1               ;  .byte $00,$00,$00,$00,$00,$00,$00,$00
000000r 1               
000000r 1               .segment "SOUNDPRG"
000000r 1               .org $8000
008000  1               .include "sound.asm"
008000  2               MusicHeaderOffsetData = MusicHeaderData - 1
008000  2               MHD                   = MusicHeaderData
008000  2               
008000  2               ;-------------------------------------------------------------------------------------
008000  2               
008000  2               SoundEngine:
008000  2  AD 70 07              lda OperMode              ;are we in attract mode?
008003  2  D0 04                 bne SndOn
008005  2  8D 15 40              sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
008008  2  60                    rts
008009  2  A9 FF        SndOn:   lda #$ff
00800B  2  8D 17 40              sta JOYPAD_PORT2          ;disable irqs from apu and set frame counter mode
00800E  2  A9 0F                 lda #$0f
008010  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable first four channels
008013  2  AD C6 07              lda PauseModeFlag         ;is sound already in pause mode?
008016  2  D0 06                 bne InPause
008018  2  A5 FA                 lda PauseSoundQueue       ;if not, check pause sfx queue
00801A  2  C9 01                 cmp #$01
00801C  2  D0 5D                 bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
00801E  2  AD B2 07     InPause: lda PauseSoundBuffer      ;check pause sfx buffer
008021  2  D0 23                 bne ContPau
008023  2  A5 FA                 lda PauseSoundQueue       ;check pause queue
008025  2  F0 66                 beq SkipSoundSubroutines
008027  2  8D B2 07              sta PauseSoundBuffer      ;if queue full, store in buffer and activate
00802A  2  8D C6 07              sta PauseModeFlag         ;pause mode to interrupt game sounds
00802D  2  A9 00                 lda #$00                  ;disable sound and clear sfx buffers
00802F  2  8D 15 40              sta SND_MASTERCTRL_REG
008032  2  85 F1                 sta Square1SoundBuffer
008034  2  85 F2                 sta Square2SoundBuffer
008036  2  85 F3                 sta NoiseSoundBuffer
008038  2  A9 0F                 lda #$0f
00803A  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable sound again
00803D  2  A9 2A                 lda #$2a                  ;store length of sound in pause counter
00803F  2  8D BB 07              sta Squ1_SfxLenCounter
008042  2  A9 44        PTone1F: lda #$44                  ;play first tone
008044  2  D0 11                 bne PTRegC                ;unconditional branch
008046  2  AD BB 07     ContPau: lda Squ1_SfxLenCounter    ;check pause length left
008049  2  C9 24                 cmp #$24                  ;time to play second?
00804B  2  F0 08                 beq PTone2F
00804D  2  C9 1E                 cmp #$1e                  ;time to play first again?
00804F  2  F0 F1                 beq PTone1F
008051  2  C9 18                 cmp #$18                  ;time to play second again?
008053  2  D0 09                 bne DecPauC               ;only load regs during times, otherwise skip
008055  2  A9 64        PTone2F: lda #$64                  ;store reg contents and play the pause sfx
008057  2  A2 84        PTRegC:  ldx #$84
008059  2  A0 7F                 ldy #$7f
00805B  2  20 B8 80              jsr PlaySqu1Sfx
00805E  2  CE BB 07     DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
008061  2  D0 2A                 bne SkipSoundSubroutines
008063  2  A9 00                 lda #$00                  ;disable sound if in pause mode and
008065  2  8D 15 40              sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
008068  2  AD B2 07              lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
00806B  2  C9 02                 cmp #$02                  ;if we need to be playing sound again
00806D  2  D0 05                 bne SkipPIn
00806F  2  A9 00                 lda #$00                  ;clear pause mode to allow game sounds again
008071  2  8D C6 07              sta PauseModeFlag
008074  2  A9 00        SkipPIn: lda #$00                  ;clear pause sfx buffer
008076  2  8D B2 07              sta PauseSoundBuffer
008079  2  F0 12                 beq SkipSoundSubroutines
00807B  2               
00807B  2               RunSoundSubroutines:
00807B  2  20 4B 81              jsr Square1SfxHandler  ;play sfx on square channel 1
00807E  2  20 AC 82              jsr Square2SfxHandler  ; ''  ''  '' square channel 2
008081  2  20 D7 83              jsr NoiseSfxHandler    ; ''  ''  '' noise channel
008084  2  20 30 84              jsr MusicHandler       ;play music on all channels
008087  2  A9 00                 lda #$00               ;clear the music queues
008089  2  85 FB                 sta AreaMusicQueue
00808B  2  85 FC                 sta EventMusicQueue
00808D  2               
00808D  2               SkipSoundSubroutines:
00808D  2  A9 00                  lda #$00               ;clear the sound effects queues
00808F  2  85 FF                  sta Square1SoundQueue
008091  2  85 FE                  sta Square2SoundQueue
008093  2  85 FD                  sta NoiseSoundQueue
008095  2  85 FA                  sta PauseSoundQueue
008097  2  AC C0 07               ldy DAC_Counter        ;load some sort of counter
00809A  2  A5 F4                  lda AreaMusicBuffer
00809C  2  29 03                  and #%00000011         ;check for specific music
00809E  2  F0 07                  beq NoIncDAC
0080A0  2  EE C0 07               inc DAC_Counter        ;increment and check counter
0080A3  2  C0 30                  cpy #$30
0080A5  2  90 06                  bcc StrWave            ;if not there yet, just store it
0080A7  2  98           NoIncDAC: tya
0080A8  2  F0 03                  beq StrWave            ;if we are at zero, do not decrement
0080AA  2  CE C0 07               dec DAC_Counter        ;decrement counter
0080AD  2  8C 11 40     StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
0080B0  2  60                     rts                    ;we are done here
0080B1  2               
0080B1  2               
0080B1  2               ;--------------------------------
0080B1  2               
0080B1  2               Dump_Squ1_Regs:
0080B1  2  8C 01 40           sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
0080B4  2  8E 00 40           stx SND_SQUARE1_REG
0080B7  2  60                 rts
0080B8  2               
0080B8  2               PlaySqu1Sfx:
0080B8  2  20 B1 80           jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
0080BB  2               
0080BB  2               SetFreq_Squ1:
0080BB  2  A2 00              ldx #$00               ;set frequency reg offset for square 1 sound channel
0080BD  2               
0080BD  2               Dump_Freq_Regs:
0080BD  2  A8                   tay
0080BE  2  B9 E0 8D             lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
0080C1  2  F0 0B                beq NoTone                ;if zero, then do not load
0080C3  2  9D 02 40             sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
0080C6  2  B9 DF 8D             lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
0080C9  2  09 08                ora #%00001000            ;length counter
0080CB  2  9D 03 40             sta SND_REGISTER+3,x
0080CE  2  60           NoTone: rts
0080CF  2               
0080CF  2               Dump_Sq2_Regs:
0080CF  2  8E 04 40           stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
0080D2  2  8C 05 40           sty SND_SQUARE2_REG+1
0080D5  2  60                 rts
0080D6  2               
0080D6  2               PlaySqu2Sfx:
0080D6  2  20 CF 80           jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
0080D9  2               
0080D9  2               SetFreq_Squ2:
0080D9  2  A2 04              ldx #$04               ;set frequency reg offset for square 2 sound channel
0080DB  2  D0 E0              bne Dump_Freq_Regs     ;unconditional branch
0080DD  2               
0080DD  2               SetFreq_Tri:
0080DD  2  A2 08              ldx #$08               ;set frequency reg offset for triangle sound channel
0080DF  2  D0 DC              bne Dump_Freq_Regs     ;unconditional branch
0080E1  2               
0080E1  2               ;--------------------------------
0080E1  2               
0080E1  2               SwimStompEnvelopeData:
0080E1  2  9F 9B 98 96        .byte $9f, $9b, $98, $96, $95, $94, $92, $90
0080E5  2  95 94 92 90  
0080E9  2  90 9A 97 95        .byte $90, $9a, $97, $95, $93, $92
0080ED  2  93 92        
0080EF  2               
0080EF  2               PlayFlagpoleSlide:
0080EF  2  A9 40               lda #$40               ;store length of flagpole sound
0080F1  2  8D BB 07            sta Squ1_SfxLenCounter
0080F4  2  A9 62               lda #$62               ;load part of reg contents for flagpole sound
0080F6  2  20 BB 80            jsr SetFreq_Squ1
0080F9  2  A2 99               ldx #$99               ;now load the rest
0080FB  2  D0 25               bne FPS2nd
0080FD  2               
0080FD  2               PlaySmallJump:
0080FD  2  A9 26               lda #$26               ;branch here for small mario jumping sound
0080FF  2  D0 02               bne JumpRegContents
008101  2               
008101  2               PlayBigJump:
008101  2  A9 18               lda #$18               ;branch here for big mario jumping sound
008103  2               
008103  2               JumpRegContents:
008103  2  A2 82               ldx #$82               ;note that small and big jump borrow each others' reg contents
008105  2  A0 A7               ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
008107  2  20 B8 80            jsr PlaySqu1Sfx
00810A  2  A9 28               lda #$28               ;store length of sfx for both jumping sounds
00810C  2  8D BB 07            sta Squ1_SfxLenCounter ;then continue on here
00810F  2               
00810F  2               ContinueSndJump:
00810F  2  AD BB 07               lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
008112  2  C9 25                  cmp #$25               ;check for time to play second part yet
008114  2  D0 06                  bne N2Prt
008116  2  A2 5F                  ldx #$5f               ;load second part
008118  2  A0 F6                  ldy #$f6
00811A  2  D0 08                  bne DmpJpFPS           ;unconditional branch
00811C  2  C9 20        N2Prt:    cmp #$20               ;check for third part
00811E  2  D0 29                  bne DecJpFPS
008120  2  A2 48                  ldx #$48               ;load third part
008122  2  A0 BC        FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
008124  2  20 B1 80     DmpJpFPS: jsr Dump_Squ1_Regs
008127  2  D0 20                  bne DecJpFPS           ;unconditional branch outta here
008129  2               
008129  2               PlayFireballThrow:
008129  2  A9 05                lda #$05
00812B  2  A0 99                ldy #$99                 ;load reg contents for fireball throw sound
00812D  2  D0 04                bne Fthrow               ;unconditional branch
00812F  2               
00812F  2               PlayBump:
00812F  2  A9 0A                  lda #$0a                ;load length of sfx and reg contents for bump sound
008131  2  A0 93                  ldy #$93
008133  2  A2 9E        Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
008135  2  8D BB 07               sta Squ1_SfxLenCounter
008138  2  A9 0C                  lda #$0c                ;load offset for bump sound
00813A  2  20 B8 80               jsr PlaySqu1Sfx
00813D  2               
00813D  2               ContinueBumpThrow:
00813D  2  AD BB 07               lda Squ1_SfxLenCounter  ;check for second part of bump sound
008140  2  C9 06                  cmp #$06
008142  2  D0 05                  bne DecJpFPS
008144  2  A9 BB                  lda #$bb                ;load second part directly
008146  2  8D 01 40               sta SND_SQUARE1_REG+1
008149  2  D0 60        DecJpFPS: bne BranchToDecLength1  ;unconditional branch
00814B  2               
00814B  2               
00814B  2               Square1SfxHandler:
00814B  2  A4 FF               ldy Square1SoundQueue   ;check for sfx in queue
00814D  2  F0 20               beq CheckSfx1Buffer
00814F  2  84 F1               sty Square1SoundBuffer  ;if found, put in buffer
008151  2  30 AA               bmi PlaySmallJump       ;small jump
008153  2  46 FF               lsr Square1SoundQueue
008155  2  B0 AA               bcs PlayBigJump         ;big jump
008157  2  46 FF               lsr Square1SoundQueue
008159  2  B0 D4               bcs PlayBump            ;bump
00815B  2  46 FF               lsr Square1SoundQueue
00815D  2  B0 2C               bcs PlaySwimStomp       ;swim/stomp
00815F  2  46 FF               lsr Square1SoundQueue
008161  2  B0 4A               bcs PlaySmackEnemy      ;smack enemy
008163  2  46 FF               lsr Square1SoundQueue
008165  2  B0 7F               bcs PlayPipeDownInj     ;pipedown/injury
008167  2  46 FF               lsr Square1SoundQueue
008169  2  B0 BE               bcs PlayFireballThrow   ;fireball throw
00816B  2  46 FF               lsr Square1SoundQueue
00816D  2  B0 80               bcs PlayFlagpoleSlide   ;slide flagpole
00816F  2               
00816F  2               CheckSfx1Buffer:
00816F  2  A5 F1               lda Square1SoundBuffer   ;check for sfx in buffer
008171  2  F0 17               beq ExS1H                ;if not found, exit sub
008173  2  30 9A               bmi ContinueSndJump      ;small mario jump
008175  2  4A                  lsr
008176  2  B0 97               bcs ContinueSndJump      ;big mario jump
008178  2  4A                  lsr
008179  2  B0 C2               bcs ContinueBumpThrow    ;bump
00817B  2  4A                  lsr
00817C  2  B0 1B               bcs ContinueSwimStomp    ;swim/stomp
00817E  2  4A                  lsr
00817F  2  B0 3C               bcs ContinueSmackEnemy   ;smack enemy
008181  2  4A                  lsr
008182  2  B0 67               bcs ContinuePipeDownInj  ;pipedown/injury
008184  2  4A                  lsr
008185  2  B0 B6               bcs ContinueBumpThrow    ;fireball throw
008187  2  4A                  lsr
008188  2  B0 48               bcs DecrementSfx1Length  ;slide flagpole
00818A  2  60           ExS1H: rts
00818B  2               
00818B  2               
00818B  2               PlaySwimStomp:
00818B  2  A9 0E              lda #$0e               ;store length of swim/stomp sound
00818D  2  8D BB 07           sta Squ1_SfxLenCounter
008190  2  A0 9C              ldy #$9c               ;store reg contents for swim/stomp sound
008192  2  A2 9E              ldx #$9e
008194  2  A9 26              lda #$26
008196  2  20 B8 80           jsr PlaySqu1Sfx
008199  2               
008199  2               ContinueSwimStomp:
008199  2  AC BB 07           ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
00819C  2  B9 E0 80           lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
00819F  2  8D 00 40           sta SND_SQUARE1_REG           ;envelope
0081A2  2  C0 06              cpy #$06
0081A4  2  D0 05              bne BranchToDecLength1
0081A6  2  A9 9E              lda #$9e                      ;when the length counts down to a certain point, put this
0081A8  2  8D 02 40           sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
0081AB  2               
0081AB  2               BranchToDecLength1:
0081AB  2  D0 25              bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
0081AD  2               
0081AD  2               PlaySmackEnemy:
0081AD  2  A9 0E              lda #$0e                 ;store length of smack enemy sound
0081AF  2  A0 CB              ldy #$cb
0081B1  2  A2 9F              ldx #$9f
0081B3  2  8D BB 07           sta Squ1_SfxLenCounter
0081B6  2  A9 28              lda #$28                 ;store reg contents for smack enemy sound
0081B8  2  20 B8 80           jsr PlaySqu1Sfx
0081BB  2  D0 15              bne DecrementSfx1Length  ;unconditional branch
0081BD  2               
0081BD  2               ContinueSmackEnemy:
0081BD  2  AC BB 07             ldy Squ1_SfxLenCounter  ;check about halfway through
0081C0  2  C0 08                cpy #$08
0081C2  2  D0 09                bne SmSpc
0081C4  2  A9 A0                lda #$a0                ;if we're at the about-halfway point, make the second tone
0081C6  2  8D 02 40             sta SND_SQUARE1_REG+2   ;in the smack enemy sound
0081C9  2  A9 9F                lda #$9f
0081CB  2  D0 02                bne SmTick
0081CD  2  A9 90        SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
0081CF  2  8D 00 40     SmTick: sta SND_SQUARE1_REG
0081D2  2               
0081D2  2               DecrementSfx1Length:
0081D2  2  CE BB 07           dec Squ1_SfxLenCounter    ;decrement length of sfx
0081D5  2  D0 0E              bne ExSfx1
0081D7  2               
0081D7  2               StopSquare1Sfx:
0081D7  2  A2 00                ldx #$00                ;if end of sfx reached, clear buffer
0081D9  2  86 F1                stx $f1                 ;and stop making the sfx
0081DB  2  A2 0E                ldx #$0e
0081DD  2  8E 15 40             stx SND_MASTERCTRL_REG
0081E0  2  A2 0F                ldx #$0f
0081E2  2  8E 15 40             stx SND_MASTERCTRL_REG
0081E5  2  60           ExSfx1: rts
0081E6  2               
0081E6  2               PlayPipeDownInj:
0081E6  2  A9 2F              lda #$2f                ;load length of pipedown sound
0081E8  2  8D BB 07           sta Squ1_SfxLenCounter
0081EB  2               
0081EB  2               ContinuePipeDownInj:
0081EB  2  AD BB 07              lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
0081EE  2  4A                    lsr                     ;to be written to only during six specific times
0081EF  2  B0 10                 bcs NoPDwnL             ;during which d3 must be set and d1-0 must be clear
0081F1  2  4A                    lsr
0081F2  2  B0 0D                 bcs NoPDwnL
0081F4  2  29 02                 and #%00000010
0081F6  2  F0 09                 beq NoPDwnL
0081F8  2  A0 91                 ldy #$91                ;and this is where it actually gets written in
0081FA  2  A2 9A                 ldx #$9a
0081FC  2  A9 44                 lda #$44
0081FE  2  20 B8 80              jsr PlaySqu1Sfx
008201  2  4C D2 81     NoPDwnL: jmp DecrementSfx1Length
008204  2               
008204  2               ;--------------------------------
008204  2               
008204  2               ExtraLifeFreqData:
008204  2  58 02 54 56        .byte $58, $02, $54, $56, $4e, $44
008208  2  4E 44        
00820A  2               
00820A  2               PowerUpGrabFreqData:
00820A  2  4C 52 4C 48        .byte $4c, $52, $4c, $48, $3e, $36, $3e, $36, $30
00820E  2  3E 36 3E 36  
008212  2  30           
008213  2  28 4A 50 4A        .byte $28, $4a, $50, $4a, $64, $3c, $32, $3c, $32
008217  2  64 3C 32 3C  
00821B  2  32           
00821C  2  2C 24 3A 64        .byte $2c, $24, $3a, $64, $3a, $34, $2c, $22, $2c
008220  2  3A 34 2C 22  
008224  2  2C           
008225  2               
008225  2               ;residual frequency data
008225  2  22 1C 14           .byte $22, $1c, $14
008228  2               
008228  2               PUp_VGrow_FreqData:
008228  2  14 04 22 24        .byte $14, $04, $22, $24, $16, $04, $24, $26 ;used by both
00822C  2  16 04 24 26  
008230  2  18 04 26 28        .byte $18, $04, $26, $28, $1a, $04, $28, $2a
008234  2  1A 04 28 2A  
008238  2  1C 04 2A 2C        .byte $1c, $04, $2a, $2c, $1e, $04, $2c, $2e ;used by vinegrow
00823C  2  1E 04 2C 2E  
008240  2  20 04 2E 30        .byte $20, $04, $2e, $30, $22, $04, $30, $32
008244  2  22 04 30 32  
008248  2               
008248  2               PlayCoinGrab:
008248  2  A9 35                lda #$35             ;load length of coin grab sound
00824A  2  A2 8D                ldx #$8d             ;and part of reg contents
00824C  2  D0 04                bne CGrab_TTickRegL
00824E  2               
00824E  2               PlayTimerTick:
00824E  2  A9 06                lda #$06             ;load length of timer tick sound
008250  2  A2 98                ldx #$98             ;and part of reg contents
008252  2               
008252  2               CGrab_TTickRegL:
008252  2  8D BD 07             sta Squ2_SfxLenCounter
008255  2  A0 7F                ldy #$7f                ;load the rest of reg contents
008257  2  A9 42                lda #$42                ;of coin grab and timer tick sound
008259  2  20 D6 80             jsr PlaySqu2Sfx
00825C  2               
00825C  2               ContinueCGrabTTick:
00825C  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second tone yet
00825F  2  C9 30                cmp #$30                ;timer tick sound also executes this, not sure why
008261  2  D0 05                bne N2Tone
008263  2  A9 54                lda #$54                ;if so, load the tone directly into the reg
008265  2  8D 06 40             sta SND_SQUARE2_REG+2
008268  2  D0 2E        N2Tone: bne DecrementSfx2Length
00826A  2               
00826A  2               PlayBlast:
00826A  2  A9 20                lda #$20                ;load length of fireworks/gunfire sound
00826C  2  8D BD 07             sta Squ2_SfxLenCounter
00826F  2  A0 94                ldy #$94                ;load reg contents of fireworks/gunfire sound
008271  2  A9 5E                lda #$5e
008273  2  D0 0B                bne SBlasJ
008275  2               
008275  2               ContinueBlast:
008275  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second part
008278  2  C9 18                cmp #$18
00827A  2  D0 1C                bne DecrementSfx2Length
00827C  2  A0 93                ldy #$93                ;load second part reg contents then
00827E  2  A9 18                lda #$18
008280  2  D0 7F        SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
008282  2               
008282  2               PlayPowerUpGrab:
008282  2  A9 36                lda #$36                    ;load length of power-up grab sound
008284  2  8D BD 07             sta Squ2_SfxLenCounter
008287  2               
008287  2               ContinuePowerUpGrab:
008287  2  AD BD 07             lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
00828A  2  4A                   lsr                         ;divide by 2
00828B  2  B0 0B                bcs DecrementSfx2Length     ;alter frequency every other frame
00828D  2  A8                   tay
00828E  2  B9 09 82             lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
008291  2  A2 5D                ldx #$5d                    ;store reg contents of power-up grab sound
008293  2  A0 7F                ldy #$7f
008295  2               
008295  2               LoadSqu2Regs:
008295  2  20 D6 80             jsr PlaySqu2Sfx
008298  2               
008298  2               DecrementSfx2Length:
008298  2  CE BD 07             dec Squ2_SfxLenCounter   ;decrement length of sfx
00829B  2  D0 0E                bne ExSfx2
00829D  2               
00829D  2               EmptySfx2Buffer:
00829D  2  A2 00                ldx #$00                ;initialize square 2's sound effects buffer
00829F  2  86 F2                stx Square2SoundBuffer
0082A1  2               
0082A1  2               StopSquare2Sfx:
0082A1  2  A2 0D                ldx #$0d                ;stop playing the sfx
0082A3  2  8E 15 40             stx SND_MASTERCTRL_REG
0082A6  2  A2 0F                ldx #$0f
0082A8  2  8E 15 40             stx SND_MASTERCTRL_REG
0082AB  2  60           ExSfx2: rts
0082AC  2               
0082AC  2               Square2SfxHandler:
0082AC  2  A5 F2                lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
0082AE  2  29 40                and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
0082B0  2  D0 65                bne ContinueExtraLife
0082B2  2  A4 FE                ldy Square2SoundQueue  ;check for sfx in queue
0082B4  2  F0 20                beq CheckSfx2Buffer
0082B6  2  84 F2                sty Square2SoundBuffer ;if found, put in buffer and check for the following
0082B8  2  30 3E                bmi PlayBowserFall     ;bowser fall
0082BA  2  46 FE                lsr Square2SoundQueue
0082BC  2  B0 8A                bcs PlayCoinGrab       ;coin grab
0082BE  2  46 FE                lsr Square2SoundQueue
0082C0  2  B0 6A                bcs PlayGrowPowerUp    ;power-up reveal
0082C2  2  46 FE                lsr Square2SoundQueue
0082C4  2  B0 6A                bcs PlayGrowVine       ;vine grow
0082C6  2  46 FE                lsr Square2SoundQueue
0082C8  2  B0 A0                bcs PlayBlast          ;fireworks/gunfire
0082CA  2  46 FE                lsr Square2SoundQueue
0082CC  2  B0 80                bcs PlayTimerTick      ;timer tick
0082CE  2  46 FE                lsr Square2SoundQueue
0082D0  2  B0 B0                bcs PlayPowerUpGrab    ;power-up grab
0082D2  2  46 FE                lsr Square2SoundQueue
0082D4  2  B0 3C                bcs PlayExtraLife      ;1-up
0082D6  2               
0082D6  2               CheckSfx2Buffer:
0082D6  2  A5 F2                lda Square2SoundBuffer   ;check for sfx in buffer
0082D8  2  F0 17                beq ExS2H                ;if not found, exit sub
0082DA  2  30 27                bmi ContinueBowserFall   ;bowser fall
0082DC  2  4A                   lsr
0082DD  2  B0 13                bcs Cont_CGrab_TTick     ;coin grab
0082DF  2  4A                   lsr
0082E0  2  B0 5D                bcs ContinueGrowItems    ;power-up reveal
0082E2  2  4A                   lsr
0082E3  2  B0 5A                bcs ContinueGrowItems    ;vine grow
0082E5  2  4A                   lsr
0082E6  2  B0 8D                bcs ContinueBlast        ;fireworks/gunfire
0082E8  2  4A                   lsr
0082E9  2  B0 07                bcs Cont_CGrab_TTick     ;timer tick
0082EB  2  4A                   lsr
0082EC  2  B0 99                bcs ContinuePowerUpGrab  ;power-up grab
0082EE  2  4A                   lsr
0082EF  2  B0 26                bcs ContinueExtraLife    ;1-up
0082F1  2  60           ExS2H:  rts
0082F2  2               
0082F2  2               Cont_CGrab_TTick:
0082F2  2  4C 5C 82             jmp ContinueCGrabTTick
0082F5  2               
0082F5  2               JumpToDecLength2:
0082F5  2  4C 98 82             jmp DecrementSfx2Length
0082F8  2               
0082F8  2               PlayBowserFall:
0082F8  2  A9 38                 lda #$38                ;load length of bowser defeat sound
0082FA  2  8D BD 07              sta Squ2_SfxLenCounter
0082FD  2  A0 C4                 ldy #$c4                ;load contents of reg for bowser defeat sound
0082FF  2  A9 18                 lda #$18
008301  2  D0 0B        BlstSJp: bne PBFRegs
008303  2               
008303  2               ContinueBowserFall:
008303  2  AD BD 07               lda Squ2_SfxLenCounter   ;check for almost near the end
008306  2  C9 08                  cmp #$08
008308  2  D0 8E                  bne DecrementSfx2Length
00830A  2  A0 A4                  ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
00830C  2  A9 5A                  lda #$5a
00830E  2  A2 9F        PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
008310  2  D0 83        EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
008312  2               
008312  2               PlayExtraLife:
008312  2  A9 30                lda #$30                  ;load length of 1-up sound
008314  2  8D BD 07             sta Squ2_SfxLenCounter
008317  2               
008317  2               ContinueExtraLife:
008317  2  AD BD 07               lda Squ2_SfxLenCounter
00831A  2  A2 03                  ldx #$03                  ;load new tones only every eight frames
00831C  2  4A           DivLLoop: lsr
00831D  2  B0 D6                  bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
00831F  2  CA                     dex
008320  2  D0 FA                  bne DivLLoop              ;do this until all bits checked, if none set, continue
008322  2  A8                     tay
008323  2  B9 03 82               lda ExtraLifeFreqData-1,y ;load our reg contents
008326  2  A2 82                  ldx #$82
008328  2  A0 7F                  ldy #$7f
00832A  2  D0 E4                  bne EL_LRegs              ;unconditional branch
00832C  2               
00832C  2               PlayGrowPowerUp:
00832C  2  A9 10                lda #$10                ;load length of power-up reveal sound
00832E  2  D0 02                bne GrowItemRegs
008330  2               
008330  2               PlayGrowVine:
008330  2  A9 20                lda #$20                ;load length of vine grow sound
008332  2               
008332  2               GrowItemRegs:
008332  2  8D BD 07             sta Squ2_SfxLenCounter
008335  2  A9 7F                lda #$7f                  ;load contents of reg for both sounds directly
008337  2  8D 05 40             sta SND_SQUARE2_REG+1
00833A  2  A9 00                lda #$00                  ;start secondary counter for both sounds
00833C  2  8D BE 07             sta Sfx_SecondaryCounter
00833F  2               
00833F  2               ContinueGrowItems:
00833F  2  EE BE 07             inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
008342  2  AD BE 07             lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
008345  2  4A                   lsr                       ;divide by 2 to get the offset
008346  2  A8                   tay
008347  2  CC BD 07             cpy Squ2_SfxLenCounter    ;have we reached the end yet?
00834A  2  F0 0C                beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
00834C  2  A9 9D                lda #$9d                  ;load contents of other reg directly
00834E  2  8D 04 40             sta SND_SQUARE2_REG
008351  2  B9 28 82             lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
008354  2  20 D9 80             jsr SetFreq_Squ2
008357  2  60                   rts
008358  2               
008358  2               StopGrowItems:
008358  2  4C 9D 82             jmp EmptySfx2Buffer       ;branch to stop playing sounds
00835B  2               
00835B  2               WindFreqEnvData:
00835B  2  37 46 55 64          .byte $37, $46, $55, $64, $74, $83, $93, $a2
00835F  2  74 83 93 A2  
008363  2  B1 C0 D0 E0          .byte $b1, $c0, $d0, $e0, $f1, $f1, $f2, $e2
008367  2  F1 F1 F2 E2  
00836B  2  E2 C3 A3 84          .byte $e2, $c3, $a3, $84, $64, $44, $35, $25
00836F  2  64 44 35 25  
008373  2               
008373  2               BrickShatterFreqData:
008373  2  01 0E 0E 0D          .byte $01, $0e, $0e, $0d, $0b, $06, $0c, $0f
008377  2  0B 06 0C 0F  
00837B  2  0A 09 03 0D          .byte $0a, $09, $03, $0d, $08, $0d, $06, $0c
00837F  2  08 0D 06 0C  
008383  2               
008383  2               SkidSfxFreqData:
008383  2  47 49 42 4A          .byte $47, $49, $42, $4a, $43, $4b
008387  2  43 4B        
008389  2               
008389  2               PlaySkidSfx:
008389  2  84 F3                sty NoiseSoundBuffer
00838B  2  A9 06                lda #$06
00838D  2  8D BF 07             sta Noise_SfxLenCounter
008390  2               
008390  2               ContinueSkidSfx:
008390  2  AD BF 07             lda Noise_SfxLenCounter
008393  2  A8                   tay
008394  2  B9 82 83             lda SkidSfxFreqData-1,y
008397  2  8D 0A 40             sta SND_TRIANGLE_REG+2
00839A  2  A9 18                lda #$18
00839C  2  8D 08 40             sta SND_TRIANGLE_REG
00839F  2  8D 0B 40             sta SND_TRIANGLE_REG+3
0083A2  2  D0 1F                bne DecrementSfx3Length
0083A4  2               
0083A4  2               PlayBrickShatter:
0083A4  2  84 F3                sty NoiseSoundBuffer
0083A6  2  A9 20                lda #$20                 ;load length of brick shatter sound
0083A8  2  8D BF 07             sta Noise_SfxLenCounter
0083AB  2               
0083AB  2               ContinueBrickShatter:
0083AB  2  AD BF 07             lda Noise_SfxLenCounter
0083AE  2  4A                   lsr                         ;divide by 2 and check for bit set to use offset
0083AF  2  90 12                bcc DecrementSfx3Length
0083B1  2  A8                   tay
0083B2  2  BE 73 83             ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
0083B5  2  B9 EA 8E             lda BrickShatterEnvData,y
0083B8  2               
0083B8  2               PlayNoiseSfx:
0083B8  2  8D 0C 40             sta SND_NOISE_REG        ;play the sfx
0083BB  2  8E 0E 40             stx SND_NOISE_REG+2
0083BE  2  A9 18                lda #$18
0083C0  2  8D 0F 40             sta SND_NOISE_REG+3
0083C3  2               
0083C3  2               DecrementSfx3Length:
0083C3  2  CE BF 07             dec Noise_SfxLenCounter  ;decrement length of sfx
0083C6  2  D0 0E                bne ExSfx3
0083C8  2  A9 F0                lda #$f0                 ;if done, stop playing the sfx
0083CA  2  8D 0C 40             sta SND_NOISE_REG
0083CD  2  A9 00                lda #$00
0083CF  2  8D 08 40             sta SND_TRIANGLE_REG
0083D2  2  A9 00                lda #$00
0083D4  2  85 F3                sta NoiseSoundBuffer
0083D6  2  60           ExSfx3: rts
0083D7  2               
0083D7  2               NoiseSfxHandler:
0083D7  2  A5 F3                lda NoiseSoundBuffer
0083D9  2  30 B5                bmi ContinueSkidSfx
0083DB  2  A4 FD                ldy NoiseSoundQueue
0083DD  2  30 AA                bmi PlaySkidSfx
0083DF  2  46 FD                lsr NoiseSoundQueue
0083E1  2  B0 C1                bcs PlayBrickShatter
0083E3  2  4A                   lsr
0083E4  2  B0 C5                bcs ContinueBrickShatter
0083E6  2  46 FD                lsr NoiseSoundQueue
0083E8  2  B0 0B                bcs PlayBowserFlame
0083EA  2  4A                   lsr
0083EB  2  B0 0F                bcs ContinueBowserFlame
0083ED  2  4A                   lsr
0083EE  2  B0 1F                bcs ContinueWindSfx
0083F0  2  46 FD                lsr NoiseSoundQueue
0083F2  2  B0 14                bcs PlayWindSfx
0083F4  2  60                   rts
0083F5  2               
0083F5  2               PlayBowserFlame:
0083F5  2  84 F3                sty NoiseSoundBuffer
0083F7  2  A9 40                lda #$40                    ;load length of bowser flame sound
0083F9  2  8D BF 07             sta Noise_SfxLenCounter
0083FC  2               
0083FC  2               ContinueBowserFlame:
0083FC  2  AD BF 07             lda Noise_SfxLenCounter
0083FF  2  4A                   lsr
008400  2  A8                   tay
008401  2  A2 0F                ldx #$0f                    ;load reg contents of bowser flame sound
008403  2  B9 C9 8E             lda BowserFlameEnvData-1,y
008406  2               WindBranch:
008406  2  D0 B0                bne PlayNoiseSfx            ;unconditional branch here
008408  2               
008408  2               PlayWindSfx:
008408  2  84 F3                sty NoiseSoundBuffer
00840A  2  A9 C0                lda #$c0
00840C  2  8D BF 07             sta Noise_SfxLenCounter
00840F  2               ContinueWindSfx:
00840F  2  46 FD                lsr NoiseSoundQueue         ;get bit for the wind sfx, note that it must
008411  2  90 C3                bcc ExSfx3                  ;be continuously set in order for it to play
008413  2  AD BF 07             lda Noise_SfxLenCounter
008416  2  4A                   lsr
008417  2  4A                   lsr                         ;divide length counter by 8
008418  2  4A                   lsr
008419  2  A8                   tay
00841A  2  B9 5B 83             lda WindFreqEnvData,y
00841D  2  29 0F                and #$0f                    ;use lower nybble as frequency data
00841F  2  09 10                ora #$10
008421  2  AA                   tax
008422  2  B9 5B 83             lda WindFreqEnvData,y       ;use upper nybble as envelope data
008425  2  4A                   lsr
008426  2  4A                   lsr
008427  2  4A                   lsr
008428  2  4A                   lsr
008429  2  09 10                ora #$10
00842B  2  D0 D9                bne WindBranch              ;unconditional branch
00842D  2               
00842D  2               ;--------------------------------
00842D  2               
00842D  2               ContinueMusic:
00842D  2  4C DB 84             jmp HandleSquare2Music  ;if we have music, start with square 2 channel
008430  2               
008430  2               MusicHandler:
008430  2  A5 FC                lda EventMusicQueue     ;check event music queue
008432  2  D0 0C                bne LoadEventMusic
008434  2  A5 FB                lda AreaMusicQueue      ;check area music queue
008436  2  D0 31                bne LoadAreaMusic
008438  2  AD B1 07             lda EventMusicBuffer    ;check both buffers
00843B  2  05 F4                ora AreaMusicBuffer
00843D  2  D0 EE                bne ContinueMusic
00843F  2  60                   rts                     ;no music, then leave
008440  2               
008440  2               LoadEventMusic:
008440  2  8D B1 07                sta EventMusicBuffer      ;copy event music queue contents to buffer
008443  2  C9 01                   cmp #DeathMusic           ;is it death music?
008445  2  D0 06                   bne NoStopSfx             ;if not, jump elsewhere
008447  2  20 D7 81                jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
00844A  2  20 A1 82                jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
00844D  2  A0 32        NoStopSfx: ldy #$32                  ;start counter used only by victory music
00844F  2  8C 1D 06                sty PatternNumber
008452  2  A6 F4                   ldx AreaMusicBuffer
008454  2  8E C5 07                stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
008457  2  A0 00                   ldy #$00
008459  2  8C C4 07                sty NoteLengthTblAdder    ;default value for additional length byte offset
00845C  2  84 F4                   sty AreaMusicBuffer       ;clear area music buffer
00845E  2  C9 40                   cmp #TimeRunningOutMusic  ;is it time running out music?
008460  2  D0 30                   bne FindEventMusicHeader
008462  2  A2 08                   ldx #$08                  ;load offset to be added to length byte of header
008464  2  8E C4 07                stx NoteLengthTblAdder
008467  2  D0 29                   bne FindEventMusicHeader  ;unconditional branch
008469  2               
008469  2               LoadAreaMusic:
008469  2  C9 04                 cmp #$04                  ;is it underground music?
00846B  2  D0 03                 bne NoStop1               ;no, do not stop square 1 sfx
00846D  2  20 D7 81              jsr StopSquare1Sfx
008470  2  A0 10        NoStop1: ldy #$10                  ;start counter used only by ground level music
008472  2  8C C7 07     GMLoopB: sty GroundMusicHeaderOfs
008475  2               
008475  2               HandleAreaMusicLoopB:
008475  2  A0 00                 ldy #$00                  ;clear event music buffer
008477  2  8C B1 07              sty EventMusicBuffer
00847A  2  85 F4                 sta AreaMusicBuffer       ;copy area music queue contents to buffer
00847C  2  C9 01                 cmp #$01                  ;is it ground level music?
00847E  2  D0 0E                 bne FindAreaMusicHeader
008480  2  EE C7 07              inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
008483  2  AC C7 07              ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
008486  2  C0 32                 cpy #$32
008488  2  D0 0C                 bne LoadHeader            ;branch ahead with alternate offset
00848A  2  A0 11                 ldy #$11
00848C  2  D0 E4                 bne GMLoopB               ;unconditional branch
00848E  2               
00848E  2               FindAreaMusicHeader:
00848E  2  A0 08                ldy #$08                   ;load Y for offset of area music
008490  2  84 F7                sty MusicOffset_Square2    ;residual instruction here
008492  2               
008492  2               FindEventMusicHeader:
008492  2  C8                   iny                       ;increment Y pointer based on previously loaded queue contents
008493  2  4A                   lsr                       ;bit shift and increment until we find a set bit for music
008494  2  90 FC                bcc FindEventMusicHeader
008496  2               
008496  2               LoadHeader:
008496  2  B9 D6 86             lda MusicHeaderOffsetData,y  ;load offset for header
008499  2  A8                   tay
00849A  2  B9 D7 86             lda MusicHeaderData,y        ;now load the header
00849D  2  85 F0                sta NoteLenLookupTblOfs
00849F  2  B9 D8 86             lda MusicHeaderData+1,y
0084A2  2  85 F5                sta MusicDataLow
0084A4  2  B9 D9 86             lda MusicHeaderData+2,y
0084A7  2  85 F6                sta MusicDataHigh
0084A9  2  B9 DA 86             lda MusicHeaderData+3,y
0084AC  2  85 F9                sta MusicOffset_Triangle
0084AE  2  B9 DB 86             lda MusicHeaderData+4,y
0084B1  2  85 F8                sta MusicOffset_Square1
0084B3  2  B9 DC 86             lda MusicHeaderData+5,y
0084B6  2  8D B0 07             sta MusicOffset_Noise
0084B9  2  8D C1 07             sta NoiseDataLoopbackOfs
0084BC  2  A9 01                lda #$01                     ;initialize music note counters
0084BE  2  8D B4 07             sta Squ2_NoteLenCounter
0084C1  2  8D B6 07             sta Squ1_NoteLenCounter
0084C4  2  8D B9 07             sta Tri_NoteLenCounter
0084C7  2  8D BA 07             sta Noise_BeatLenCounter
0084CA  2  A9 00                lda #$00                     ;initialize music data offset for square 2
0084CC  2  85 F7                sta MusicOffset_Square2
0084CE  2  8D CA 07             sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
0084D1  2  A9 0B                lda #$0b                     ;disable triangle channel and reenable it
0084D3  2  8D 15 40             sta SND_MASTERCTRL_REG
0084D6  2  A9 0F                lda #$0f
0084D8  2  8D 15 40             sta SND_MASTERCTRL_REG
0084DB  2               
0084DB  2               HandleSquare2Music:
0084DB  2  CE B4 07             dec Squ2_NoteLenCounter  ;decrement square 2 note length
0084DE  2  D0 69                bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
0084E0  2  A4 F7                ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
0084E2  2  E6 F7                inc MusicOffset_Square2
0084E4  2  B1 F5                lda (MusicData),y
0084E6  2  F0 04                beq EndOfMusicData       ;if zero, the data is a null terminator
0084E8  2  10 47                bpl Squ2NoteHandler      ;if non-negative, data is a note
0084EA  2  D0 39                bne Squ2LengthHandler    ;otherwise it is length data
0084EC  2               
0084EC  2               EndOfMusicData:
0084EC  2  AD B1 07             lda EventMusicBuffer     ;check secondary buffer for time running out music
0084EF  2  C9 40                cmp #TimeRunningOutMusic
0084F1  2  D0 05                bne NotTRO
0084F3  2  AD C5 07             lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
0084F6  2  D0 1D                bne MusicLoopBack        ;and start playing the song again if there is one
0084F8  2  29 04        NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
0084FA  2  D0 1C                bne VictoryMLoopBack
0084FC  2  A5 F4                lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
0084FE  2  29 5F                and #%01011111
008500  2  D0 13                bne MusicLoopBack        ;if any area music except pipe intro, music loops
008502  2               StopMusic:
008502  2  A9 00                lda #$00                 ;clear primary and secondary buffers and initialize
008504  2  85 F4                sta AreaMusicBuffer      ;control regs of square and triangle channels
008506  2  8D B1 07             sta EventMusicBuffer
008509  2  8D 08 40             sta SND_TRIANGLE_REG
00850C  2  A9 90                lda #$90
00850E  2  8D 00 40             sta SND_SQUARE1_REG
008511  2  8D 04 40             sta SND_SQUARE2_REG
008514  2  60                   rts
008515  2               
008515  2               MusicLoopBack:
008515  2  4C 75 84             jmp HandleAreaMusicLoopB
008518  2               
008518  2               VictoryMLoopBack:
008518  2  EE 1D 06             inc PatternNumber   ;increment counter for next part of victory music
00851B  2  AC 1D 06             ldy PatternNumber
00851E  2  C0 3D                cpy #$3d            ;if counter reached a certain point, end song
008520  2  F0 E0                beq StopMusic
008522  2  4C 96 84             jmp LoadHeader      ;otherwise play the next part of the song
008525  2               
008525  2               Squ2LengthHandler:
008525  2  20 85 86             jsr ProcessLengthData    ;store length of note
008528  2  8D B3 07             sta Squ2_NoteLenBuffer
00852B  2  A4 F7                ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
00852D  2  E6 F7                inc MusicOffset_Square2
00852F  2  B1 F5                lda (MusicData),y
008531  2               
008531  2               Squ2NoteHandler:
008531  2  A6 F2                  ldx Square2SoundBuffer     ;is there a sound playing on this channel?
008533  2  D0 0E                  bne SkipFqL1
008535  2  20 D9 80               jsr SetFreq_Squ2           ;no, then play the note
008538  2  F0 03                  beq Rest                   ;check to see if note is rest
00853A  2  20 92 86               jsr LoadControlRegs        ;if not, load control regs for square 2
00853D  2  8D B5 07     Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
008540  2  20 CF 80               jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
008543  2  AD B3 07     SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
008546  2  8D B4 07               sta Squ2_NoteLenCounter
008549  2               
008549  2               MiscSqu2MusicTasks:
008549  2  A5 F2                   lda Square2SoundBuffer     ;is there a sound playing on square 2?
00854B  2  D0 1A                   bne HandleSquare1Music
00854D  2  AD B1 07                lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
008550  2  29 91                   and #%10010001             ;note that regs for death music or d4 are loaded by default
008552  2  D0 13                   bne HandleSquare1Music
008554  2  AC B5 07                ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
008557  2  F0 03                   beq NoDecEnv1
008559  2  CE B5 07                dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
00855C  2  20 B6 86     NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
00855F  2  8D 04 40                sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
008562  2  A2 7F                   ldx #$7f                   ;death music or d4 set on secondary buffer
008564  2  8E 05 40                stx SND_SQUARE2_REG+1
008567  2               
008567  2               HandleSquare1Music:
008567  2  A4 F8                ldy MusicOffset_Square1    ;is there a nonzero offset here?
008569  2  F0 5A                beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
00856B  2  CE B6 07             dec Squ1_NoteLenCounter    ;decrement square 1 note length
00856E  2  D0 32                bne MiscSqu1MusicTasks     ;is it time for more data?
008570  2               
008570  2               FetchSqu1MusicData:
008570  2  A4 F8                ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
008572  2  E6 F8                inc MusicOffset_Square1
008574  2  B1 F5                lda (MusicData),y
008576  2  D0 0F                bne Squ1NoteHandler        ;if nonzero, then skip this part
008578  2  A9 83                lda #$83
00857A  2  8D 00 40             sta SND_SQUARE1_REG        ;store some data into control regs for square 1
00857D  2  A9 94                lda #$94                   ;and fetch another byte of data, used to give
00857F  2  8D 01 40             sta SND_SQUARE1_REG+1      ;death music its unique sound
008582  2  8D CA 07             sta AltRegContentFlag
008585  2  D0 E9                bne FetchSqu1MusicData     ;unconditional branch
008587  2               
008587  2               Squ1NoteHandler:
008587  2  20 7F 86                jsr AlternateLengthHandler
00858A  2  8D B6 07                sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
00858D  2  A4 F1                   ldy Square1SoundBuffer     ;is there a sound playing on square 1?
00858F  2  D0 34                   bne HandleTriangleMusic
008591  2  8A                      txa
008592  2  29 3E                   and #%00111110             ;change saved data to appropriate note format
008594  2  20 BB 80                jsr SetFreq_Squ1           ;play the note
008597  2  F0 03                   beq SkipCtrlL
008599  2  20 92 86                jsr LoadControlRegs
00859C  2  8D B7 07     SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
00859F  2  20 B1 80                jsr Dump_Squ1_Regs
0085A2  2               
0085A2  2               MiscSqu1MusicTasks:
0085A2  2  A5 F1                      lda Square1SoundBuffer     ;is there a sound playing on square 1?
0085A4  2  D0 1F                      bne HandleTriangleMusic
0085A6  2  AD B1 07                   lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
0085A9  2  29 91                      and #%10010001
0085AB  2  D0 0E                      bne DeathMAltReg
0085AD  2  AC B7 07                   ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
0085B0  2  F0 03                      beq NoDecEnv2
0085B2  2  CE B7 07                   dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
0085B5  2  20 B6 86     NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
0085B8  2  8D 00 40                   sta SND_SQUARE1_REG        ;based on offset set by first load
0085BB  2  AD CA 07     DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
0085BE  2  D0 02                      bne DoAltLoad
0085C0  2  A9 7F                      lda #$7f                   ;load this value if zero, the alternate value
0085C2  2  8D 01 40     DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
0085C5  2               
0085C5  2               HandleTriangleMusic:
0085C5  2  A5 F9                lda MusicOffset_Triangle
0085C7  2  CE B9 07             dec Tri_NoteLenCounter    ;decrement triangle note length
0085CA  2  D0 54                bne HandleNoiseMusic      ;is it time for more data?
0085CC  2  A4 F9                ldy MusicOffset_Triangle  ;increment triangle music offset and fetch data
0085CE  2  E6 F9                inc MusicOffset_Triangle
0085D0  2  B1 F5                lda (MusicData),y
0085D2  2  F0 49                beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise
0085D4  2  10 13                bpl TriNoteHandler        ;if non-negative, data is note
0085D6  2  20 85 86             jsr ProcessLengthData     ;otherwise, it is length data
0085D9  2  8D B8 07             sta Tri_NoteLenBuffer     ;save contents of A
0085DC  2  A9 1F                lda #$1f
0085DE  2  8D 08 40             sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
0085E1  2  A4 F9                ldy MusicOffset_Triangle  ;fetch another byte
0085E3  2  E6 F9                inc MusicOffset_Triangle
0085E5  2  B1 F5                lda (MusicData),y
0085E7  2  F0 34                beq LoadTriCtrlReg        ;check once more for nonzero data
0085E9  2               
0085E9  2               TriNoteHandler:
0085E9  2  20 DD 80               jsr SetFreq_Tri
0085EC  2  AE B8 07               ldx Tri_NoteLenBuffer   ;save length in triangle note counter
0085EF  2  8E B9 07               stx Tri_NoteLenCounter
0085F2  2  AD B1 07               lda EventMusicBuffer
0085F5  2  29 6E                  and #%01101110          ;check for death music or d4 set on secondary buffer
0085F7  2  D0 06                  bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
0085F9  2  A5 F4                  lda AreaMusicBuffer     ;check primary buffer for water or castle level music
0085FB  2  29 0A                  and #%00001010
0085FD  2  F0 21                  beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
0085FF  2  8A           NotDOrD4: txa                     ;if playing water or castle music or any secondary
008600  2  C9 12                  cmp #$12                ;besides death music or d4 set, check length of note
008602  2  B0 17                  bcs LongN
008604  2  AD B1 07               lda EventMusicBuffer    ;check for victory music if not playing a long note
008607  2  C9 04                  cmp #VictoryMusic
008609  2  D0 04                  bne NotVictoryMusic     ;go to check for win castle music if not
00860B  2  A9 18                  lda #$18                ;otherwise load value $18 for victory music
00860D  2  D0 0E                  bne LoadTriCtrlReg
00860F  2               NotVictoryMusic:
00860F  2  29 08                  and #EndOfCastleMusic   ;check for win castle music again if not playing a long note
008611  2  F0 04                  beq MediN
008613  2  A9 0F                  lda #$0f                ;load value $0f if playing the win castle music and playing a short
008615  2  D0 06                  bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
008617  2  A9 1F        MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
008619  2  D0 02                  bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
00861B  2  A9 FF        LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
00861D  2               
00861D  2               LoadTriCtrlReg:
00861D  2  8D 08 40             sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
008620  2               
008620  2               HandleNoiseMusic:
008620  2  AD B1 07             lda EventMusicBuffer      ;check if playing victory music
008623  2  C9 04                cmp #VictoryMusic
008625  2  F0 06                beq PlayNoiseMusic        ;if so, play noise
008627  2  A5 F4                lda AreaMusicBuffer       ;check if playing underground or castle music
008629  2  29 F3                and #%11110011
00862B  2  F0 51                beq ExitMusicHandler      ;if so, skip the noise routine
00862D  2               PlayNoiseMusic:
00862D  2  CE BA 07             dec Noise_BeatLenCounter  ;decrement noise beat length
008630  2  D0 4C                bne ExitMusicHandler      ;is it time for more data?
008632  2               
008632  2               FetchNoiseBeatData:
008632  2  AC B0 07             ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
008635  2  EE B0 07             inc MusicOffset_Noise
008638  2  B1 F5                lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
00863A  2  D0 08                bne NoiseBeatHandler
00863C  2  AD C1 07             lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
00863F  2  8D B0 07             sta MusicOffset_Noise       ;and loopback next time around
008642  2  D0 EE                bne FetchNoiseBeatData      ;unconditional branch
008644  2               
008644  2               NoiseBeatHandler:
008644  2  20 7F 86             jsr AlternateLengthHandler
008647  2  8D BA 07             sta Noise_BeatLenCounter    ;store length in noise beat counter
00864A  2  8A                   txa
00864B  2  29 3E                and #%00111110              ;reload data and erase length bits
00864D  2  F0 24                beq SilentBeat              ;if no beat data, silence
00864F  2  C9 30                cmp #$30                    ;check the beat data and play the appropriate
008651  2  F0 18                beq LongBeat                ;noise accordingly
008653  2  C9 20                cmp #$20
008655  2  F0 0C                beq StrongBeat
008657  2  29 10                and #%00010000
008659  2  F0 18                beq SilentBeat
00865B  2  A9 1C                lda #$1c        ;short beat data
00865D  2  A2 03                ldx #$03
00865F  2  A0 18                ldy #$18
008661  2  D0 12                bne PlayBeat
008663  2               
008663  2               StrongBeat:
008663  2  A9 1C                lda #$1c        ;strong beat data
008665  2  A2 0C                ldx #$0c
008667  2  A0 18                ldy #$18
008669  2  D0 0A                bne PlayBeat
00866B  2               
00866B  2               LongBeat:
00866B  2  A9 1C                lda #$1c        ;long beat data
00866D  2  A2 03                ldx #$03
00866F  2  A0 58                ldy #$58
008671  2  D0 02                bne PlayBeat
008673  2               
008673  2               SilentBeat:
008673  2  A9 10                lda #$10        ;silence
008675  2               
008675  2               PlayBeat:
008675  2  8D 0C 40             sta SND_NOISE_REG    ;load beat data into noise regs
008678  2  8E 0E 40             stx SND_NOISE_REG+2
00867B  2  8C 0F 40             sty SND_NOISE_REG+3
00867E  2               
00867E  2               ExitMusicHandler:
00867E  2  60                   rts
00867F  2               
00867F  2               AlternateLengthHandler:
00867F  2  AA                   tax            ;save a copy of original byte into X
008680  2  6A                   ror            ;save LSB from original byte into carry
008681  2  8A                   txa            ;reload original byte and rotate three times
008682  2  2A                   rol            ;turning xx00000x into 00000xxx, with the
008683  2  2A                   rol            ;bit in carry as the MSB here
008684  2  2A                   rol
008685  2               
008685  2               ProcessLengthData:
008685  2  29 07                and #%00000111              ;clear all but the three LSBs
008687  2  18                   clc
008688  2  65 F0                adc NoteLenLookupTblOfs     ;add offset loaded from first header byte
00868A  2  6D C4 07             adc NoteLengthTblAdder      ;add extra if time running out music
00868D  2  A8                   tay
00868E  2  B9 45 8E             lda MusicLengthLookupTbl,y  ;load length
008691  2  60                   rts
008692  2               
008692  2               LoadControlRegs:
008692  2  AD B1 07                lda EventMusicBuffer  ;check secondary buffer for victory music
008695  2  C9 04                   cmp #VictoryMusic
008697  2  D0 04                   bne NotVctryM
008699  2  A9 10                   lda #$10              ;this value is only used for victory music
00869B  2  D0 14                   bne AllMus            ;unconditional branch
00869D  2  29 08        NotVctryM: and #EndOfCastleMusic ;check secondary buffer for win castle music
00869F  2  F0 04                   beq NotECstlM
0086A1  2  A9 04                   lda #$04              ;this value is only used for win castle music
0086A3  2  D0 0C                   bne AllMus            ;unconditional branch
0086A5  2  A5 F4        NotECstlM: lda AreaMusicBuffer
0086A7  2  29 7D                   and #%01111101        ;check primary buffer for water music
0086A9  2  F0 04                   beq WaterMus
0086AB  2  A9 08                   lda #$08              ;this is the default value for all other music
0086AD  2  D0 02                   bne AllMus
0086AF  2  A9 28        WaterMus:  lda #$28              ;this value is used for water music and all other event music
0086B1  2  A2 82        AllMus:    ldx #$82              ;load contents of other sound regs for square 2
0086B3  2  A0 7F                   ldy #$7f
0086B5  2  60                      rts
0086B6  2               
0086B6  2               LoadEnvelopeData:
0086B6  2  AD B1 07             lda EventMusicBuffer           ;check secondary buffer for victory music
0086B9  2  C9 04                cmp #VictoryMusic
0086BB  2  D0 04                bne LoadEndOfCastleMusEnvData
0086BD  2  B9 85 8E             lda VictoryMusEnvData,y        ;load data from offset for victory music
0086C0  2  60                   rts
0086C1  2               
0086C1  2               LoadEndOfCastleMusEnvData:
0086C1  2  29 08                and #EndOfCastleMusic          ;check secondary buffer for win castle music
0086C3  2  F0 04                beq LoadUsualEnvData
0086C5  2  B9 96 8E             lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
0086C8  2  60                   rts
0086C9  2               
0086C9  2               LoadUsualEnvData:
0086C9  2  A5 F4                lda AreaMusicBuffer            ;check primary buffer for water music
0086CB  2  29 7D                and #%01111101
0086CD  2  F0 04                beq LoadWaterEventMusEnvData
0086CF  2  B9 9A 8E             lda AreaMusicEnvData,y         ;load default data from offset for all other music
0086D2  2  60                   rts
0086D3  2               
0086D3  2               LoadWaterEventMusEnvData:
0086D3  2  B9 A2 8E             lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
0086D6  2  60                   rts
0086D7  2               
0086D7  2               MusicHeaderData:
0086D7  2  CF             .byte DeathMusHdr-MHD
0086D8  2  83             .byte GameOverMusHdr-MHD
0086D9  2  5F             .byte VictoryPart1AHdr-MHD
0086DA  2  8E             .byte WinCastleMusHdr-MHD
0086DB  2  83             .byte GameOverMusHdr-MHD
0086DC  2  47             .byte EndOfLevelMusHdr-MHD
0086DD  2  3C             .byte TimeRunningOutHdr-MHD
0086DE  2  56             .byte SilenceHdr-MHD
0086DF  2               
0086DF  2  93             .byte GroundLevelPart1Hdr-MHD   ;area music
0086E0  2  88             .byte WaterMusHdr-MHD
0086E1  2  51             .byte UndergroundMusHdr-MHD
0086E2  2  5A             .byte CastleMusHdr-MHD
0086E3  2  41             .byte Star_CloudHdr-MHD
0086E4  2  B7             .byte GroundLevelLeadInHdr-MHD
0086E5  2  41             .byte Star_CloudHdr-MHD
0086E6  2  56             .byte SilenceHdr-MHD
0086E7  2               
0086E7  2  B7             .byte GroundLevelLeadInHdr-MHD  ;ground level music layout
0086E8  2  93 93          .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
0086EA  2  99 9F 99 A5    .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
0086EE  2  99 9F 99 A5    .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
0086F2  2  AB B1 AB B7    .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
0086F6  2  93 93          .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
0086F8  2  BD C3 BD C9    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
0086FC  2  BD C3 BD C9    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
008700  2  AB B1 AB B7    .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
008704  2  BD C3 BD C9    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
008708  2               
008708  2  5F 5F 65 5F    .byte VictoryPart1AHdr-MHD, VictoryPart1AHdr-MHD, VictoryPart1BHdr-MHD, VictoryPart1AHdr-MHD ;victory music layout
00870C  2  6B 7D 6B 7D    .byte VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD
008710  2  71 6B 77       .byte VictoryPart2CHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2DHdr-MHD
008713  2               
008713  2               ;music headers
008713  2               ;header format is as follows:
008713  2               ;1 byte - length byte offset
008713  2               ;2 bytes -  music data address
008713  2               ;1 byte - triangle data offset
008713  2               ;1 byte - square 1 data offset
008713  2               ;1 byte - noise data offset (not used by secondary music)
008713  2               
008713  2  08 66 8A 27  TimeRunningOutHdr:     .byte $08, <TimeRunOutMusData, >TimeRunOutMusData, $27, $18
008717  2  18           
008718  2  20 AC 87 2E  Star_CloudHdr:         .byte $20, <Star_CloudMData, >Star_CloudMData, $2e, $1a, $40
00871C  2  1A 40        
00871E  2  20 A4 8A 3D  EndOfLevelMusHdr:      .byte $20, <WinLevelMusData, >WinLevelMusData, $3d, $21
008722  2  21           
008723  2  20 FB DC 3F  ResidualHeaderData:    .byte $20, $fb, $dc, $3f, $1d
008727  2  1D           
008728  2  18 05 8B 00  UndergroundMusHdr:     .byte $18, <UndergroundMusData, >UndergroundMusData, $00, $00
00872C  2  00           
00872D  2  08 10 88 00  SilenceHdr:            .byte $08, <SilenceData, >SilenceData, $00
008731  2  00 98 89 93  CastleMusHdr:          .byte $00, <CastleMusData, >CastleMusData, $93, $62
008735  2  62           
008736  2  30 BC 8C 24  VictoryPart1AHdr:      .byte $30, <VictoryM_P1AData, >VictoryM_P1AData, $24, $14, $77
00873A  2  14 77        
00873C  2  30 F1 8C 31  VictoryPart1BHdr:      .byte $30, <VictoryM_P1BData, >VictoryM_P1BData, $31, $21, $42
008740  2  21 42        
008742  2  30 3A 8D 29  VictoryPart2AHdr:      .byte $30, <VictoryM_P2AData, >VictoryM_P2AData, $29, $1c, $7c
008746  2  1C 7C        
008748  2  30 74 8D 31  VictoryPart2CHdr:      .byte $30, <VictoryM_P2CData, >VictoryM_P2CData, $31, $20, $42
00874C  2  20 42        
00874E  2  38 BD 8D 06  VictoryPart2DHdr:      .byte $38, <VictoryM_P2DData, >VictoryM_P2DData, $06, $04, $1b
008752  2  04 1B        
008754  2  38 51 8D 20  VictoryPart2BHdr:      .byte $38, <VictoryM_P2BData, >VictoryM_P2BData, $20, $10, $65
008758  2  10 65        
00875A  2  18 39 8A 1E  GameOverMusHdr:        .byte $18, <GameOverMusData, >GameOverMusData, $1e, $14
00875E  2  14           
00875F  2  08 46 8B A0  WaterMusHdr:           .byte $08, <WaterMusData, >WaterMusData, $a0, $70, $68
008763  2  70 68        
008765  2  08 45 8C 4C  WinCastleMusHdr:       .byte $08, <EndOfCastleMusData, >EndOfCastleMusData, $4c, $24
008769  2  24           
00876A  2  18 F5 87 2D  GroundLevelPart1Hdr:   .byte $18, <GroundM_P1Data, >GroundM_P1Data, $2d, $1c, $b8
00876E  2  1C B8        
008770  2  18 3D 88 20  GroundLevelPart2AHdr:  .byte $18, <GroundM_P2AData, >GroundM_P2AData, $20, $12, $70
008774  2  12 70        
008776  2  18 69 88 1B  GroundLevelPart2BHdr:  .byte $18, <GroundM_P2BData, >GroundM_P2BData, $1b, $10, $44
00877A  2  10 44        
00877C  2  18 91 88 11  GroundLevelPart2CHdr:  .byte $18, <GroundM_P2CData, >GroundM_P2CData, $11, $0a, $1c
008780  2  0A 1C        
008782  2  18 B6 88 2D  GroundLevelPart3AHdr:  .byte $18, <GroundM_P3AData, >GroundM_P3AData, $2d, $10, $58
008786  2  10 58        
008788  2  18 CF 88 14  GroundLevelPart3BHdr:  .byte $18, <GroundM_P3BData, >GroundM_P3BData, $14, $0d, $3f
00878C  2  0D 3F        
00878E  2  18 ED 88 15  GroundLevelLeadInHdr:  .byte $18, <GroundMLdInData, >GroundMLdInData, $15, $0d, $21
008792  2  0D 21        
008794  2  18 19 89 18  GroundLevelPart4AHdr:  .byte $18, <GroundM_P4AData, >GroundM_P4AData, $18, $10, $7a
008798  2  10 7A        
00879A  2  18 3F 89 19  GroundLevelPart4BHdr:  .byte $18, <GroundM_P4BData, >GroundM_P4BData, $19, $0f, $54
00879E  2  0F 54        
0087A0  2  18 68 89 1E  GroundLevelPart4CHdr:  .byte $18, <GroundM_P4CData, >GroundM_P4CData, $1e, $12, $2b
0087A4  2  12 2B        
0087A6  2  18 66 89 1E  DeathMusHdr:           .byte $18, <DeathMusData, >DeathMusData, $1e, $0f, $2d
0087AA  2  0F 2D        
0087AC  2               
0087AC  2               ;--------------------------------
0087AC  2               
0087AC  2               ;MUSIC DATA
0087AC  2               ;square 2/triangle format
0087AC  2               ;d7 - length byte flag (0-note, 1-length)
0087AC  2               ;if d7 is set to 0 and d6-d0 is nonzero:
0087AC  2               ;d6-d0 - note offset in frequency look-up table (must be even)
0087AC  2               ;if d7 is set to 1:
0087AC  2               ;d6-d3 - unused
0087AC  2               ;d2-d0 - length offset in length look-up table
0087AC  2               ;value of $00 in square 2 data is used as null terminator, affects all sound channels
0087AC  2               ;value of $00 in triangle data causes routine to skip note
0087AC  2               
0087AC  2               ;square 1 format
0087AC  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
0087AC  2               ;d5-d1 - note offset in frequency look-up table
0087AC  2               ;value of $00 in square 1 data is flag alternate control reg data to be loaded
0087AC  2               
0087AC  2               ;noise format
0087AC  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
0087AC  2               ;d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)
0087AC  2               ;d3-d1 - unused
0087AC  2               ;value of $00 in noise data is used as null terminator, affects only noise
0087AC  2               
0087AC  2               ;all music data is organized into sections (unless otherwise stated):
0087AC  2               ;square 2, square 1, triangle, noise
0087AC  2               
0087AC  2               Star_CloudMData:
0087AC  2  84 2C 2C 2C        .byte $84, $2c, $2c, $2c, $82, $04, $2c, $04, $85, $2c, $84, $2c, $2c
0087B0  2  82 04 2C 04  
0087B4  2  85 2C 84 2C  
0087B9  2  2A 2A 2A 82        .byte $2a, $2a, $2a, $82, $04, $2a, $04, $85, $2a, $84, $2a, $2a, $00
0087BD  2  04 2A 04 85  
0087C1  2  2A 84 2A 2A  
0087C6  2               
0087C6  2  1F 1F 1F 98        .byte $1f, $1f, $1f, $98, $1f, $1f, $98, $9e, $98, $1f
0087CA  2  1F 1F 98 9E  
0087CE  2  98 1F        
0087D0  2  1D 1D 1D 94        .byte $1d, $1d, $1d, $94, $1d, $1d, $94, $9c, $94, $1d
0087D4  2  1D 1D 94 9C  
0087D8  2  94 1D        
0087DA  2               
0087DA  2  86 18 85 26        .byte $86, $18, $85, $26, $30, $84, $04, $26, $30
0087DE  2  30 84 04 26  
0087E2  2  30           
0087E3  2  86 14 85 22        .byte $86, $14, $85, $22, $2c, $84, $04, $22, $2c
0087E7  2  2C 84 04 22  
0087EB  2  2C           
0087EC  2               
0087EC  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
0087F0  2  31 D0 C4 D0  
0087F4  2  00           
0087F5  2               
0087F5  2               GroundM_P1Data:
0087F5  2  85 2C 22 1C        .byte $85, $2c, $22, $1c, $84, $26, $2a, $82, $28, $26, $04
0087F9  2  84 26 2A 82  
0087FD  2  28 26 04     
008800  2  87 22 34 3A        .byte $87, $22, $34, $3a, $82, $40, $04, $36, $84, $3a, $34
008804  2  82 40 04 36  
008808  2  84 3A 34     
00880B  2  82 2C 30 85        .byte $82, $2c, $30, $85, $2a
00880F  2  2A           
008810  2               
008810  2               SilenceData:
008810  2  00                 .byte $00
008811  2               
008811  2  5D 55 4D 15        .byte $5d, $55, $4d, $15, $19, $96, $15, $d5, $e3, $eb
008815  2  19 96 15 D5  
008819  2  E3 EB        
00881B  2  2D A6 2B 27        .byte $2d, $a6, $2b, $27, $9c, $9e, $59
00881F  2  9C 9E 59     
008822  2               
008822  2  85 22 1C 14        .byte $85, $22, $1c, $14, $84, $1e, $22, $82, $20, $1e, $04, $87
008826  2  84 1E 22 82  
00882A  2  20 1E 04 87  
00882E  2  1C 2C 34 82        .byte $1c, $2c, $34, $82, $36, $04, $30, $34, $04, $2c, $04, $26
008832  2  36 04 30 34  
008836  2  04 2C 04 26  
00883A  2  2A 85 22           .byte $2a, $85, $22
00883D  2               
00883D  2               GroundM_P2AData:
00883D  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
008841  2  38 36 32 04  
008845  2  34           
008846  2  04 24 26 2C        .byte $04, $24, $26, $2c, $04, $26, $2c, $30, $00
00884A  2  04 26 2C 30  
00884E  2  00           
00884F  2               
00884F  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
008853  2  2B AC 84     
008856  2  9C 9E A2 84        .byte $9c, $9e, $a2, $84, $94, $9c, $9e
00885A  2  94 9C 9E     
00885D  2               
00885D  2  85 14 22 84        .byte $85, $14, $22, $84, $2c, $85, $1e
008861  2  2C 85 1E     
008864  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $1e
008868  2  1E           
008869  2               
008869  2               GroundM_P2BData:
008869  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00886D  2  38 36 32 04  
008871  2  34           
008872  2  04 64 04 64        .byte $04, $64, $04, $64, $86, $64, $00
008876  2  86 64 00     
008879  2               
008879  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00887D  2  2B AC 84     
008880  2  37 B6 B6 45        .byte $37, $b6, $b6, $45
008884  2               
008884  2  85 14 1C 82        .byte $85, $14, $1c, $82, $22, $84, $2c
008888  2  22 84 2C     
00888B  2  4E 82 4E 84        .byte $4e, $82, $4e, $84, $4e, $22
00888F  2  4E 22        
008891  2               
008891  2               GroundM_P2CData:
008891  2  84 04 85 32        .byte $84, $04, $85, $32, $85, $30, $86, $2c, $04, $00
008895  2  85 30 86 2C  
008899  2  04 00        
00889B  2               
00889B  2  05 A4 05 9E        .byte $05, $a4, $05, $9e, $05, $9d, $85
00889F  2  05 9D 85     
0088A2  2               
0088A2  2  84 14 85 24        .byte $84, $14, $85, $24, $28, $2c, $82
0088A6  2  28 2C 82     
0088A9  2  22 84 22 14        .byte $22, $84, $22, $14
0088AD  2               
0088AD  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
0088B1  2  31 D0 C4 D0  
0088B5  2  00           
0088B6  2               
0088B6  2               GroundM_P3AData:
0088B6  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $2c, $82, $2c, $30
0088BA  2  2C 82 2C 30  
0088BE  2  04 34 2C 04        .byte $04, $34, $2c, $04, $26, $86, $22, $00
0088C2  2  26 86 22 00  
0088C6  2               
0088C6  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $29, $a2, $1d, $9c, $95
0088CA  2  29 A2 1D 9C  
0088CE  2  95           
0088CF  2               
0088CF  2               GroundM_P3BData:
0088CF  2  82 2C 2C 04        .byte $82, $2c, $2c, $04, $2c, $04, $2c, $30, $85, $34, $04, $04, $00
0088D3  2  2C 04 2C 30  
0088D7  2  85 34 04 04  
0088DC  2               
0088DC  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $a8, $63, $04
0088E0  2  A8 63 04     
0088E3  2               
0088E3  2               ;triangle data used by both sections of third part
0088E3  2  85 0E 1A 84        .byte $85, $0e, $1a, $84, $24, $85, $22, $14, $84, $0c
0088E7  2  24 85 22 14  
0088EB  2  84 0C        
0088ED  2               
0088ED  2               GroundMLdInData:
0088ED  2  82 34 84 34        .byte $82, $34, $84, $34, $34, $82, $2c, $84, $34, $86, $3a, $04, $00
0088F1  2  34 82 2C 84  
0088F5  2  34 86 3A 04  
0088FA  2               
0088FA  2  A0 21 21 A0        .byte $a0, $21, $21, $a0, $21, $2b, $05, $a3
0088FE  2  21 2B 05 A3  
008902  2               
008902  2  82 18 84 18        .byte $82, $18, $84, $18, $18, $82, $18, $18, $04, $86, $3a, $22
008906  2  18 82 18 18  
00890A  2  04 86 3A 22  
00890E  2               
00890E  2               ;noise data used by lead-in and third part sections
00890E  2  31 90 31 90        .byte $31, $90, $31, $90, $31, $71, $31, $90, $90, $90, $00
008912  2  31 71 31 90  
008916  2  90 90 00     
008919  2               
008919  2               GroundM_P4AData:
008919  2  82 34 84 2C        .byte $82, $34, $84, $2c, $85, $22, $84, $24
00891D  2  85 22 84 24  
008921  2  82 26 36 04        .byte $82, $26, $36, $04, $36, $86, $26, $00
008925  2  36 86 26 00  
008929  2               
008929  2  AC 27 5D 1D        .byte $ac, $27, $5d, $1d, $9e, $2d, $ac, $9f
00892D  2  9E 2D AC 9F  
008931  2               
008931  2  85 14 82 20        .byte $85, $14, $82, $20, $84, $22, $2c
008935  2  84 22 2C     
008938  2  1E 1E 82 2C        .byte $1e, $1e, $82, $2c, $2c, $1e, $04
00893C  2  2C 1E 04     
00893F  2               
00893F  2               GroundM_P4BData:
00893F  2  87 2A 40 40        .byte $87, $2a, $40, $40, $40, $3a, $36
008943  2  40 3A 36     
008946  2  82 34 2C 04        .byte $82, $34, $2c, $04, $26, $86, $22, $00
00894A  2  26 86 22 00  
00894E  2               
00894E  2  E3 F7 F7 F7        .byte $e3, $f7, $f7, $f7, $f5, $f1, $ac, $27, $9e, $9d
008952  2  F5 F1 AC 27  
008956  2  9E 9D        
008958  2               
008958  2  85 18 82 1E        .byte $85, $18, $82, $1e, $84, $22, $2a
00895C  2  84 22 2A     
00895F  2  22 22 82 2C        .byte $22, $22, $82, $2c, $2c, $22, $04
008963  2  2C 22 04     
008966  2               
008966  2               DeathMusData:
008966  2  86 04              .byte $86, $04 ;death music share data with fourth part c of ground level music
008968  2               
008968  2               GroundM_P4CData:
008968  2  82 2A 36 04        .byte $82, $2a, $36, $04, $36, $87, $36, $34, $30, $86, $2c, $04, $00
00896C  2  36 87 36 34  
008970  2  30 86 2C 04  
008975  2               
008975  2  00 68 6A 6C        .byte $00, $68, $6a, $6c, $45 ;death music only
008979  2  45           
00897A  2               
00897A  2  A2 31 B0 F1        .byte $a2, $31, $b0, $f1, $ed, $eb, $a2, $1d, $9c, $95
00897E  2  ED EB A2 1D  
008982  2  9C 95        
008984  2               
008984  2  86 04              .byte $86, $04 ;death music only
008986  2               
008986  2  85 22 82 22        .byte $85, $22, $82, $22, $87, $22, $26, $2a, $84, $2c, $22, $86, $14
00898A  2  87 22 26 2A  
00898E  2  84 2C 22 86  
008993  2               
008993  2               ;noise data used by fourth part sections
008993  2  51 90 31 11        .byte $51, $90, $31, $11, $00
008997  2  00           
008998  2               
008998  2               CastleMusData:
008998  2  80 22 28 22        .byte $80, $22, $28, $22, $26, $22, $24, $22, $26
00899C  2  26 22 24 22  
0089A0  2  26           
0089A1  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
0089A5  2  22 28 22 26  
0089A9  2  22 28 22 26        .byte $22, $28, $22, $26, $22, $24, $22, $26
0089AD  2  22 24 22 26  
0089B1  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
0089B5  2  22 28 22 26  
0089B9  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
0089BD  2  20 26 20 28  
0089C1  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
0089C5  2  20 26 20 24  
0089C9  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
0089CD  2  20 26 20 28  
0089D1  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
0089D5  2  20 26 20 24  
0089D9  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
0089DD  2  28 30 28 2E  
0089E1  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e
0089E5  2  28 2C 28 2E  
0089E9  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
0089ED  2  28 30 28 2E  
0089F1  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e, $00
0089F5  2  28 2C 28 2E  
0089F9  2  00           
0089FA  2               
0089FA  2  04 70 6E 6C        .byte $04, $70, $6e, $6c, $6e, $70, $72, $70, $6e
0089FE  2  6E 70 72 70  
008A02  2  6E           
008A03  2  70 6E 6C 6E        .byte $70, $6e, $6c, $6e, $70, $72, $70, $6e
008A07  2  70 72 70 6E  
008A0B  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
008A0F  2  6E 70 6E 6C  
008A13  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
008A17  2  6E 70 6E 6C  
008A1B  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
008A1F  2  76 74 72 74  
008A23  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
008A27  2  76 74 72 74  
008A2B  2               
008A2B  2  84 1A 83 18        .byte $84, $1a, $83, $18, $20, $84, $1e, $83, $1c, $28
008A2F  2  20 84 1E 83  
008A33  2  1C 28        
008A35  2  26 1C 1A 1C        .byte $26, $1c, $1a, $1c
008A39  2               
008A39  2               GameOverMusData:
008A39  2  82 2C 04 04        .byte $82, $2c, $04, $04, $22, $04, $04, $84, $1c, $87
008A3D  2  22 04 04 84  
008A41  2  1C 87        
008A43  2  26 2A 26 84        .byte $26, $2a, $26, $84, $24, $28, $24, $80, $22, $00
008A47  2  24 28 24 80  
008A4B  2  22 00        
008A4D  2               
008A4D  2  9C 05 94 05        .byte $9c, $05, $94, $05, $0d, $9f, $1e, $9c, $98, $9d
008A51  2  0D 9F 1E 9C  
008A55  2  98 9D        
008A57  2               
008A57  2  82 22 04 04        .byte $82, $22, $04, $04, $1c, $04, $04, $84, $14
008A5B  2  1C 04 04 84  
008A5F  2  14           
008A60  2  86 1E 80 16        .byte $86, $1e, $80, $16, $80, $14
008A64  2  80 14        
008A66  2               
008A66  2               TimeRunOutMusData:
008A66  2  81 1C 30 04        .byte $81, $1c, $30, $04, $30, $30, $04, $1e, $32, $04, $32, $32
008A6A  2  30 30 04 1E  
008A6E  2  32 04 32 32  
008A72  2  04 20 34 04        .byte $04, $20, $34, $04, $34, $34, $04, $36, $04, $84, $36, $00
008A76  2  34 34 04 36  
008A7A  2  04 84 36 00  
008A7E  2               
008A7E  2  46 A4 64 A4        .byte $46, $a4, $64, $a4, $48, $a6, $66, $a6, $4a, $a8, $68, $a8
008A82  2  48 A6 66 A6  
008A86  2  4A A8 68 A8  
008A8A  2  6A 44 2B           .byte $6a, $44, $2b
008A8D  2               
008A8D  2  81 2A 42 04        .byte $81, $2a, $42, $04, $42, $42, $04, $2c, $64, $04, $64, $64
008A91  2  42 42 04 2C  
008A95  2  64 04 64 64  
008A99  2  04 2E 46 04        .byte $04, $2e, $46, $04, $46, $46, $04, $22, $04, $84, $22
008A9D  2  46 46 04 22  
008AA1  2  04 84 22     
008AA4  2               
008AA4  2               WinLevelMusData:
008AA4  2  87 04 06 0C        .byte $87, $04, $06, $0c, $14, $1c, $22, $86, $2c, $22
008AA8  2  14 1C 22 86  
008AAC  2  2C 22        
008AAE  2  87 04 60 0E        .byte $87, $04, $60, $0e, $14, $1a, $24, $86, $2c, $24
008AB2  2  14 1A 24 86  
008AB6  2  2C 24        
008AB8  2  87 04 08 10        .byte $87, $04, $08, $10, $18, $1e, $28, $86, $30, $30
008ABC  2  18 1E 28 86  
008AC0  2  30 30        
008AC2  2  80 64 00           .byte $80, $64, $00
008AC5  2               
008AC5  2  CD D5 DD E3        .byte $cd, $d5, $dd, $e3, $ed, $f5, $bb, $b5, $cf, $d5
008AC9  2  ED F5 BB B5  
008ACD  2  CF D5        
008ACF  2  DB E5 ED F3        .byte $db, $e5, $ed, $f3, $bd, $b3, $d1, $d9, $df, $e9
008AD3  2  BD B3 D1 D9  
008AD7  2  DF E9        
008AD9  2  F1 F7 BF FF        .byte $f1, $f7, $bf, $ff, $ff, $ff, $34
008ADD  2  FF FF 34     
008AE0  2  00                 .byte $00 ;unused byte
008AE1  2               
008AE1  2  86 04 87 14        .byte $86, $04, $87, $14, $1c, $22, $86, $34, $84, $2c
008AE5  2  1C 22 86 34  
008AE9  2  84 2C        
008AEB  2  04 04 04 87        .byte $04, $04, $04, $87, $14, $1a, $24, $86, $32, $84
008AEF  2  14 1A 24 86  
008AF3  2  32 84        
008AF5  2  2C 04 86 04        .byte $2c, $04, $86, $04, $87, $18, $1e, $28, $86, $36
008AF9  2  87 18 1E 28  
008AFD  2  86 36        
008AFF  2  87 30 30 30        .byte $87, $30, $30, $30, $80, $2c
008B03  2  80 2C        
008B05  2               
008B05  2               ;square 2 and triangle use the same data, square 1 is unused
008B05  2               UndergroundMusData:
008B05  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
008B09  2  26 10 28 80  
008B0D  2  04           
008B0E  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
008B12  2  26 10 28 80  
008B16  2  04           
008B17  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $80, $04
008B1B  2  18 60 1A 80  
008B1F  2  04           
008B20  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $86, $04
008B24  2  18 60 1A 86  
008B28  2  04           
008B29  2  83 1A 18 16        .byte $83, $1a, $18, $16, $84, $14, $1a, $18, $0e, $0c
008B2D  2  84 14 1A 18  
008B31  2  0E 0C        
008B33  2  16 83 14 20        .byte $16, $83, $14, $20, $1e, $1c, $28, $26, $87
008B37  2  1E 1C 28 26  
008B3B  2  87           
008B3C  2  24 1A 12 10        .byte $24, $1a, $12, $10, $62, $0e, $80, $04, $04
008B40  2  62 0E 80 04  
008B44  2  04           
008B45  2  00                 .byte $00
008B46  2               
008B46  2               ;noise data directly follows square 2 here unlike in other songs
008B46  2               WaterMusData:
008B46  2  82 18 1C 20        .byte $82, $18, $1c, $20, $22, $26, $28
008B4A  2  22 26 28     
008B4D  2  81 2A 2A 2A        .byte $81, $2a, $2a, $2a, $04, $2a, $04, $83, $2a, $82, $22
008B51  2  04 2A 04 83  
008B55  2  2A 82 22     
008B58  2  86 34 32 34        .byte $86, $34, $32, $34, $81, $04, $22, $26, $2a, $2c, $30
008B5C  2  81 04 22 26  
008B60  2  2A 2C 30     
008B63  2  86 34 83 32        .byte $86, $34, $83, $32, $82, $36, $84, $34, $85, $04, $81, $22
008B67  2  82 36 84 34  
008B6B  2  85 04 81 22  
008B6F  2  86 30 2E 30        .byte $86, $30, $2e, $30, $81, $04, $22, $26, $2a, $2c, $2e
008B73  2  81 04 22 26  
008B77  2  2A 2C 2E     
008B7A  2  86 30 83 22        .byte $86, $30, $83, $22, $82, $36, $84, $34, $85, $04, $81, $22
008B7E  2  82 36 84 34  
008B82  2  85 04 81 22  
008B86  2  86 3A 3A 3A        .byte $86, $3a, $3a, $3a, $82, $3a, $81, $40, $82, $04, $81, $3a
008B8A  2  82 3A 81 40  
008B8E  2  82 04 81 3A  
008B92  2  86 36 36 36        .byte $86, $36, $36, $36, $82, $36, $81, $3a, $82, $04, $81, $36
008B96  2  82 36 81 3A  
008B9A  2  82 04 81 36  
008B9E  2  86 34 82 26        .byte $86, $34, $82, $26, $2a, $36
008BA2  2  2A 36        
008BA4  2  81 34 34 85        .byte $81, $34, $34, $85, $34, $81, $2a, $86, $2c, $00
008BA8  2  34 81 2A 86  
008BAC  2  2C 00        
008BAE  2               
008BAE  2  84 90 B0 84        .byte $84, $90, $b0, $84, $50, $50, $b0, $00
008BB2  2  50 50 B0 00  
008BB6  2               
008BB6  2  98 96 94 92        .byte $98, $96, $94, $92, $94, $96, $58, $58, $58, $44
008BBA  2  94 96 58 58  
008BBE  2  58 44        
008BC0  2  5C 44 9F A3        .byte $5c, $44, $9f, $a3, $a1, $a3, $85, $a3, $e0, $a6
008BC4  2  A1 A3 85 A3  
008BC8  2  E0 A6        
008BCA  2  23 C4 9F 9D        .byte $23, $c4, $9f, $9d, $9f, $85, $9f, $d2, $a6, $23
008BCE  2  9F 85 9F D2  
008BD2  2  A6 23        
008BD4  2  C4 B5 B1 AF        .byte $c4, $b5, $b1, $af, $85, $b1, $af, $ad, $85, $95
008BD8  2  85 B1 AF AD  
008BDC  2  85 95        
008BDE  2  9E A2 AA 6A        .byte $9e, $a2, $aa, $6a, $6a, $6b, $5e, $9d
008BE2  2  6A 6B 5E 9D  
008BE6  2               
008BE6  2  84 04 04 82        .byte $84, $04, $04, $82, $22, $86, $22
008BEA  2  22 86 22     
008BED  2  82 14 22 2C        .byte $82, $14, $22, $2c, $12, $22, $2a, $14, $22, $2c
008BF1  2  12 22 2A 14  
008BF5  2  22 2C        
008BF7  2  1C 22 2C 14        .byte $1c, $22, $2c, $14, $22, $2c, $12, $22, $2a, $14
008BFB  2  22 2C 12 22  
008BFF  2  2A 14        
008C01  2  22 2C 1C 22        .byte $22, $2c, $1c, $22, $2c, $18, $22, $2a, $16, $20
008C05  2  2C 18 22 2A  
008C09  2  16 20        
008C0B  2  28 18 22 2A        .byte $28, $18, $22, $2a, $12, $22, $2a, $18, $22, $2a
008C0F  2  12 22 2A 18  
008C13  2  22 2A        
008C15  2  12 22 2A 14        .byte $12, $22, $2a, $14, $22, $2c, $0c, $22, $2c, $14, $22, $34, $12
008C19  2  22 2C 0C 22  
008C1D  2  2C 14 22 34  
008C22  2  22 30 10 22        .byte $22, $30, $10, $22, $2e, $16, $22, $34, $18, $26
008C26  2  2E 16 22 34  
008C2A  2  18 26        
008C2C  2  36 16 26 36        .byte $36, $16, $26, $36, $14, $26, $36, $12, $22, $36
008C30  2  14 26 36 12  
008C34  2  22 36        
008C36  2  5C 22 34 0C        .byte $5c, $22, $34, $0c, $22, $22, $81, $1e, $1e, $85, $1e
008C3A  2  22 22 81 1E  
008C3E  2  1E 85 1E     
008C41  2  81 12 86 14        .byte $81, $12, $86, $14
008C45  2               
008C45  2               EndOfCastleMusData:
008C45  2  81 2C 22 1C        .byte $81, $2c, $22, $1c, $2c, $22, $1c, $85, $2c, $04
008C49  2  2C 22 1C 85  
008C4D  2  2C 04        
008C4F  2  81 2E 24 1E        .byte $81, $2e, $24, $1e, $2e, $24, $1e, $85, $2e, $04
008C53  2  2E 24 1E 85  
008C57  2  2E 04        
008C59  2  81 32 28 22        .byte $81, $32, $28, $22, $32, $28, $22, $85, $32
008C5D  2  32 28 22 85  
008C61  2  32           
008C62  2  87 36 36 36        .byte $87, $36, $36, $36, $84, $3a, $00
008C66  2  84 3A 00     
008C69  2               
008C69  2  5C 54 4C 5C        .byte $5c, $54, $4c, $5c, $54, $4c
008C6D  2  54 4C        
008C6F  2  5C 1C 1C 5C        .byte $5c, $1c, $1c, $5c, $5c, $5c, $5c
008C73  2  5C 5C 5C     
008C76  2  5E 56 4E 5E        .byte $5e, $56, $4e, $5e, $56, $4e
008C7A  2  56 4E        
008C7C  2  5E 1E 1E 5E        .byte $5e, $1e, $1e, $5e, $5e, $5e, $5e
008C80  2  5E 5E 5E     
008C83  2  62 5A 50 62        .byte $62, $5a, $50, $62, $5a, $50
008C87  2  5A 50        
008C89  2  62 22 22 62        .byte $62, $22, $22, $62, $e7, $e7, $e7, $2b
008C8D  2  E7 E7 E7 2B  
008C91  2               
008C91  2  86 14 81 14        .byte $86, $14, $81, $14, $80, $14, $14, $81, $14, $14, $14, $14
008C95  2  80 14 14 81  
008C99  2  14 14 14 14  
008C9D  2  86 16 81 16        .byte $86, $16, $81, $16, $80, $16, $16, $81, $16, $16, $16, $16
008CA1  2  80 16 16 81  
008CA5  2  16 16 16 16  
008CA9  2  81 28 22 1A        .byte $81, $28, $22, $1a, $28, $22, $1a, $28, $80, $28, $28
008CAD  2  28 22 1A 28  
008CB1  2  80 28 28     
008CB4  2  81 28 87 2C        .byte $81, $28, $87, $2c, $2c, $2c, $84, $30
008CB8  2  2C 2C 84 30  
008CBC  2               
008CBC  2               VictoryM_P1AData:
008CBC  2               ;square 2
008CBC  2  84 12 86 0C      .byte $84, $12, $86, $0c, $84, $62, $10, $86
008CC0  2  84 62 10 86  
008CC4  2  12 84 1C 22      .byte $12, $84, $1c, $22, $1e, $22, $26, $18
008CC8  2  1E 22 26 18  
008CCC  2  1E 04 1C 00      .byte $1e, $04, $1c, $00
008CD0  2               ;square 1
008CD0  2  E2 E0 E2 9D      .byte $e2, $e0, $e2, $9d, $1f, $21, $a3, $2d
008CD4  2  1F 21 A3 2D  
008CD8  2  74 F4 31 35      .byte $74, $f4, $31, $35, $37, $2b, $b1, $2d
008CDC  2  37 2B B1 2D  
008CE0  2               ;triangle
008CE0  2  84 12 14 04      .byte $84, $12, $14, $04, $18, $1a, $1c, $14
008CE4  2  18 1A 1C 14  
008CE8  2  26 22 1E 1C      .byte $26, $22, $1e, $1c, $18, $1e, $22, $0c
008CEC  2  18 1E 22 0C  
008CF0  2  14               .byte $14
008CF1  2               
008CF1  2               VictoryM_P1BData:
008CF1  2               ;square 2
008CF1  2  81 22 83 22      .byte $81, $22, $83, $22, $86, $24, $85, $18
008CF5  2  86 24 85 18  
008CF9  2  82 1E 80 1E      .byte $82, $1e, $80, $1e, $83, $1c, $83, $18
008CFD  2  83 1C 83 18  
008D01  2  84 1C 81 26      .byte $84, $1c, $81, $26, $83, $26, $86, $26
008D05  2  83 26 86 26  
008D09  2  85 1E 82 24      .byte $85, $1e, $82, $24, $86, $22, $84, $1e
008D0D  2  86 22 84 1E  
008D11  2  00               .byte $00
008D12  2               ;square 1
008D12  2  74 F4 B5 6B      .byte $74, $f4, $b5, $6b, $b0, $30, $ec, $ea
008D16  2  B0 30 EC EA  
008D1A  2  2D 76 F6 B7      .byte $2d, $76, $f6, $b7, $6d, $b0, $b5, $31
008D1E  2  6D B0 B5 31  
008D22  2               ;triangle
008D22  2  84 12 1C 20      .byte $84, $12, $1c, $20, $24, $2a, $26, $24
008D26  2  24 2A 26 24  
008D2A  2  26 22 1E 22      .byte $26, $22, $1e, $22, $24, $1e, $22, $0c
008D2E  2  24 1E 22 0C  
008D32  2  1E               .byte $1e
008D33  2               ;noise (also used by part 1A)
008D33  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
008D37  2  D0 11 00     
008D3A  2               
008D3A  2               VictoryM_P2AData:
008D3A  2               ;square 2
008D3A  2  83 2C 2A 2C      .byte $83, $2c, $2a, $2c, $86, $26, $84, $28
008D3E  2  86 26 84 28  
008D42  2  2A 86 2C 84      .byte $2a, $86, $2c, $84, $36, $81, $40, $83
008D46  2  36 81 40 83  
008D4A  2  40 84 3A 40      .byte $40, $84, $3a, $40, $3e, $34, $00
008D4E  2  3E 34 00     
008D51  2               
008D51  2               VictoryM_P2BData:
008D51  2               ;square 2
008D51  2  86 3A 84 36      .byte $86, $3a, $84, $36, $00
008D55  2  00           
008D56  2               ;square 1 of part 2A
008D56  2  1D 95 19 1B      .byte $1d, $95, $19, $1b, $9d, $27, $2d, $29
008D5A  2  9D 27 2D 29  
008D5E  2  2D 31 23         .byte $2d, $31, $23
008D61  2               ;square 1 of part 2B
008D61  2  A9 27            .byte $a9, $27
008D63  2               ;triangle of part 2A
008D63  2  84 1C 1E 04      .byte $84, $1c, $1e, $04, $22, $24, $26, $1e
008D67  2  22 24 26 1E  
008D6B  2  30 2C 28 26      .byte $30, $2c, $28, $26, $22, $28
008D6F  2  22 28        
008D71  2               ;triangle of part 2B
008D71  2  2C 14 1E         .byte $2c, $14, $1e
008D74  2               
008D74  2               VictoryM_P2CData:
008D74  2               ;square 2
008D74  2  81 40 83 40      .byte $81, $40, $83, $40, $86, $40, $85, $34
008D78  2  86 40 85 34  
008D7C  2  82 3A 80 3A      .byte $82, $3a, $80, $3a, $83, $36, $34, $84
008D80  2  83 36 34 84  
008D84  2  36 81 3E 83      .byte $36, $81, $3e, $83, $3e, $86, $3e, $85
008D88  2  3E 86 3E 85  
008D8C  2  36 82 3A 86      .byte $36, $82, $3a, $86, $40, $84, $3a, $00
008D90  2  40 84 3A 00  
008D94  2               ;square 1
008D94  2  6C EC AF 63      .byte $6c, $ec, $af, $63, $a8, $29, $c4, $e6
008D98  2  A8 29 C4 E6  
008D9C  2  E2 27 70 F0      .byte $e2, $27, $70, $f0, $b1, $69, $ae, $ad
008DA0  2  B1 69 AE AD  
008DA4  2  29               .byte $29
008DA5  2               ;triangle
008DA5  2  84 1C 26 2A      .byte $84, $1c, $26, $2a, $2e, $34, $30, $2e
008DA9  2  2E 34 30 2E  
008DAD  2  30 2C 28 2C      .byte $30, $2c, $28, $2c, $2e, $28, $2c, $14
008DB1  2  2E 28 2C 14  
008DB5  2  28               .byte $28
008DB6  2               ;noise of part 2A, 2B and 2C
008DB6  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
008DBA  2  D0 11 00     
008DBD  2               
008DBD  2               VictoryM_P2DData:
008DBD  2               ;square 2
008DBD  2  87 3A 36 00      .byte $87, $3a, $36, $00
008DC1  2               ;square 1
008DC1  2  E9 E7            .byte $e9, $e7
008DC3  2               ;triangle
008DC3  2  83 16 1C 22      .byte $83, $16, $1c, $22, $28, $2e, $34, $84
008DC7  2  28 2E 34 84  
008DCB  2  3A 83 34 22      .byte $3a, $83, $34, $22, $34, $84, $36, $83
008DCF  2  34 84 36 83  
008DD3  2  1E 1E 1E 86      .byte $1e, $1e, $1e, $86, $1e
008DD7  2  1E           
008DD8  2               ;noise of part 2D
008DD8  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
008DDC  2  D0 11 00     
008DDF  2               
008DDF  2               FreqRegLookupTbl:
008DDF  2  00 88 00 2F        .byte $00, $88, $00, $2f, $00, $00
008DE3  2  00 00        
008DE5  2  02 A6 02 80        .byte $02, $a6, $02, $80, $02, $5c, $02, $3a
008DE9  2  02 5C 02 3A  
008DED  2  02 1A 01 DF        .byte $02, $1a, $01, $df, $01, $c4, $01, $ab
008DF1  2  01 C4 01 AB  
008DF5  2  01 93 01 7C        .byte $01, $93, $01, $7c, $01, $67, $01, $53
008DF9  2  01 67 01 53  
008DFD  2  01 40 01 2E        .byte $01, $40, $01, $2e, $01, $1d, $01, $0d
008E01  2  01 1D 01 0D  
008E05  2  00 FE 00 EF        .byte $00, $fe, $00, $ef, $00, $e2, $00, $d5
008E09  2  00 E2 00 D5  
008E0D  2  00 C9 00 BE        .byte $00, $c9, $00, $be, $00, $b3, $00, $a9
008E11  2  00 B3 00 A9  
008E15  2  00 A0 00 97        .byte $00, $a0, $00, $97, $00, $8e, $00, $86
008E19  2  00 8E 00 86  
008E1D  2  00 77 00 7E        .byte $00, $77, $00, $7e, $00, $71, $00, $54
008E21  2  00 71 00 54  
008E25  2  00 64 00 5F        .byte $00, $64, $00, $5f, $00, $59, $00, $50
008E29  2  00 59 00 50  
008E2D  2  00 47 00 43        .byte $00, $47, $00, $43, $00, $3b, $00, $35
008E31  2  00 3B 00 35  
008E35  2  00 2A 00 23        .byte $00, $2a, $00, $23, $04, $75, $03, $57
008E39  2  04 75 03 57  
008E3D  2  02 F9 02 CF        .byte $02, $f9, $02, $cf, $01, $fc, $00, $6a
008E41  2  01 FC 00 6A  
008E45  2               
008E45  2               MusicLengthLookupTbl:
008E45  2  05 0A 14 28        .byte $05, $0a, $14, $28, $50, $1e, $3c, $02
008E49  2  50 1E 3C 02  
008E4D  2  04 08 10 20        .byte $04, $08, $10, $20, $40, $18, $30, $0c
008E51  2  40 18 30 0C  
008E55  2  03 06 0C 18        .byte $03, $06, $0c, $18, $30, $12, $24, $08
008E59  2  30 12 24 08  
008E5D  2  36 03 09 06        .byte $36, $03, $09, $06, $12, $1b, $24, $0c
008E61  2  12 1B 24 0C  
008E65  2  24 02 06 04        .byte $24, $02, $06, $04, $0c, $12, $18, $08
008E69  2  0C 12 18 08  
008E6D  2  12 01 03 02        .byte $12, $01, $03, $02, $06, $09, $0c, $04
008E71  2  06 09 0C 04  
008E75  2  24 12 0D 09        .byte $24, $12, $0d, $09, $1b, $28, $36, $12 ;these two used in victory music only
008E79  2  1B 28 36 12  
008E7D  2  24 12 0D 09        .byte $24, $12, $0d, $09, $1b, $28, $36, $6c
008E81  2  1B 28 36 6C  
008E85  2               
008E85  2               VictoryMusEnvData:
008E85  2  97 98 9A 9B        .byte $97, $98, $9a, $9b, $9b, $9a, $9a, $99
008E89  2  9B 9A 9A 99  
008E8D  2  99 98 98 97        .byte $99, $98, $98, $97, $97, $96, $96, $95
008E91  2  97 96 96 95  
008E95  2  02                 .byte $02 ;needed to produce correct sound
008E96  2               
008E96  2               EndOfCastleMusicEnvData:
008E96  2  98 99 9A 9B        .byte $98, $99, $9a, $9b
008E9A  2               
008E9A  2               AreaMusicEnvData:
008E9A  2  90 94 94 95        .byte $90, $94, $94, $95, $95, $96, $97, $98
008E9E  2  95 96 97 98  
008EA2  2               
008EA2  2               WaterEventMusEnvData:
008EA2  2  90 91 92 92        .byte $90, $91, $92, $92, $93, $93, $93, $94
008EA6  2  93 93 93 94  
008EAA  2  94 94 94 94        .byte $94, $94, $94, $94, $94, $95, $95, $95
008EAE  2  94 95 95 95  
008EB2  2  95 95 95 96        .byte $95, $95, $95, $96, $96, $96, $96, $96
008EB6  2  96 96 96 96  
008EBA  2  96 96 96 96        .byte $96, $96, $96, $96, $96, $96, $96, $96
008EBE  2  96 96 96 96  
008EC2  2  96 96 96 96        .byte $96, $96, $96, $96, $95, $95, $94, $93
008EC6  2  95 95 94 93  
008ECA  2               
008ECA  2               BowserFlameEnvData:
008ECA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
008ECE  2  17 18 19 19  
008ED2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
008ED6  2  1D 1E 1E 1F  
008EDA  2  1F 1F 1F 1E        .byte $1f, $1f, $1f, $1e, $1d, $1c, $1e, $1f
008EDE  2  1D 1C 1E 1F  
008EE2  2  1F 1E 1D 1C        .byte $1f, $1e, $1d, $1c, $1a, $18, $16, $14
008EE6  2  1A 18 16 14  
008EEA  2               
008EEA  2               BrickShatterEnvData:
008EEA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
008EEE  2  17 18 19 19  
008EF2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
008EF6  2  1D 1E 1E 1F  
008EFA  2               
008EFA  2               ;-------------------------------------------------------------------------------------
008EFA  2               
008EFA  1  FF FF FF FF  .res $c000 - *, $ff
008EFE  1  FF FF FF FF  
008F02  1  FF FF FF FF  
00C000  1               
00C000  1               .segment "LEVELPRG"
00C000  1               .org $8000
008000  1               .include "levels.asm"
008000  2               ;-------------------------------------------------------------------------------------
008000  2               
008000  2               LoadAreaPointer:
008000  2  20 10 80                  jsr FindAreaPointer  ;find it and store it here
008003  2  8D 50 07                  sta AreaPointer
008006  2  29 60        GetAreaType: and #%01100000       ;mask out all but d6 and d5
008008  2  0A                        asl
008009  2  2A                        rol
00800A  2  2A                        rol
00800B  2  2A                        rol                  ;make %0xx00000 into %000000xx
00800C  2  8D 4E 07                  sta AreaType         ;save 2 MSB as area type
00800F  2  60                        rts
008010  2               
008010  2               .export FindAreaPointer
008010  2               FindAreaPointer:
008010  2  AD 5F 07           lda WorldNumber        ;load offset from world variable
008013  2  AC FB 07           ldy HardWorldFlag      ;check if playing worlds A-D
008016  2  F0 03              beq Nrml               ;if not, use world number as offset
008018  2  18                 clc
008019  2  69 09              adc #$09               ;otherwise add nine for correct offset
00801B  2  A8           Nrml: tay
00801C  2  B9 26 81           lda WorldAddrOffsets,y
00801F  2  18           	  clc
008020  2  6D 60 07           adc AreaNumber         ;add area number used to find data
008023  2  A8                 tay
008024  2  B9 33 81           lda AreaAddrOffsets,y  ;from there we have our area pointer
008027  2  60                 rts
008028  2               
008028  2               GetAreaPointer:
008028  2  98                tya
008029  2  AC FB 07          ldy HardWorldFlag         ;check if playing worlds A-D
00802C  2  F0 03             beq Nml                   ;if not, use world number as offset
00802E  2  18                clc
00802F  2  69 09             adc #$09                  ;otherwise add nine for correct offset
008031  2  A8           Nml: tay
008032  2  BE 26 81          ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
008035  2  BC 33 81          ldy AreaAddrOffsets,x     ;get area offset based on world offset
008038  2  60                rts
008039  2               
008039  2               GetAreaDataAddrs:
008039  2  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00803C  2  20 06 80                 jsr GetAreaType
00803F  2  A8                       tay
008040  2  AD 50 07                 lda AreaPointer            ;mask out all but 5 LSB
008043  2  29 1F                    and #%00011111
008045  2  8D 4F 07                 sta AreaAddrsLOffset       ;save as low offset
008048  2  AD FB 07                 lda HardWorldFlag          ;check if playing worlds A-D
00804B  2  D0 2C                    bne HWorldAreaDataAddrs    ;if so, refer to alternate offsets
00804D  2  B9 6D 81                 lda EnemyAddrHOffsets,y    ;load base value with 2 altered MSB,
008050  2  18                       clc                        ;then add base value to 5 LSB, result
008051  2  6D 4F 07                 adc AreaAddrsLOffset       ;becomes offset for level data
008054  2  0A                       asl
008055  2  A8                       tay
008056  2  B9 72 81                 lda EnemyDataAddrs+1,y     ;use offset to load pointer
008059  2  85 EA                    sta EnemyDataHigh
00805B  2  B9 71 81                 lda EnemyDataAddrs,y
00805E  2  85 E9                    sta EnemyDataLow
008060  2  AC 4E 07                 ldy AreaType               ;use area type as offset
008063  2  B9 D9 81                 lda AreaDataHOffsets,y     ;do the same thing but with different base value
008066  2  18                       clc
008067  2  6D 4F 07                 adc AreaAddrsLOffset
00806A  2  0A                       asl
00806B  2  A8                       tay
00806C  2  B9 DE 81                 lda AreaDataAddrs+1,y      ;use this offset to load another pointer
00806F  2  85 E8                    sta AreaDataHigh
008071  2  B9 DD 81                 lda AreaDataAddrs,y
008074  2  85 E7                    sta AreaDataLow
008076  2  4C A2 80                 jmp ContinueAreaDataAddrs
008079  2               HWorldAreaDataAddrs:
008079  2  B9 45 82                 lda HWEnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00807C  2  18                       clc                        ;then add base value to 5 LSB, result
00807D  2  6D 4F 07                 adc AreaAddrsLOffset       ;becomes offset for level data
008080  2  0A                       asl
008081  2  A8                       tay
008082  2  B9 4A 82                 lda HWEnemyDataAddrs+1,y   ;use offset to load pointer
008085  2  85 EA                    sta EnemyDataHigh
008087  2  B9 49 82                 lda HWEnemyDataAddrs,y
00808A  2  85 E9                    sta EnemyDataLow
00808C  2  AC 4E 07                 ldy AreaType               ;use area type as offset
00808F  2  B9 73 82                 lda HWAreaDataHOffsets,y   ;do the same thing but with different base value
008092  2  18                       clc
008093  2  6D 4F 07                 adc AreaAddrsLOffset
008096  2  0A                       asl
008097  2  A8                       tay
008098  2  B9 78 82                 lda HWAreaDataAddrs+1,y    ;use this offset to load another pointer
00809B  2  85 E8                    sta AreaDataHigh
00809D  2  B9 77 82                 lda HWAreaDataAddrs,y
0080A0  2  85 E7                    sta AreaDataLow
0080A2  2               ContinueAreaDataAddrs:
0080A2  2  A0 00                    ldy #$00                 ;load first byte of header
0080A4  2  B1 E7                    lda (AreaData),y
0080A6  2  48                       pha                      ;save it to the stack for now
0080A7  2  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
0080A9  2  C9 04                    cmp #$04
0080AB  2  90 05                    bcc StoreFore
0080AD  2  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
0080B0  2  A9 00                    lda #$00
0080B2  2  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
0080B5  2  68                       pla                      ;pull byte from stack and push it back
0080B6  2  48                       pha
0080B7  2  29 38                    and #%00111000           ;save player entrance control bits
0080B9  2  4A                       lsr                      ;shift bits over to LSBs
0080BA  2  4A                       lsr
0080BB  2  4A                       lsr
0080BC  2  8D 10 07                 sta PlayerEntranceCtrl   ;save value here as player entrance control
0080BF  2  68                       pla                      ;pull byte again but do not push it back
0080C0  2  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
0080C2  2  18                       clc
0080C3  2  2A                       rol                      ;rotate bits over to LSBs
0080C4  2  2A                       rol
0080C5  2  2A                       rol
0080C6  2  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
0080C9  2  C8                       iny
0080CA  2  B1 E7                    lda (AreaData),y         ;load second byte of header
0080CC  2  48                       pha                      ;save to stack
0080CD  2  29 0F                    and #%00001111           ;mask out all but lower nybble
0080CF  2  8D 27 07                 sta TerrainControl
0080D2  2  68                       pla                      ;pull and push byte to copy it to A
0080D3  2  48                       pha
0080D4  2  29 30                    and #%00110000           ;save 2 MSB for background scenery type
0080D6  2  4A                       lsr
0080D7  2  4A                       lsr                      ;shift bits to LSBs
0080D8  2  4A                       lsr
0080D9  2  4A                       lsr
0080DA  2  8D 42 07                 sta BackgroundScenery    ;save as background scenery
0080DD  2  68                       pla
0080DE  2  29 C0                    and #%11000000
0080E0  2  18                       clc
0080E1  2  2A                       rol                      ;rotate bits over to LSBs
0080E2  2  2A                       rol
0080E3  2  2A                       rol
0080E4  2  C9 03                    cmp #%00000011           ;if set to 3, store here
0080E6  2  D0 05                    bne StoreStyle           ;and nullify other value
0080E8  2  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
0080EB  2  A9 00                    lda #$00
0080ED  2  8D 33 07     StoreStyle: sta AreaStyle
0080F0  2  A0 00                    ldy #$00                 ;init counter
0080F2  2  B1 E7        ADataLoop:  lda (AreaData),y         ;store area data into region of RAM
0080F4  2  99 10 60                 sta AreaDataCopy,y
0080F7  2  C8                       iny                      ;increment Y for next byte
0080F8  2  C9 FD                    cmp #$fd                 ;did we just store a $fd byte?
0080FA  2  D0 F6                    bne ADataLoop            ;if not, we aren't done storing area data yet
0080FC  2  A9 60                    lda #>AreaDataCopy       ;now move area data pointers to RAM
0080FE  2  85 E8                    sta AreaDataHigh
008100  2  A9 10                    lda #<AreaDataCopy
008102  2  85 E7                    sta AreaDataLow
008104  2  A0 00                    ldy #$00                 ;init counter
008106  2  B1 E9        EDataLoop:  lda (EnemyData),y        ;store enemy data into region of RAM
008108  2  99 10 61                 sta EnemyDataCopy,y
00810B  2  C8                       iny                      ;increment Y for next byte
00810C  2  C9 FF                    cmp #$ff                 ;did we just store a $ff byte?
00810E  2  D0 F6                    bne EDataLoop            ;if not, we aren't done storing enemy data yet
008110  2  A9 61                    lda #>EnemyDataCopy      ;now move enemy data pointers to RAM
008112  2  85 EA                    sta EnemyDataHigh
008114  2  A9 10                    lda #<EnemyDataCopy
008116  2  85 E9                    sta EnemyDataLow         ;(credit to threecreepio for this code)
008118  2  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00811A  2  18                       clc
00811B  2  69 02                    adc #$02
00811D  2  85 E7                    sta AreaDataLow
00811F  2  A5 E8                    lda AreaDataHigh
008121  2  69 00                    adc #$00
008123  2  85 E8                    sta AreaDataHigh
008125  2  60                       rts
008126  2               
008126  2               ;-------------------------------------------------------------------------------------
008126  2               
008126  2               .export WorldAddrOffsets
008126  2               WorldAddrOffsets:
008126  2  00 05          .byte World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
008128  2  09 0E          .byte World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
00812A  2  12 17          .byte World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
00812C  2  1C 20          .byte World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
00812E  2  24             .byte World9Areas-AreaAddrOffsets
00812F  2               
00812F  2  28 2D          .byte WorldAAreas-AreaAddrOffsets, WorldBAreas-AreaAddrOffsets
008131  2  32 36          .byte WorldCAreas-AreaAddrOffsets, WorldDAreas-AreaAddrOffsets
008133  2               
008133  2               AreaAddrOffsets:
008133  2  20 29 40 21  World1Areas: .byte $20, $29, $40, $21, $60
008137  2  60           
008138  2  22 23 24 61  World2Areas: .byte $22, $23, $24, $61
00813C  2  25 29 00 26  World3Areas: .byte $25, $29, $00, $26, $62
008140  2  62           
008141  2  27 28 2A 63  World4Areas: .byte $27, $28, $2a, $63
008145  2  2B 29 43 2C  World5Areas: .byte $2b, $29, $43, $2c, $64
008149  2  64           
00814A  2  2D 29 01 2E  World6Areas: .byte $2d, $29, $01, $2e, $65
00814E  2  65           
00814F  2  2F 30 31 66  World7Areas: .byte $2f, $30, $31, $66
008153  2  32 35 36 67  World8Areas: .byte $32, $35, $36, $67
008157  2  38 06 68 07  World9Areas: .byte $38, $06, $68, $07
00815B  2               
00815B  2  20 2C 40 21  WorldAAreas: .byte $20, $2c, $40, $21, $60
00815F  2  60           
008160  2  22 2C 00 23  WorldBAreas: .byte $22, $2c, $00, $23, $61
008164  2  61           
008165  2  24 25 26 62  WorldCAreas: .byte $24, $25, $26, $62
008169  2  27 28 29 63  WorldDAreas: .byte $27, $28, $29, $63
00816D  2               
00816D  2               EnemyAddrHOffsets:
00816D  2  2C 0A 27 00    .byte $2c, $0a, $27, $00
008171  2               
008171  2               EnemyDataAddrs:
008171  2  A1 82 C0 82    .word E_CastleArea1, E_CastleArea2, E_CastleArea3, E_CastleArea4, E_CastleArea5, E_CastleArea6
008175  2  E7 82 FA 82  
008179  2  2F 83 68 83  
00817D  2  8F 83 CE 83    .word E_CastleArea7, E_CastleArea8, E_CastleArea9, E_CastleArea10, E_GroundArea1, E_GroundArea2
008181  2  0E 84 18 84  
008185  2  DA 84 00 85  
008189  2  23 85 4C 85    .word E_GroundArea3, E_GroundArea4, E_GroundArea5, E_GroundArea6, E_GroundArea7, E_GroundArea8
00818D  2  82 85 99 85  
008191  2  C3 85 E8 85  
008195  2  FF 85 20 86    .word E_GroundArea9, E_GroundArea10, E_GroundArea11, E_GroundArea12, E_GroundArea13, E_GroundArea14
008199  2  21 86 44 86  
00819D  2  75 86 9D 86  
0081A1  2  C1 86 DE 86    .word E_GroundArea15, E_GroundArea16, E_GroundArea17, E_GroundArea18, E_GroundArea19, E_GroundArea20
0081A5  2  0F 87 3B 87  
0081A9  2  54 87 7C 87  
0081AD  2  20 86 88 87    .word E_GroundArea21, E_GroundArea22, E_GroundArea23, E_GroundArea24, E_GroundArea25, E_GroundArea26
0081B1  2  AB 87 D2 87  
0081B5  2  D3 87 91 8A  
0081B9  2  91 8A 20 86    .word E_GroundArea27, E_GroundArea28, E_GroundArea29, E_UndergroundArea1, E_UndergroundArea2
0081BD  2  D7 87 55 89  
0081C1  2  7B 89        
0081C3  2  85 89 9F 89    .word E_UndergroundArea3, E_UndergroundArea4, E_UndergroundArea5, E_WaterArea1, E_WaterArea2
0081C7  2  C0 89 08 8A  
0081CB  2  2E 8A        
0081CD  2  5E 8A 6E 8A    .word E_WaterArea3, E_WaterArea4, E_WaterArea5, E_WaterArea6, E_WaterArea7, E_WaterArea8
0081D1  2  7C 8A 91 8A  
0081D5  2  B2 8A B7 8A  
0081D9  2               
0081D9  2               AreaDataHOffsets:
0081D9  2  2C 0A 27 00    .byte $2c, $0a, $27, $00
0081DD  2               
0081DD  2               AreaDataAddrs:
0081DD  2  EC 8A 4B 8B    .word L_CastleArea1, L_CastleArea2, L_CastleArea3, L_CastleArea4, L_CastleArea5, L_CastleArea6
0081E1  2  D6 8B 6D 8C  
0081E5  2  E2 8C AF 8D  
0081E9  2  3E 8E D1 8E    .word L_CastleArea7, L_CastleArea8, L_CastleArea9, L_CastleArea10, L_GroundArea1, L_GroundArea2
0081ED  2  A8 8F 0B 90  
0081F1  2  36 92 91 92  
0081F5  2  E0 92 59 93    .word L_GroundArea3, L_GroundArea4, L_GroundArea5, L_GroundArea6, L_GroundArea7, L_GroundArea8
0081F9  2  D6 93 35 94  
0081FD  2  B4 94 13 95  
008201  2  8A 95 EB 95    .word L_GroundArea9, L_GroundArea10, L_GroundArea11, L_GroundArea12, L_GroundArea13, L_GroundArea14
008205  2  F4 95 3D 96  
008209  2  DE 96 3D 97  
00820D  2  BC 97 29 98    .word L_GroundArea15, L_GroundArea16, L_GroundArea17, L_GroundArea18, L_GroundArea19, L_GroundArea20
008211  2  AC 98 09 99  
008215  2  84 99 F9 99  
008219  2  12 9A 39 9A    .word L_GroundArea21, L_GroundArea22, L_GroundArea23, L_GroundArea24, L_GroundArea25, L_GroundArea26
00821D  2  A4 9A 08 9B  
008221  2  09 9B 08 9B  
008225  2  08 9B 18 9B    .word L_GroundArea27, L_GroundArea28, L_GroundArea29, L_UndergroundArea1, L_UndergroundArea2
008229  2  2B 9B FC 9F  
00822D  2  BD A0        
00822F  2  F8 A0 43 A1    .word L_UndergroundArea3, L_UndergroundArea4, L_UndergroundArea5, L_WaterArea1, L_WaterArea2
008233  2  10 A2 25 A3  
008237  2  D8 A3        
008239  2  A1 A4 D2 A4    .word L_WaterArea3, L_WaterArea4, L_WaterArea5, L_WaterArea6, L_WaterArea7, L_WaterArea8
00823D  2  EB A4 2C A5  
008241  2  73 A5 B6 A5  
008245  2               
008245  2               HWEnemyAddrHOffsets:
008245  2  14 04 12 00       .byte $14, $04, $12, $00
008249  2               
008249  2               HWEnemyDataAddrs:
008249  2  1E 84 43 84       .word E_CastleArea11, E_CastleArea12, E_CastleArea13, E_CastleArea14, E_GroundArea30, E_GroundArea31
00824D  2  6A 84 AB 84  
008251  2  E0 87 1B 88  
008255  2  2A 88 58 88       .word E_GroundArea32, E_GroundArea33, E_GroundArea34, E_GroundArea35, E_GroundArea36, E_GroundArea37
008259  2  7D 88 A0 88  
00825D  2  BF 88 DE 88  
008261  2  FE 88 1F 89       .word E_GroundArea38, E_GroundArea39, E_GroundArea40, E_GroundArea41, E_GroundArea10, E_GroundArea28
008265  2  36 89 46 89  
008269  2  20 86 20 86  
00826D  2  DA 89 F4 89       .word E_UndergroundArea6, E_UndergroundArea7, E_WaterArea9
008271  2  C8 8A        
008273  2               
008273  2               HWAreaDataHOffsets:
008273  2  14 04 12 00       .byte $14, $04, $12, $00
008277  2               
008277  2               HWAreaDataAddrs:
008277  2  1C 90 8F 90       .word L_CastleArea11, L_CastleArea12, L_CastleArea13, L_CastleArea14, L_GroundArea30, L_GroundArea31
00827B  2  0C 91 A7 91  
00827F  2  62 9B F1 9B  
008283  2  4A 9C DB 9C       .word L_GroundArea32, L_GroundArea33, L_GroundArea34, L_GroundArea35, L_GroundArea36, L_GroundArea37
008287  2  3A 9D B1 9D  
00828B  2  0C 9E 89 9E  
00828F  2  06 9F 51 9F       .word L_GroundArea38, L_GroundArea39, L_GroundArea40, L_GroundArea41, L_GroundArea10, L_GroundArea28
008293  2  BC 9F DF 9F  
008297  2  EB 95 18 9B  
00829B  2  51 A2 C6 A2       .word L_UndergroundArea6, L_UndergroundArea7, L_WaterArea9
00829F  2  07 A6        
0082A1  2               
0082A1  2               ;-------------------------------------------------------------------------------------
0082A1  2               
0082A1  2               ;GAME LEVELS DATA
0082A1  2               
0082A1  2               ;level 1-4
0082A1  2               E_CastleArea1:
0082A1  2  35 9D 55 9B    .byte $35, $9d, $55, $9b, $c9, $1b, $59, $9d, $45, $9b, $c5, $1b, $26, $80, $45, $1b
0082A5  2  C9 1B 59 9D  
0082A9  2  45 9B C5 1B  
0082B1  2  B9 1D F0 15    .byte $b9, $1d, $f0, $15, $59, $9d, $0f, $08, $78, $2d, $96, $28, $90, $b5, $ff
0082B5  2  59 9D 0F 08  
0082B9  2  78 2D 96 28  
0082C0  2               
0082C0  2               ;level 2-4
0082C0  2               E_CastleArea2:
0082C0  2  74 80 F0 38    .byte $74, $80, $f0, $38, $a0, $bb, $40, $bc, $8c, $1d, $c9, $9d, $05, $9b, $1c, $0c
0082C4  2  A0 BB 40 BC  
0082C8  2  8C 1D C9 9D  
0082D0  2  59 1B B5 1D    .byte $59, $1b, $b5, $1d, $2c, $8c, $40, $15, $7c, $1b, $dc, $1d, $6c, $8c, $bc, $0c
0082D4  2  2C 8C 40 15  
0082D8  2  7C 1B DC 1D  
0082E0  2  78 AD A5 28    .byte $78, $ad, $a5, $28, $90, $b5, $ff
0082E4  2  90 B5 FF     
0082E7  2               
0082E7  2               ;level 3-4
0082E7  2               E_CastleArea3:
0082E7  2  0F 04 9C 0C    .byte $0f, $04, $9c, $0c, $0f, $07, $c5, $1b, $65, $9d, $49, $9d, $5c, $8c, $78, $2d
0082EB  2  0F 07 C5 1B  
0082EF  2  65 9D 49 9D  
0082F7  2  90 B5 FF       .byte $90, $b5, $ff
0082FA  2               
0082FA  2               ;level 4-4
0082FA  2               E_CastleArea4:
0082FA  2  49 9F 67 03    .byte $49, $9f, $67, $03, $79, $9d, $a0, $3a, $57, $9f, $bb, $1d, $d5, $25, $0f, $05
0082FE  2  79 9D A0 3A  
008302  2  57 9F BB 1D  
00830A  2  18 1D 74 00    .byte $18, $1d, $74, $00, $84, $00, $94, $00, $c6, $29, $49, $9d, $db, $05, $0f, $08
00830E  2  84 00 94 00  
008312  2  C6 29 49 9D  
00831A  2  05 9B 09 1D    .byte $05, $9b, $09, $1d, $b0, $38, $80, $95, $c0, $3c, $ec, $a8, $cc, $8c, $4a, $9b
00831E  2  B0 38 80 95  
008322  2  C0 3C EC A8  
00832A  2  78 2D 90 B5    .byte $78, $2d, $90, $b5, $ff
00832E  2  FF           
00832F  2               
00832F  2               ;level 5-4
00832F  2               E_CastleArea5:
00832F  2  2A A9 6B 0C    .byte $2a, $a9, $6b, $0c, $cb, $0c, $15, $9c, $89, $1c, $cc, $1d, $09, $9d, $f5, $1c
008333  2  CB 0C 15 9C  
008337  2  89 1C CC 1D  
00833F  2  6B A9 AB 0C    .byte $6b, $a9, $ab, $0c, $db, $29, $48, $9d, $9b, $0c, $5b, $8c, $a5, $1c, $49, $9d
008343  2  DB 29 48 9D  
008347  2  9B 0C 5B 8C  
00834F  2  79 1D 09 9D    .byte $79, $1d, $09, $9d, $6b, $0c, $c9, $1f, $3b, $8c, $88, $95, $b9, $1c, $19, $9d
008353  2  6B 0C C9 1F  
008357  2  3B 8C 88 95  
00835F  2  30 CC 78 2D    .byte $30, $cc, $78, $2d, $a6, $28, $90, $b5, $ff
008363  2  A6 28 90 B5  
008367  2  FF           
008368  2               
008368  2               ;level 6-4
008368  2               E_CastleArea6:
008368  2  0F 02 09 1F    .byte $0f, $02, $09, $1f, $8b, $85, $2b, $8c, $e9, $1b, $25, $9d, $0f, $07, $09, $1d
00836C  2  8B 85 2B 8C  
008370  2  E9 1B 25 9D  
008378  2  6D 28 99 1B    .byte $6d, $28, $99, $1b, $b5, $2c, $4b, $8c, $09, $9f, $fb, $15, $9d, $a8, $0f, $0c
00837C  2  B5 2C 4B 8C  
008380  2  09 9F FB 15  
008388  2  2B 0C 78 2D    .byte $2b, $0c, $78, $2d, $90, $b5, $ff
00838C  2  90 B5 FF     
00838F  2               
00838F  2               ;level 7-4
00838F  2               E_CastleArea7:
00838F  2  05 9D 0D A8    .byte $05, $9d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c, $42, $ac
008393  2  DD 1D 07 AC  
008397  2  54 2C A2 2C  
00839F  2  26 9D D4 03    .byte $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02, $9b, $02
0083A3  2  24 83 64 03  
0083A7  2  2B 82 4B 02  
0083AF  2  5B 82 7B 02    .byte $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02, $a6, $1b
0083B3  2  0B 82 2B 02  
0083B7  2  C6 1B 28 82  
0083BF  2  7B 95 85 0C    .byte $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5, $ff
0083C3  2  9D 9B 0F 0E  
0083C7  2  78 2D 7A 1D  
0083CE  2               
0083CE  2               ;level 8-4
0083CE  2               E_CastleArea8:
0083CE  2  19 9B 99 1B    .byte $19, $9b, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0e, $83, $e0, $0f, $06, $2e
0083D2  2  2C 8C 59 1B  
0083D6  2  C5 0F 0E 83  
0083DE  2  67 E7 0F 08    .byte $67, $e7, $0f, $08, $9b, $07, $0e, $83, $e0, $39, $0e, $87, $10, $bd, $28, $59
0083E2  2  9B 07 0E 83  
0083E6  2  E0 39 0E 87  
0083EE  2  9F 0F 0F 34    .byte $9f, $0f, $0f, $34, $0f, $77, $10, $9e, $67, $f1, $0f, $12, $0e, $67, $e3, $78
0083F2  2  0F 77 10 9E  
0083F6  2  67 F1 0F 12  
0083FE  2  2D 0F 15 3B    .byte $2d, $0f, $15, $3b, $29, $57, $82, $0f, $18, $55, $1d, $78, $2d, $90, $b5, $ff
008402  2  29 57 82 0F  
008406  2  18 55 1D 78  
00840E  2               
00840E  2               ;level 9-3
00840E  2               E_CastleArea9:
00840E  2  1F 01 0E 69      .byte $1f, $01, $0e, $69, $00, $1f, $0b, $78, $2d, $ff
008412  2  00 1F 0B 78  
008416  2  2D FF        
008418  2               
008418  2               ;cloud level used in level 9-3
008418  2               E_CastleArea10:
008418  2  1F 01 1E 68      .byte $1f, $01, $1e, $68, $06, $ff
00841C  2  06 FF        
00841E  2               
00841E  2               ;level A-4
00841E  2               E_CastleArea11:
00841E  2  2A 9E 6B 0C    .byte $2a, $9e, $6b, $0c, $8d, $1c, $ea, $1f, $1b, $8c, $e6, $1c, $8c, $9c, $bb, $0c
008422  2  8D 1C EA 1F  
008426  2  1B 8C E6 1C  
00842E  2  F3 83 9B 8C    .byte $f3, $83, $9b, $8c, $db, $0c, $1b, $8c, $6b, $0c, $bb, $0c, $0f, $09, $40, $15
008432  2  DB 0C 1B 8C  
008436  2  6B 0C BB 0C  
00843E  2  78 AD 90 B5    .byte $78, $ad, $90, $b5, $ff
008442  2  FF           
008443  2               
008443  2               ;level B-4
008443  2               E_CastleArea12:
008443  2  0F 02 38 1D    .byte $0f, $02, $38, $1d, $d9, $1b, $6e, $e1, $21, $3a, $a8, $18, $9d, $0f, $07, $18
008447  2  D9 1B 6E E1  
00844B  2  21 3A A8 18  
008453  2  1D 0F 09 18    .byte $1d, $0f, $09, $18, $1d, $0f, $0b, $18, $1d, $7b, $15, $8e, $21, $2e, $b9, $9d
008457  2  1D 0F 0B 18  
00845B  2  1D 7B 15 8E  
008463  2  0F 0E 78 2D    .byte $0f, $0e, $78, $2d, $90, $b5, $ff
008467  2  90 B5 FF     
00846A  2               
00846A  2               ;level C-4
00846A  2               E_CastleArea13:
00846A  2  05 9D 65 1D    .byte $05, $9d, $65, $1d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c
00846E  2  0D A8 DD 1D  
008472  2  07 AC 54 2C  
00847A  2  42 AC 26 9D    .byte $42, $ac, $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02
00847E  2  D4 03 24 83  
008482  2  64 03 2B 82  
00848A  2  9B 02 5B 82    .byte $9b, $02, $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02
00848E  2  7B 02 0B 82  
008492  2  2B 02 C6 1B  
00849A  2  A6 1B 7B 95    .byte $a6, $1b, $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5
00849E  2  85 0C 9D 9B  
0084A2  2  0F 0E 78 2D  
0084AA  2  FF             .byte $ff
0084AB  2               
0084AB  2               ;level D-4
0084AB  2               E_CastleArea14:
0084AB  2  19 9F 99 1B    .byte $19, $9f, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0f, $04, $09, $29, $bd, $1d
0084AF  2  2C 8C 59 1B  
0084B3  2  C5 0F 0F 04  
0084BB  2  0F 06 6E 2A    .byte $0f, $06, $6e, $2a, $61, $0f, $09, $48, $2d, $46, $87, $79, $07, $8e, $63, $60
0084BF  2  61 0F 09 48  
0084C3  2  2D 46 87 79  
0084CB  2  A5 07 B8 85    .byte $a5, $07, $b8, $85, $57, $a5, $8c, $8c, $76, $9d, $78, $2d, $90, $b5, $ff
0084CF  2  57 A5 8C 8C  
0084D3  2  76 9D 78 2D  
0084DA  2               
0084DA  2               ;level 1-1
0084DA  2               E_GroundArea1:
0084DA  2  07 8E 47 03    .byte $07, $8e, $47, $03, $0f, $03, $10, $38, $1b, $80, $53, $06, $77, $0e, $83, $83
0084DE  2  0F 03 10 38  
0084E2  2  1B 80 53 06  
0084EA  2  A0 3D 90 3B    .byte $a0, $3d, $90, $3b, $90, $b7, $60, $bc, $b7, $0e, $ee, $42, $00, $f7, $80, $6b
0084EE  2  90 B7 60 BC  
0084F2  2  B7 0E EE 42  
0084FA  2  83 1B 83 AB    .byte $83, $1b, $83, $ab, $06, $ff
0084FE  2  06 FF        
008500  2               
008500  2               ;level 1-3
008500  2               E_GroundArea2:
008500  2  96 A4 F9 24    .byte $96, $a4, $f9, $24, $d3, $83, $3a, $83, $5a, $03, $95, $07, $f4, $0f, $69, $a8
008504  2  D3 83 3A 83  
008508  2  5A 03 95 07  
008510  2  33 87 86 24    .byte $33, $87, $86, $24, $c9, $24, $4b, $83, $67, $83, $17, $83, $56, $28, $95, $24
008514  2  C9 24 4B 83  
008518  2  67 83 17 83  
008520  2  0A A4 FF       .byte $0a, $a4, $ff
008523  2               
008523  2               ;level 2-1
008523  2               E_GroundArea3:
008523  2  0F 02 47 0E    .byte $0f, $02, $47, $0e, $87, $0e, $c7, $0e, $f7, $0e, $27, $8e, $ee, $42, $25, $0f
008527  2  87 0E C7 0E  
00852B  2  F7 0E 27 8E  
008533  2  06 AC 28 8C    .byte $06, $ac, $28, $8c, $a8, $4e, $b3, $20, $8b, $8e, $f7, $90, $36, $90, $e5, $8e
008537  2  A8 4E B3 20  
00853B  2  8B 8E F7 90  
008543  2  32 8E C2 06    .byte $32, $8e, $c2, $06, $d2, $06, $e2, $06, $ff
008547  2  D2 06 E2 06  
00854B  2  FF           
00854C  2               
00854C  2               ;level 2-2
00854C  2               E_GroundArea4:
00854C  2  15 8E 9B 06    .byte $15, $8e, $9b, $06, $e0, $37, $80, $bc, $0f, $04, $2b, $3b, $ab, $0e, $eb, $0e
008550  2  E0 37 80 BC  
008554  2  0F 04 2B 3B  
00855C  2  0F 06 F0 37    .byte $0f, $06, $f0, $37, $4b, $8e, $6b, $80, $bb, $3c, $4b, $bb, $ee, $42, $20, $1b
008560  2  4B 8E 6B 80  
008564  2  BB 3C 4B BB  
00856C  2  BC CB 00 AB    .byte $bc, $cb, $00, $ab, $83, $eb, $bb, $0f, $0e, $1b, $03, $9b, $37, $d4, $0e, $a3
008570  2  83 EB BB 0F  
008574  2  0E 1B 03 9B  
00857C  2  86 B3 06 C3    .byte $86, $b3, $06, $c3, $06, $ff
008580  2  06 FF        
008582  2               
008582  2               ;level 2-3
008582  2               E_GroundArea5:
008582  2  C0 BE 0F 03    .byte $c0, $be, $0f, $03, $38, $0e, $15, $8f, $aa, $83, $f8, $07, $0f, $07, $96, $10
008586  2  38 0E 15 8F  
00858A  2  AA 83 F8 07  
008592  2  0F 09 48 10    .byte $0f, $09, $48, $10, $ba, $03, $ff
008596  2  BA 03 FF     
008599  2               
008599  2               ;level 3-1
008599  2               E_GroundArea6:
008599  2  87 85 A3 05    .byte $87, $85, $a3, $05, $db, $83, $fb, $03, $93, $8f, $bb, $03, $ce, $42, $42, $9b
00859D  2  DB 83 FB 03  
0085A1  2  93 8F BB 03  
0085A9  2  83 AE B3 40    .byte $83, $ae, $b3, $40, $db, $00, $f4, $0f, $33, $8f, $74, $0f, $10, $bc, $f5, $0f
0085AD  2  DB 00 F4 0F  
0085B1  2  33 8F 74 0F  
0085B9  2  2E C2 45 B7    .byte $2e, $c2, $45, $b7, $03, $f7, $03, $c8, $90, $ff
0085BD  2  03 F7 03 C8  
0085C1  2  90 FF        
0085C3  2               
0085C3  2               ;level 3-3
0085C3  2               E_GroundArea7:
0085C3  2  80 BE 83 03    .byte $80, $be, $83, $03, $92, $10, $4b, $80, $b0, $3c, $07, $80, $b7, $24, $0c, $a4
0085C7  2  92 10 4B 80  
0085CB  2  B0 3C 07 80  
0085D3  2  96 A9 1B 83    .byte $96, $a9, $1b, $83, $7b, $24, $b7, $24, $97, $83, $e2, $0f, $a9, $a9, $38, $a9
0085D7  2  7B 24 B7 24  
0085DB  2  97 83 E2 0F  
0085E3  2  0F 0B 74 8F    .byte $0f, $0b, $74, $8f, $ff
0085E7  2  FF           
0085E8  2               
0085E8  2               ;level 4-1
0085E8  2               E_GroundArea8:
0085E8  2  E2 91 0F 03    .byte $e2, $91, $0f, $03, $42, $11, $0f, $06, $72, $11, $0f, $08, $ee, $02, $60, $02
0085EC  2  42 11 0F 06  
0085F0  2  72 11 0F 08  
0085F8  2  91 EE B3 60    .byte $91, $ee, $b3, $60, $d3, $86, $ff
0085FC  2  D3 86 FF     
0085FF  2               
0085FF  2               ;level 4-2
0085FF  2               E_GroundArea9:
0085FF  2  0F 02 9B 02    .byte $0f, $02, $9b, $02, $ab, $02, $0f, $04, $13, $03, $92, $11, $60, $b7, $00, $bc
008603  2  AB 02 0F 04  
008607  2  13 03 92 11  
00860F  2  00 BB 0B 83    .byte $00, $bb, $0b, $83, $cb, $03, $7b, $85, $9e, $c2, $60, $e6, $05, $0f, $0c, $62
008613  2  CB 03 7B 85  
008617  2  9E C2 60 E6  
00861F  2  10             .byte $10
008620  2               
008620  2               ;enemy data used by pipe intro area, warp zone area and exit area
008620  2               E_GroundArea10:
008620  2               E_GroundArea21:
008620  2               E_GroundArea28:
008620  2  FF             .byte $ff
008621  2               
008621  2               ;level 4-3
008621  2               E_GroundArea11:
008621  2  E6 A9 57 A8    .byte $e6, $a9, $57, $a8, $b5, $24, $19, $a4, $76, $28, $a2, $0f, $95, $8f, $9d, $a8
008625  2  B5 24 19 A4  
008629  2  76 28 A2 0F  
008631  2  0F 07 09 29    .byte $0f, $07, $09, $29, $55, $24, $8b, $17, $a9, $24, $db, $83, $04, $a9, $24, $8f
008635  2  55 24 8B 17  
008639  2  A9 24 DB 83  
008641  2  65 0F FF       .byte $65, $0f, $ff
008644  2               
008644  2               ;level 5-1
008644  2               E_GroundArea12:
008644  2  1B 82 4B 02    .byte $1b, $82, $4b, $02, $7b, $02, $ab, $02, $0f, $03, $f9, $0e, $d0, $be, $8e, $c4
008648  2  7B 02 AB 02  
00864C  2  0F 03 F9 0E  
008654  2  86 F8 0E C0    .byte $86, $f8, $0e, $c0, $ba, $0f, $0d, $3a, $0e, $bb, $02, $30, $b7, $80, $bc, $c0
008658  2  BA 0F 0D 3A  
00865C  2  0E BB 02 30  
008664  2  BC 0F 12 24    .byte $bc, $0f, $12, $24, $0f, $54, $0f, $ce, $3c, $80, $d3, $0f, $cb, $8e, $f9, $0e
008668  2  0F 54 0F CE  
00866C  2  3C 80 D3 0F  
008674  2  FF             .byte $ff
008675  2               
008675  2               ;level 5-3
008675  2               E_GroundArea13:
008675  2  0A AA 15 8F    .byte $0a, $aa, $15, $8f, $44, $0f, $4e, $44, $80, $d8, $07, $57, $90, $0f, $06, $67
008679  2  44 0F 4E 44  
00867D  2  80 D8 07 57  
008685  2  24 8B 17 B9    .byte $24, $8b, $17, $b9, $24, $ab, $97, $16, $87, $2a, $28, $84, $0f, $57, $a9, $a5
008689  2  24 AB 97 16  
00868D  2  87 2A 28 84  
008695  2  29 F5 29 A7    .byte $29, $f5, $29, $a7, $a4, $0a, $a4, $ff
008699  2  A4 0A A4 FF  
00869D  2               
00869D  2               ;level 6-1
00869D  2               E_GroundArea14:
00869D  2  07 82 67 0E    .byte $07, $82, $67, $0e, $40, $bd, $e0, $38, $d0, $bc, $6e, $84, $a0, $9b, $05, $0f
0086A1  2  40 BD E0 38  
0086A5  2  D0 BC 6E 84  
0086AD  2  06 BB 05 0F    .byte $06, $bb, $05, $0f, $08, $0b, $0e, $4b, $0e, $0f, $0a, $05, $29, $85, $29, $0f
0086B1  2  08 0B 0E 4B  
0086B5  2  0E 0F 0A 05  
0086BD  2  0C DD 28 FF    .byte $0c, $dd, $28, $ff
0086C1  2               
0086C1  2               ;level 6-3
0086C1  2               E_GroundArea15:
0086C1  2  0F 02 28 10    .byte $0f, $02, $28, $10, $e6, $03, $d8, $90, $0f, $05, $85, $0f, $78, $83, $c8, $10
0086C5  2  E6 03 D8 90  
0086C9  2  0F 05 85 0F  
0086D1  2  18 83 58 83    .byte $18, $83, $58, $83, $f7, $90, $0f, $0c, $43, $0f, $73, $8f, $ff
0086D5  2  F7 90 0F 0C  
0086D9  2  43 0F 73 8F  
0086DE  2               
0086DE  2               ;level 7-1
0086DE  2               E_GroundArea16:
0086DE  2  A7 83 D7 03    .byte $a7, $83, $d7, $03, $0f, $03, $6b, $00, $0f, $06, $e3, $0f, $14, $8f, $3e, $44
0086E2  2  0F 03 6B 00  
0086E6  2  0F 06 E3 0F  
0086EE  2  C3 0B 80 87    .byte $c3, $0b, $80, $87, $05, $ab, $05, $db, $83, $0f, $0b, $07, $05, $13, $0e, $2b
0086F2  2  05 AB 05 DB  
0086F6  2  83 0F 0B 07  
0086FE  2  02 4B 02 0F    .byte $02, $4b, $02, $0f, $10, $0b, $0e, $b0, $37, $90, $bc, $80, $bc, $ae, $44, $c0
008702  2  10 0B 0E B0  
008706  2  37 90 BC 80  
00870E  2  FF             .byte $ff
00870F  2               
00870F  2               ;level 7-2
00870F  2               E_GroundArea17:
00870F  2  0A AA D5 8F    .byte $0a, $aa, $d5, $8f, $03, $8f, $3e, $44, $c6, $d8, $83, $0f, $06, $a6, $11, $b9
008713  2  03 8F 3E 44  
008717  2  C6 D8 83 0F  
00871F  2  0E 39 9D 79    .byte $0e, $39, $9d, $79, $1b, $a6, $11, $e8, $03, $87, $83, $16, $90, $a6, $11, $b9
008723  2  1B A6 11 E8  
008727  2  03 87 83 16  
00872F  2  1D 05 8F 38    .byte $1d, $05, $8f, $38, $29, $89, $29, $26, $8f, $46, $29, $ff
008733  2  29 89 29 26  
008737  2  8F 46 29 FF  
00873B  2               
00873B  2               ;level 7-3
00873B  2               E_GroundArea18:
00873B  2  0F 04 A3 10    .byte $0f, $04, $a3, $10, $0f, $09, $e3, $29, $0f, $0d, $55, $24, $a9, $24, $0f, $11
00873F  2  0F 09 E3 29  
008743  2  0F 0D 55 24  
00874B  2  59 1D A9 1B    .byte $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
00874F  2  23 8F 15 9B  
008753  2  FF           
008754  2               
008754  2               ;level 8-1
008754  2               E_GroundArea19:
008754  2  0F 01 DB 02    .byte $0f, $01, $db, $02, $30, $b7, $80, $3b, $1b, $8e, $4a, $0e, $eb, $03, $3b, $82
008758  2  30 B7 80 3B  
00875C  2  1B 8E 4A 0E  
008764  2  5B 02 E5 0F    .byte $5b, $02, $e5, $0f, $14, $8f, $44, $0f, $5b, $82, $0c, $85, $35, $8f, $06, $85
008768  2  14 8F 44 0F  
00876C  2  5B 82 0C 85  
008774  2  E3 05 DB 83    .byte $e3, $05, $db, $83, $3e, $84, $e0, $ff
008778  2  3E 84 E0 FF  
00877C  2               
00877C  2               ;cloud level used in levels 2-1, 3-1 and 4-1
00877C  2               E_GroundArea20:
00877C  2  0A AA 1E 22    .byte $0a, $aa, $1e, $22, $29, $1e, $25, $49, $2e, $27, $66, $ff
008780  2  29 1E 25 49  
008784  2  2E 27 66 FF  
008788  2               
008788  2               ;level 8-2
008788  2               E_GroundArea22:
008788  2  0F 02 0A 29    .byte $0f, $02, $0a, $29, $f7, $02, $80, $bc, $6b, $82, $7b, $02, $9b, $02, $ab, $02
00878C  2  F7 02 80 BC  
008790  2  6B 82 7B 02  
008798  2  39 8E 0F 07    .byte $39, $8e, $0f, $07, $ce, $35, $ec, $f5, $0f, $fb, $85, $fb, $85, $3e, $c4, $e3
00879C  2  CE 35 EC F5  
0087A0  2  0F FB 85 FB  
0087A8  2  A7 02 FF       .byte $a7, $02, $ff
0087AB  2               
0087AB  2               ;level 8-3
0087AB  2               E_GroundArea23:
0087AB  2  09 A9 86 11    .byte $09, $a9, $86, $11, $d5, $10, $a3, $8f, $d5, $29, $86, $91, $2b, $83, $58, $03
0087AF  2  D5 10 A3 8F  
0087B3  2  D5 29 86 91  
0087BB  2  5B 85 EB 05    .byte $5b, $85, $eb, $05, $3e, $bc, $e0, $0f, $09, $43, $0f, $74, $0f, $6b, $85, $db
0087BF  2  3E BC E0 0F  
0087C3  2  09 43 0F 74  
0087CB  2  05 C6 A4 19    .byte $05, $c6, $a4, $19, $a4, $12, $8f
0087CF  2  A4 12 8F     
0087D2  2               ;another unused area
0087D2  2               E_GroundArea24:
0087D2  2  FF             .byte $ff
0087D3  2               
0087D3  2               ;level 9-1 starting area
0087D3  2               E_GroundArea25:
0087D3  2  1E 05 00 FF      .byte $1e, $05, $00, $ff
0087D7  2               
0087D7  2               ;cloud level used with level 5-1
0087D7  2               E_GroundArea29:
0087D7  2  0A AA 2E 2B    .byte $0a, $aa, $2e, $2b, $98, $2e, $36, $e7, $ff
0087DB  2  98 2E 36 E7  
0087DF  2  FF           
0087E0  2               
0087E0  2               ;level A-1
0087E0  2               E_GroundArea30:
0087E0  2  07 83 37 03    .byte $07, $83, $37, $03, $6b, $0e, $e0, $3d, $20, $be, $6e, $2b, $00, $a7, $85, $d3
0087E4  2  6B 0E E0 3D  
0087E8  2  20 BE 6E 2B  
0087F0  2  05 E7 83 24    .byte $05, $e7, $83, $24, $83, $27, $03, $49, $00, $59, $00, $10, $bb, $b0, $3b, $6e
0087F4  2  83 27 03 49  
0087F8  2  00 59 00 10  
008800  2  C1 00 17 85    .byte $c1, $00, $17, $85, $53, $05, $36, $8e, $76, $0e, $b6, $0e, $e7, $83, $63, $83
008804  2  53 05 36 8E  
008808  2  76 0E B6 0E  
008810  2  68 03 29 83    .byte $68, $03, $29, $83, $57, $03, $85, $03, $b5, $29, $ff
008814  2  57 03 85 03  
008818  2  B5 29 FF     
00881B  2               
00881B  2               ;level A-3
00881B  2               E_GroundArea31:
00881B  2  0F 04 66 07    .byte $0f, $04, $66, $07, $0f, $06, $86, $10, $0f, $08, $55, $0f, $e5, $8f, $ff
00881F  2  0F 06 86 10  
008823  2  0F 08 55 0F  
00882A  2               
00882A  2               ;level B-1
00882A  2               E_GroundArea32:
00882A  2  70 B7 CA 00    .byte $70, $b7, $ca, $00, $66, $80, $0f, $04, $79, $0e, $ab, $0e, $ee, $2b, $20, $eb
00882E  2  66 80 0F 04  
008832  2  79 0E AB 0E  
00883A  2  80 40 BB FB    .byte $80, $40, $bb, $fb, $00, $40, $b7, $cb, $0e, $0f, $09, $4b, $00, $76, $00, $d8
00883E  2  00 40 B7 CB  
008842  2  0E 0F 09 4B  
00884A  2  00 6B 8E 73    .byte $00, $6b, $8e, $73, $06, $83, $06, $c7, $0e, $36, $90, $c5, $06, $ff
00884E  2  06 83 06 C7  
008852  2  0E 36 90 C5  
008858  2               
008858  2               ;level B-3
008858  2               E_GroundArea33:
008858  2  84 8F A7 24    .byte $84, $8f, $a7, $24, $d3, $0f, $ea, $24, $45, $a9, $d5, $28, $45, $a9, $84, $25
00885C  2  D3 0F EA 24  
008860  2  45 A9 D5 28  
008868  2  B4 8F 09 90    .byte $b4, $8f, $09, $90, $b5, $a8, $5b, $97, $cd, $28, $b5, $a4, $09, $a4, $65, $28
00886C  2  B5 A8 5B 97  
008870  2  CD 28 B5 A4  
008878  2  92 90 E3 83    .byte $92, $90, $e3, $83, $ff
00887C  2  FF           
00887D  2               
00887D  2               ;level C-1
00887D  2               E_GroundArea34:
00887D  2  3A 8E 5B 0E    .byte $3a, $8e, $5b, $0e, $c3, $8e, $ca, $8e, $0b, $8e, $4a, $0e, $de, $c1, $44, $0f
008881  2  C3 8E CA 8E  
008885  2  0B 8E 4A 0E  
00888D  2  08 49 0E EB    .byte $08, $49, $0e, $eb, $0e, $8a, $90, $ab, $85, $0f, $0c, $03, $0f, $2e, $2b, $40
008891  2  0E 8A 90 AB  
008895  2  85 0F 0C 03  
00889D  2  67 86 FF       .byte $67, $86, $ff
0088A0  2               
0088A0  2               ;level C-2
0088A0  2               E_GroundArea35:
0088A0  2  15 8F 54 07    .byte $15, $8f, $54, $07, $aa, $83, $f8, $07, $0f, $04, $14, $07, $96, $10, $0f, $07
0088A4  2  AA 83 F8 07  
0088A8  2  0F 04 14 07  
0088B0  2  95 0F 9D A8    .byte $95, $0f, $9d, $a8, $0b, $97, $09, $a9, $55, $24, $a9, $24, $bb, $17, $ff
0088B4  2  0B 97 09 A9  
0088B8  2  55 24 A9 24  
0088BF  2               
0088BF  2               ;level C-3
0088BF  2               E_GroundArea36:
0088BF  2  0F 03 A6 11    .byte $0f, $03, $a6, $11, $a3, $90, $a6, $91, $0f, $08, $a6, $11, $e3, $a9, $0f, $0d
0088C3  2  A3 90 A6 91  
0088C7  2  0F 08 A6 11  
0088CF  2  55 24 A9 24    .byte $55, $24, $a9, $24, $0f, $11, $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
0088D3  2  0F 11 59 1D  
0088D7  2  A9 1B 23 8F  
0088DE  2               
0088DE  2               ;level D-1
0088DE  2               E_GroundArea37:
0088DE  2  87 85 9B 05    .byte $87, $85, $9b, $05, $18, $90, $a4, $8f, $6e, $c1, $60, $9b, $02, $d0, $3b, $80
0088E2  2  18 90 A4 8F  
0088E6  2  6E C1 60 9B  
0088EE  2  B8 03 8E 1B    .byte $b8, $03, $8e, $1b, $02, $3b, $02, $0f, $08, $03, $10, $f7, $05, $6b, $85, $ff
0088F2  2  02 3B 02 0F  
0088F6  2  08 03 10 F7  
0088FE  2               
0088FE  2               ;level D-2
0088FE  2               E_GroundArea38:
0088FE  2  DB 82 F3 03    .byte $db, $82, $f3, $03, $10, $b7, $80, $37, $1a, $8e, $4b, $0e, $7a, $0e, $ab, $0e
008902  2  10 B7 80 37  
008906  2  1A 8E 4B 0E  
00890E  2  0F 05 F9 0E    .byte $0f, $05, $f9, $0e, $d0, $be, $2e, $c1, $62, $d4, $8f, $64, $8f, $7e, $2b, $60
008912  2  D0 BE 2E C1  
008916  2  62 D4 8F 64  
00891E  2  FF             .byte $ff
00891F  2               
00891F  2               ;level D-3
00891F  2               E_GroundArea39:
00891F  2  0F 03 AB 05    .byte $0f, $03, $ab, $05, $1b, $85, $a3, $85, $d7, $05, $0f, $08, $33, $03, $0b, $85
008923  2  1B 85 A3 85  
008927  2  D7 05 0F 08  
00892F  2  FB 85 8B 85    .byte $fb, $85, $8b, $85, $3a, $8e, $ff
008933  2  3A 8E FF     
008936  2               
008936  2               ;ground level area used with level D-4
008936  2               E_GroundArea40:
008936  2  0F 02 09 05    .byte $0f, $02, $09, $05, $3e, $41, $64, $2b, $8e, $58, $0e, $ca, $07, $34, $87, $ff
00893A  2  3E 41 64 2B  
00893E  2  8E 58 0E CA  
008946  2               
008946  2               ;cloud level used with levels A-1, B-1 and D-2
008946  2               E_GroundArea41:
008946  2  0A AA 1E 20    .byte $0a, $aa, $1e, $20, $03, $1e, $22, $27, $2e, $24, $48, $2e, $28, $67, $ff
00894A  2  03 1E 22 27  
00894E  2  2E 24 48 2E  
008955  2               
008955  2               ;level 1-2
008955  2               E_UndergroundArea1:
008955  2  0A 8E DE B4    .byte $0a, $8e, $de, $b4, $00, $e0, $37, $5b, $82, $2b, $a9, $aa, $29, $29, $a9, $a8
008959  2  00 E0 37 5B  
00895D  2  82 2B A9 AA  
008965  2  29 0F 08 F0    .byte $29, $0f, $08, $f0, $3c, $79, $a9, $c5, $26, $cd, $26, $ee, $3b, $01, $67, $b4
008969  2  3C 79 A9 C5  
00896D  2  26 CD 26 EE  
008975  2  0F 0C 2E C1    .byte $0f, $0c, $2e, $c1, $00, $ff
008979  2  00 FF        
00897B  2               
00897B  2               ;warp zone area used by level 1-2
00897B  2               E_UndergroundArea2:
00897B  2  09 A9 19 A9    .byte $09, $a9, $19, $a9, $de, $42, $02, $7b, $83, $ff
00897F  2  DE 42 02 7B  
008983  2  83 FF        
008985  2               
008985  2               ;underground bonus rooms used in many levels
008985  2               E_UndergroundArea3:
008985  2  1E A0 0A 1E    .byte $1e, $a0, $0a, $1e, $23, $2b, $1e, $28, $6b, $0f, $03, $1e, $40, $08, $1e, $25
008989  2  23 2B 1E 28  
00898D  2  6B 0F 03 1E  
008995  2  4E 0F 06 1E    .byte $4e, $0f, $06, $1e, $22, $25, $1e, $25, $45, $ff
008999  2  22 25 1E 25  
00899D  2  45 FF        
00899F  2               
00899F  2               ;level 5-2
00899F  2               E_UndergroundArea4:
00899F  2  0B 83 B7 03    .byte $0b, $83, $b7, $03, $d7, $03, $0f, $05, $67, $03, $7b, $02, $9b, $02, $80, $b9
0089A3  2  D7 03 0F 05  
0089A7  2  67 03 7B 02  
0089AF  2  3B 83 4E B4    .byte $3b, $83, $4e, $b4, $80, $86, $2b, $c9, $2c, $16, $ac, $67, $b4, $de, $3b, $81
0089B3  2  80 86 2B C9  
0089B7  2  2C 16 AC 67  
0089BF  2  FF             .byte $ff
0089C0  2               
0089C0  2               ;underground bonus rooms used with worlds 5-8
0089C0  2               E_UndergroundArea5:
0089C0  2  1E AF CA 1E    .byte $1e, $af, $ca, $1e, $2c, $85, $0f, $04, $1e, $2d, $a7, $1e, $2f, $ce, $1e, $35
0089C4  2  2C 85 0F 04  
0089C8  2  1E 2D A7 1E  
0089D0  2  E5 0F 07 1E    .byte $e5, $0f, $07, $1e, $2b, $87, $1e, $30, $c5, $ff
0089D4  2  2B 87 1E 30  
0089D8  2  C5 FF        
0089DA  2               
0089DA  2               ;level A-2
0089DA  2               E_UndergroundArea6:
0089DA  2  BB A9 1B A9    .byte $bb, $a9, $1b, $a9, $69, $29, $b8, $29, $59, $a9, $8d, $a8, $0f, $07, $15, $29
0089DE  2  69 29 B8 29  
0089E2  2  59 A9 8D A8  
0089EA  2  55 AC 6B 85    .byte $55, $ac, $6b, $85, $0e, $ad, $01, $67, $34, $ff
0089EE  2  0E AD 01 67  
0089F2  2  34 FF        
0089F4  2               
0089F4  2               ;underground bonus rooms used with worlds A-D
0089F4  2               E_UndergroundArea7:
0089F4  2  1E A0 09 1E    .byte $1e, $a0, $09, $1e, $27, $67, $0f, $03, $1e, $28, $68, $0f, $05, $1e, $24, $48
0089F8  2  27 67 0F 03  
0089FC  2  1E 28 68 0F  
008A04  2  1E 63 68 FF    .byte $1e, $63, $68, $ff
008A08  2               
008A08  2               ;level 3-2
008A08  2               E_WaterArea1:
008A08  2  0F 01 2A 07    .byte $0f, $01, $2a, $07, $2e, $3b, $41, $e9, $07, $0f, $03, $6b, $07, $f9, $07, $b8
008A0C  2  2E 3B 41 E9  
008A10  2  07 0F 03 6B  
008A18  2  80 2A 87 4A    .byte $80, $2a, $87, $4a, $87, $b3, $0f, $84, $87, $47, $83, $87, $07, $0a, $87, $42
008A1C  2  87 B3 0F 84  
008A20  2  87 47 83 87  
008A28  2  87 1B 87 6B    .byte $87, $1b, $87, $6b, $03, $ff
008A2C  2  03 FF        
008A2E  2               
008A2E  2               ;level 6-2
008A2E  2               E_WaterArea2:
008A2E  2  0F 01 2E 3B    .byte $0f, $01, $2e, $3b, $a1, $5b, $07, $ab, $07, $69, $87, $ba, $07, $fb, $87, $65
008A32  2  A1 5B 07 AB  
008A36  2  07 69 87 BA  
008A3E  2  A7 6A 27 A6    .byte $a7, $6a, $27, $a6, $a7, $ac, $27, $1b, $87, $88, $07, $2b, $83, $7b, $07, $a7
008A42  2  A7 AC 27 1B  
008A46  2  87 88 07 2B  
008A4E  2  90 E5 83 14    .byte $90, $e5, $83, $14, $a7, $19, $27, $77, $07, $f8, $07, $47, $8f, $b9, $07, $ff
008A52  2  A7 19 27 77  
008A56  2  07 F8 07 47  
008A5E  2               
008A5E  2               ;water area used by level 4-1
008A5E  2               E_WaterArea3:
008A5E  2  1E A7 6A 5B    .byte $1e, $a7, $6a, $5b, $82, $74, $07, $d8, $07, $e8, $02, $0f, $04, $26, $07, $ff
008A62  2  82 74 07 D8  
008A66  2  07 E8 02 0F  
008A6E  2               
008A6E  2               ;water area used in level 8-4
008A6E  2               E_WaterArea4:
008A6E  2  07 9B 0A 07    .byte $07, $9b, $0a, $07, $b9, $1b, $66, $9b, $78, $07, $ae, $67, $e5, $ff
008A72  2  B9 1B 66 9B  
008A76  2  78 07 AE 67  
008A7C  2               
008A7C  2               ;water area used in level 6-1
008A7C  2               E_WaterArea5:
008A7C  2  97 87 CB 00    .byte $97, $87, $cb, $00, $ee, $2b, $f8, $fe, $2d, $ad, $75, $87, $d3, $27, $d9, $27
008A80  2  EE 2B F8 FE  
008A84  2  2D AD 75 87  
008A8C  2  0F 04 56 0F    .byte $0f, $04, $56, $0f, $ff
008A90  2  FF           
008A91  2               
008A91  2               ;two unused levels that have the same enemy data address as a used level
008A91  2               E_GroundArea26:
008A91  2               E_GroundArea27:
008A91  2               
008A91  2               ;level 9-1 water area
008A91  2               E_WaterArea6:
008A91  2  26 8F 05 AC      .byte $26, $8f, $05, $ac, $46, $0f, $1f, $04, $e8, $10, $38, $90, $66, $11, $fb, $3c
008A95  2  46 0F 1F 04  
008A99  2  E8 10 38 90  
008AA1  2  9B B7 CB 85      .byte $9b, $b7, $cb, $85, $29, $87, $95, $07, $eb, $02, $0b, $82, $96, $0e, $c3, $0e
008AA5  2  29 87 95 07  
008AA9  2  EB 02 0B 82  
008AB1  2  FF               .byte $ff
008AB2  2               
008AB2  2               ;level 9-2
008AB2  2               E_WaterArea7:
008AB2  2  1F 01 E6 11      .byte $1f, $01, $e6, $11, $ff
008AB6  2  FF           
008AB7  2               
008AB7  2               ;level 9-4
008AB7  2               E_WaterArea8:
008AB7  2  3B 86 7B 00      .byte $3b, $86, $7b, $00, $bb, $02, $2b, $8e, $7a, $05, $57, $87, $27, $8f, $9a, $0c
008ABB  2  BB 02 2B 8E  
008ABF  2  7A 05 57 87  
008AC7  2  FF               .byte $ff
008AC8  2               
008AC8  2               ;level B-2
008AC8  2               E_WaterArea9:
008AC8  2  EE AD 21 26    .byte $ee, $ad, $21, $26, $87, $f3, $0e, $66, $87, $cb, $00, $65, $87, $0f, $06, $06
008ACC  2  87 F3 0E 66  
008AD0  2  87 CB 00 65  
008AD8  2  0E 97 07 CB    .byte $0e, $97, $07, $cb, $00, $75, $87, $d3, $27, $d9, $27, $0f, $09, $77, $1f, $46
008ADC  2  00 75 87 D3  
008AE0  2  27 D9 27 0F  
008AE8  2  87 B1 0F FF    .byte $87, $b1, $0f, $ff
008AEC  2               
008AEC  2               ;level 1-4
008AEC  2               L_CastleArea1:
008AEC  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $34, $33, $8e, $4e, $0a, $7e, $06, $9e, $0a
008AF0  2  06 33 07 34  
008AF4  2  33 8E 4E 0A  
008AFC  2  CE 06 E3 00    .byte $ce, $06, $e3, $00, $ee, $0a, $1e, $87, $53, $0e, $8e, $02, $9c, $00, $c7, $0e
008B00  2  EE 0A 1E 87  
008B04  2  53 0E 8E 02  
008B0C  2  D7 37 57 8E    .byte $d7, $37, $57, $8e, $6c, $05, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $43, $8e
008B10  2  6C 05 DA 60  
008B14  2  E9 61 F8 62  
008B1C  2  C3 0E 43 8E    .byte $c3, $0e, $43, $8e, $b7, $0e, $ee, $09, $fe, $0a, $3e, $86, $57, $0e, $6e, $0a
008B20  2  B7 0E EE 09  
008B24  2  FE 0A 3E 86  
008B2C  2  7E 06 AE 0A    .byte $7e, $06, $ae, $0a, $be, $06, $fe, $07, $15, $e2, $55, $62, $95, $62, $fe, $0a
008B30  2  BE 06 FE 07  
008B34  2  15 E2 55 62  
008B3C  2  0D C4 CD 43    .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
008B40  2  CE 09 DE 0B  
008B44  2  DD 42 FE 02  
008B4B  2               
008B4B  2               ;level 2-4
008B4B  2               L_CastleArea2:
008B4B  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $34, $03, $e2, $0e, $06, $1e, $0c, $7e, $0a
008B4F  2  06 33 07 34  
008B53  2  03 E2 0E 06  
008B5B  2  8E 05 8E 82    .byte $8e, $05, $8e, $82, $8a, $8e, $8e, $0a, $ee, $02, $0a, $e0, $19, $61, $23, $06
008B5F  2  8A 8E 8E 0A  
008B63  2  EE 02 0A E0  
008B6B  2  28 62 2E 0B    .byte $28, $62, $2e, $0b, $7e, $0a, $81, $62, $87, $30, $8e, $04, $a7, $31, $c7, $0e
008B6F  2  7E 0A 81 62  
008B73  2  87 30 8E 04  
008B7B  2  D7 33 FE 03    .byte $d7, $33, $fe, $03, $03, $8e, $0e, $0a, $11, $62, $1e, $04, $27, $32, $4e, $0a
008B7F  2  03 8E 0E 0A  
008B83  2  11 62 1E 04  
008B8B  2  51 62 57 0E    .byte $51, $62, $57, $0e, $5e, $04, $67, $34, $9e, $0a, $a1, $62, $ae, $03, $b3, $0e
008B8F  2  5E 04 67 34  
008B93  2  9E 0A A1 62  
008B9B  2  BE 0B EE 09    .byte $be, $0b, $ee, $09, $fe, $0a, $2e, $82, $7a, $0e, $7e, $0a, $97, $31, $be, $04
008B9F  2  FE 0A 2E 82  
008BA3  2  7A 0E 7E 0A  
008BAB  2  DA 0E EE 0A    .byte $da, $0e, $ee, $0a, $f1, $62, $fe, $02, $3e, $8a, $7e, $06, $ae, $0a, $ce, $06
008BAF  2  F1 62 FE 02  
008BB3  2  3E 8A 7E 06  
008BBB  2  FE 0A 0D C4    .byte $fe, $0a, $0d, $c4, $11, $53, $21, $52, $24, $0b, $51, $52, $61, $52, $cd, $43
008BBF  2  11 53 21 52  
008BC3  2  24 0B 51 52  
008BCB  2  CE 09 DD 42    .byte $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
008BCF  2  DE 0B FE 02  
008BD3  2  5D C7 FD     
008BD6  2               
008BD6  2               ;level 3-4
008BD6  2               L_CastleArea3:
008BD6  2  5B 09 05 34    .byte $5b, $09, $05, $34, $06, $35, $6e, $06, $7e, $0a, $ae, $02, $fe, $02, $0d, $01
008BDA  2  06 35 6E 06  
008BDE  2  7E 0A AE 02  
008BE6  2  0E 0E 2E 0A    .byte $0e, $0e, $2e, $0a, $6e, $09, $be, $0a, $ed, $4b, $e4, $60, $ee, $0d, $5e, $82
008BEA  2  6E 09 BE 0A  
008BEE  2  ED 4B E4 60  
008BF6  2  78 72 A4 3D    .byte $78, $72, $a4, $3d, $a5, $3e, $a6, $3f, $a3, $be, $a6, $3e, $a9, $32, $e9, $3a
008BFA  2  A5 3E A6 3F  
008BFE  2  A3 BE A6 3E  
008C06  2  9C 80 A3 33    .byte $9c, $80, $a3, $33, $a6, $33, $a9, $33, $e5, $06, $ed, $4b, $f3, $30, $f6, $30
008C0A  2  A6 33 A9 33  
008C0E  2  E5 06 ED 4B  
008C16  2  F9 30 FE 02    .byte $f9, $30, $fe, $02, $0d, $05, $3c, $01, $57, $73, $7c, $02, $93, $30, $a7, $73
008C1A  2  0D 05 3C 01  
008C1E  2  57 73 7C 02  
008C26  2  B3 37 CC 01    .byte $b3, $37, $cc, $01, $07, $83, $17, $03, $27, $03, $37, $03, $64, $3b, $77, $3a
008C2A  2  07 83 17 03  
008C2E  2  27 03 37 03  
008C36  2  0C 80 2E 0E    .byte $0c, $80, $2e, $0e, $9e, $02, $a5, $62, $b6, $61, $cc, $02, $c3, $33, $ed, $4b
008C3A  2  9E 02 A5 62  
008C3E  2  B6 61 CC 02  
008C46  2  03 B7 07 37    .byte $03, $b7, $07, $37, $83, $37, $87, $37, $dd, $4b, $03, $b5, $07, $35, $5e, $0a
008C4A  2  83 37 87 37  
008C4E  2  DD 4B 03 B5  
008C56  2  8E 02 AE 0A    .byte $8e, $02, $ae, $0a, $de, $06, $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42
008C5A  2  DE 06 FE 0A  
008C5E  2  0D C4 CD 43  
008C66  2  DE 0B FE 02    .byte $de, $0b, $fe, $02, $5d, $c7, $fd
008C6A  2  5D C7 FD     
008C6D  2               
008C6D  2               ;level 4-4
008C6D  2               L_CastleArea4:
008C6D  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $34, $4e, $03, $5c, $02, $0c, $f1, $27, $00
008C71  2  06 33 07 34  
008C75  2  4E 03 5C 02  
008C7D  2  3C 74 47 0E    .byte $3c, $74, $47, $0e, $fc, $00, $fe, $0b, $77, $8e, $ee, $09, $fe, $0a, $45, $b2
008C81  2  FC 00 FE 0B  
008C85  2  77 8E EE 09  
008C8D  2  55 0E 99 32    .byte $55, $0e, $99, $32, $b9, $0e, $fe, $02, $0e, $85, $fe, $02, $16, $8e, $2e, $0c
008C91  2  B9 0E FE 02  
008C95  2  0E 85 FE 02  
008C9D  2  AE 0A EE 05    .byte $ae, $0a, $ee, $05, $1e, $82, $47, $0e, $07, $bd, $c4, $72, $de, $0a, $fe, $02
008CA1  2  1E 82 47 0E  
008CA5  2  07 BD C4 72  
008CAD  2  03 8E 07 0E    .byte $03, $8e, $07, $0e, $13, $3c, $17, $3d, $e3, $03, $ee, $0a, $f3, $06, $f7, $03
008CB1  2  13 3C 17 3D  
008CB5  2  E3 03 EE 0A  
008CBD  2  FE 0E FE 8A    .byte $fe, $0e, $fe, $8a, $38, $e4, $4a, $72, $68, $64, $37, $b0, $98, $64, $a8, $64
008CC1  2  38 E4 4A 72  
008CC5  2  68 64 37 B0  
008CCD  2  E8 64 F8 64    .byte $e8, $64, $f8, $64, $0d, $c4, $71, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b
008CD1  2  0D C4 71 64  
008CD5  2  CD 43 CE 09  
008CDD  2  FE 02 5D C7    .byte $fe, $02, $5d, $c7, $fd
008CE1  2  FD           
008CE2  2               
008CE2  2               ;level 5-4
008CE2  2               L_CastleArea5:
008CE2  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $03, $4c, $50, $4e, $07, $57, $31
008CE6  2  06 33 07 33  
008CEA  2  3E 03 4C 50  
008CF2  2  6E 03 7C 52    .byte $6e, $03, $7c, $52, $9e, $07, $fe, $0a, $7e, $89, $9e, $0a, $ee, $09, $fe, $0b
008CF6  2  9E 07 FE 0A  
008CFA  2  7E 89 9E 0A  
008D02  2  13 8E 1E 09    .byte $13, $8e, $1e, $09, $3e, $0a, $6e, $09, $87, $0e, $9e, $02, $c6, $07, $ca, $0e
008D06  2  3E 0A 6E 09  
008D0A  2  87 0E 9E 02  
008D12  2  F7 62 07 8E    .byte $f7, $62, $07, $8e, $08, $61, $17, $62, $1e, $0a, $4e, $06, $5e, $0a, $7e, $06
008D16  2  08 61 17 62  
008D1A  2  1E 0A 4E 06  
008D22  2  8E 0A AE 06    .byte $8e, $0a, $ae, $06, $be, $07, $f3, $0e, $1e, $86, $2e, $0a, $84, $37, $93, $36
008D26  2  BE 07 F3 0E  
008D2A  2  1E 86 2E 0A  
008D32  2  A2 45 1E 89    .byte $a2, $45, $1e, $89, $46, $0e, $6e, $0a, $a7, $31, $db, $60, $f7, $60, $1b, $e0
008D36  2  46 0E 6E 0A  
008D3A  2  A7 31 DB 60  
008D42  2  37 31 7E 09    .byte $37, $31, $7e, $09, $8e, $0b, $a3, $0e, $fe, $04, $17, $bb, $47, $0e, $77, $0e
008D46  2  8E 0B A3 0E  
008D4A  2  FE 04 17 BB  
008D52  2  BE 02 CE 0A    .byte $be, $02, $ce, $0a, $07, $8e, $17, $31, $63, $31, $a7, $34, $c7, $0e, $13, $b1
008D56  2  07 8E 17 31  
008D5A  2  63 31 A7 34  
008D62  2  4E 09 1E 8A    .byte $4e, $09, $1e, $8a, $7e, $02, $97, $34, $b7, $0e, $ce, $0a, $de, $02, $d8, $61
008D66  2  7E 02 97 34  
008D6A  2  B7 0E CE 0A  
008D72  2  F7 62 FE 03    .byte $f7, $62, $fe, $03, $07, $b4, $17, $0e, $47, $62, $4e, $0a, $5e, $03, $51, $61
008D76  2  07 B4 17 0E  
008D7A  2  47 62 4E 0A  
008D82  2  67 62 77 34    .byte $67, $62, $77, $34, $b7, $62, $c1, $61, $da, $60, $e9, $61, $f8, $62, $fe, $0a
008D86  2  B7 62 C1 61  
008D8A  2  DA 60 E9 61  
008D92  2  0D C4 01 52    .byte $0d, $c4, $01, $52, $11, $52, $21, $52, $31, $52, $41, $52, $51, $52, $61, $52
008D96  2  11 52 21 52  
008D9A  2  31 52 41 52  
008DA2  2  CD 43 CE 09    .byte $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
008DA6  2  DE 0B DD 42  
008DAA  2  FE 02 5D C7  
008DAF  2               
008DAF  2               ;level 6-4
008DAF  2               L_CastleArea6:
008DAF  2  5B 09 05 32    .byte $5b, $09, $05, $32, $06, $33, $4e, $0a, $87, $31, $fe, $02, $88, $f2, $c7, $33
008DB3  2  06 33 4E 0A  
008DB7  2  87 31 FE 02  
008DBF  2  0D 02 07 0E    .byte $0d, $02, $07, $0e, $17, $34, $6e, $0a, $8e, $02, $bf, $67, $ed, $4b, $b7, $b6
008DC3  2  17 34 6E 0A  
008DC7  2  8E 02 BF 67  
008DCF  2  C3 35 1E 8A    .byte $c3, $35, $1e, $8a, $2e, $02, $33, $3f, $37, $3f, $88, $f2, $c7, $33, $ed, $4b
008DD3  2  2E 02 33 3F  
008DD7  2  37 3F 88 F2  
008DDF  2  0D 06 03 33    .byte $0d, $06, $03, $33, $0f, $74, $47, $73, $67, $73, $7e, $09, $9e, $0a, $ed, $4b
008DE3  2  0F 74 47 73  
008DE7  2  67 73 7E 09  
008DEF  2  F7 32 07 8E    .byte $f7, $32, $07, $8e, $97, $0e, $ae, $00, $de, $02, $e3, $35, $e7, $35, $3e, $8a
008DF3  2  97 0E AE 00  
008DF7  2  DE 02 E3 35  
008DFF  2  4E 02 53 3E    .byte $4e, $02, $53, $3e, $57, $3e, $07, $8e, $a7, $34, $bf, $63, $ed, $4b, $2e, $8a
008E03  2  57 3E 07 8E  
008E07  2  A7 34 BF 63  
008E0F  2  FE 06 2E 88    .byte $fe, $06, $2e, $88, $34, $33, $35, $33, $6e, $06, $8e, $0c, $be, $06, $fe, $0a
008E13  2  34 33 35 33  
008E17  2  6E 06 8E 0C  
008E1F  2  01 D2 0D 44    .byte $01, $d2, $0d, $44, $11, $52, $21, $52, $31, $52, $41, $52, $42, $0b, $51, $52
008E23  2  11 52 21 52  
008E27  2  31 52 41 52  
008E2F  2  61 52 CD 43    .byte $61, $52, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
008E33  2  CE 09 DD 42  
008E37  2  DE 0B FE 02  
008E3E  2               
008E3E  2               ;level 7-4
008E3E  2               L_CastleArea7:
008E3E  2  58 07 05 35    .byte $58, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
008E42  2  06 3D 07 3D  
008E46  2  BE 06 DE 0C  
008E4E  2  6E 43 CE 0A    .byte $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05, $28, $39
008E52  2  E1 67 F1 67  
008E56  2  01 E7 11 67  
008E5E  2  6E 40 BE 01    .byte $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00, $bf, $00
008E62  2  C7 06 DB 0E  
008E66  2  DE 00 1F 80  
008E6E  2  0F 80 5F 00    .byte $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30, $3e, $0c
008E72  2  7E 05 A8 37  
008E76  2  FE 02 24 8E  
008E7E  2  4E 43 AE 0A    .byte $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c, $7e, $02
008E82  2  BE 0C EE 0A  
008E86  2  FE 0C 2E 8A  
008E8E  2  8E 0E 98 36    .byte $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86, $4e, $0c
008E92  2  B9 34 08 BF  
008E96  2  09 3F 0E 82  
008E9E  2  9E 09 C1 62    .byte $9e, $09, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c, $7e, $09, $a1, $62
008EA2  2  C4 0E EE 0C  
008EA6  2  0E 86 5E 0C  
008EAE  2  A4 0E CE 0C    .byte $a4, $0e, $ce, $0c, $fe, $0a, $28, $b4, $a6, $31, $e8, $34, $8b, $b2, $9b, $0e
008EB2  2  FE 0A 28 B4  
008EB6  2  A6 31 E8 34  
008EBE  2  FE 07 FE 8A    .byte $fe, $07, $fe, $8a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
008EC2  2  0D C4 CD 43  
008EC6  2  CE 09 DD 42  
008ECE  2  5D C7 FD       .byte $5d, $c7, $fd
008ED1  2               
008ED1  2               ;level 8-4
008ED1  2               L_CastleArea8:
008ED1  2  5B 03 05 34    .byte $5b, $03, $05, $34, $06, $35, $07, $36, $6e, $0a, $ee, $02, $fe, $05, $0d, $01
008ED5  2  06 35 07 36  
008ED9  2  6E 0A EE 02  
008EE1  2  17 0E 97 0E    .byte $17, $0e, $97, $0e, $9e, $02, $c6, $05, $fa, $30, $fe, $0a, $4e, $82, $57, $0e
008EE5  2  9E 02 C6 05  
008EE9  2  FA 30 FE 0A  
008EF1  2  58 62 68 62    .byte $58, $62, $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $7b, $39, $f3
008EF5  2  79 61 8A 60  
008EF9  2  8E 0A F5 31  
008F01  2  97 33 B5 71    .byte $97, $33, $b5, $71, $39, $f3, $4d, $48, $9e, $02, $ae, $05, $cd, $4a, $ed, $4b
008F05  2  39 F3 4D 48  
008F09  2  9E 02 AE 05  
008F11  2  0E 81 17 06    .byte $0e, $81, $17, $06, $39, $73, $5c, $02, $85, $65, $95, $32, $a9, $7b, $cc, $03
008F15  2  39 73 5C 02  
008F19  2  85 65 95 32  
008F21  2  5E 8F 6D 47    .byte $5e, $8f, $6d, $47, $fe, $02, $0d, $07, $39, $73, $4e, $0a, $ae, $02, $ec, $71
008F25  2  FE 02 0D 07  
008F29  2  39 73 4E 0A  
008F31  2  07 81 17 02    .byte $07, $81, $17, $02, $39, $73, $e6, $05, $39, $fb, $4e, $0a, $c4, $31, $eb, $61
008F35  2  39 73 E6 05  
008F39  2  39 FB 4E 0A  
008F41  2  FE 02 07 B0    .byte $fe, $02, $07, $b0, $1e, $0a, $4e, $06, $57, $0e, $be, $02, $c9, $61, $da, $60
008F45  2  1E 0A 4E 06  
008F49  2  57 0E BE 02  
008F51  2  ED 4B 0E 85    .byte $ed, $4b, $0e, $85, $0d, $0e, $fe, $0a, $78, $e4, $8e, $06, $b3, $06, $bf, $47
008F55  2  0D 0E FE 0A  
008F59  2  78 E4 8E 06  
008F61  2  EE 0F 6D C7    .byte $ee, $0f, $6d, $c7, $0e, $82, $39, $73, $9a, $60, $a9, $61, $ae, $06, $de, $0a
008F65  2  0E 82 39 73  
008F69  2  9A 60 A9 61  
008F71  2  E7 03 EB 79    .byte $e7, $03, $eb, $79, $f7, $03, $fe, $06, $0d, $14, $fe, $0a, $5e, $82, $7f, $66
008F75  2  F7 03 FE 06  
008F79  2  0D 14 FE 0A  
008F81  2  9E 0A F8 64    .byte $9e, $0a, $f8, $64, $fe, $0b, $9e, $84, $be, $05, $be, $82, $da, $60, $e9, $61
008F85  2  FE 0B 9E 84  
008F89  2  BE 05 BE 82  
008F91  2  F8 62 FE 0A    .byte $f8, $62, $fe, $0a, $0d, $c4, $11, $64, $51, $62, $cd, $43, $ce, $09, $dd, $42
008F95  2  0D C4 11 64  
008F99  2  51 62 CD 43  
008FA1  2  DE 0B FE 02    .byte $de, $0b, $fe, $02, $5d, $c7, $fd
008FA5  2  5D C7 FD     
008FA8  2               
008FA8  2               ;level 9-3
008FA8  2               L_CastleArea9:
008FA8  2  55 31 0D 01      .byte $55, $31, $0d, $01, $cf, $33, $fe, $39, $fe, $b2, $2e, $be, $fe, $31, $29, $8f
008FAC  2  CF 33 FE 39  
008FB0  2  FE B2 2E BE  
008FB8  2  9E 43 FE 30      .byte $9e, $43, $fe, $30, $16, $b1, $23, $09, $4e, $31, $4e, $40, $d7, $e0, $e6, $61
008FBC  2  16 B1 23 09  
008FC0  2  4E 31 4E 40  
008FC8  2  FE 3E F5 62      .byte $fe, $3e, $f5, $62, $fa, $60, $0c, $df, $0c, $df, $0c, $d1, $1e, $3c, $2d, $40
008FCC  2  FA 60 0C DF  
008FD0  2  0C DF 0C D1  
008FD8  2  4E 32 5E 36      .byte $4e, $32, $5e, $36, $5e, $42, $ce, $38, $0d, $0b, $8e, $36, $8e, $40, $87, $37
008FDC  2  5E 42 CE 38  
008FE0  2  0D 0B 8E 36  
008FE8  2  96 36 BE 3A      .byte $96, $36, $be, $3a, $cc, $5d, $06, $bd, $07, $3e, $a8, $64, $b8, $64, $c8, $64
008FEC  2  CC 5D 06 BD  
008FF0  2  07 3E A8 64  
008FF8  2  D8 64 E8 64      .byte $d8, $64, $e8, $64, $f8, $64, $fe, $31, $09, $e1, $1a, $60, $6d, $41, $9f, $26
008FFC  2  F8 64 FE 31  
009000  2  09 E1 1A 60  
009008  2  7D C7 FD         .byte $7d, $c7, $fd
00900B  2               
00900B  2               ;cloud level used by level 9-3
00900B  2               L_CastleArea10:
00900B  2  00 F1 FE B5      .byte $00, $f1, $fe, $b5, $0d, $02, $fe, $34, $07, $cf, $ce, $00, $0d, $05, $8d, $47
00900F  2  0D 02 FE 34  
009013  2  07 CF CE 00  
00901B  2  FD               .byte $fd
00901C  2               
00901C  2               ;level A-4
00901C  2               L_CastleArea11:
00901C  2  9B 87 05 32    .byte $9b, $87, $05, $32, $06, $33, $07, $34, $ee, $0a, $0e, $86, $28, $0e, $3e, $0a
009020  2  06 33 07 34  
009024  2  EE 0A 0E 86  
00902C  2  6E 02 8B 0E    .byte $6e, $02, $8b, $0e, $97, $00, $9e, $0a, $ce, $06, $e8, $0e, $fe, $0a, $2e, $86
009030  2  97 00 9E 0A  
009034  2  CE 06 E8 0E  
00903C  2  6E 0A 8E 08    .byte $6e, $0a, $8e, $08, $e4, $0e, $1e, $82, $8a, $0e, $8e, $0a, $fe, $02, $1a, $e0
009040  2  E4 0E 1E 82  
009044  2  8A 0E 8E 0A  
00904C  2  29 61 2E 06    .byte $29, $61, $2e, $06, $3e, $09, $56, $60, $65, $61, $6e, $0c, $83, $60, $7e, $8a
009050  2  3E 09 56 60  
009054  2  65 61 6E 0C  
00905C  2  BB 61 F9 63    .byte $bb, $61, $f9, $63, $27, $e5, $88, $64, $eb, $61, $fe, $05, $68, $90, $0a, $90
009060  2  27 E5 88 64  
009064  2  EB 61 FE 05  
00906C  2  FE 02 3A 90    .byte $fe, $02, $3a, $90, $3e, $0a, $ae, $02, $da, $60, $e9, $61, $f8, $62, $fe, $0a
009070  2  3E 0A AE 02  
009074  2  DA 60 E9 61  
00907C  2  0D C4 A1 62    .byte $0d, $c4, $a1, $62, $b1, $62, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02
009080  2  B1 62 CD 43  
009084  2  CE 09 DE 0B  
00908C  2  5D C7 FD       .byte $5d, $c7, $fd
00908F  2               
00908F  2               ;level B-4
00908F  2               L_CastleArea12:
00908F  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $0a, $41, $3b, $42, $3b, $58, $64
009093  2  06 33 07 33  
009097  2  3E 0A 41 3B  
00909F  2  7A 62 C8 31    .byte $7a, $62, $c8, $31, $18, $e4, $39, $73, $5e, $09, $66, $3c, $0e, $82, $28, $07
0090A3  2  18 E4 39 73  
0090A7  2  5E 09 66 3C  
0090AF  2  36 0E 3E 0A    .byte $36, $0e, $3e, $0a, $ae, $02, $d7, $0e, $fe, $0c, $fe, $8a, $11, $e5, $21, $65
0090B3  2  AE 02 D7 0E  
0090B7  2  FE 0C FE 8A  
0090BF  2  31 65 4E 0C    .byte $31, $65, $4e, $0c, $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e
0090C3  2  FE 02 16 8E  
0090C7  2  2E 0E FE 02  
0090CF  2  FE 02 16 8E    .byte $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e
0090D3  2  2E 0E FE 02  
0090D7  2  18 FA 3E 0E  
0090DF  2  2E 0E FE 02    .byte $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e, $2e, $0e, $fe, $02
0090E3  2  18 FA 3E 0E  
0090E7  2  FE 02 16 8E  
0090EF  2  18 FA 5E 0A    .byte $18, $fa, $5e, $0a, $6e, $02, $7e, $0a, $b7, $0e, $ee, $07, $fe, $8a, $0d, $c4
0090F3  2  6E 02 7E 0A  
0090F7  2  B7 0E EE 07  
0090FF  2  CD 43 CE 09    .byte $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
009103  2  DD 42 DE 0B  
009107  2  FE 02 5D C7  
00910C  2               
00910C  2               ;level C-4
00910C  2               L_CastleArea13:
00910C  2  98 07 05 35    .byte $98, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
009110  2  06 3D 07 3D  
009114  2  BE 06 DE 0C  
00911C  2  63 0E 6E 43    .byte $63, $0e, $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05
009120  2  CE 0A E1 67  
009124  2  F1 67 01 E7  
00912C  2  28 39 6E 40    .byte $28, $39, $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00
009130  2  BE 01 C7 06  
009134  2  DB 0E DE 00  
00913C  2  BF 00 0F 80    .byte $bf, $00, $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30
009140  2  5F 00 7E 05  
009144  2  A8 37 FE 02  
00914C  2  3E 0C 4E 43    .byte $3e, $0c, $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c
009150  2  AE 0A BE 0C  
009154  2  EE 0A FE 0C  
00915C  2  7E 02 8E 0E    .byte $7e, $02, $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86
009160  2  98 36 B9 34  
009164  2  08 BF 09 3F  
00916C  2  4E 0C 9E 09    .byte $4e, $0c, $9e, $09, $a6, $60, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c
009170  2  A6 60 C1 62  
009174  2  C4 0E EE 0C  
00917C  2  7E 09 86 60    .byte $7e, $09, $86, $60, $a1, $62, $a4, $0e, $c6, $60, $ce, $0c, $fe, $0a, $28, $b4
009180  2  A1 62 A4 0E  
009184  2  C6 60 CE 0C  
00918C  2  A6 31 E8 34    .byte $a6, $31, $e8, $34, $8b, $b2, $9b, $0e, $fe, $07, $fe, $8a, $0d, $c4, $cd, $43
009190  2  8B B2 9B 0E  
009194  2  FE 07 FE 8A  
00919C  2  CE 09 DD 42    .byte $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
0091A0  2  DE 0B FE 02  
0091A4  2  5D C7 FD     
0091A7  2               
0091A7  2               ;level D-4
0091A7  2               L_CastleArea14:
0091A7  2  5B 03 05 34    .byte $5b, $03, $05, $34, $06, $35, $39, $71, $6e, $02, $ae, $0a, $fe, $05, $17, $8e
0091AB  2  06 35 39 71  
0091AF  2  6E 02 AE 0A  
0091B7  2  97 0E 9E 02    .byte $97, $0e, $9e, $02, $a6, $06, $fa, $30, $fe, $0a, $4e, $82, $57, $0e, $58, $62
0091BB  2  A6 06 FA 30  
0091BF  2  FE 0A 4E 82  
0091C7  2  68 62 79 61    .byte $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $73, $39, $f3, $b5, $71
0091CB  2  8A 60 8E 0A  
0091CF  2  F5 31 F9 73  
0091D7  2  B7 31 4D C8    .byte $b7, $31, $4d, $c8, $8a, $62, $9a, $62, $ae, $05, $bb, $0e, $cd, $4a, $fe, $82
0091DB  2  8A 62 9A 62  
0091DF  2  AE 05 BB 0E  
0091E7  2  77 FB DE 0F    .byte $77, $fb, $de, $0f, $4e, $82, $6d, $47, $39, $f3, $0c, $ea, $08, $3f, $b3, $00
0091EB  2  4E 82 6D 47  
0091EF  2  39 F3 0C EA  
0091F7  2  CC 63 F9 30    .byte $cc, $63, $f9, $30, $69, $f9, $ea, $60, $f9, $61, $fe, $07, $de, $84, $e4, $62
0091FB  2  69 F9 EA 60  
0091FF  2  F9 61 FE 07  
009207  2  E9 61 F4 62    .byte $e9, $61, $f4, $62, $fa, $60, $04, $e2, $14, $62, $24, $62, $34, $62, $3e, $0a
00920B  2  FA 60 04 E2  
00920F  2  14 62 24 62  
009217  2  7E 0C 7E 8A    .byte $7e, $0c, $7e, $8a, $8e, $08, $94, $36, $fe, $0a, $0d, $c4, $61, $64, $71, $64
00921B  2  8E 08 94 36  
00921F  2  FE 0A 0D C4  
009227  2  81 64 CD 43    .byte $81, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00922B  2  CE 09 DD 42  
00922F  2  DE 0B FE 02  
009236  2               
009236  2               ;level 1-1
009236  2               L_GroundArea1:
009236  2  50 31 0F 26    .byte $50, $31, $0f, $26, $13, $e4, $23, $24, $27, $23, $37, $07, $66, $61, $ac, $74
00923A  2  13 E4 23 24  
00923E  2  27 23 37 07  
009246  2  C7 01 0B F1    .byte $c7, $01, $0b, $f1, $77, $73, $b6, $04, $db, $71, $5c, $82, $83, $2d, $a2, $47
00924A  2  77 73 B6 04  
00924E  2  DB 71 5C 82  
009256  2  A7 0A B7 29    .byte $a7, $0a, $b7, $29, $4f, $b3, $87, $0b, $93, $23, $cc, $06, $e3, $2c, $3a, $e0
00925A  2  4F B3 87 0B  
00925E  2  93 23 CC 06  
009266  2  7C 71 97 01    .byte $7c, $71, $97, $01, $ac, $73, $e6, $61, $0e, $b1, $b7, $f3, $dc, $02, $d3, $25
00926A  2  AC 73 E6 61  
00926E  2  0E B1 B7 F3  
009276  2  07 FB 2C 01    .byte $07, $fb, $2c, $01, $e7, $73, $2c, $f2, $34, $72, $57, $00, $7c, $02, $39, $f1
00927A  2  E7 73 2C F2  
00927E  2  34 72 57 00  
009286  2  BF 37 33 E7    .byte $bf, $37, $33, $e7, $cd, $41, $0f, $a6, $ed, $47, $fd
00928A  2  CD 41 0F A6  
00928E  2  ED 47 FD     
009291  2               
009291  2               ;level 1-3
009291  2               L_GroundArea2:
009291  2  50 11 0F 26    .byte $50, $11, $0f, $26, $fe, $10, $47, $92, $56, $40, $ac, $16, $af, $12, $0f, $95
009295  2  FE 10 47 92  
009299  2  56 40 AC 16  
0092A1  2  73 16 82 44    .byte $73, $16, $82, $44, $ec, $48, $bc, $c2, $1c, $b1, $b3, $16, $c2, $44, $86, $c0
0092A5  2  EC 48 BC C2  
0092A9  2  1C B1 B3 16  
0092B1  2  9C 14 9F 12    .byte $9c, $14, $9f, $12, $a6, $40, $df, $15, $0b, $96, $43, $12, $97, $31, $d3, $12
0092B5  2  A6 40 DF 15  
0092B9  2  0B 96 43 12  
0092C1  2  03 92 27 14    .byte $03, $92, $27, $14, $63, $00, $c7, $15, $d6, $43, $ac, $97, $af, $11, $1f, $96
0092C5  2  63 00 C7 15  
0092C9  2  D6 43 AC 97  
0092D1  2  64 13 E3 12    .byte $64, $13, $e3, $12, $2e, $91, $9d, $41, $ae, $42, $df, $20, $cd, $c7, $fd
0092D5  2  2E 91 9D 41  
0092D9  2  AE 42 DF 20  
0092E0  2               
0092E0  2               ;level 2-1
0092E0  2               L_GroundArea3:
0092E0  2  52 21 0F 20    .byte $52, $21, $0f, $20, $6e, $64, $4f, $b2, $7c, $5f, $7c, $3f, $7c, $d8, $7c, $38
0092E4  2  6E 64 4F B2  
0092E8  2  7C 5F 7C 3F  
0092F0  2  83 02 A3 00    .byte $83, $02, $a3, $00, $c3, $02, $f7, $16, $5c, $d6, $cf, $35, $d3, $20, $e3, $0a
0092F4  2  C3 02 F7 16  
0092F8  2  5C D6 CF 35  
009300  2  F3 20 25 B5    .byte $f3, $20, $25, $b5, $2c, $53, $6a, $7a, $8c, $54, $da, $72, $fc, $50, $0c, $d2
009304  2  2C 53 6A 7A  
009308  2  8C 54 DA 72  
009310  2  39 73 5C 54    .byte $39, $73, $5c, $54, $aa, $72, $cc, $53, $f7, $16, $33, $83, $40, $06, $5c, $5b
009314  2  AA 72 CC 53  
009318  2  F7 16 33 83  
009320  2  09 93 27 0F    .byte $09, $93, $27, $0f, $3c, $5c, $0a, $b0, $63, $27, $78, $72, $93, $09, $97, $03
009324  2  3C 5C 0A B0  
009328  2  63 27 78 72  
009330  2  A7 03 B7 22    .byte $a7, $03, $b7, $22, $47, $81, $5c, $72, $2a, $b0, $28, $0f, $3c, $5f, $58, $31
009334  2  47 81 5C 72  
009338  2  2A B0 28 0F  
009340  2  B8 31 28 B1    .byte $b8, $31, $28, $b1, $3c, $5b, $98, $31, $fa, $30, $03, $b2, $20, $04, $7f, $b7
009344  2  3C 5B 98 31  
009348  2  FA 30 03 B2  
009350  2  F3 67 8D C1    .byte $f3, $67, $8d, $c1, $bf, $26, $ad, $c7, $fd
009354  2  BF 26 AD C7  
009358  2  FD           
009359  2               
009359  2               ;level 2-2
009359  2               L_GroundArea4:
009359  2  54 11 0F 26    .byte $54, $11, $0f, $26, $38, $f2, $ab, $71, $0b, $f1, $96, $42, $ce, $10, $1e, $91
00935D  2  38 F2 AB 71  
009361  2  0B F1 96 42  
009369  2  29 61 3A 60    .byte $29, $61, $3a, $60, $4e, $10, $78, $74, $8e, $11, $06, $c3, $1a, $e0, $1e, $10
00936D  2  4E 10 78 74  
009371  2  8E 11 06 C3  
009379  2  5E 11 67 63    .byte $5e, $11, $67, $63, $77, $63, $88, $62, $99, $61, $aa, $60, $be, $10, $0a, $f2
00937D  2  77 63 88 62  
009381  2  99 61 AA 60  
009389  2  15 45 7E 11    .byte $15, $45, $7e, $11, $7a, $31, $9a, $e0, $ac, $02, $d9, $61, $d4, $0a, $ec, $01
00938D  2  7A 31 9A E0  
009391  2  AC 02 D9 61  
009399  2  D6 C2 84 C3    .byte $d6, $c2, $84, $c3, $98, $fa, $d3, $07, $d7, $0b, $e9, $61, $ee, $10, $2e, $91
00939D  2  98 FA D3 07  
0093A1  2  D7 0B E9 61  
0093A9  2  39 71 93 03    .byte $39, $71, $93, $03, $a6, $03, $be, $10, $e1, $71, $e3, $31, $5e, $91, $69, $61
0093AD  2  A6 03 BE 10  
0093B1  2  E1 71 E3 31  
0093B9  2  E6 41 28 E2    .byte $e6, $41, $28, $e2, $99, $71, $ae, $10, $ce, $11, $be, $90, $d6, $32, $3e, $91
0093BD  2  99 71 AE 10  
0093C1  2  CE 11 BE 90  
0093C9  2  5F 37 66 60    .byte $5f, $37, $66, $60, $d3, $67, $6d, $c1, $af, $26, $9d, $c7, $fd
0093CD  2  D3 67 6D C1  
0093D1  2  AF 26 9D C7  
0093D6  2               
0093D6  2               ;level 2-3
0093D6  2               L_GroundArea5:
0093D6  2  54 11 0F 26    .byte $54, $11, $0f, $26, $af, $32, $d8, $62, $e8, $62, $f8, $62, $fe, $10, $0c, $be
0093DA  2  AF 32 D8 62  
0093DE  2  E8 62 F8 62  
0093E6  2  F8 64 0D C8    .byte $f8, $64, $0d, $c8, $2c, $43, $98, $64, $ac, $39, $48, $e4, $6a, $62, $7c, $47
0093EA  2  2C 43 98 64  
0093EE  2  AC 39 48 E4  
0093F6  2  FA 62 3C B7    .byte $fa, $62, $3c, $b7, $ea, $62, $fc, $4d, $f6, $02, $03, $80, $06, $02, $13, $02
0093FA  2  EA 62 FC 4D  
0093FE  2  F6 02 03 80  
009406  2  DA 62 0D C8    .byte $da, $62, $0d, $c8, $0b, $17, $97, $16, $2c, $b1, $33, $43, $6c, $31, $ac, $31
00940A  2  0B 17 97 16  
00940E  2  2C B1 33 43  
009416  2  17 93 73 12    .byte $17, $93, $73, $12, $cc, $31, $1a, $e2, $2c, $4b, $67, $48, $ea, $62, $0d, $ca
00941A  2  CC 31 1A E2  
00941E  2  2C 4B 67 48  
009426  2  17 12 53 12    .byte $17, $12, $53, $12, $be, $11, $1d, $c1, $3e, $42, $6f, $20, $4d, $c7, $fd
00942A  2  BE 11 1D C1  
00942E  2  3E 42 6F 20  
009435  2               
009435  2               ;level 3-1
009435  2               L_GroundArea6:
009435  2  52 B1 0F 20    .byte $52, $b1, $0f, $20, $6e, $75, $53, $aa, $57, $25, $b7, $0a, $c7, $23, $0c, $83
009439  2  6E 75 53 AA  
00943D  2  57 25 B7 0A  
009445  2  5C 72 87 01    .byte $5c, $72, $87, $01, $c3, $00, $c7, $20, $dc, $65, $0c, $87, $c3, $22, $f3, $03
009449  2  C3 00 C7 20  
00944D  2  DC 65 0C 87  
009455  2  03 A2 27 7B    .byte $03, $a2, $27, $7b, $33, $03, $43, $23, $52, $42, $9c, $06, $a7, $20, $c3, $23
009459  2  33 03 43 23  
00945D  2  52 42 9C 06  
009465  2  03 A2 0C 02    .byte $03, $a2, $0c, $02, $33, $09, $39, $71, $43, $23, $77, $06, $83, $67, $a7, $73
009469  2  33 09 39 71  
00946D  2  43 23 77 06  
009475  2  5C 82 C9 11    .byte $5c, $82, $c9, $11, $07, $80, $1c, $71, $98, $11, $9a, $10, $f3, $04, $16, $f4
009479  2  07 80 1C 71  
00947D  2  98 11 9A 10  
009485  2  3C 02 68 7A    .byte $3c, $02, $68, $7a, $8c, $01, $a7, $73, $e7, $73, $ac, $83, $09, $8f, $1c, $03
009489  2  8C 01 A7 73  
00948D  2  E7 73 AC 83  
009495  2  9F 37 13 E7    .byte $9f, $37, $13, $e7, $7c, $02, $ad, $41, $ef, $26, $0d, $0e, $39, $71, $7f, $37
009499  2  7C 02 AD 41  
00949D  2  EF 26 0D 0E  
0094A5  2  F2 68 02 E8    .byte $f2, $68, $02, $e8, $12, $3a, $1c, $00, $68, $7a, $de, $3f, $6d, $c5, $fd
0094A9  2  12 3A 1C 00  
0094AD  2  68 7A DE 3F  
0094B4  2               
0094B4  2               ;level 3-3
0094B4  2               L_GroundArea7:
0094B4  2  55 10 0B 1F    .byte $55, $10, $0b, $1f, $0f, $26, $d6, $12, $07, $9f, $33, $1a, $fb, $1f, $f7, $94
0094B8  2  0F 26 D6 12  
0094BC  2  07 9F 33 1A  
0094C4  2  53 94 71 71    .byte $53, $94, $71, $71, $cc, $15, $cf, $13, $1f, $98, $63, $12, $9b, $13, $a9, $71
0094C8  2  CC 15 CF 13  
0094CC  2  1F 98 63 12  
0094D4  2  FB 17 09 F1    .byte $fb, $17, $09, $f1, $13, $13, $21, $42, $59, $0f, $eb, $13, $33, $93, $40, $06
0094D8  2  13 13 21 42  
0094DC  2  59 0F EB 13  
0094E4  2  8C 14 8F 17    .byte $8c, $14, $8f, $17, $93, $40, $cf, $13, $0b, $94, $57, $15, $07, $93, $19, $f3
0094E8  2  93 40 CF 13  
0094EC  2  0B 94 57 15  
0094F4  2  C6 43 C7 13    .byte $c6, $43, $c7, $13, $d3, $03, $e3, $03, $33, $b0, $4a, $72, $55, $46, $73, $31
0094F8  2  D3 03 E3 03  
0094FC  2  33 B0 4A 72  
009504  2  A8 74 E3 12    .byte $a8, $74, $e3, $12, $8e, $91, $ad, $41, $ce, $42, $ef, $20, $dd, $c7, $fd
009508  2  8E 91 AD 41  
00950C  2  CE 42 EF 20  
009513  2               
009513  2               ;level 4-1
009513  2               L_GroundArea8:
009513  2  52 21 0F 20    .byte $52, $21, $0f, $20, $6e, $63, $a9, $f1, $fb, $71, $22, $83, $37, $0b, $36, $50
009517  2  6E 63 A9 F1  
00951B  2  FB 71 22 83  
009523  2  39 51 B8 62    .byte $39, $51, $b8, $62, $57, $f3, $e8, $02, $f8, $02, $08, $82, $18, $02, $2d, $4a
009527  2  57 F3 E8 02  
00952B  2  F8 02 08 82  
009533  2  28 02 38 02    .byte $28, $02, $38, $02, $48, $00, $a8, $0f, $aa, $30, $bc, $5a, $6a, $b0, $4f, $b6
009537  2  48 00 A8 0F  
00953B  2  AA 30 BC 5A  
009543  2  B7 04 9A B0    .byte $b7, $04, $9a, $b0, $ac, $71, $c7, $01, $e6, $74, $0d, $09, $46, $02, $56, $00
009547  2  AC 71 C7 01  
00954B  2  E6 74 0D 09  
009553  2  6C 01 84 79    .byte $6c, $01, $84, $79, $86, $02, $96, $02, $a4, $71, $a6, $02, $b6, $02, $c4, $71
009557  2  86 02 96 02  
00955B  2  A4 71 A6 02  
009563  2  C6 02 D6 02    .byte $c6, $02, $d6, $02, $39, $f1, $6c, $00, $77, $02, $a3, $09, $ac, $00, $b8, $72
009567  2  39 F1 6C 00  
00956B  2  77 02 A3 09  
009573  2  DC 01 07 F3    .byte $dc, $01, $07, $f3, $4c, $00, $6f, $37, $e3, $03, $e6, $03, $5d, $ca, $6c, $00
009577  2  4C 00 6F 37  
00957B  2  E3 03 E6 03  
009583  2  7D 41 CF 26    .byte $7d, $41, $cf, $26, $9d, $c7, $fd
009587  2  9D C7 FD     
00958A  2               
00958A  2               ;level 4-2
00958A  2               L_GroundArea9:
00958A  2  50 A1 0F 26    .byte $50, $a1, $0f, $26, $17, $91, $19, $11, $48, $00, $68, $11, $6a, $10, $96, $14
00958E  2  17 91 19 11  
009592  2  48 00 68 11  
00959A  2  D8 0A E8 02    .byte $d8, $0a, $e8, $02, $f8, $02, $dc, $81, $6c, $81, $89, $0f, $9c, $00, $c3, $29
00959E  2  F8 02 DC 81  
0095A2  2  6C 81 89 0F  
0095AA  2  F8 62 47 A7    .byte $f8, $62, $47, $a7, $c6, $61, $0d, $07, $56, $74, $b7, $00, $b9, $11, $cc, $76
0095AE  2  C6 61 0D 07  
0095B2  2  56 74 B7 00  
0095BA  2  ED 4A 1C 80    .byte $ed, $4a, $1c, $80, $37, $01, $3a, $10, $de, $20, $e9, $0b, $ee, $21, $c8, $bc
0095BE  2  37 01 3A 10  
0095C2  2  DE 20 E9 0B  
0095CA  2  9C F6 BC 00    .byte $9c, $f6, $bc, $00, $cb, $7a, $eb, $72, $0c, $82, $39, $71, $b7, $63, $cc, $03
0095CE  2  CB 7A EB 72  
0095D2  2  0C 82 39 71  
0095DA  2  E6 60 26 E0    .byte $e6, $60, $26, $e0, $4a, $30, $53, $31, $5c, $58, $ed, $41, $2f, $a6, $1d, $c7
0095DE  2  4A 30 53 31  
0095E2  2  5C 58 ED 41  
0095EA  2  FD             .byte $fd
0095EB  2               
0095EB  2               ;pipe intro area
0095EB  2               L_GroundArea10:
0095EB  2  38 11 0F 26    .byte $38, $11, $0f, $26, $ad, $40, $3d, $c7, $fd
0095EF  2  AD 40 3D C7  
0095F3  2  FD           
0095F4  2               
0095F4  2               ;level 4-3
0095F4  2               L_GroundArea11:
0095F4  2  50 11 0F 26    .byte $50, $11, $0f, $26, $fe, $10, $8b, $93, $a9, $0f, $14, $c1, $cc, $16, $cf, $11
0095F8  2  FE 10 8B 93  
0095FC  2  A9 0F 14 C1  
009604  2  2F 95 B7 14    .byte $2f, $95, $b7, $14, $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00
009608  2  C7 96 D6 44  
00960C  2  2B 92 39 0F  
009614  2  1B 95 97 13    .byte $1b, $95, $97, $13, $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9f
009618  2  6C 95 6F 11  
00961C  2  A2 40 BF 15  
009624  2  53 16 62 44    .byte $53, $16, $62, $44, $72, $c2, $9b, $1d, $b7, $e0, $ed, $4a, $03, $e0, $8e, $11
009628  2  72 C2 9B 1D  
00962C  2  B7 E0 ED 4A  
009634  2  9D 41 BE 42    .byte $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
009638  2  EF 20 CD C7  
00963C  2  FD           
00963D  2               
00963D  2               ;level 5-1
00963D  2               L_GroundArea12:
00963D  2  52 B1 0F 20    .byte $52, $b1, $0f, $20, $6e, $75, $cc, $73, $a3, $b3, $bf, $74, $0c, $84, $83, $3f
009641  2  6E 75 CC 73  
009645  2  A3 B3 BF 74  
00964D  2  9F 74 EF 71    .byte $9f, $74, $ef, $71, $ec, $01, $2f, $f1, $2c, $01, $6f, $71, $6c, $01, $a8, $91
009651  2  EC 01 2F F1  
009655  2  2C 01 6F 71  
00965D  2  AA 10 77 FB    .byte $aa, $10, $77, $fb, $56, $f4, $39, $f1, $bf, $37, $33, $e7, $43, $04, $47, $03
009661  2  56 F4 39 F1  
009665  2  BF 37 33 E7  
00966D  2  6C 05 C3 67    .byte $6c, $05, $c3, $67, $d3, $67, $e3, $67, $ed, $4c, $fc, $07, $73, $e7, $83, $67
009671  2  D3 67 E3 67  
009675  2  ED 4C FC 07  
00967D  2  93 67 A3 67    .byte $93, $67, $a3, $67, $bc, $08, $43, $e7, $53, $67, $dc, $02, $59, $91, $c3, $33
009681  2  BC 08 43 E7  
009685  2  53 67 DC 02  
00968D  2  D9 71 DF 72    .byte $d9, $71, $df, $72, $2d, $cd, $5b, $71, $9b, $71, $3b, $f1, $a7, $c2, $db, $71
009691  2  2D CD 5B 71  
009695  2  9B 71 3B F1  
00969D  2  0D 10 9B 71    .byte $0d, $10, $9b, $71, $0a, $b0, $1c, $04, $67, $63, $76, $64, $85, $65, $94, $66
0096A1  2  0A B0 1C 04  
0096A5  2  67 63 76 64  
0096AD  2  A3 67 B3 67    .byte $a3, $67, $b3, $67, $cc, $09, $73, $a3, $87, $22, $b3, $09, $d6, $83, $e3, $03
0096B1  2  CC 09 73 A3  
0096B5  2  87 22 B3 09  
0096BD  2  FE 3F 0D 15    .byte $fe, $3f, $0d, $15, $de, $31, $ec, $01, $03, $f7, $9d, $41, $df, $26, $0d, $18
0096C1  2  DE 31 EC 01  
0096C5  2  03 F7 9D 41  
0096CD  2  39 71 7F 37    .byte $39, $71, $7f, $37, $f2, $68, $01, $e9, $11, $39, $68, $7a, $de, $3f, $6d, $c5
0096D1  2  F2 68 01 E9  
0096D5  2  11 39 68 7A  
0096DD  2  FD             .byte $fd
0096DE  2               
0096DE  2               ;level 5-3
0096DE  2               L_GroundArea13:
0096DE  2  50 11 0F 26    .byte $50, $11, $0f, $26, $df, $32, $fe, $10, $0d, $01, $98, $74, $c8, $13, $52, $e1
0096E2  2  DF 32 FE 10  
0096E6  2  0D 01 98 74  
0096EE  2  63 31 61 79    .byte $63, $31, $61, $79, $c6, $61, $06, $e1, $8b, $71, $ab, $71, $e4, $19, $eb, $19
0096F2  2  C6 61 06 E1  
0096F6  2  8B 71 AB 71  
0096FE  2  60 86 C8 13    .byte $60, $86, $c8, $13, $cd, $4b, $39, $f3, $98, $13, $17, $f5, $7c, $15, $7f, $13
009702  2  CD 4B 39 F3  
009706  2  98 13 17 F5  
00970E  2  CF 15 D4 40    .byte $cf, $15, $d4, $40, $0b, $9a, $23, $16, $32, $44, $a3, $95, $b2, $43, $0d, $0a
009712  2  0B 9A 23 16  
009716  2  32 44 A3 95  
00971E  2  27 14 3D 4A    .byte $27, $14, $3d, $4a, $a4, $40, $bc, $16, $bf, $13, $c4, $40, $04, $c0, $1f, $16
009722  2  A4 40 BC 16  
009726  2  BF 13 C4 40  
00972E  2  24 40 43 31    .byte $24, $40, $43, $31, $ce, $11, $dd, $41, $0e, $d2, $3f, $20, $3d, $c7, $fd
009732  2  CE 11 DD 41  
009736  2  0E D2 3F 20  
00973D  2               
00973D  2               ;level 6-1
00973D  2               L_GroundArea14:
00973D  2  52 A1 0F 20    .byte $52, $a1, $0f, $20, $6e, $40, $d6, $61, $e7, $07, $f7, $21, $16, $e1, $34, $63
009741  2  6E 40 D6 61  
009745  2  E7 07 F7 21  
00974D  2  47 21 54 04    .byte $47, $21, $54, $04, $67, $0a, $74, $63, $dc, $01, $06, $e1, $17, $26, $86, $61
009751  2  67 0A 74 63  
009755  2  DC 01 06 E1  
00975D  2  66 C2 58 C1    .byte $66, $c2, $58, $c1, $f7, $03, $04, $f6, $8a, $10, $9c, $04, $e8, $62, $f9, $61
009761  2  F7 03 04 F6  
009765  2  8A 10 9C 04  
00976D  2  0A E0 53 31    .byte $0a, $e0, $53, $31, $5f, $73, $7b, $71, $77, $25, $fc, $e2, $17, $aa, $23, $00
009771  2  5F 73 7B 71  
009775  2  77 25 FC E2  
00977D  2  3C 67 B3 01    .byte $3c, $67, $b3, $01, $cc, $63, $db, $71, $df, $73, $fc, $00, $4f, $b7, $ca, $7a
009781  2  CC 63 DB 71  
009785  2  DF 73 FC 00  
00978D  2  C5 31 EC 54    .byte $c5, $31, $ec, $54, $3c, $dc, $5d, $4c, $0f, $b3, $47, $63, $6b, $f1, $8c, $0a
009791  2  3C DC 5D 4C  
009795  2  0F B3 47 63  
00979D  2  39 F1 EC 03    .byte $39, $f1, $ec, $03, $f0, $33, $0f, $e2, $29, $73, $49, $61, $58, $62, $67, $73
0097A1  2  F0 33 0F E2  
0097A5  2  29 73 49 61  
0097AD  2  85 65 94 66    .byte $85, $65, $94, $66, $a3, $77, $ad, $4d, $4d, $c1, $6f, $26, $5d, $c7, $fd
0097B1  2  A3 77 AD 4D  
0097B5  2  4D C1 6F 26  
0097BC  2               
0097BC  2               ;level 6-3
0097BC  2               L_GroundArea15:
0097BC  2  50 11 0F 26    .byte $50, $11, $0f, $26, $af, $32, $d8, $62, $de, $10, $08, $e4, $5a, $62, $6c, $4c
0097C0  2  AF 32 D8 62  
0097C4  2  DE 10 08 E4  
0097CC  2  86 43 AD 48    .byte $86, $43, $ad, $48, $3a, $e2, $53, $42, $88, $64, $9c, $36, $08, $e4, $4a, $62
0097D0  2  3A E2 53 42  
0097D4  2  88 64 9C 36  
0097DC  2  5C 4D 3A E2    .byte $5c, $4d, $3a, $e2, $9c, $32, $fc, $41, $3c, $b1, $83, $00, $ac, $42, $2a, $e2
0097E0  2  9C 32 FC 41  
0097E4  2  3C B1 83 00  
0097EC  2  3C 46 AA 62    .byte $3c, $46, $aa, $62, $bc, $4e, $c6, $43, $46, $c3, $aa, $62, $bd, $48, $0b, $96
0097F0  2  BC 4E C6 43  
0097F4  2  46 C3 AA 62  
0097FC  2  47 07 C7 12    .byte $47, $07, $c7, $12, $3c, $c2, $9c, $41, $cd, $48, $dc, $32, $4c, $c2, $bc, $32
009800  2  3C C2 9C 41  
009804  2  CD 48 DC 32  
00980C  2  1C B1 5A 62    .byte $1c, $b1, $5a, $62, $6c, $44, $76, $43, $ba, $62, $dc, $32, $5d, $ca, $73, $12
009810  2  6C 44 76 43  
009814  2  BA 62 DC 32  
00981C  2  E3 12 8E 91    .byte $e3, $12, $8e, $91, $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
009820  2  9D 41 BE 42  
009824  2  EF 20 CD C7  
009829  2               
009829  2               ;level 7-1
009829  2               L_GroundArea16:
009829  2  52 B1 0F 20    .byte $52, $b1, $0f, $20, $6e, $76, $03, $b1, $09, $71, $0f, $71, $6f, $33, $a7, $63
00982D  2  6E 76 03 B1  
009831  2  09 71 0F 71  
009839  2  B7 34 BC 0E    .byte $b7, $34, $bc, $0e, $4d, $cc, $03, $a6, $08, $72, $3f, $72, $6d, $4c, $73, $07
00983D  2  4D CC 03 A6  
009841  2  08 72 3F 72  
009849  2  77 73 83 27    .byte $77, $73, $83, $27, $ac, $00, $bf, $73, $3c, $80, $9a, $30, $ac, $5b, $c6, $3c
00984D  2  AC 00 BF 73  
009851  2  3C 80 9A 30  
009859  2  6A B0 75 10    .byte $6a, $b0, $75, $10, $96, $74, $b6, $0a, $da, $30, $e3, $28, $ec, $5b, $ed, $48
00985D  2  96 74 B6 0A  
009861  2  DA 30 E3 28  
009869  2  AA B0 33 B4    .byte $aa, $b0, $33, $b4, $51, $79, $ad, $4a, $dd, $4d, $e3, $2c, $0c, $fa, $73, $07
00986D  2  51 79 AD 4A  
009871  2  DD 4D E3 2C  
009879  2  B3 04 CB 71    .byte $b3, $04, $cb, $71, $ec, $07, $0d, $0a, $39, $71, $df, $33, $ca, $b0, $d6, $10
00987D  2  EC 07 0D 0A  
009881  2  39 71 DF 33  
009889  2  D7 30 DC 0C    .byte $d7, $30, $dc, $0c, $03, $b1, $ad, $41, $ef, $26, $ed, $c7, $39, $f1, $0d, $10
00988D  2  03 B1 AD 41  
009891  2  EF 26 ED C7  
009899  2  7D 4C 0D 13    .byte $7d, $4c, $0d, $13, $a8, $11, $aa, $10, $1c, $83, $d7, $7b, $f3, $67, $5d, $cd
00989D  2  A8 11 AA 10  
0098A1  2  1C 83 D7 7B  
0098A9  2  6D 47 FD       .byte $6d, $47, $fd
0098AC  2               
0098AC  2               ;level 7-2
0098AC  2               L_GroundArea17:
0098AC  2  56 11 0F 26    .byte $56, $11, $0f, $26, $df, $32, $fe, $11, $0d, $01, $0c, $5f, $03, $80, $0c, $52
0098B0  2  DF 32 FE 11  
0098B4  2  0D 01 0C 5F  
0098BC  2  29 15 7C 5B    .byte $29, $15, $7c, $5b, $23, $b2, $29, $1f, $31, $79, $1c, $de, $48, $3b, $ed, $4b
0098C0  2  23 B2 29 1F  
0098C4  2  31 79 1C DE  
0098CC  2  39 F1 CF B3    .byte $39, $f1, $cf, $b3, $fe, $10, $37, $8e, $77, $0e, $9e, $11, $a8, $34, $a9, $34
0098D0  2  FE 10 37 8E  
0098D4  2  77 0E 9E 11  
0098DC  2  AA 34 F8 62    .byte $aa, $34, $f8, $62, $fe, $10, $37, $b6, $de, $11, $e7, $63, $f8, $62, $09, $e1
0098E0  2  FE 10 37 B6  
0098E4  2  DE 11 E7 63  
0098EC  2  0E 10 47 36    .byte $0e, $10, $47, $36, $b7, $0e, $be, $91, $ca, $32, $ee, $10, $1d, $ca, $7e, $11
0098F0  2  B7 0E BE 91  
0098F4  2  CA 32 EE 10  
0098FC  2  83 77 9E 10    .byte $83, $77, $9e, $10, $1e, $91, $2d, $41, $4f, $26, $4d, $c7, $fd
009900  2  1E 91 2D 41  
009904  2  4F 26 4D C7  
009909  2               
009909  2               ;level 7-3
009909  2               L_GroundArea18:
009909  2  57 11 0F 26    .byte $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
00990D  2  FE 10 4B 92  
009911  2  59 0F AD 4C  
009919  2  29 0F 7B 93    .byte $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
00991D  2  99 0F 0D 06  
009921  2  27 12 35 0F  
009929  2  A3 31 AB 71    .byte $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
00992D  2  F7 75 23 B1  
009931  2  87 13 95 0F  
009939  2  38 13 55 00    .byte $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $3b, $92, $49, $0f, $ad, $4c
00993D  2  9B 16 0B 96  
009941  2  C7 75 3B 92  
009949  2  29 92 52 40    .byte $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93, $0a, $13
00994D  2  6C 15 6F 11  
009951  2  72 40 BF 15  
009959  2  12 41 8B 12    .byte $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32, $13, $b1
00995D  2  99 0F 0D 10  
009961  2  47 16 46 45  
009969  2  57 0E A7 0E    .byte $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e, $8d, $4d
00996D  2  D3 31 53 B1  
009971  2  A6 31 03 B2  
009979  2  AE 11 BD 41    .byte $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
00997D  2  EE 52 0F A0  
009981  2  DD 47 FD     
009984  2               
009984  2               ;level 8-1
009984  2               L_GroundArea19:
009984  2  52 A1 0F 20    .byte $52, $a1, $0f, $20, $6e, $65, $57, $f3, $60, $21, $6f, $62, $ac, $75, $07, $80
009988  2  6E 65 57 F3  
00998C  2  60 21 6F 62  
009994  2  1C 76 87 01    .byte $1c, $76, $87, $01, $9c, $70, $b0, $33, $cf, $66, $57, $e3, $6c, $04, $cd, $4c
009998  2  9C 70 B0 33  
00999C  2  CF 66 57 E3  
0099A4  2  9A B0 AC 0C    .byte $9a, $b0, $ac, $0c, $83, $b1, $8f, $74, $bd, $4d, $f8, $11, $fa, $10, $83, $87
0099A8  2  83 B1 8F 74  
0099AC  2  BD 4D F8 11  
0099B4  2  93 22 9F 74    .byte $93, $22, $9f, $74, $59, $f1, $89, $61, $a9, $61, $bc, $0c, $67, $a0, $eb, $71
0099B8  2  59 F1 89 61  
0099BC  2  A9 61 BC 0C  
0099C4  2  77 87 7A 10    .byte $77, $87, $7a, $10, $86, $51, $95, $52, $a4, $53, $b6, $04, $b3, $24, $26, $85
0099C8  2  86 51 95 52  
0099CC  2  A4 53 B6 04  
0099D4  2  4A 10 53 23    .byte $4a, $10, $53, $23, $5c, $00, $6f, $73, $93, $08, $07, $fb, $2c, $04, $33, $30
0099D8  2  5C 00 6F 73  
0099DC  2  93 08 07 FB  
0099E4  2  74 76 EB 71    .byte $74, $76, $eb, $71, $57, $8b, $6c, $02, $96, $74, $e3, $30, $0c, $86, $7d, $41
0099E8  2  57 8B 6C 02  
0099EC  2  96 74 E3 30  
0099F4  2  BF 26 BD C7    .byte $bf, $26, $bd, $c7, $fd
0099F8  2  FD           
0099F9  2               
0099F9  2               ;cloud level used in levels 2-1, 3-1 and 4-1
0099F9  2               L_GroundArea20:
0099F9  2  00 C1 4C 00    .byte $00, $c1, $4c, $00, $03, $cf, $00, $d7, $23, $4d, $07, $af, $2a, $4c, $03, $cf
0099FD  2  03 CF 00 D7  
009A01  2  23 4D 07 AF  
009A09  2  3E 80 F3 4A    .byte $3e, $80, $f3, $4a, $bb, $c2, $bd, $c7, $fd
009A0D  2  BB C2 BD C7  
009A11  2  FD           
009A12  2               
009A12  2               ;warp zone area used in levels 1-2 and 5-2
009A12  2               L_GroundArea21:
009A12  2  10 00 0B 13    .byte $10, $00, $0b, $13, $5b, $14, $6a, $42, $c7, $12, $c6, $42, $1b, $94, $2a, $42
009A16  2  5B 14 6A 42  
009A1A  2  C7 12 C6 42  
009A22  2  53 13 62 41    .byte $53, $13, $62, $41, $97, $17, $a6, $45, $6e, $81, $8f, $37, $02, $e8, $12, $3a
009A26  2  97 17 A6 45  
009A2A  2  6E 81 8F 37  
009A32  2  68 7A DE 0F    .byte $68, $7a, $de, $0f, $6d, $c5, $fd
009A36  2  6D C5 FD     
009A39  2               
009A39  2               ;level 8-2
009A39  2               L_GroundArea22:
009A39  2  50 61 0F 26    .byte $50, $61, $0f, $26, $bb, $f1, $dc, $06, $23, $87, $b5, $71, $b7, $31, $d7, $28
009A3D  2  BB F1 DC 06  
009A41  2  23 87 B5 71  
009A49  2  06 C5 67 08    .byte $06, $c5, $67, $08, $0d, $05, $39, $71, $7c, $00, $9e, $62, $b6, $0b, $e6, $08
009A4D  2  0D 05 39 71  
009A51  2  7C 00 9E 62  
009A59  2  4E E0 5D 4C    .byte $4e, $e0, $5d, $4c, $59, $0f, $6c, $02, $93, $67, $ac, $56, $ad, $4c, $1f, $b1
009A5D  2  59 0F 6C 02  
009A61  2  93 67 AC 56  
009A69  2  3C 01 98 0A    .byte $3c, $01, $98, $0a, $9e, $20, $a8, $21, $f3, $09, $0e, $a1, $27, $20, $3e, $62
009A6D  2  9E 20 A8 21  
009A71  2  F3 09 0E A1  
009A79  2  56 08 7D 4D    .byte $56, $08, $7d, $4d, $c6, $08, $3e, $e0, $9e, $62, $b6, $08, $1e, $e0, $4c, $00
009A7D  2  C6 08 3E E0  
009A81  2  9E 62 B6 08  
009A89  2  6C 00 A7 7B    .byte $6c, $00, $a7, $7b, $de, $2f, $6d, $c7, $fe, $10, $0b, $93, $5b, $15, $b7, $12
009A8D  2  DE 2F 6D C7  
009A91  2  FE 10 0B 93  
009A99  2  03 91 AB 1F    .byte $03, $91, $ab, $1f, $bd, $41, $ef, $26, $ad, $c7, $fd
009A9D  2  BD 41 EF 26  
009AA1  2  AD C7 FD     
009AA4  2               
009AA4  2               ;level 8-3
009AA4  2               L_GroundArea23:
009AA4  2  50 50 0F 26    .byte $50, $50, $0f, $26, $0b, $1f, $57, $92, $8b, $12, $d2, $14, $4b, $92, $59, $0f
009AA8  2  0B 1F 57 92  
009AAC  2  8B 12 D2 14  
009AB4  2  0B 95 BB 1F    .byte $0b, $95, $bb, $1f, $be, $52, $58, $e2, $9e, $50, $97, $08, $bb, $1f, $ae, $d2
009AB8  2  BE 52 58 E2  
009ABC  2  9E 50 97 08  
009AC4  2  B6 08 BB 1F    .byte $b6, $08, $bb, $1f, $dd, $4a, $f6, $07, $26, $89, $8e, $50, $98, $62, $eb, $11
009AC8  2  DD 4A F6 07  
009ACC  2  26 89 8E 50  
009AD4  2  07 F3 0B 1D    .byte $07, $f3, $0b, $1d, $2e, $52, $47, $0a, $ce, $50, $eb, $1f, $ee, $52, $5e, $d0
009AD8  2  2E 52 47 0A  
009ADC  2  CE 50 EB 1F  
009AE4  2  D9 0F AB 9F    .byte $d9, $0f, $ab, $9f, $be, $52, $8e, $d0, $ab, $1d, $ae, $52, $36, $8b, $56, $08
009AE8  2  BE 52 8E D0  
009AEC  2  AB 1D AE 52  
009AF4  2  5E 50 DC 15    .byte $5e, $50, $dc, $15, $df, $12, $2f, $95, $c3, $31, $5b, $9f, $6d, $41, $8e, $52
009AF8  2  DF 12 2F 95  
009AFC  2  C3 31 5B 9F  
009B04  2  AF 20 AD C7    .byte $af, $20, $ad, $c7
009B08  2               
009B08  2               ;three unused levels
009B08  2               L_GroundArea24:
009B08  2               L_GroundArea26:
009B08  2               L_GroundArea27:
009B08  2  FD             .byte $fd
009B09  2               
009B09  2               ;level 9-1 starting area
009B09  2               L_GroundArea25:
009B09  2  50 02 9F 38      .byte $50, $02, $9f, $38, $ee, $01, $12, $b9, $77, $7b, $de, $0f, $6d, $c7, $fd
009B0D  2  EE 01 12 B9  
009B11  2  77 7B DE 0F  
009B18  2               
009B18  2               ;exit area used in levels 1-2, 3-2, 5-2, 6-2, A-2 and B-2
009B18  2               L_GroundArea28:
009B18  2  90 31 39 F1    .byte $90, $31, $39, $f1, $bf, $37, $33, $e7, $a3, $03, $a7, $03, $cd, $41, $0f, $a6
009B1C  2  BF 37 33 E7  
009B20  2  A3 03 A7 03  
009B28  2  ED 47 FD       .byte $ed, $47, $fd
009B2B  2               
009B2B  2               ;cloud level used with level 5-1
009B2B  2               L_GroundArea29:
009B2B  2  00 C1 4C 00    .byte $00, $c1, $4c, $00, $f3, $4f, $fa, $c6, $68, $a0, $69, $20, $6a, $20, $7a, $47
009B2F  2  F3 4F FA C6  
009B33  2  68 A0 69 20  
009B3B  2  F8 20 F9 20    .byte $f8, $20, $f9, $20, $fa, $20, $0a, $cf, $b4, $49, $55, $a0, $56, $20, $73, $47
009B3F  2  FA 20 0A CF  
009B43  2  B4 49 55 A0  
009B4B  2  F5 20 F6 20    .byte $f5, $20, $f6, $20, $22, $a1, $41, $48, $52, $20, $72, $20, $92, $20, $b2, $20
009B4F  2  22 A1 41 48  
009B53  2  52 20 72 20  
009B5B  2  FE 00 9B C2    .byte $fe, $00, $9b, $c2, $ad, $c7, $fd
009B5F  2  AD C7 FD     
009B62  2               
009B62  2               ;level A-1
009B62  2               L_GroundArea30:
009B62  2  52 71 0F 20    .byte $52, $71, $0f, $20, $6e, $70, $e3, $64, $fc, $61, $fc, $71, $13, $86, $2c, $61
009B66  2  6E 70 E3 64  
009B6A  2  FC 61 FC 71  
009B72  2  2C 71 43 64    .byte $2c, $71, $43, $64, $b2, $22, $b5, $62, $c7, $28, $22, $a2, $52, $09, $56, $61
009B76  2  B2 22 B5 62  
009B7A  2  C7 28 22 A2  
009B82  2  6C 03 DB 71    .byte $6c, $03, $db, $71, $fc, $03, $f3, $20, $03, $a4, $0f, $71, $40, $0c, $8c, $74
009B86  2  FC 03 F3 20  
009B8A  2  03 A4 0F 71  
009B92  2  9C 66 D7 01    .byte $9c, $66, $d7, $01, $ec, $71, $89, $e1, $b6, $61, $b9, $2a, $c7, $26, $f4, $23
009B96  2  EC 71 89 E1  
009B9A  2  B6 61 B9 2A  
009BA2  2  67 E2 E8 F2    .byte $67, $e2, $e8, $f2, $78, $82, $88, $01, $98, $02, $a8, $02, $b8, $02, $03, $a6
009BA6  2  78 82 88 01  
009BAA  2  98 02 A8 02  
009BB2  2  07 26 21 79    .byte $07, $26, $21, $79, $4b, $71, $cf, $33, $06, $e4, $16, $2a, $39, $71, $58, $45
009BB6  2  4B 71 CF 33  
009BBA  2  06 E4 16 2A  
009BC2  2  5A 45 C6 07    .byte $5a, $45, $c6, $07, $dc, $04, $3f, $e7, $3b, $71, $8c, $71, $ac, $01, $e7, $63
009BC6  2  DC 04 3F E7  
009BCA  2  3B 71 8C 71  
009BD2  2  39 8F 63 20    .byte $39, $8f, $63, $20, $65, $0b, $68, $62, $8c, $00, $0c, $81, $29, $63, $3c, $01
009BD6  2  65 0B 68 62  
009BDA  2  8C 00 0C 81  
009BE2  2  57 65 6C 01    .byte $57, $65, $6c, $01, $85, $67, $9c, $04, $1d, $c1, $5f, $26, $3d, $c7, $fd
009BE6  2  85 67 9C 04  
009BEA  2  1D C1 5F 26  
009BF1  2               
009BF1  2               ;level A-3
009BF1  2               L_GroundArea31:
009BF1  2  50 50 0B 1F    .byte $50, $50, $0b, $1f, $0f, $26, $19, $96, $84, $43, $b7, $1f, $5d, $cc, $6d, $48
009BF5  2  0F 26 19 96  
009BF9  2  84 43 B7 1F  
009C01  2  E0 42 E3 12    .byte $e0, $42, $e3, $12, $39, $9c, $56, $43, $47, $9b, $a4, $12, $c1, $06, $ed, $4d
009C05  2  39 9C 56 43  
009C09  2  47 9B A4 12  
009C11  2  F4 42 1B 98    .byte $f4, $42, $1b, $98, $b7, $13, $02, $c2, $03, $12, $47, $1f, $ad, $48, $63, $9c
009C15  2  B7 13 02 C2  
009C19  2  03 12 47 1F  
009C21  2  82 48 76 93    .byte $82, $48, $76, $93, $08, $94, $8e, $11, $b0, $03, $c9, $0f, $1d, $c1, $2d, $4a
009C25  2  08 94 8E 11  
009C29  2  B0 03 C9 0F  
009C31  2  4E 42 6F 20    .byte $4e, $42, $6f, $20, $0d, $0e, $0e, $40, $39, $71, $7f, $37, $f2, $68, $01, $e9
009C35  2  0D 0E 0E 40  
009C39  2  39 71 7F 37  
009C41  2  11 39 68 7A    .byte $11, $39, $68, $7a, $de, $1f, $6d, $c5, $fd
009C45  2  DE 1F 6D C5  
009C49  2  FD           
009C4A  2               
009C4A  2               ;level B-1
009C4A  2               L_GroundArea32:
009C4A  2  52 21 0F 20    .byte $52, $21, $0f, $20, $6e, $60, $6c, $f6, $ca, $30, $dc, $02, $08, $f2, $37, $04
009C4E  2  6E 60 6C F6  
009C52  2  CA 30 DC 02  
009C5A  2  56 74 7C 00    .byte $56, $74, $7c, $00, $dc, $01, $e7, $25, $47, $8b, $49, $20, $6c, $02, $96, $74
009C5E  2  DC 01 E7 25  
009C62  2  47 8B 49 20  
009C6A  2  06 82 36 02    .byte $06, $82, $36, $02, $66, $00, $a7, $22, $dc, $02, $0a, $e0, $63, $22, $78, $72
009C6E  2  66 00 A7 22  
009C72  2  DC 02 0A E0  
009C7A  2  93 09 97 03    .byte $93, $09, $97, $03, $a3, $25, $a7, $03, $b6, $24, $03, $a2, $5c, $75, $65, $71
009C7E  2  A3 25 A7 03  
009C82  2  B6 24 03 A2  
009C8A  2  7C 00 9C 00    .byte $7c, $00, $9c, $00, $63, $a2, $67, $20, $77, $03, $87, $20, $93, $0a, $97, $03
009C8E  2  63 A2 67 20  
009C92  2  77 03 87 20  
009C9A  2  A3 22 A7 20    .byte $a3, $22, $a7, $20, $b7, $03, $bc, $00, $c7, $20, $dc, $00, $fc, $01, $19, $8f
009C9E  2  B7 03 BC 00  
009CA2  2  C7 20 DC 00  
009CAA  2  1E 20 46 22    .byte $1e, $20, $46, $22, $4c, $61, $63, $00, $8e, $21, $d7, $73, $46, $a6, $4c, $62
009CAE  2  4C 61 63 00  
009CB2  2  8E 21 D7 73  
009CBA  2  68 62 73 01    .byte $68, $62, $73, $01, $8c, $62, $d8, $62, $43, $a9, $c7, $73, $ec, $06, $57, $f3
009CBE  2  8C 62 D8 62  
009CC2  2  43 A9 C7 73  
009CCA  2  7C 00 B5 65    .byte $7c, $00, $b5, $65, $c5, $65, $dc, $00, $e3, $67, $7d, $c1, $bf, $26, $ad, $c7
009CCE  2  C5 65 DC 00  
009CD2  2  E3 67 7D C1  
009CDA  2  FD             .byte $fd
009CDB  2               
009CDB  2               ;level B-3
009CDB  2               L_GroundArea33:
009CDB  2  90 10 0B 1B    .byte $90, $10, $0b, $1b, $0f, $26, $07, $94, $bc, $14, $bf, $13, $c7, $40, $ff, $16
009CDF  2  0F 26 07 94  
009CE3  2  BC 14 BF 13  
009CEB  2  D1 80 C3 94    .byte $d1, $80, $c3, $94, $cb, $17, $c2, $44, $29, $8f, $77, $31, $0b, $96, $76, $32
009CEF  2  CB 17 C2 44  
009CF3  2  29 8F 77 31  
009CFB  2  C7 75 13 F7    .byte $c7, $75, $13, $f7, $1b, $61, $2b, $61, $4b, $12, $59, $0f, $3b, $b0, $3a, $40
009CFF  2  1B 61 2B 61  
009D03  2  4B 12 59 0F  
009D0B  2  43 12 7A 40    .byte $43, $12, $7a, $40, $7b, $30, $b5, $41, $b6, $20, $c6, $07, $f3, $13, $03, $92
009D0F  2  7B 30 B5 41  
009D13  2  B6 20 C6 07  
009D1B  2  6B 12 79 0F    .byte $6b, $12, $79, $0f, $cc, $15, $cf, $11, $1f, $95, $c3, $14, $b3, $95, $a3, $95
009D1F  2  CC 15 CF 11  
009D23  2  1F 95 C3 14  
009D2B  2  4D CA 6B 61    .byte $4d, $ca, $6b, $61, $7e, $11, $8d, $41, $be, $42, $df, $20, $bd, $c7, $fd
009D2F  2  7E 11 8D 41  
009D33  2  BE 42 DF 20  
009D3A  2               
009D3A  2               ;level C-1
009D3A  2               L_GroundArea34:
009D3A  2  52 31 0F 20    .byte $52, $31, $0f, $20, $6e, $74, $0d, $02, $03, $33, $1f, $72, $39, $71, $65, $04
009D3E  2  6E 74 0D 02  
009D42  2  03 33 1F 72  
009D4A  2  6C 70 77 01    .byte $6c, $70, $77, $01, $84, $72, $8c, $72, $b3, $34, $ec, $01, $ef, $72, $0d, $04
009D4E  2  84 72 8C 72  
009D52  2  B3 34 EC 01  
009D5A  2  AC 67 CC 01    .byte $ac, $67, $cc, $01, $cf, $71, $e7, $22, $17, $88, $23, $00, $27, $23, $3c, $62
009D5E  2  CF 71 E7 22  
009D62  2  17 88 23 00  
009D6A  2  65 71 67 33    .byte $65, $71, $67, $33, $8c, $61, $dc, $01, $08, $fa, $45, $75, $63, $0a, $73, $23
009D6E  2  8C 61 DC 01  
009D72  2  08 FA 45 75  
009D7A  2  7C 02 8F 72    .byte $7c, $02, $8f, $72, $73, $a9, $9f, $74, $bf, $74, $ef, $73, $39, $f1, $fc, $0a
009D7E  2  73 A9 9F 74  
009D82  2  BF 74 EF 73  
009D8A  2  0D 0B 13 25    .byte $0d, $0b, $13, $25, $4c, $01, $4f, $72, $73, $0b, $77, $03, $dc, $08, $23, $a2
009D8E  2  4C 01 4F 72  
009D92  2  73 0B 77 03  
009D9A  2  53 09 56 03    .byte $53, $09, $56, $03, $63, $24, $8c, $02, $3f, $b3, $77, $63, $96, $74, $b3, $77
009D9E  2  63 24 8C 02  
009DA2  2  3F B3 77 63  
009DAA  2  5D C1 8F 26    .byte $5d, $c1, $8f, $26, $7d, $c7, $fd
009DAE  2  7D C7 FD     
009DB1  2               
009DB1  2               ;level C-2
009DB1  2               L_GroundArea35:
009DB1  2  54 11 0F 26    .byte $54, $11, $0f, $26, $cf, $32, $f8, $62, $fe, $10, $3c, $b2, $bd, $48, $ea, $62
009DB5  2  CF 32 F8 62  
009DB9  2  FE 10 3C B2  
009DC1  2  FC 4D FC 4D    .byte $fc, $4d, $fc, $4d, $17, $c9, $da, $62, $0b, $97, $b7, $12, $2c, $b1, $33, $43
009DC5  2  17 C9 DA 62  
009DC9  2  0B 97 B7 12  
009DD1  2  6C 31 AC 41    .byte $6c, $31, $ac, $41, $0b, $98, $ad, $4a, $db, $30, $27, $b0, $b7, $14, $c6, $42
009DD5  2  0B 98 AD 4A  
009DD9  2  DB 30 27 B0  
009DE1  2  C7 96 D6 44    .byte $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00, $1b, $95, $97, $13
009DE5  2  2B 92 39 0F  
009DE9  2  72 41 A7 00  
009DF1  2  6C 95 6F 11    .byte $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9a, $62, $42, $63, $12
009DF5  2  A2 40 BF 15  
009DF9  2  C2 40 0B 9A  
009E01  2  AD 4A 0E 91    .byte $ad, $4a, $0e, $91, $1d, $41, $4f, $26, $4d, $c7, $fd
009E05  2  1D 41 4F 26  
009E09  2  4D C7 FD     
009E0C  2               
009E0C  2               ;level C-3
009E0C  2               L_GroundArea36:
009E0C  2  57 11 0F 26    .byte $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
009E10  2  FE 10 4B 92  
009E14  2  59 0F AD 4C  
009E1C  2  29 0F 7B 93    .byte $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
009E20  2  99 0F 0D 06  
009E24  2  27 12 35 0F  
009E2C  2  A3 31 AB 71    .byte $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
009E30  2  F7 75 23 B1  
009E34  2  87 13 95 0F  
009E3C  2  38 13 55 00    .byte $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $dd, $4a, $3b, $92, $49, $0f
009E40  2  9B 16 0B 96  
009E44  2  C7 75 DD 4A  
009E4C  2  AD 4C 29 92    .byte $ad, $4c, $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93
009E50  2  52 40 6C 15  
009E54  2  6F 11 72 40  
009E5C  2  0A 13 12 41    .byte $0a, $13, $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32
009E60  2  8B 12 99 0F  
009E64  2  0D 10 47 16  
009E6C  2  13 B1 57 0E    .byte $13, $b1, $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e
009E70  2  A7 0E D3 31  
009E74  2  53 B1 A6 31  
009E7C  2  8D 4D AE 11    .byte $8d, $4d, $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
009E80  2  BD 41 EE 52  
009E84  2  0F A0 DD 47  
009E89  2               
009E89  2               ;level D-1
009E89  2               L_GroundArea37:
009E89  2  52 A1 0F 20    .byte $52, $a1, $0f, $20, $6e, $65, $04, $a0, $14, $07, $24, $2d, $57, $25, $bc, $09
009E8D  2  6E 65 04 A0  
009E91  2  14 07 24 2D  
009E99  2  4C 80 6F 33    .byte $4c, $80, $6f, $33, $a5, $11, $a7, $63, $b7, $63, $e7, $20, $35, $a0, $59, $11
009E9D  2  A5 11 A7 63  
009EA1  2  B7 63 E7 20  
009EA9  2  B4 08 C0 04    .byte $b4, $08, $c0, $04, $05, $82, $15, $02, $25, $02, $3a, $10, $4c, $01, $6c, $79
009EAD  2  05 82 15 02  
009EB1  2  25 02 3A 10  
009EB9  2  95 79 73 A7    .byte $95, $79, $73, $a7, $8f, $74, $f3, $0a, $03, $a0, $93, $08, $97, $73, $e3, $20
009EBD  2  8F 74 F3 0A  
009EC1  2  03 A0 93 08  
009EC9  2  39 F1 94 07    .byte $39, $f1, $94, $07, $aa, $30, $bc, $5c, $c7, $30, $24, $f2, $27, $31, $8f, $33
009ECD  2  AA 30 BC 5C  
009ED1  2  C7 30 24 F2  
009ED9  2  C6 10 C7 63    .byte $c6, $10, $c7, $63, $d7, $63, $e7, $63, $f7, $63, $03, $a5, $07, $25, $aa, $10
009EDD  2  D7 63 E7 63  
009EE1  2  F7 63 03 A5  
009EE9  2  03 BF 4F 74    .byte $03, $bf, $4f, $74, $6c, $00, $df, $74, $fc, $00, $5c, $81, $77, $73, $9d, $4c
009EED  2  6C 00 DF 74  
009EF1  2  FC 00 5C 81  
009EF9  2  C5 30 E3 30    .byte $c5, $30, $e3, $30, $7d, $c1, $bd, $4d, $bf, $26, $ad, $c7, $fd
009EFD  2  7D C1 BD 4D  
009F01  2  BF 26 AD C7  
009F06  2               
009F06  2               ;level D-2
009F06  2               L_GroundArea38:
009F06  2  55 A1 0F 26    .byte $55, $a1, $0f, $26, $9c, $01, $4f, $b6, $b3, $34, $c9, $3f, $13, $ba, $a3, $b3
009F0A  2  9C 01 4F B6  
009F0E  2  B3 34 C9 3F  
009F16  2  BF 74 0C 84    .byte $bf, $74, $0c, $84, $83, $3f, $9f, $74, $ef, $72, $ec, $01, $2f, $f2, $2c, $01
009F1A  2  83 3F 9F 74  
009F1E  2  EF 72 EC 01  
009F26  2  6F 72 6C 01    .byte $6f, $72, $6c, $01, $a8, $91, $aa, $10, $03, $b7, $61, $79, $6f, $75, $39, $f1
009F2A  2  A8 91 AA 10  
009F2E  2  03 B7 61 79  
009F36  2  DB 71 03 A2    .byte $db, $71, $03, $a2, $17, $22, $33, $09, $43, $20, $5b, $71, $48, $8f, $4a, $30
009F3A  2  17 22 33 09  
009F3E  2  43 20 5B 71  
009F46  2  5C 5C A3 30    .byte $5c, $5c, $a3, $30, $2d, $c1, $5f, $26, $3d, $c7, $fd
009F4A  2  2D C1 5F 26  
009F4E  2  3D C7 FD     
009F51  2               
009F51  2               ;level D-3
009F51  2               L_GroundArea39:
009F51  2  55 A1 0F 26    .byte $55, $a1, $0f, $26, $39, $91, $68, $12, $a7, $12, $aa, $10, $c7, $07, $e8, $12
009F55  2  39 91 68 12  
009F59  2  A7 12 AA 10  
009F61  2  19 91 6C 00    .byte $19, $91, $6c, $00, $78, $74, $0e, $c2, $76, $a8, $fe, $40, $29, $91, $73, $29
009F65  2  78 74 0E C2  
009F69  2  76 A8 FE 40  
009F71  2  77 53 8C 77    .byte $77, $53, $8c, $77, $59, $91, $87, $13, $b6, $14, $ba, $10, $e8, $12, $38, $92
009F75  2  59 91 87 13  
009F79  2  B6 14 BA 10  
009F81  2  19 8F 2C 00    .byte $19, $8f, $2c, $00, $33, $67, $4e, $42, $68, $0b, $2e, $c0, $38, $72, $a8, $11
009F85  2  33 67 4E 42  
009F89  2  68 0B 2E C0  
009F91  2  AA 10 49 91    .byte $aa, $10, $49, $91, $6e, $42, $de, $40, $e7, $22, $0e, $c2, $4e, $c0, $6c, $00
009F95  2  6E 42 DE 40  
009F99  2  E7 22 0E C2  
009FA1  2  79 11 8C 01    .byte $79, $11, $8c, $01, $a7, $13, $bc, $01, $d5, $15, $ec, $01, $03, $97, $0e, $00
009FA5  2  A7 13 BC 01  
009FA9  2  D5 15 EC 01  
009FB1  2  6E 01 9D 41    .byte $6e, $01, $9d, $41, $ce, $42, $ff, $20, $9d, $c7, $fd
009FB5  2  CE 42 FF 20  
009FB9  2  9D C7 FD     
009FBC  2               
009FBC  2               ;ground level area used with level D-4
009FBC  2               L_GroundArea40:
009FBC  2  10 21 39 F1    .byte $10, $21, $39, $f1, $09, $f1, $ad, $4c, $7c, $83, $96, $30, $5b, $f1, $c8, $05
009FC0  2  09 F1 AD 4C  
009FC4  2  7C 83 96 30  
009FCC  2  1F B7 93 67    .byte $1f, $b7, $93, $67, $a3, $67, $b3, $67, $bd, $4d, $cc, $08, $54, $fe, $6e, $2f
009FD0  2  A3 67 B3 67  
009FD4  2  BD 4D CC 08  
009FDC  2  6D C7 FD       .byte $6d, $c7, $fd
009FDF  2               
009FDF  2               ;cloud level used with levels A-1, B-1 and D-2
009FDF  2               L_GroundArea41:
009FDF  2  00 C1 4C 00    .byte $00, $c1, $4c, $00, $02, $c9, $ba, $49, $62, $c9, $a4, $20, $a5, $20, $1a, $c9
009FE3  2  02 C9 BA 49  
009FE7  2  62 C9 A4 20  
009FEF  2  A3 2C B2 49    .byte $a3, $2c, $b2, $49, $56, $c2, $6e, $00, $95, $41, $ad, $c7, $fd
009FF3  2  56 C2 6E 00  
009FF7  2  95 41 AD C7  
009FFC  2               
009FFC  2               ;level 1-2
009FFC  2               L_UndergroundArea1:
009FFC  2  48 0F 0E 01    .byte $48, $0f, $0e, $01, $5e, $02, $0a, $b0, $1c, $54, $6a, $30, $7f, $34, $c6, $64
00A000  2  5E 02 0A B0  
00A004  2  1C 54 6A 30  
00A00C  2  D6 64 E6 64    .byte $d6, $64, $e6, $64, $f6, $64, $fe, $00, $f0, $07, $00, $a1, $1e, $02, $47, $73
00A010  2  F6 64 FE 00  
00A014  2  F0 07 00 A1  
00A01C  2  7E 04 84 52    .byte $7e, $04, $84, $52, $94, $50, $95, $0b, $96, $50, $a4, $52, $ae, $05, $b8, $51
00A020  2  94 50 95 0B  
00A024  2  96 50 A4 52  
00A02C  2  C8 51 CE 01    .byte $c8, $51, $ce, $01, $17, $f3, $45, $03, $52, $09, $62, $21, $6f, $34, $81, $21
00A030  2  17 F3 45 03  
00A034  2  52 09 62 21  
00A03C  2  9E 02 B6 64    .byte $9e, $02, $b6, $64, $c6, $64, $c0, $0c, $d6, $64, $d0, $07, $e6, $64, $e0, $0c
00A040  2  C6 64 C0 0C  
00A044  2  D6 64 D0 07  
00A04C  2  F0 07 FE 0A    .byte $f0, $07, $fe, $0a, $0d, $06, $0e, $01, $4e, $04, $67, $73, $8e, $02, $b7, $0a
00A050  2  0D 06 0E 01  
00A054  2  4E 04 67 73  
00A05C  2  BC 03 C4 72    .byte $bc, $03, $c4, $72, $c7, $22, $08, $f2, $2c, $02, $59, $71, $7c, $01, $96, $74
00A060  2  C7 22 08 F2  
00A064  2  2C 02 59 71  
00A06C  2  BC 01 D8 72    .byte $bc, $01, $d8, $72, $fc, $01, $39, $f1, $4e, $01, $9e, $04, $a7, $52, $b7, $0b
00A070  2  FC 01 39 F1  
00A074  2  4E 01 9E 04  
00A07C  2  B8 51 C7 51    .byte $b8, $51, $c7, $51, $d7, $50, $de, $02, $3a, $e0, $3e, $0a, $9e, $00, $08, $d4
00A080  2  D7 50 DE 02  
00A084  2  3A E0 3E 0A  
00A08C  2  18 54 28 54    .byte $18, $54, $28, $54, $48, $54, $6e, $06, $9e, $01, $a8, $52, $af, $47, $b8, $52
00A090  2  48 54 6E 06  
00A094  2  9E 01 A8 52  
00A09C  2  C8 52 D8 52    .byte $c8, $52, $d8, $52, $de, $0f, $4d, $c7, $ce, $01, $dc, $01, $f9, $79, $1c, $82
00A0A0  2  DE 0F 4D C7  
00A0A4  2  CE 01 DC 01  
00A0AC  2  48 72 7F 37    .byte $48, $72, $7f, $37, $f2, $68, $01, $e9, $11, $3a, $68, $7a, $de, $0f, $6d, $c5
00A0B0  2  F2 68 01 E9  
00A0B4  2  11 3A 68 7A  
00A0BC  2  FD             .byte $fd
00A0BD  2               
00A0BD  2               ;warp zone area used by level 1-2
00A0BD  2               L_UndergroundArea2:
00A0BD  2  0B 0F 0E 01    .byte $0b, $0f, $0e, $01, $9c, $71, $b7, $00, $be, $00, $3e, $81, $47, $73, $5e, $00
00A0C1  2  9C 71 B7 00  
00A0C5  2  BE 00 3E 81  
00A0CD  2  63 42 8E 01    .byte $63, $42, $8e, $01, $a7, $73, $be, $00, $7e, $81, $88, $72, $f0, $59, $fe, $00
00A0D1  2  A7 73 BE 00  
00A0D5  2  7E 81 88 72  
00A0DD  2  00 D9 0E 01    .byte $00, $d9, $0e, $01, $39, $79, $a7, $03, $ae, $00, $b4, $03, $de, $0f, $0d, $05
00A0E1  2  39 79 A7 03  
00A0E5  2  AE 00 B4 03  
00A0ED  2  0E 02 68 7A    .byte $0e, $02, $68, $7a, $be, $01, $de, $0f, $6d, $c5, $fd
00A0F1  2  BE 01 DE 0F  
00A0F5  2  6D C5 FD     
00A0F8  2               
00A0F8  2               ;underground bonus rooms used with worlds 1-4
00A0F8  2               L_UndergroundArea3:
00A0F8  2  08 8F 0E 01    .byte $08, $8f, $0e, $01, $17, $05, $2e, $02, $30, $07, $37, $03, $3a, $49, $44, $03
00A0FC  2  17 05 2E 02  
00A100  2  30 07 37 03  
00A108  2  58 47 DF 4A    .byte $58, $47, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $87, $52, $97, $2f
00A10C  2  6D C7 0E 81  
00A110  2  00 5A 2E 02  
00A118  2  99 4F 0A 90    .byte $99, $4f, $0a, $90, $93, $56, $a3, $0b, $a7, $50, $b3, $55, $df, $4a, $6d, $c7
00A11C  2  93 56 A3 0B  
00A120  2  A7 50 B3 55  
00A128  2  0E 81 00 5A    .byte $0e, $81, $00, $5a, $2e, $00, $3e, $02, $41, $56, $57, $25, $56, $45, $68, $51
00A12C  2  2E 00 3E 02  
00A130  2  41 56 57 25  
00A138  2  7A 43 B7 0B    .byte $7a, $43, $b7, $0b, $b8, $51, $df, $4a, $6d, $c7, $fd
00A13C  2  B8 51 DF 4A  
00A140  2  6D C7 FD     
00A143  2               
00A143  2               ;level 5-2
00A143  2               L_UndergroundArea4:
00A143  2  48 0F 1E 01    .byte $48, $0f, $1e, $01, $27, $06, $5e, $02, $8f, $63, $8c, $01, $ef, $67, $1c, $81
00A147  2  27 06 5E 02  
00A14B  2  8F 63 8C 01  
00A153  2  2E 09 3C 63    .byte $2e, $09, $3c, $63, $73, $01, $8c, $60, $fe, $02, $1e, $8e, $3e, $02, $44, $07
00A157  2  73 01 8C 60  
00A15B  2  FE 02 1E 8E  
00A163  2  45 52 4E 0E    .byte $45, $52, $4e, $0e, $8e, $02, $99, $71, $b5, $24, $b6, $24, $b7, $24, $fe, $02
00A167  2  8E 02 99 71  
00A16B  2  B5 24 B6 24  
00A173  2  07 87 17 22    .byte $07, $87, $17, $22, $37, $52, $37, $0b, $47, $52, $4e, $0a, $57, $52, $5e, $02
00A177  2  37 52 37 0B  
00A17B  2  47 52 4E 0A  
00A183  2  67 52 77 52    .byte $67, $52, $77, $52, $7e, $0a, $87, $52, $8e, $02, $96, $46, $97, $52, $a7, $52
00A187  2  7E 0A 87 52  
00A18B  2  8E 02 96 46  
00A193  2  B7 52 C7 52    .byte $b7, $52, $c7, $52, $d7, $52, $e7, $52, $f7, $52, $fe, $04, $07, $a3, $47, $08
00A197  2  D7 52 E7 52  
00A19B  2  F7 52 FE 04  
00A1A3  2  57 26 C7 0A    .byte $57, $26, $c7, $0a, $e9, $71, $17, $a7, $97, $08, $9e, $01, $a0, $24, $c6, $74
00A1A7  2  E9 71 17 A7  
00A1AB  2  97 08 9E 01  
00A1B3  2  F0 0C FE 04    .byte $f0, $0c, $fe, $04, $0c, $80, $6f, $32, $98, $62, $a8, $62, $bc, $00, $c7, $73
00A1B7  2  0C 80 6F 32  
00A1BB  2  98 62 A8 62  
00A1C3  2  E7 73 FE 02    .byte $e7, $73, $fe, $02, $7f, $e7, $8e, $01, $9e, $00, $de, $02, $f7, $0b, $fe, $0e
00A1C7  2  7F E7 8E 01  
00A1CB  2  9E 00 DE 02  
00A1D3  2  4E 82 54 52    .byte $4e, $82, $54, $52, $64, $51, $6e, $00, $74, $09, $9f, $00, $df, $00, $2f, $80
00A1D7  2  64 51 6E 00  
00A1DB  2  74 09 9F 00  
00A1E3  2  4E 02 59 47    .byte $4e, $02, $59, $47, $ce, $0a, $07, $f5, $68, $54, $7f, $64, $88, $54, $a8, $54
00A1E7  2  CE 0A 07 F5  
00A1EB  2  68 54 7F 64  
00A1F3  2  AE 01 B8 52    .byte $ae, $01, $b8, $52, $bf, $47, $c8, $52, $d8, $52, $e8, $52, $ee, $0f, $4d, $c7
00A1F7  2  BF 47 C8 52  
00A1FB  2  D8 52 E8 52  
00A203  2  0D 0D 0E 02    .byte $0d, $0d, $0e, $02, $68, $7a, $be, $01, $ee, $0f, $6d, $c5, $fd
00A207  2  68 7A BE 01  
00A20B  2  EE 0F 6D C5  
00A210  2               
00A210  2               ;underground bonus rooms used with worlds 5-8
00A210  2               L_UndergroundArea5:
00A210  2  08 0F 0E 01    .byte $08, $0f, $0e, $01, $2e, $05, $38, $2c, $3a, $4f, $08, $ac, $c7, $0b, $ce, $01
00A214  2  2E 05 38 2C  
00A218  2  3A 4F 08 AC  
00A220  2  DF 4A 6D C7    .byte $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $b8, $4f, $cf, $65, $0f, $e5
00A224  2  0E 81 00 5A  
00A228  2  2E 02 B8 4F  
00A230  2  4F 65 8F 65    .byte $4f, $65, $8f, $65, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $30, $07, $34, $52
00A234  2  DF 4A 6D C7  
00A238  2  0E 81 00 5A  
00A240  2  3E 02 42 47    .byte $3e, $02, $42, $47, $44, $47, $46, $27, $c0, $0b, $c4, $52, $df, $4a, $6d, $c7
00A244  2  44 47 46 27  
00A248  2  C0 0B C4 52  
00A250  2  FD             .byte $fd
00A251  2               
00A251  2               ;level A-2
00A251  2               L_UndergroundArea6:
00A251  2  48 8F 1E 01    .byte $48, $8f, $1e, $01, $4e, $02, $00, $8c, $09, $0f, $6e, $0a, $ee, $82, $2e, $80
00A255  2  4E 02 00 8C  
00A259  2  09 0F 6E 0A  
00A261  2  30 20 7E 01    .byte $30, $20, $7e, $01, $87, $27, $07, $87, $17, $23, $3e, $00, $9e, $05, $5b, $f1
00A265  2  87 27 07 87  
00A269  2  17 23 3E 00  
00A271  2  8B 71 BB 71    .byte $8b, $71, $bb, $71, $eb, $71, $3e, $82, $7f, $38, $fe, $0a, $3e, $84, $47, $29
00A275  2  EB 71 3E 82  
00A279  2  7F 38 FE 0A  
00A281  2  48 2E AF 71    .byte $48, $2e, $af, $71, $cb, $71, $e7, $0a, $f7, $23, $2b, $f1, $37, $51, $3e, $00
00A285  2  CB 71 E7 0A  
00A289  2  F7 23 2B F1  
00A291  2  6F 00 8E 04    .byte $6f, $00, $8e, $04, $df, $32, $9c, $82, $ca, $12, $dc, $00, $e8, $14, $fc, $00
00A295  2  DF 32 9C 82  
00A299  2  CA 12 DC 00  
00A2A1  2  FE 08 4E 8A    .byte $fe, $08, $4e, $8a, $88, $74, $9e, $01, $a8, $52, $bf, $47, $b8, $52, $c8, $52
00A2A5  2  88 74 9E 01  
00A2A9  2  A8 52 BF 47  
00A2B1  2  D8 52 E8 52    .byte $d8, $52, $e8, $52, $ee, $0f, $4d, $c7, $0d, $0d, $0e, $02, $68, $7a, $be, $01
00A2B5  2  EE 0F 4D C7  
00A2B9  2  0D 0D 0E 02  
00A2C1  2  EE 0F 6D C5    .byte $ee, $0f, $6d, $c5, $fd
00A2C5  2  FD           
00A2C6  2               
00A2C6  2               ;underground bonus rooms used with worlds A-D
00A2C6  2               L_UndergroundArea7:
00A2C6  2  08 0F 0E 01    .byte $08, $0f, $0e, $01, $2e, $05, $38, $20, $3e, $04, $48, $07, $55, $45, $57, $45
00A2CA  2  2E 05 38 20  
00A2CE  2  3E 04 48 07  
00A2D6  2  58 25 B8 08    .byte $58, $25, $b8, $08, $be, $05, $c8, $20, $ce, $01, $df, $4a, $6d, $c7, $0e, $81
00A2DA  2  BE 05 C8 20  
00A2DE  2  CE 01 DF 4A  
00A2E6  2  00 5A 2E 02    .byte $00, $5a, $2e, $02, $34, $42, $36, $42, $37, $22, $73, $54, $83, $0b, $87, $20
00A2EA  2  34 42 36 42  
00A2EE  2  37 22 73 54  
00A2F6  2  93 54 90 07    .byte $93, $54, $90, $07, $b4, $41, $b6, $41, $b7, $21, $df, $4a, $6d, $c7, $0e, $81
00A2FA  2  B4 41 B6 41  
00A2FE  2  B7 21 DF 4A  
00A306  2  00 5A 14 56    .byte $00, $5a, $14, $56, $24, $56, $2e, $0c, $33, $43, $6e, $09, $8e, $0b, $96, $48
00A30A  2  24 56 2E 0C  
00A30E  2  33 43 6E 09  
00A316  2  1E 84 3E 05    .byte $1e, $84, $3e, $05, $4a, $48, $47, $0b, $ce, $01, $df, $4a, $6d, $c7, $fd
00A31A  2  4A 48 47 0B  
00A31E  2  CE 01 DF 4A  
00A325  2               
00A325  2               ;level 3-2
00A325  2               L_WaterArea1:
00A325  2  41 01 03 B4    .byte $41, $01, $03, $b4, $04, $34, $05, $34, $5c, $02, $83, $37, $84, $37, $85, $37
00A329  2  04 34 05 34  
00A32D  2  5C 02 83 37  
00A335  2  09 C2 0C 02    .byte $09, $c2, $0c, $02, $1d, $49, $fa, $60, $09, $e1, $18, $62, $20, $63, $27, $63
00A339  2  1D 49 FA 60  
00A33D  2  09 E1 18 62  
00A345  2  33 37 37 63    .byte $33, $37, $37, $63, $47, $63, $5c, $05, $79, $43, $fe, $06, $35, $d2, $46, $48
00A349  2  47 63 5C 05  
00A34D  2  79 43 FE 06  
00A355  2  91 53 D6 51    .byte $91, $53, $d6, $51, $fe, $01, $0c, $83, $6c, $04, $b4, $62, $c4, $62, $d4, $62
00A359  2  FE 01 0C 83  
00A35D  2  6C 04 B4 62  
00A365  2  E4 62 F4 62    .byte $e4, $62, $f4, $62, $18, $d2, $79, $51, $f4, $66, $fe, $02, $0c, $8a, $1d, $49
00A369  2  18 D2 79 51  
00A36D  2  F4 66 FE 02  
00A375  2  31 55 56 41    .byte $31, $55, $56, $41, $77, $41, $98, $41, $c5, $55, $fe, $01, $07, $e3, $17, $63
00A379  2  77 41 98 41  
00A37D  2  C5 55 FE 01  
00A385  2  27 63 37 63    .byte $27, $63, $37, $63, $47, $63, $57, $63, $67, $63, $78, $62, $89, $61, $9a, $60
00A389  2  47 63 57 63  
00A38D  2  67 63 78 62  
00A395  2  BC 07 CA 42    .byte $bc, $07, $ca, $42, $3a, $b3, $46, $53, $63, $34, $66, $44, $7c, $01, $9a, $33
00A399  2  3A B3 46 53  
00A39D  2  63 34 66 44  
00A3A5  2  B7 52 DC 01    .byte $b7, $52, $dc, $01, $fa, $32, $05, $d4, $2c, $0d, $43, $37, $47, $35, $b7, $30
00A3A9  2  FA 32 05 D4  
00A3AD  2  2C 0D 43 37  
00A3B5  2  C3 64 23 E4    .byte $c3, $64, $23, $e4, $29, $45, $33, $64, $43, $64, $53, $64, $63, $64, $73, $64
00A3B9  2  29 45 33 64  
00A3BD  2  43 64 53 64  
00A3C5  2  9A 60 A9 61    .byte $9a, $60, $a9, $61, $b8, $62, $be, $0b, $d4, $31, $d5, $0d, $de, $0f, $0d, $ca
00A3C9  2  B8 62 BE 0B  
00A3CD  2  D4 31 D5 0D  
00A3D5  2  7D 47 FD       .byte $7d, $47, $fd
00A3D8  2               
00A3D8  2               ;level 6-2
00A3D8  2               L_WaterArea2:
00A3D8  2  41 01 27 D3    .byte $41, $01, $27, $d3, $79, $51, $c4, $56, $00, $e2, $03, $53, $0c, $0f, $12, $3b
00A3DC  2  79 51 C4 56  
00A3E0  2  00 E2 03 53  
00A3E8  2  1A 42 43 54    .byte $1a, $42, $43, $54, $6d, $49, $83, $53, $99, $53, $c3, $54, $da, $52, $0c, $84
00A3EC  2  6D 49 83 53  
00A3F0  2  99 53 C3 54  
00A3F8  2  09 53 53 64    .byte $09, $53, $53, $64, $63, $31, $67, $34, $86, $41, $8c, $01, $a3, $30, $b3, $64
00A3FC  2  63 31 67 34  
00A400  2  86 41 8C 01  
00A408  2  CC 03 D9 42    .byte $cc, $03, $d9, $42, $5c, $84, $a0, $62, $a8, $62, $b0, $62, $b8, $62, $c0, $62
00A40C  2  5C 84 A0 62  
00A410  2  A8 62 B0 62  
00A418  2  C8 62 D0 62    .byte $c8, $62, $d0, $62, $d8, $62, $e0, $62, $e8, $62, $16, $c2, $58, $52, $8c, $04
00A41C  2  D8 62 E0 62  
00A420  2  E8 62 16 C2  
00A428  2  A7 55 D0 63    .byte $a7, $55, $d0, $63, $d7, $65, $e2, $61, $e7, $65, $f2, $61, $f7, $65, $13, $b8
00A42C  2  D7 65 E2 61  
00A430  2  E7 65 F2 61  
00A438  2  17 38 8C 03    .byte $17, $38, $8c, $03, $1d, $c9, $50, $62, $5c, $0b, $62, $3e, $63, $52, $8a, $52
00A43C  2  1D C9 50 62  
00A440  2  5C 0B 62 3E  
00A448  2  93 54 AA 42    .byte $93, $54, $aa, $42, $d3, $51, $ea, $41, $03, $d3, $1c, $04, $1a, $52, $33, $55
00A44C  2  D3 51 EA 41  
00A450  2  03 D3 1C 04  
00A458  2  73 44 77 44    .byte $73, $44, $77, $44, $16, $d2, $19, $31, $1a, $32, $5c, $0f, $9a, $47, $95, $64
00A45C  2  16 D2 19 31  
00A460  2  1A 32 5C 0F  
00A468  2  A5 64 B5 64    .byte $a5, $64, $b5, $64, $c5, $64, $d5, $64, $e5, $64, $f5, $64, $05, $e4, $40, $61
00A46C  2  C5 64 D5 64  
00A470  2  E5 64 F5 64  
00A478  2  42 35 56 34    .byte $42, $35, $56, $34, $5c, $09, $a2, $61, $a6, $61, $b3, $34, $b7, $34, $fc, $08
00A47C  2  5C 09 A2 61  
00A480  2  A6 61 B3 34  
00A488  2  0C 87 28 54    .byte $0c, $87, $28, $54, $59, $53, $9a, $30, $a9, $61, $b8, $62, $be, $0b, $d4, $60
00A48C  2  59 53 9A 30  
00A490  2  A9 61 B8 62  
00A498  2  D5 0D DE 0F    .byte $d5, $0d, $de, $0f, $0d, $ca, $7d, $47, $fd
00A49C  2  0D CA 7D 47  
00A4A0  2  FD           
00A4A1  2               
00A4A1  2               ;water area used by level 4-1
00A4A1  2               L_WaterArea3:
00A4A1  2  01 01 78 52    .byte $01, $01, $78, $52, $b5, $55, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81
00A4A5  2  B5 55 DA 60  
00A4A9  2  E9 61 F8 62  
00A4B1  2  0A CF 36 49    .byte $0a, $cf, $36, $49, $62, $43, $fe, $07, $36, $c9, $fe, $01, $0c, $84, $65, $55
00A4B5  2  62 43 FE 07  
00A4B9  2  36 C9 FE 01  
00A4C1  2  97 52 9A 32    .byte $97, $52, $9a, $32, $a9, $31, $b8, $30, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
00A4C5  2  A9 31 B8 30  
00A4C9  2  C7 63 CE 0F  
00A4D1  2  FD             .byte $fd
00A4D2  2               
00A4D2  2               ;water area used in level 8-4
00A4D2  2               L_WaterArea4:
00A4D2  2  07 0F 0E 02    .byte $07, $0f, $0e, $02, $39, $73, $05, $8e, $2e, $0b, $b7, $0e, $64, $8e, $6e, $02
00A4D6  2  39 73 05 8E  
00A4DA  2  2E 0B B7 0E  
00A4E2  2  CE 06 DE 0F    .byte $ce, $06, $de, $0f, $e6, $0d, $7d, $c7, $fd
00A4E6  2  E6 0D 7D C7  
00A4EA  2  FD           
00A4EB  2               
00A4EB  2               ;water area used in level 6-1
00A4EB  2               L_WaterArea5:
00A4EB  2  01 01 77 39    .byte $01, $01, $77, $39, $a3, $43, $00, $bf, $29, $51, $39, $48, $61, $55, $d6, $54
00A4EF  2  A3 43 00 BF  
00A4F3  2  29 51 39 48  
00A4FB  2  D2 44 0C 82    .byte $d2, $44, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32, $4a, $47, $97, $32
00A4FF  2  2E 02 31 66  
00A503  2  44 47 47 32  
00A50B  2  C1 66 CE 01    .byte $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f, $fe, $01, $27, $d3
00A50F  2  DC 02 FE 0E  
00A513  2  0C 8F 08 4F  
00A51B  2  5C 02 9A 60    .byte $5c, $02, $9a, $60, $a9, $61, $b8, $62, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
00A51F  2  A9 61 B8 62  
00A523  2  C7 63 CE 0F  
00A52B  2  FD             .byte $fd
00A52C  2               
00A52C  2               ;level 9-1 water area
00A52C  2               L_WaterArea6:
00A52C  2  00 A1 0A 60      .byte $00, $a1, $0a, $60, $19, $61, $28, $62, $39, $71, $58, $62, $69, $61, $7a, $60
00A530  2  19 61 28 62  
00A534  2  39 71 58 62  
00A53C  2  7C F5 A5 11      .byte $7c, $f5, $a5, $11, $fe, $20, $1f, $80, $5e, $21, $80, $3f, $8f, $65, $d6, $74
00A540  2  FE 20 1F 80  
00A544  2  5E 21 80 3F  
00A54C  2  5E A0 6F 66      .byte $5e, $a0, $6f, $66, $9e, $21, $c3, $37, $47, $f3, $9e, $20, $fe, $21, $0d, $06
00A550  2  9E 21 C3 37  
00A554  2  47 F3 9E 20  
00A55C  2  57 32 64 11      .byte $57, $32, $64, $11, $66, $10, $83, $a7, $87, $27, $0d, $09, $1d, $4a, $5f, $38
00A560  2  66 10 83 A7  
00A564  2  87 27 0D 09  
00A56C  2  6D C1 AF 26      .byte $6d, $c1, $af, $26, $6d, $c7, $fd
00A570  2  6D C7 FD     
00A573  2               
00A573  2               ;level 9-2
00A573  2               L_WaterArea7:
00A573  2  50 11 D7 73      .byte $50, $11, $d7, $73, $fe, $1a, $6f, $e2, $1f, $e5, $bf, $63, $c7, $a8, $df, $61
00A577  2  FE 1A 6F E2  
00A57B  2  1F E5 BF 63  
00A583  2  15 F1 7F 62      .byte $15, $f1, $7f, $62, $9b, $2f, $a8, $72, $fe, $10, $69, $f1, $b7, $25, $c5, $71
00A587  2  9B 2F A8 72  
00A58B  2  FE 10 69 F1  
00A593  2  33 AC 5F 71      .byte $33, $ac, $5f, $71, $8d, $4a, $aa, $14, $d1, $71, $17, $95, $26, $42, $72, $42
00A597  2  8D 4A AA 14  
00A59B  2  D1 71 17 95  
00A5A3  2  73 12 7A 14      .byte $73, $12, $7a, $14, $c6, $14, $d5, $42, $fe, $11, $7f, $b8, $8d, $c1, $cf, $26
00A5A7  2  C6 14 D5 42  
00A5AB  2  FE 11 7F B8  
00A5B3  2  6D C7 FD         .byte $6d, $c7, $fd
00A5B6  2               
00A5B6  2               ;level 9-4
00A5B6  2               L_WaterArea8:
00A5B6  2  57 00 0B 3F      .byte $57, $00, $0b, $3f, $0b, $bf, $0b, $bf, $73, $36, $9a, $30, $a5, $64, $b6, $31
00A5BA  2  0B BF 0B BF  
00A5BE  2  73 36 9A 30  
00A5C6  2  D4 61 0B BF      .byte $d4, $61, $0b, $bf, $13, $63, $4a, $60, $53, $66, $a5, $34, $b3, $67, $e5, $65
00A5CA  2  13 63 4A 60  
00A5CE  2  53 66 A5 34  
00A5D6  2  F4 60 0B BF      .byte $f4, $60, $0b, $bf, $14, $60, $53, $67, $67, $32, $c4, $62, $d4, $31, $f3, $61
00A5DA  2  14 60 53 67  
00A5DE  2  67 32 C4 62  
00A5E6  2  FA 60 0B BF      .byte $fa, $60, $0b, $bf, $04, $30, $09, $61, $14, $65, $63, $65, $6a, $60, $0b, $bf
00A5EA  2  04 30 09 61  
00A5EE  2  14 65 63 65  
00A5F6  2  0F 38 0B BF      .byte $0f, $38, $0b, $bf, $1d, $41, $3e, $42, $5f, $20, $ce, $40, $0b, $bf, $3d, $47
00A5FA  2  1D 41 3E 42  
00A5FE  2  5F 20 CE 40  
00A606  2  FD               .byte $fd
00A607  2               
00A607  2               ;level B-2
00A607  2               L_WaterArea9:
00A607  2  41 01 DA 60    .byte $41, $01, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81, $47, $d3, $8a, $60
00A60B  2  E9 61 F8 62  
00A60F  2  FE 0B FE 81  
00A617  2  99 61 A8 62    .byte $99, $61, $a8, $62, $b7, $63, $c6, $64, $d5, $65, $e4, $66, $ed, $49, $f3, $67
00A61B  2  B7 63 C6 64  
00A61F  2  D5 65 E4 66  
00A627  2  1A CB E3 67    .byte $1a, $cb, $e3, $67, $f3, $67, $fe, $02, $31, $d6, $3c, $02, $77, $53, $ac, $02
00A62B  2  F3 67 FE 02  
00A62F  2  31 D6 3C 02  
00A637  2  B1 56 E7 53    .byte $b1, $56, $e7, $53, $fe, $01, $77, $b9, $a3, $43, $00, $bf, $29, $51, $39, $48
00A63B  2  FE 01 77 B9  
00A63F  2  A3 43 00 BF  
00A647  2  61 55 D2 44    .byte $61, $55, $d2, $44, $d6, $54, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32
00A64B  2  D6 54 0C 82  
00A64F  2  2E 02 31 66  
00A657  2  4A 47 97 32    .byte $4a, $47, $97, $32, $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f
00A65B  2  C1 66 CE 01  
00A65F  2  DC 02 FE 0E  
00A667  2  FE 02 75 E0    .byte $fe, $02, $75, $e0, $fe, $01, $0c, $87, $9a, $60, $a9, $61, $b8, $62, $c7, $63
00A66B  2  FE 01 0C 87  
00A66F  2  9A 60 A9 61  
00A677  2  CE 0F D5 0D    .byte $ce, $0f, $d5, $0d, $6d, $ca, $7d, $47, $fd
00A67B  2  6D CA 7D 47  
00A67F  2  FD           
00A680  2               
00A680  2               ;-------------------------------------------------------------------------------------
00A680  2               
00A680  1  FF FF FF FF  .res $c000 - *, $ff
00A684  1  FF FF FF FF  
00A688  1  FF FF FF FF  
00C000  1               
00C000  1               .segment "SM2MAIN"
00C000  1               .export GL_ENTER
00C000  1               .export GetAreaDataAddrs
00C000  1               .export LoadAreaPointer
00C000  1               .export NMIHandler
00C000  1               .export IRQHandler
00C000  1               .export InitializeBG_CHR
00C000  1               .export InitializeSPR_CHR
00C000  1               
00C000  1               .import BANK_PractisePrintScore
00C000  1               .import BANK_PractiseEnterStage
00C000  1               .import BANK_PractiseWriteTopStatusLine
00C000  1               .import BANK_PractiseWriteBottomStatusLine
00C000  1               .import BANK_PractiseNMI
00C000  1               .import BANK_PractiseReset
00C000  1               .org $8000
008000  1               ;-------------------------------------------------------------------------------------
008000  1               
008000  1               Start:
008000  1  4C rr rr                 jmp BANK_PractiseReset
008003  1                           ;lda WorldNumber             ;get world number and save it temporarily
008003  1  48                       pha
008004  1  A0 FE                    ldy #ColdBootOffset         ;load default cold boot pointer
008006  1  A2 05                    ldx #$05
008008  1  BD D7 07     WBootCheck: lda TopScoreDisplay,x       ;first checkpoint, check each score digit
00800B  1  C9 0A                    cmp #10                     ;in the top score for a valid digit
00800D  1  B0 0C                    bcs ColdBoot                ;if even one digit isn't valid (greater than 10 decimal)
00800F  1  CA                       dex                         ;then branch to perform cold boot
008010  1  10 F6                    bpl WBootCheck
008012  1  AD FF 07                 lda WarmBootValidation      ;second checkpoint, check to see if
008015  1  C9 A5                    cmp #$a5                    ;another location has a specific value
008017  1  D0 02                    bne ColdBoot
008019  1  A0 D6                    ldy #WarmBootOffset         ;if passed both, load warm boot pointer
00801B  1  20 F3 8E     ColdBoot:   jsr InitializeMemory        ;clear memory using pointer in Y
00801E  1  8D 11 40                 sta SND_DELTA_REG+1
008021  1  8D 70 07                 sta OperMode                ;now manually reset some other stuff
008024  1  8D FC 07                 sta DiskIOTask
008027  1  68                       pla
008028  1  8D 5F 07                 sta WorldNumber
00802B  1  A9 A5                    lda #$a5                    ;set warm boot flag in case the player hits reset
00802D  1  8D FF 07                 sta WarmBootValidation
008030  1  8D A7 07                 sta PseudoRandomBitReg      ;set seed for pseudorandom register
008033  1               GL_ENTER:
008033  1  A9 0F                    lda #%00001111
008035  1  8D 15 40                 sta SND_MASTERCTRL_REG      ;enable all sound channels except dmc
008038  1  A9 06                    lda #%00000110
00803A  1  8D 01 20                 sta PPU_MASK                ;turn off clipping for OAM and background
00803D  1  20 30 82                 jsr MoveAllSpritesOffscreen
008040  1  20 7E 8C                 jsr InitializeNameTables
008043  1  EE 74 07                 inc DisableScreenFlag
008046  1  58                       cli
008047  1  AD 78 07                 lda Mirror_PPU_CTRL
00804A  1  09 80                    ora #%10000000
00804C  1  20 52 8D                 jsr WritePPUReg1
00804F  1               EndlessLoop:
00804F  1  A5 00                    lda $00                     ;endless loop
008051  1  4C 4F 80                 jmp EndlessLoop
008054  1               
008054  1               ;-------------------------------------------------------------------------------------
008054  1               
008054  1               VRAM_AddrTable:
008054  1  01 03 65 8B     .word VRAM_Buffer1, WaterPaletteData, GroundPaletteData, UndergroundPaletteData
008058  1  89 8B AD 8B  
00805C  1  D1 8B 8F E2     .word CastlePaletteData, TitleScreenGfxData, VRAM_Buffer2, VRAM_Buffer2
008060  1  41 03 41 03  
008064  1  0D 8C F5 8B     .word BowserPaletteData, DaySnowPaletteData, NightSnowPaletteData, MushroomPaletteData
008068  1  FD 8B 05 8C  
00806C  1  15 8C 29 8C     .word MarioThankYouMsg, LuigiThankYouMsg, MushroomRetainerMsg, FinalRoomPalette
008070  1  3D 8C C4 E7  
008074  1  D8 E7 08 E8     .word MarioThankYouMsgFinal, PeaceIsPavedMsg, WithKingdomSavedMsg, MarioHurrahMsg
008078  1  1E E8 34 E8  
00807C  1  5C E8 6D E8     .word OurOnlyHeroMsg, ThisEndsYourTripMsg, OfALongFriendshipMsg, PointsAddedMsg
008080  1  84 E8 9C E8  
008084  1  B4 E8 F0 E7     .word ForEachPlayerLeftMsg, LuigiThankYouMsgFinal, LuigiHurrahMsg, DiskScreenPalette
008088  1  48 E8 57 E0  
00808C  1  CD E8 EE E8     .word PrincessPeachsRoom, FantasyWorld9Msg, SuperPlayerMsg
008090  1  31 E9        
008092  1               
008092  1               VRAM_Buffer_Offset:
008092  1  00 40           .byte <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
008094  1               
008094  1               ;-------------------------------------------------------------------------------------
008094  1               
008094  1               NMIHandler:
008094  1  AD 78 07        lda Mirror_PPU_CTRL       ;alter name table address to be $2800
008097  1  29 7E           and #%01111110            ;(essentially $2000) and disable another NMI
008099  1  8D 78 07        sta Mirror_PPU_CTRL       ;from interrupting this one
00809C  1  8D 00 20        sta PPU_CTRL
00809F  1  78              sei
0080A0  1  AD 79 07        lda Mirror_PPU_MASK
0080A3  1  29 E6           and #%11100110            ;disable OAM and background display by default
0080A5  1  AC 74 07        ldy DisableScreenFlag     ;if screen disabled, skip this
0080A8  1  D0 05           bne ScrnSwch
0080AA  1  AD 79 07        lda Mirror_PPU_MASK       ;otherwise reenable bits and save them
0080AD  1  09 1E           ora #%00011110
0080AF  1               ScrnSwch:
0080AF  1  8D 79 07        sta Mirror_PPU_MASK
0080B2  1  29 E7           and #%11100111            ;turn screen off regardless of mirror reg
0080B4  1  8D 01 20        sta PPU_MASK
0080B7  1  AE 02 20        ldx PPU_STATUS
0080BA  1  A9 00           lda #$00
0080BC  1  20 4B 8D        jsr InitScroll
0080BF  1  8D 03 20        sta PPU_SPR_ADDR
0080C2  1  A9 02           lda #$02                  ;dump OAM data to PPU's sprite RAM
0080C4  1  8D 14 40        sta SPR_DMA
0080C7  1  AD 73 07        lda VRAM_Buffer_AddrCtrl
0080CA  1  0A              asl
0080CB  1  AA              tax
0080CC  1  BD 54 80        lda VRAM_AddrTable,x      ;get pointer to VRAM data
0080CF  1  85 00           sta $00
0080D1  1  E8              inx
0080D2  1  BD 54 80        lda VRAM_AddrTable,x
0080D5  1  85 01           sta $01
0080D7  1  20 42 8D        jsr UpdateScreen          ;now update the screen with it
0080DA  1  A0 00           ldy #$00
0080DC  1  AE 73 07        ldx VRAM_Buffer_AddrCtrl
0080DF  1  E0 06           cpx #$06                  ;if pointer number was set to 6 (for
0080E1  1  D0 01           bne InitVRAMVars          ;second VRAM buffer), increment Y to get
0080E3  1  C8              iny                       ;offset for second VRAM buffer
0080E4  1               InitVRAMVars:
0080E4  1  BE 92 80        ldx VRAM_Buffer_Offset,y  ;get pointer to correct buffer offset
0080E7  1  A9 00           lda #$00                  ;erase the VRAM buffer offset, init first VRAM buffer
0080E9  1  9D 00 03        sta VRAM_Buffer1_Offset,x ;by writing end terminator at the first byte, and
0080EC  1  9D 01 03        sta VRAM_Buffer1,x        ;init address control to point at first VRAM buffer
0080EF  1  8D 73 07        sta VRAM_Buffer_AddrCtrl
0080F2  1  AD 79 07        lda Mirror_PPU_MASK
0080F5  1  8D 01 20        sta PPU_MASK              ;dump PPU control register 2
0080F8  1  58              cli
0080F9  1  AD 22 07        lda IRQUpdateFlag
0080FC  1  F0 0E           beq SkipIRQ
0080FE  1  A9 1F           lda #31                   ;count 31 scanlines (plus the pre-render scanline)
008100  1  8D 00 C0        sta MMC3_IRQLatch
008103  1  8D 01 C0        sta MMC3_IRQReload
008106  1  8D 01 E0        sta MMC3_IRQEnable
008109  1  EE 7B 07        inc IRQAckFlag            ;reset flag to wait for next IRQ
00810C  1               SkipIRQ:
00810C  1  20 19 FF        jsr RunSoundEngine        ;run subs that need to be run on every frame
00810F  1  20 C1 8C        jsr ReadJoypads
008112  1  20 92 81        jsr PauseRoutine
008115  1  20 rr rr        jsr BANK_PractiseNMI
008118  1                  ;REPLACED;jsr UpdateTopScore
008118  1  AD 76 07        lda GamePauseStatus       ;check d0 of game pause flags
00811B  1  4A              lsr                       ;if set, branch to skip
00811C  1  B0 25           bcs SeedLFSR
00811E  1  AD 47 07        lda TimerControl          ;if master timer control not set, branch
008121  1  F0 05           beq CheckIntervalTC       ;to decrement frame and interval timers
008123  1  CE 47 07        dec TimerControl          ;otherwise count this timer down
008126  1  D0 19           bne IncFrameCntr
008128  1               CheckIntervalTC:
008128  1  A2 14           ldx #$14                  ;set offset to decrement only frame timers
00812A  1  CE 7F 07        dec IntervalTimerControl  ;if interval timer control not expired, branch
00812D  1  10 07           bpl DecrTheTimers         ;to skip and thus decrement only frame timers
00812F  1  A9 14           lda #$14
008131  1  8D 7F 07        sta IntervalTimerControl  ;otherwise reset interval timer control to 20 frames
008134  1  A2 23           ldx #$23                  ;and load offset to decrement frame and interval timers
008136  1               DecrTheTimers:
008136  1  BD 80 07        lda Timers,x              ;if current timer is already expired, skip it
008139  1  F0 03           beq DTTLoop               ;otherwise decrement it
00813B  1  DE 80 07        dec Timers,x
00813E  1               DTTLoop:
00813E  1  CA              dex                       ;loop until all timers that need to be counted down are
00813F  1  10 F5           bpl DecrTheTimers
008141  1               IncFrameCntr:
008141  1  E6 09           inc FrameCounter
008143  1               SeedLFSR:
008143  1  A2 00           ldx #$00
008145  1  A0 07           ldy #$07
008147  1  AD A7 07        lda PseudoRandomBitReg    ;get d1 of first byte
00814A  1  29 02           and #$02
00814C  1  85 00           sta $00
00814E  1  AD A8 07        lda PseudoRandomBitReg+1  ;get d1 of second byte, XOR it with the first byte
008151  1  29 02           and #$02
008153  1  45 00           eor $00
008155  1  18              clc
008156  1  F0 01           beq RotateLFSR            ;prepare to rotate the result in
008158  1  38              sec
008159  1               RotateLFSR:
008159  1  7E A7 07        ror PseudoRandomBitReg,x  ;basically, rotate the operation result into d7
00815C  1  E8              inx                       ;then rotate the entire LFSR
00815D  1  88              dey
00815E  1  D0 F9           bne RotateLFSR
008160  1  AD 76 07        lda GamePauseStatus       ;if d0 of game pause flag is set, skip this part
008163  1  4A              lsr
008164  1  B0 18           bcs WaitForIRQ
008166  1  AD 22 07        lda IRQUpdateFlag
008169  1  F0 06           beq CheckInvalidWorldNum
00816B  1  20 33 82        jsr MoveSpritesOffscreen
00816E  1  20 D6 81        jsr SpriteShuffler
008171  1               CheckInvalidWorldNum:
008171  1  AD 5F 07        lda WorldNumber           ;if world number somehow goes past 9, just end the game
008174  1  C9 09           cmp #$09
008176  1  90 03           bcc ExecutionTree
008178  1  20 88 90        jsr TerminateGame
00817B  1               ExecutionTree:
00817B  1  20 22 82        jsr OperModeExecutionTree ;run one of the program's four modes
00817E  1               WaitForIRQ:
00817E  1  AD 7B 07        lda IRQAckFlag            ;wait for IRQ
008181  1  D0 FB           bne WaitForIRQ
008183  1  AD 02 20        lda PPU_STATUS
008186  1  AD 78 07        lda Mirror_PPU_CTRL       ;reenable NMIs
008189  1  09 80           ora #$80
00818B  1  8D 78 07        sta Mirror_PPU_CTRL       ;then park it at endless loop until next NMI
00818E  1  8D 00 20        sta PPU_CTRL
008191  1  40              rti
008192  1               
008192  1               ;-------------------------------------------------------------------------------------
008192  1               
008192  1               PauseRoutine:
008192  1  AD 70 07                    lda OperMode           ;are we in victory mode?
008195  1  C9 02                       cmp #VictoryMode       ;if so, go ahead
008197  1  F0 0B                       beq ChkPauseTimer
008199  1  C9 01                       cmp #GameMode          ;are we in game mode?
00819B  1  D0 38                       bne ExitPause          ;if not, leave
00819D  1  AD 72 07                    lda OperMode_Task      ;if we are in game mode, are we running game engine?
0081A0  1  C9 04                       cmp #$04
0081A2  1  D0 31                       bne ExitPause          ;if not, leave
0081A4  1  AD 77 07     ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
0081A7  1  F0 04                       beq ChkStart
0081A9  1  CE 77 07                    dec GamePauseTimer     ;if so, decrement and leave
0081AC  1  60                          rts
0081AD  1  AD FC 06     ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
0081B0  1  29 10                       and #Start_Button
0081B2  1  F0 19                       beq ClrPauseTimer
0081B4  1  AD 76 07                    lda GamePauseStatus    ;check to see if timer flag is set
0081B7  1  29 80                       and #%10000000         ;and if so, do not reset timer (residual,
0081B9  1  D0 1A                       bne ExitPause          ;joypad reading routine makes this unnecessary)
0081BB  1  A9 2B                       lda #$2b               ;set pause timer
0081BD  1  8D 77 07                    sta GamePauseTimer
0081C0  1  AD 76 07                    lda GamePauseStatus
0081C3  1  A8                          tay
0081C4  1  C8                          iny                    ;set pause sfx queue for next pause mode
0081C5  1  84 FA                       sty PauseSoundQueue
0081C7  1  49 01                       eor #%00000001         ;invert d0 and set d7
0081C9  1  09 80                       ora #%10000000
0081CB  1  D0 05                       bne SetPause           ;unconditional branch
0081CD  1  AD 76 07     ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
0081D0  1  29 7F                       and #%01111111         ;is not pressed
0081D2  1  8D 76 07     SetPause:      sta GamePauseStatus
0081D5  1  60           ExitPause:     rts
0081D6  1               
0081D6  1               
0081D6  1               ;-------------------------------------------------------------------------------------
0081D6  1               ;$00 - used for preset value
0081D6  1               
0081D6  1               SpriteShuffler:
0081D6  1  AC 4E 07                    ldy AreaType                ;residual code, this value is never used
0081D9  1  A9 28                       lda #$28                    ;load preset value which will put it at
0081DB  1  85 00                       sta $00                     ;sprite #10
0081DD  1  A2 0E                       ldx #$0e                    ;start at the end of OAM data offsets
0081DF  1  BD E4 06     ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
0081E2  1  C5 00                       cmp $00                     ;the preset value
0081E4  1  90 0F                       bcc NextSprOffset           ;if less, skip this part
0081E6  1  AC E0 06                    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
0081E9  1  18                          clc
0081EA  1  79 E1 06                    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
0081ED  1  90 03                       bcc StrSprOffset            ;if not exceeded $ff, skip second add
0081EF  1  18                          clc
0081F0  1  65 00                       adc $00                     ;otherwise add preset value $28 to offset
0081F2  1  9D E4 06     StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
0081F5  1  CA           NextSprOffset: dex                         ;move backwards to next one
0081F6  1  10 E7                       bpl ShuffleLoop
0081F8  1  AE E0 06                    ldx SprShuffleAmtOffset     ;load offset
0081FB  1  E8                          inx
0081FC  1  E0 03                       cpx #$03                    ;check if offset + 1 goes to 3
0081FE  1  D0 02                       bne SetAmtOffset            ;if offset + 1 not 3, store
008200  1  A2 00                       ldx #$00                    ;otherwise, init to 0
008202  1  8E E0 06     SetAmtOffset:  stx SprShuffleAmtOffset
008205  1  A2 08                       ldx #$08                    ;load offsets for values and storage
008207  1  A0 02                       ldy #$02
008209  1  B9 E9 06     SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
00820C  1  9D F1 06                    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
00820F  1  18                          clc                         ;add eight to the second and eight
008210  1  69 08                       adc #$08                    ;more to the third one
008212  1  9D F2 06                    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
008215  1  18                          clc                         ;this code loads into the misc sprite offsets
008216  1  69 08                       adc #$08
008218  1  9D F3 06                    sta Misc_SprDataOffset,x
00821B  1  CA                          dex
00821C  1  CA                          dex
00821D  1  CA                          dex
00821E  1  88                          dey
00821F  1  10 E8                       bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
008221  1  60                          rts
008222  1               
008222  1               ;-------------------------------------------------------------------------------------
008222  1               
008222  1               OperModeExecutionTree:
008222  1  AD 70 07           lda OperMode     ;this is the heart of the entire program,
008225  1  20 69 8C           jsr JumpEngine   ;most of what goes on starts here
008228  1               
008228  1  94 DF              .word AttractModeSubs
00822A  1  32 9A              .word GameModeSubs
00822C  1  41 82              .word VictoryModeMain
00822E  1  52 90              .word GameOverSubs
008230  1               
008230  1               ;-------------------------------------------------------------------------------------
008230  1               
008230  1               MoveAllSpritesOffscreen:
008230  1  A0 00                      ldy #$00                ;this routine moves all sprites off the screen
008232  1  2C                         .byte $2c                 ;BIT instruction opcode
008233  1               
008233  1               MoveSpritesOffscreen:
008233  1  A0 04                      ldy #$04                ;this routine moves all but sprite 0
008235  1  A9 F8                      lda #$f8                ;off the screen
008237  1  99 00 02     SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
00823A  1  C8                         iny                     ;which will move it off the screen
00823B  1  C8                         iny
00823C  1  C8                         iny
00823D  1  C8                         iny
00823E  1  D0 F7                      bne SprInitLoop
008240  1  60           VMExit:       rts
008241  1               
008241  1               ;-------------------------------------------------------------------------------------
008241  1               
008241  1               VictoryModeMain:
008241  1  20 65 82               jsr VictoryModeSubroutines ;run victory mode subroutines in order
008244  1  AD 72 07               lda OperMode_Task          ;if running bridge collapse subroutine
008247  1  F0 16                  beq BrdgSkip               ;then skip most of this
008249  1  AE 5F 07               ldx WorldNumber
00824C  1  E0 07                  cpx #World8                ;if not on world 8, skip, don't bother checking
00824E  1  D0 08                  bne NotW8                  ;to see which subroutine we're on
008250  1  C9 05                  cmp #$05
008252  1  F0 EC                  beq VMExit                 ;if running disk subroutines, branch to leave
008254  1  C9 0D                  cmp #$0d                   ;because the screen will be blank during this
008256  1  F0 E8                  beq VMExit
008258  1  A2 00        NotW8:    ldx #$00
00825A  1  86 08                  stx ObjectOffset           ;run code for a single enemy object
00825C  1  20 43 AC               jsr EnemiesAndLoopsCore    ;(either the mushroom retainer or door/princess)
00825F  1  20 F4 DD     BrdgSkip: jsr RelativePlayerPosition ;draw the player as usual
008262  1  4C A9 DB               jmp PlayerGfxHandler
008265  1               
008265  1               VictoryModeSubroutines:
008265  1  AD 5F 07         lda WorldNumber               ;run different list of subroutines if on world 8
008268  1  C9 07            cmp #World8
00826A  1  F0 12            beq VictoryModeSubsForW8      ;note that world D will also run second set of subs
00826C  1  AD 72 07         lda OperMode_Task             ;after running the first two subs in the first set
00826F  1  20 69 8C         jsr JumpEngine
008272  1               
008272  1  1D BC            .word BridgeCollapse
008274  1  A8 82            .word SetupVictoryMode
008276  1  DD 82            .word PlayerVictoryWalk
008278  1  16 83            .word PrintVictoryMessages
00827A  1  61 83            .word EndCastleAward
00827C  1  84 83            .word EndWorld1Thru7
00827E  1               
00827E  1               VictoryModeSubsForW8:
00827E  1  AD 72 07         lda OperMode_Task
008281  1  20 69 8C         jsr JumpEngine
008284  1               
008284  1  1D BC            .word BridgeCollapse
008286  1  A8 82            .word SetupVictoryMode
008288  1  DD 82            .word PlayerVictoryWalk
00828A  1  31 E0            .word StartVMDelay
00828C  1  38 E0            .word ContinueVMDelay
00828E  1  3E E0            .word VictoryModeDiskRoutines
008290  1  96 E5            .word ScreenSubsForFinalRoom    ;all these subs are in SM2DATA3
008292  1  D2 E5            .word PrintVictoryMsgsForWorld8
008294  1  61 83            .word EndCastleAward            ;except this one
008296  1  1F E6            .word AwardExtraLives
008298  1  63 E6            .word FadeToBlue
00829A  1  A9 E6            .word EraseLivesLines
00829C  1  C0 E6            .word RunMushroomRetainers
00829E  1  D1 E6            .word EndingDiskRoutines
0082A0  1               
0082A0  1               ;-------------------------------------------------------------------------------------
0082A0  1               
0082A0  1               WorldBits:
0082A0  1  01 02 04 08      .byte $01, $02, $04, $08, $10, $20, $40, $80
0082A4  1  10 20 40 80  
0082A8  1               
0082A8  1               SetupVictoryMode:
0082A8  1  AE 1B 07              ldx ScreenRight_PageLoc ;get page location of right side of screen
0082AB  1  E8                    inx                     ;increment to next page
0082AC  1  86 34                 stx DestinationPageLoc
0082AE  1  AC 5F 07              ldy WorldNumber
0082B1  1  B9 A0 82              lda WorldBits,y
0082B4  1  0D FA 07              ora CompletedWorlds     ;set bit according to the world the player was in
0082B7  1  8D FA 07              sta CompletedWorlds
0082BA  1  AD FB 07              lda HardWorldFlag       ;if not playing worlds A-D, branch to skip this
0082BD  1  F0 0C                 beq W1Thru8
0082BF  1  AD 5F 07              lda WorldNumber         ;otherwise, if not on world D, branch to skip this
0082C2  1  C9 03                 cmp #World4             ;(note worlds A-D use values 0-3 in this variable)
0082C4  1  90 05                 bcc W1Thru8
0082C6  1  A9 07                 lda #World8             ;if on world D, set world number to 8 to satisfy
0082C8  1  8D 5F 07              sta WorldNumber         ;end of game condition in later victory mode subs
0082CB  1  A9 08        W1Thru8: lda #EndOfCastleMusic
0082CD  1  85 FC                 sta EventMusicQueue     ;play win castle music
0082CF  1               
0082CF  1               IncModeTask:
0082CF  1  EE 72 07         inc OperMode_Task
0082D2  1  60               rts
0082D3  1               
0082D3  1               ;-------------------------------------------------------------------------------------
0082D3  1               
0082D3  1               DrawTitleScreen:
0082D3  1  AD 70 07         lda OperMode       ;if not in attract mode, do not draw title screen
0082D6  1  D0 F7            bne IncModeTask    ;yes, this routine is run in other modes
0082D8  1  A9 05            lda #$05
0082DA  1  4C 5E 85         jmp SetVRAMAddr_B  ;otherwise set up VRAM address controller accordingly
0082DD  1               
0082DD  1               ;-------------------------------------------------------------------------------------
0082DD  1               
0082DD  1               PlayerVictoryWalk:
0082DD  1  A0 00                     ldy #$00                ;set value here to not walk player by default
0082DF  1  84 35                     sty VictoryWalkControl
0082E1  1  A5 6D                     lda Player_PageLoc      ;get player's page location
0082E3  1  C5 34                     cmp DestinationPageLoc  ;compare with destination page location
0082E5  1  D0 06                     bne PerformWalk         ;if page locations don't match, branch
0082E7  1  A5 86                     lda Player_X_Position   ;otherwise get player's horizontal position
0082E9  1  C9 60                     cmp #$60                ;compare with preset horizontal position
0082EB  1  B0 03                     bcs DontWalk            ;if still on other page, branch ahead
0082ED  1  E6 35        PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
0082EF  1  C8                        iny                     ;note Y will be used to walk the player
0082F0  1  98           DontWalk:    tya                     ;put contents of Y in A and
0082F1  1  20 39 9C                  jsr AutoControlPlayer   ;use A to move player to the right or not
0082F4  1  AD 1A 07                  lda ScreenLeft_PageLoc  ;check page location of left side of screen
0082F7  1  C5 34                     cmp DestinationPageLoc  ;against set value here
0082F9  1  F0 16                     beq ExitVWalk           ;branch if equal to change modes if necessary
0082FB  1  AD 68 07                  lda ScrollFractional
0082FE  1  18                        clc                     ;do fixed point math on fractional part of scroll
0082FF  1  69 80                     adc #$80
008301  1  8D 68 07                  sta ScrollFractional    ;save fractional movement amount
008304  1  A9 01                     lda #$01                ;set 1 pixel per frame
008306  1  69 00                     adc #$00                ;add carry from previous addition
008308  1  A8                        tay                     ;use as scroll amount
008309  1  20 1B 9B                  jsr ScrollScreen        ;do sub to scroll the screen
00830C  1  20 C6 9A                  jsr UpdScrollVar        ;do another sub to update screen and scroll variables
00830F  1  E6 35                     inc VictoryWalkControl  ;increment value to stay in this routine
008311  1  A5 35        ExitVWalk:   lda VictoryWalkControl  ;load value set here
008313  1  F0 48                     beq IncModeTask_A       ;if zero, branch to change modes
008315  1  60                        rts                     ;otherwise leave
008316  1               
008316  1               PrintVictoryMessages:
008316  1  AD 49 07                    lda MsgFractional        ;load message counter fractional
008319  1  D0 28                       bne IncMsgCounter        ;if not yet wrapped, branch to increment it
00831B  1  AD 19 07                    lda MsgCounter           ;otherwise load message counter
00831E  1  F0 08                       beq ThankPlayer          ;if set to zero, branch to print first message
008320  1  C9 08                       cmp #$08                 ;if at 8 or above, branch elsewhere
008322  1  B0 1F                       bcs IncMsgCounter
008324  1  C9 01                       cmp #$01                 ;if at zero, branch (note, this branch is never
008326  1  90 1B                       bcc IncMsgCounter        ;taken because we already branched at zero earlier)
008328  1  A8           ThankPlayer:   tay
008329  1  F0 0B                       beq ChkPlayer
00832B  1  C0 03                       cpy #$03
00832D  1  B0 27                       bcs SetEndTimer          ;wait until a specific point to set the timer
00832F  1  C0 02                       cpy #$02
008331  1  B0 10                       bcs IncMsgCounter        ;skip printing of messages after the first two
008333  1  C8                          iny                      ;increment Y for second messsage
008334  1  D0 06                       bne PrintMsgs            ;unconditional branch
008336  1  AD 53 07     ChkPlayer:     lda SelectedPlayer       ;get selected player
008339  1  F0 01                       beq PrintMsgs            ;if mario, branch
00833B  1  C8                          iny                      ;otherwise increment Y once for luigi
00833C  1  98           PrintMsgs:     tya                      ;put primary message counter in A
00833D  1  18                          clc                      ;add 12 to counter, thus giving an appropriate value
00833E  1  69 0C                       adc #$0c
008340  1  8D 73 07                    sta VRAM_Buffer_AddrCtrl ;write message counter to vram address controller
008343  1  AD 49 07     IncMsgCounter: lda MsgFractional
008346  1  18                          clc
008347  1  69 04                       adc #$04                 ;add four to fractional
008349  1  8D 49 07                    sta MsgFractional
00834C  1  AD 19 07                    lda MsgCounter
00834F  1  69 00                       adc #$00                 ;carry the one if fractional wraps
008351  1  8D 19 07                    sta MsgCounter
008354  1  C9 06                       cmp #$06                 ;check message counter one more time
008356  1  90 08        SetEndTimer:   bcc ExitMsgs             ;if not reached 6 yet, branch to leave
008358  1  A9 08                       lda #$08
00835A  1  8D A1 07                    sta WorldEndTimer        ;otherwise set world end timer
00835D  1  EE 72 07     IncModeTask_A: inc OperMode_Task        ;move onto next task in mode
008360  1  60           ExitMsgs:      rts
008361  1               
008361  1               EndCastleAward:
008361  1  AD A1 07        lda WorldEndTimer      ;if world end timer has not yet reached a certain point
008364  1  C9 06           cmp #$06               ;then go ahead and skip all of this
008366  1  B0 1B           bcs ExEWA
008368  1  20 3B BF        jsr AwardTimerCastle
00836B  1  AD EC 07        lda GameTimerDisplay   ;if game timer points not all awarded, skip this part
00836E  1  0D ED 07        ora GameTimerDisplay+1
008371  1  0D EE 07        ora GameTimerDisplay+2
008374  1  D0 0D           bne ExEWA
008376  1  A9 30           lda #$30
008378  1  8D 80 07        sta SelectTimer        ;set select timer (used for world 8 ending only)
00837B  1  A9 06           lda #$06
00837D  1  8D A1 07        sta WorldEndTimer      ;another short delay, then on to the next task
008380  1  EE 72 07        inc OperMode_Task
008383  1               ExEWA:
008383  1  60              rts
008384  1               
008384  1               .export EndWorld1Thru7
008384  1               EndWorld1Thru7:
008384  1  AD A1 07                lda WorldEndTimer         ;skip this until world end timer expires
008387  1  D0 25                   bne EndExit
008389  1  A9 00        NextWorld: lda #$00
00838B  1  8D 60 07                sta AreaNumber            ;reset area/level numbers to start the next world
00838E  1  8D 5C 07                sta LevelNumber
008391  1  8D 72 07                sta OperMode_Task
008394  1  AD 5F 07                lda WorldNumber
008397  1  18                      clc
008398  1  69 01                   adc #$01                  ;add one, but only up to world 9
00839A  1  C9 08                   cmp #World9
00839C  1  90 02                   bcc NoPast9
00839E  1  A9 08                   lda #World9               ;make world 9 loop forever (or until game is over)
0083A0  1  8D 5F 07     NoPast9:   sta WorldNumber           ;update the world number
0083A3  1  20 29 FF                jsr RunLoadAreaPointer    ;get pointer for the next area
0083A6  1  EE 57 07                inc FetchNewGameTimerFlag ;and get a new game timer
0083A9  1  A9 01                   lda #$01
0083AB  1  8D 70 07                sta OperMode              ;and oh yeah, go back to game mode also
0083AE  1  60           EndExit:   rts
0083AF  1               
0083AF  1               ;-------------------------------------------------------------------------------------
0083AF  1               
0083AF  1               ;data is used as tiles for numbers
0083AF  1               ;that appear when you defeat enemies
0083AF  1               FloateyNumTileData:
0083AF  1  FF FF              .byte $ff, $ff ;dummy
0083B1  1  F6 FB              .byte $f6, $fb ; "100"
0083B3  1  F7 FB              .byte $f7, $fb ; "200"
0083B5  1  F8 FB              .byte $f8, $fb ; "400"
0083B7  1  F9 FB              .byte $f9, $fb ; "500"
0083B9  1  FA FB              .byte $fa, $fb ; "800"
0083BB  1  F6 50              .byte $f6, $50 ; "1000"
0083BD  1  F7 50              .byte $f7, $50 ; "2000"
0083BF  1  F8 50              .byte $f8, $50 ; "4000"
0083C1  1  F9 50              .byte $f9, $50 ; "5000"
0083C3  1  FA 50              .byte $fa, $50 ; "8000"
0083C5  1  FD FE              .byte $fd, $fe ; "1-UP"
0083C7  1               
0083C7  1               ;high nybble is digit number, low nybble is number to
0083C7  1               ;add to the digit of the player's score
0083C7  1               ScoreUpdateData:
0083C7  1  FF                 .byte $ff ;dummy
0083C8  1  41 42 44 45        .byte $41, $42, $44, $45, $48
0083CC  1  48           
0083CD  1  31 32 34 35        .byte $31, $32, $34, $35, $38, $00
0083D1  1  38 00        
0083D3  1               
0083D3  1               FloateyNumbersRoutine:
0083D3  1  BD 10 01                   lda FloateyNum_Control,x     ;load control for floatey number
0083D6  1  F0 D6                      beq EndExit                  ;if zero, branch to leave
0083D8  1  C9 0B                      cmp #$0b                     ;if less than $0b, branch
0083DA  1  90 05                      bcc ChkNumTimer
0083DC  1  A9 0B                      lda #$0b                     ;otherwise set to $0b, thus keeping
0083DE  1  9D 10 01                   sta FloateyNum_Control,x     ;it in range
0083E1  1  A8           ChkNumTimer:  tay                          ;use as Y
0083E2  1  BD 2C 01                   lda FloateyNum_Timer,x       ;check value here
0083E5  1  D0 04                      bne DecNumTimer              ;if nonzero, branch ahead
0083E7  1  9D 10 01                   sta FloateyNum_Control,x     ;initialize floatey number control and leave
0083EA  1  60                         rts
0083EB  1  DE 2C 01     DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
0083EE  1  C9 2B                      cmp #$2b                     ;if not reached a certain point, branch
0083F0  1  D0 1E                      bne ChkTallEnemy
0083F2  1  C0 0B                      cpy #$0b                     ;check offset for $0b
0083F4  1  D0 07                      bne LoadNumTiles             ;branch ahead if not found
0083F6  1  EE 5A 07                   inc NumberofLives            ;give player one extra life (1-up)
0083F9  1  A9 40                      lda #Sfx_ExtraLife
0083FB  1  85 FE                      sta Square2SoundQueue        ;and play the 1-up sound
0083FD  1  B9 C7 83     LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
008400  1  4A                         lsr                          ;move high nybble to low
008401  1  4A                         lsr
008402  1  4A                         lsr
008403  1  4A                         lsr
008404  1  AA                         tax                          ;use as X offset, essentially the digit
008405  1  B9 C7 83                   lda ScoreUpdateData,y        ;load again and this time
008408  1  29 0F                      and #%00001111               ;mask out the high nybble
00840A  1  9D 34 01                   sta DigitModifier,x          ;store as amount to add to the digit
00840D  1  20 13 A8                   jsr AddToScore               ;update the score accordingly
008410  1  BC E5 06     ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
008413  1  B5 16                      lda Enemy_ID,x               ;get enemy object identifier
008415  1  C9 12                      cmp #Spiny
008417  1  F0 22                      beq FloateyPart              ;branch if spiny
008419  1  C9 0D                      cmp #PiranhaPlant
00841B  1  F0 1E                      beq FloateyPart              ;branch if piranha plant
00841D  1  C9 05                      cmp #HammerBro
00841F  1  F0 12                      beq GetAltOffset             ;branch elsewhere if hammer bro
008421  1  C9 0A                      cmp #GreyCheepCheep
008423  1  F0 16                      beq FloateyPart              ;branch if cheep-cheep of either color
008425  1  C9 0B                      cmp #RedCheepCheep
008427  1  F0 12                      beq FloateyPart
008429  1  C9 09                      cmp #TallEnemy
00842B  1  B0 06                      bcs GetAltOffset             ;branch elsewhere if enemy object => $09
00842D  1  B5 1E                      lda Enemy_State,x
00842F  1  C9 02                      cmp #$02                     ;if enemy state defeated or otherwise
008431  1  B0 08                      bcs FloateyPart              ;$02 or greater, branch beyond this part
008433  1  AE EE 03     GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
008436  1  BC EC 06                   ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
008439  1  A6 08                      ldx ObjectOffset             ;get enemy object offset again
00843B  1  BD 1E 01     FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
00843E  1  C9 18                      cmp #$18                     ;floatey number, if coordinate in the
008440  1  90 05                      bcc SetupNumSpr              ;status bar, branch
008442  1  E9 01                      sbc #$01
008444  1  9D 1E 01                   sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
008447  1  BD 1E 01     SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
00844A  1  E9 08                      sbc #$08                     ;subtract eight and dump into the
00844C  1  20 43 D2                   jsr DumpTwoSpr               ;left and right sprite's Y coordinates
00844F  1  BD 17 01                   lda FloateyNum_X_Pos,x       ;get horizontal coordinate
008452  1  99 03 02                   sta Sprite_X_Position,y      ;store into X coordinate of left sprite
008455  1  18                         clc
008456  1  69 08                      adc #$08                     ;add eight pixels and store into X
008458  1  99 07 02                   sta Sprite_X_Position+4,y    ;coordinate of right sprite
00845B  1  A9 02                      lda #$02
00845D  1  99 02 02                   sta Sprite_Attributes,y      ;set palette control in attribute bytes
008460  1  99 06 02                   sta Sprite_Attributes+4,y    ;of left and right sprites
008463  1  BD 10 01                   lda FloateyNum_Control,x
008466  1  0A                         asl                          ;multiply our floatey number control by 2
008467  1  AA                         tax                          ;and use as offset for look-up table
008468  1  BD AF 83                   lda FloateyNumTileData,x
00846B  1  99 01 02                   sta Sprite_Tilenumber,y      ;display first half of number of points
00846E  1  BD B0 83                   lda FloateyNumTileData+1,x
008471  1  99 05 02                   sta Sprite_Tilenumber+4,y    ;display the second half
008474  1  A6 08                      ldx ObjectOffset             ;get enemy object offset and leave
008476  1  60                         rts
008477  1               
008477  1               ;-------------------------------------------------------------------------------------
008477  1               
008477  1               ScreenRoutines:
008477  1  AD 3C 07        lda ScreenRoutineTask
00847A  1  20 69 8C        jsr JumpEngine
00847D  1               
00847D  1  9D 84           .word InitScreen
00847F  1  AD 84           .word SetupIntermediate
008481  1  rr rr           .word BANK_PractiseWriteTopStatusLine
008483  1  rr rr           .word BANK_PractiseWriteBottomStatusLine
008485  1                  ;REPLACED;.word WriteTopStatusLine
008485  1                  ;REPLACED;.word WriteBottomStatusLine
008485  1  B5 85           .word DisplayTimeUp
008487  1  52 87           .word ResetSpritesAndScreenTimer
008489  1  D4 85           .word DisplayIntermediate
00848B  1  61 E5           .word PrintWorld9Msgs
00848D  1  52 87           .word ResetSpritesAndScreenTimer
00848F  1  1B 86           .word AreaParserTaskControl
008491  1  D1 84           .word GetAreaPalette
008493  1  F5 84           .word GetBackgroundColor
008495  1  55 85           .word GetAlternatePalette1
008497  1  D3 82           .word DrawTitleScreen
008499  1  F0 E1           .word ClearBuffersDrawIcon
00849B  1  54 E2           .word WriteTopScore
00849D  1               
00849D  1               InitScreen:
00849D  1  20 30 82           jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
0084A0  1  20 7E 8C           jsr InitializeNameTables    ;and erase both name and attribute tables
0084A3  1  AD 70 07           lda OperMode
0084A6  1  F0 32              beq NextSubtask             ;if in attact mode, do not set pointer control
0084A8  1               InitScreenPalette:
0084A8  1  A2 03              ldx #$03                    ;otherwise set for underground palette
0084AA  1  4C D7 84           jmp SetVRAMAddr_A
0084AD  1               
0084AD  1               SetupIntermediate:
0084AD  1  AD 44 07           lda BackgroundColorCtrl  ;save current background color control
0084B0  1  48                 pha                      ;and player status to stack
0084B1  1  AD 56 07           lda PlayerStatus
0084B4  1  48                 pha
0084B5  1  A9 00              lda #$00                 ;set background color to black
0084B7  1  8D 56 07           sta PlayerStatus         ;and player status to not fiery
0084BA  1  A9 02              lda #$02                 ;this is the ONLY time background color control
0084BC  1  8D 44 07           sta BackgroundColorCtrl  ;is set to less than 4
0084BF  1  20 03 85           jsr GetPlayerColors
0084C2  1  68                 pla                      ;set up colors for intermediate lives display
0084C3  1  8D 56 07           sta PlayerStatus
0084C6  1  68                 pla                      ;return bg color control and player status
0084C7  1  8D 44 07           sta BackgroundColorCtrl
0084CA  1  4C D0 85           jmp IncSubtask           ;then move onto the next task
0084CD  1               
0084CD  1               AreaPalette:
0084CD  1  01 02 03 04        .byte $01, $02, $03, $04
0084D1  1               
0084D1  1               GetAreaPalette:
0084D1  1  AC 4E 07                    ldy AreaType             ;select appropriate palette to load
0084D4  1  BE CD 84                    ldx AreaPalette,y        ;based on area type
0084D7  1  8E 73 07     SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
0084DA  1  4C D0 85     NextSubtask:   jmp IncSubtask           ;move onto next task
0084DD  1               
0084DD  1               ;-------------------------------------------------------------------------------------
0084DD  1               ;$00 - used as temp counter in GetPlayerColors
0084DD  1               
0084DD  1               BGColorCtrl_Addr:
0084DD  1  00 09 0A 04        .byte $00, $09, $0a, $04
0084E1  1               
0084E1  1               BackgroundColors:
0084E1  1  22 22 0F 0F        .byte $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
0084E5  1  0F 22 0F 0F        .byte $0f, $22, $0f, $0f ;used by background color control if set
0084E9  1               
0084E9  1               PlayerColors:
0084E9  1  22 16 27 18        .byte $22, $16, $27, $18 ;mario's normal colors
0084ED  1  22 30 27 19        .byte $22, $30, $27, $19 ;luigi's normal colors
0084F1  1  22 37 27 16        .byte $22, $37, $27, $16 ;player's colors after grabbing fire flower
0084F5  1               
0084F5  1               GetBackgroundColor:
0084F5  1  AC 44 07                ldy BackgroundColorCtrl   ;check background color control
0084F8  1  F0 06                   beq NoBGColor             ;if not set, increment task and fetch palette
0084FA  1  B9 D9 84                lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
0084FD  1  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, first VRAM buffer will not be read
008500  1  EE 3C 07     NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
008503  1               
008503  1               GetPlayerColors:
008503  1  AE 00 03                    ldx VRAM_Buffer1_Offset  ;get current buffer offset
008506  1  A0 00                       ldy #$00
008508  1  AD 53 07                    lda SelectedPlayer       ;check which player is on the screen
00850B  1  F0 02                       beq ChkFiery
00850D  1  A0 04                       ldy #$04                 ;load offset for luigi
00850F  1  AD 56 07     ChkFiery:      lda PlayerStatus         ;check player status
008512  1  C9 02                       cmp #$02
008514  1  D0 02                       bne StartClrGet          ;if fiery, load alternate offset for fiery player
008516  1  A0 08                       ldy #$08
008518  1  A9 03        StartClrGet:   lda #$03                 ;do four colors
00851A  1  85 00                       sta $00
00851C  1  B9 E9 84     ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
00851F  1  9D 04 03                    sta VRAM_Buffer1+3,x     ;in the buffer
008522  1  C8                          iny
008523  1  E8                          inx
008524  1  C6 00                       dec $00
008526  1  10 F4                       bpl ClrGetLoop
008528  1  AE 00 03                    ldx VRAM_Buffer1_Offset  ;load original offset from before
00852B  1  AC 44 07                    ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
00852E  1  D0 03                       bne SetBGColor           ;therefore use it as offset to background color
008530  1  AC 4E 07                    ldy AreaType             ;otherwise use area type bits from area offset as offset
008533  1  B9 E1 84     SetBGColor:    lda BackgroundColors,y   ;to background color instead
008536  1  9D 04 03                    sta VRAM_Buffer1+3,x
008539  1  A9 3F                       lda #$3f                 ;set for sprite palette address
00853B  1  9D 01 03                    sta VRAM_Buffer1,x       ;save to buffer
00853E  1  A9 10                       lda #$10
008540  1  9D 02 03                    sta VRAM_Buffer1+1,x
008543  1  A9 04                       lda #$04                 ;write length byte to buffer
008545  1  9D 03 03                    sta VRAM_Buffer1+2,x
008548  1  A9 00                       lda #$00                 ;now the null terminator
00854A  1  9D 08 03                    sta VRAM_Buffer1+7,x
00854D  1  8A                          txa                      ;move the buffer pointer ahead 7 bytes
00854E  1  18                          clc                      ;in case we want to write anything else later
00854F  1  69 07                       adc #$07
008551  1  8D 00 03     SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
008554  1  60                          rts
008555  1               
008555  1               GetAlternatePalette1:
008555  1  AD 33 07                    lda AreaStyle            ;check for mushroom level style
008558  1  C9 01                       cmp #$01
00855A  1  D0 05                       bne NoAltPal
00855C  1  A9 0B                       lda #$0b                 ;if found, load appropriate palette
00855E  1  8D 73 07     SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
008561  1  4C D0 85     NoAltPal:      jmp IncSubtask           ;now onto the next task
008564  1               
008564  1               WriteTopStatusLine:
008564  1  A9 00              lda #$00          ;select main status bar
008566  1  20 E2 86           jsr WriteGameText ;output it
008569  1  4C D0 85           jmp IncSubtask    ;onto the next task
00856C  1               
00856C  1               WriteBottomStatusLine:
00856C  1  20 18 A8           jsr WriteScoreAndCoinTally ;write player's score and coin tally to screen
00856F  1  AE 00 03           ldx VRAM_Buffer1_Offset
008572  1  A9 20              lda #$20                   ;write address for world-area number on screen
008574  1  9D 01 03           sta VRAM_Buffer1,x
008577  1  A9 73              lda #$73
008579  1  9D 02 03           sta VRAM_Buffer1+1,x
00857C  1  A9 03              lda #$03                   ;write length for it
00857E  1  9D 03 03           sta VRAM_Buffer1+2,x
008581  1  20 A3 85           jsr GetWorldNumForDisplay  ;first the world number
008584  1  9D 04 03           sta VRAM_Buffer1+3,x
008587  1  A9 28              lda #$28                   ;next the dash
008589  1  9D 05 03           sta VRAM_Buffer1+4,x
00858C  1  AC 5C 07           ldy LevelNumber            ;next the level number
00858F  1  C8                 iny                        ;increment for proper number display
008590  1  98                 tya
008591  1  9D 06 03           sta VRAM_Buffer1+5,x
008594  1  A9 00              lda #$00                   ;put null terminator at the end
008596  1  9D 07 03           sta VRAM_Buffer1+6,x
008599  1  8A                 txa                        ;move the buffer offset up by 6 bytes
00859A  1  18                 clc
00859B  1  69 06              adc #$06
00859D  1  8D 00 03           sta VRAM_Buffer1_Offset
0085A0  1  4C D0 85           jmp IncSubtask
0085A3  1               
0085A3  1               GetWorldNumForDisplay:
0085A3  1  AC 5F 07            ldy WorldNumber
0085A6  1  AD FB 07            lda HardWorldFlag  ;if not in worlds A-D, branch to use digits 1-8
0085A9  1  F0 07               beq WNumD
0085AB  1  98                  tya
0085AC  1  29 03               and #$03           ;otherwise mask out any world numbers higher than 4
0085AE  1  18                  clc                ;and add 9 to get the proper letter A thru D
0085AF  1  69 09               adc #$09
0085B1  1  A8                  tay
0085B2  1  C8           WNumD: iny                ;increment the world number/letter because
0085B3  1  98                  tya                ;the internal world number counts from 0, not 1
0085B4  1  60                  rts
0085B5  1               
0085B5  1               DisplayTimeUp:
0085B5  1  AD 59 07               lda GameTimerExpiredFlag  ;if game timer not expired, increment task
0085B8  1  F0 13                  beq IncSubtaskby2         ;control 2 tasks forward, otherwise, stay here
0085BA  1  A9 00                  lda #$00
0085BC  1  8D 59 07               sta GameTimerExpiredFlag  ;reset timer expiration flag
0085BF  1  A9 02                  lda #$02                  ;output time-up screen to buffer
0085C1  1               OtherInter:
0085C1  1  20 E2 86               jsr WriteGameText
0085C4  1  20 5A 87               jsr ResetScreenTimer
0085C7  1  A9 00                  lda #$00
0085C9  1  8D 74 07               sta DisableScreenFlag
0085CC  1  60                     rts
0085CD  1               
0085CD  1               IncSubtaskby2:
0085CD  1  EE 3C 07           inc ScreenRoutineTask
0085D0  1               IncSubtask:
0085D0  1  EE 3C 07           inc ScreenRoutineTask
0085D3  1  60                 rts
0085D4  1               
0085D4  1               DisplayIntermediate:
0085D4  1  A9 00                       lda #$00
0085D6  1  8D 7A 07                    sta NameTableSelect          ;we need to reset nametable unlike super mario bros 1
0085D9  1  AD 70 07                    lda OperMode                 ;check primary mode of operation
0085DC  1  F0 37                       beq NoInter                  ;if in attract mode, do not display intermediate screens
0085DE  1  C9 03                       cmp #GameOverMode            ;are we in game over mode?
0085E0  1  F0 24                       beq GameOverInter            ;if so, proceed to display game over screen
0085E2  1  AD 52 07                    lda AltEntranceControl       ;otherwise check for mode of alternate entry
0085E5  1  D0 2E                       bne NoInter                  ;and branch if found
0085E7  1  AC 4E 07                    ldy AreaType                 ;check if we are on castle level
0085EA  1  C0 03                       cpy #$03                     ;and if so, branch (possibly residual)
0085EC  1  F0 05                       beq PlayerInter
0085EE  1  AD 69 07                    lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
0085F1  1  D0 22                       bne NoInter                  ;and jump to specific task, otherwise
0085F3  1  20 64 DC     PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
0085F6  1  A9 01                       lda #$01                     ;lives display, then output lives display to buffer
0085F8  1  20 C1 85     OutputInter:   jsr OtherInter
0085FB  1  AD 5F 07                    lda WorldNumber              ;if on any world besides 9, do next task
0085FE  1  C9 08                       cmp #World9
008600  1  D0 CE                       bne IncSubtask
008602  1  EE 74 07                    inc DisableScreenFlag        ;disable screen output
008605  1  60                          rts
008606  1               
008606  1  A9 03        GameOverInter: lda #$03                     ;output game over screen to buffer
008608  1  20 E2 86                    jsr WriteGameText
00860B  1  AD 5F 07                    lda WorldNumber
00860E  1  C9 08                       cmp #World9
008610  1  F0 BE                       beq IncSubtask
008612  1  4C CF 82                    jmp IncModeTask
008615  1               
008615  1  A9 09        NoInter:       lda #$09                     ;skip ahead in screen routine list
008617  1  8D 3C 07                    sta ScreenRoutineTask        ;to execute area parser
00861A  1  60                          rts
00861B  1               
00861B  1               AreaParserTaskControl:
00861B  1  EE 74 07                inc DisableScreenFlag     ;turn off screen
00861E  1  20 BC 90     TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
008621  1  AD 1F 07                lda AreaParserTaskNum     ;check number of tasks
008624  1  D0 F8                   bne TaskLoop              ;if tasks still not all done, do another one
008626  1  CE 1E 07                dec ColumnSets            ;do we need to render more column sets?
008629  1  10 03                   bpl OutputCol
00862B  1  EE 3C 07                inc ScreenRoutineTask     ;if not, move on to the next task
00862E  1  A9 06        OutputCol: lda #$06                  ;set vram buffer to output rendered column set
008630  1  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;on next NMI
008633  1  60                      rts
008634  1               
008634  1               GameText:
008634  1               TopStatusBarLine:
008634  1  20 43 05 16    .byte $20, $43, $05, $16, $0a, $1b, $12, $18 ;"MARIO"
008638  1  0A 1B 12 18  
00863C  1  20 52 0B 20    .byte $20, $52, $0b, $20, $18, $1b, $15, $0d ;"WORLD  TIME"
008640  1  18 1B 15 0D  
008644  1  24 24 1D 12    .byte $24, $24, $1d, $12, $16, $0e
008648  1  16 0E        
00864A  1  20 68 05 00    .byte $20, $68, $05, $00, $24, $24, $2e, $29 ;score trailing digit and coin display
00864E  1  24 24 2E 29  
008652  1  23 C0 7F AA    .byte $23, $c0, $7f, $aa ;attribute table data, clears name table 0 to palette 2
008656  1  23 C2 01 EA    .byte $23, $c2, $01, $ea ;attribute table data, used for coin icon in status bar
00865A  1  FF             .byte $ff ;end of data block
00865B  1               
00865B  1               WorldLivesDisplay:
00865B  1  21 CD 07 24    .byte $21, $cd, $07, $24, $24 ;cross with spaces used on
00865F  1  24           
008660  1  29 24 24 24    .byte $29, $24, $24, $24, $24 ;lives display
008664  1  24           
008665  1  21 4B 09 20    .byte $21, $4b, $09, $20, $18 ;"WORLD  - " used on lives display
008669  1  18           
00866A  1  1B 15 0D 24    .byte $1b, $15, $0d, $24, $24, $28, $24
00866E  1  24 28 24     
008671  1  22 0C 47 24    .byte $22, $0c, $47, $24 ;possibly used to clear time up
008675  1  23 DC 01 BA    .byte $23, $dc, $01, $ba ;attribute table data for crown if more than 9 lives
008679  1  FF             .byte $ff
00867A  1               
00867A  1               TimeUp:
00867A  1  22 0C 07 1D    .byte $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
00867E  1  12 16 0E 24  
008682  1  1E 19        
008684  1  FF             .byte $ff
008685  1               
008685  1               GameOver:
008685  1  21 6B 09 10    .byte $21, $6b, $09, $10, $0a, $16, $0e, $24 ;"GAME OVER"
008689  1  0A 16 0E 24  
00868D  1  18 1F 0E 1B    .byte $18, $1f, $0e, $1b
008691  1  21 EB 08 0C    .byte $21, $eb, $08, $0c, $18, $17, $1d, $12, $17, $1e, $0e ;"CONTINUE"
008695  1  18 17 1D 12  
008699  1  17 1E 0E     
00869C  1  22 0C 47 24    .byte $22, $0c, $47, $24
0086A0  1  22 4B 05 1B    .byte $22, $4b, $05, $1b, $0e, $1d, $1b, $22 ;"RETRY"
0086A4  1  0E 1D 1B 22  
0086A8  1  FF             .byte $ff
0086A9  1               
0086A9  1               WarpZone:
0086A9  1  25 84 15       .byte $25, $84, $15
0086AC  1  20 0E 15 0C    .byte $20, $0e, $15, $0c, $18, $16, $0e, $24, $1d, $18 ; "WELCOME TO WARP ZONE!"
0086B0  1  18 16 0E 24  
0086B4  1  1D 18        
0086B6  1  24 20 0A 1B    .byte $24, $20, $0a, $1b, $19, $24, $23, $18, $17, $0e
0086BA  1  19 24 23 18  
0086BE  1  17 0E        
0086C0  1  2B             .byte $2b
0086C1  1  26 2D 01 24    .byte $26, $2d, $01, $24 ;blank filler for world number
0086C5  1  27 D9 46 AA    .byte $27, $d9, $46, $aa ;attribute data
0086C9  1  27 E1 45 AA    .byte $27, $e1, $45, $aa
0086CD  1  00             .byte $00
0086CE  1               
0086CE  1               LuigiName:
0086CE  1  15 1E 12 10    .byte $15, $1e, $12, $10, $12 ; "LUIGI", no address or length
0086D2  1  12           
0086D3  1               
0086D3  1               WarpZoneNumbers:
0086D3  1  02 03 04 01    .byte $02, $03, $04, $01, $06, $07, $08, $05, $0b, $0c, $0d
0086D7  1  06 07 08 05  
0086DB  1  0B 0C 0D     
0086DE  1               
0086DE  1               GameTextOffsets:
0086DE  1  00              .byte TopStatusBarLine-GameText
0086DF  1  27              .byte WorldLivesDisplay-GameText
0086E0  1  46              .byte TimeUp-GameText
0086E1  1  51              .byte GameOver-GameText
0086E2  1               
0086E2  1               WriteGameText:
0086E2  1  48                          pha                       ;save text number to stack and use as offset
0086E3  1  A8                          tay
0086E4  1  BE DE 86                    ldx GameTextOffsets,y     ;get offset to game text we want to print
0086E7  1  A0 00                       ldy #$00
0086E9  1  BD 34 86     GameTextLoop:  lda GameText,x            ;load game text data
0086EC  1  C9 FF                       cmp #$ff                  ;check for terminator
0086EE  1  F0 07                       beq EndGameText           ;branch to end text if found
0086F0  1  99 01 03                    sta VRAM_Buffer1,y        ;otherwise write data to buffer
0086F3  1  E8                          inx                       ;and increment increment
0086F4  1  C8                          iny
0086F5  1  D0 F2                       bne GameTextLoop          ;do this for 256 bytes if no terminator found
0086F7  1  A9 00        EndGameText:   lda #$00                  ;put null terminator at end
0086F9  1  99 01 03                    sta VRAM_Buffer1,y
0086FC  1  68                          pla                       ;pull original text number from stack
0086FD  1  F0 26                       beq CheckPlayerName       ;if printing top status bar, branch to check player's name
0086FF  1  AA                          tax
008700  1  CA                          dex                       ;if printing anything else besides world/lives display
008701  1  D0 21                       bne ExWGT                 ;then branch to leave
008703  1  AD 5A 07                    lda NumberofLives         ;otherwise, check number of lives
008706  1  18                          clc                       ;and increment by one for display
008707  1  69 01                       adc #$01
008709  1  C9 0A                       cmp #10                   ;more than 9 lives?
00870B  1  90 07                       bcc PutLives
00870D  1  E9 0A                       sbc #10                   ;if so, subtract 10 and put a crown tile
00870F  1  A0 9F                       ldy #$9f                  ;next to the difference...strange things happen if
008711  1  8C 08 03                    sty VRAM_Buffer1+7        ;the number of lives exceeds 19
008714  1  8D 09 03     PutLives:      sta VRAM_Buffer1+8
008717  1  20 A3 85                    jsr GetWorldNumForDisplay ;get world number or letter
00871A  1  8D 14 03                    sta VRAM_Buffer1+19
00871D  1  AC 5C 07                    ldy LevelNumber
008720  1  C8                          iny
008721  1  8C 16 03                    sty VRAM_Buffer1+21       ;we're done here
008724  1  60           ExWGT:         rts
008725  1               
008725  1               CheckPlayerName:
008725  1  AD 53 07                  lda SelectedPlayer     ;check selected player
008728  1  F0 0B                     beq ExitChkName        ;if mario, leave
00872A  1  A0 04                     ldy #$04
00872C  1  B9 CE 86     NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
00872F  1  99 04 03                  sta VRAM_Buffer1+3,y
008732  1  88                        dey
008733  1  10 F7                     bpl NameLoop           ;do this until each letter is replaced
008735  1  60           ExitChkName: rts
008736  1               
008736  1               WriteWarpZoneMessage:
008736  1  48                    pha                   ;save warp zone control temporarily
008737  1  A0 FF                 ldy #$ff
008739  1  C8           WZMLoop: iny
00873A  1  B9 A9 86              lda WarpZone,y        ;write warp zone message to VRAM buffer
00873D  1  99 01 03              sta VRAM_Buffer1,y
008740  1  D0 F7                 bne WZMLoop
008742  1  68                    pla
008743  1  38                    sec
008744  1  E9 80                 sbc #$80              ;clear d7 of warp zone control, use as offset
008746  1  AA                    tax
008747  1  BD D3 86              lda WarpZoneNumbers,x ;replace blank tile with world number
00874A  1  8D 1C 03              sta VRAM_Buffer1+27   ;that the warp zone leads to
00874D  1  A9 24                 lda #$24              ;set VRAM offset after the contents
00874F  1  4C 51 85              jmp SetVRAMOffset     ;in case anything else needs to go in there
008752  1               
008752  1               ResetSpritesAndScreenTimer:
008752  1  AD A0 07              lda ScreenTimer             ;check if screen timer has expired
008755  1  D0 0B                 bne NoReset                 ;if not, branch to leave
008757  1  20 30 82              jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
00875A  1               
00875A  1               ResetScreenTimer:
00875A  1  A9 07                 lda #$07                    ;reset timer again
00875C  1  8D A0 07              sta ScreenTimer
00875F  1  EE 3C 07              inc ScreenRoutineTask       ;move onto next task
008762  1  60           NoReset: rts
008763  1               
008763  1               ;-------------------------------------------------------------------------------------
008763  1               ;$00 - temp vram buffer offset
008763  1               ;$01 - temp metatile buffer offset
008763  1               ;$02 - temp metatile graphics table offset
008763  1               ;$03 - used to store attribute bits
008763  1               ;$04 - used to determine attribute table row
008763  1               ;$05 - used to determine attribute table column
008763  1               ;$06 - metatile graphics table address low
008763  1               ;$07 - metatile graphics table address high
008763  1               
008763  1               RenderAreaGraphics:
008763  1  AD 26 07                 lda CurrentColumnPos         ;store LSB of where we're at
008766  1  29 01                    and #$01
008768  1  85 05                    sta $05
00876A  1  AC 40 03                 ldy VRAM_Buffer2_Offset      ;store vram buffer offset
00876D  1  84 00                    sty $00
00876F  1  AD 21 07                 lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
008772  1  99 42 03                 sta VRAM_Buffer2+1,y
008775  1  AD 20 07                 lda CurrentNTAddr_High
008778  1  99 41 03                 sta VRAM_Buffer2,y
00877B  1  A9 9A                    lda #$9a                     ;store length byte of 26 here with d7 set
00877D  1  99 43 03                 sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
008780  1  A9 00                    lda #$00                     ;init attribute row
008782  1  85 04                    sta $04
008784  1  AA                       tax
008785  1  86 01        DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
008787  1  BD A1 06                 lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
00878A  1  29 C0                    and #%11000000
00878C  1  85 03                    sta $03                      ;store attribute table bits here
00878E  1  0A                       asl                          ;note that metatile format is:
00878F  1  2A                       rol                          ;%xx000000 - attribute table bits,
008790  1  2A                       rol                          ;%00xxxxxx - metatile number
008791  1  A8                       tay                          ;rotate bits to d1-d0 and use as offset here
008792  1  B9 BD 89                 lda MetatileGraphics_Low,y   ;get address to graphics table from here
008795  1  85 06                    sta $06
008797  1  B9 C1 89                 lda MetatileGraphics_High,y
00879A  1  85 07                    sta $07
00879C  1  BD A1 06                 lda MetatileBuffer,x         ;get metatile number again
00879F  1  0A                       asl                          ;multiply by 4 and use as tile offset
0087A0  1  0A                       asl
0087A1  1  85 02                    sta $02
0087A3  1  AD 1F 07                 lda AreaParserTaskNum        ;get current task number for level processing and
0087A6  1  29 01                    and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
0087A8  1  49 01                    eor #%00000001               ;to get the correct column position in the metatile,
0087AA  1  0A                       asl                          ;then add to the tile offset so we can draw either side
0087AB  1  65 02                    adc $02                      ;of the metatiles
0087AD  1  A8                       tay
0087AE  1  A6 00                    ldx $00                      ;use vram buffer offset from before as X
0087B0  1  B1 06                    lda ($06),y
0087B2  1  9D 44 03                 sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
0087B5  1  C8                       iny
0087B6  1  B1 06                    lda ($06),y                  ;now get the second (bottom left or bottom right) and store
0087B8  1  9D 45 03                 sta VRAM_Buffer2+4,x
0087BB  1  A4 04                    ldy $04                      ;get current attribute row
0087BD  1  A5 05                    lda $05                      ;get LSB of current column where we're at, and
0087BF  1  D0 0E                    bne RightCheck               ;branch if set (clear = left attrib, set = right)
0087C1  1  A5 01                    lda $01                      ;get current row we're rendering
0087C3  1  4A                       lsr                          ;branch if LSB set (clear = top left, set = bottom left)
0087C4  1  B0 19                    bcs LLeft
0087C6  1  26 03                    rol $03                      ;rotate attribute bits 3 to the left
0087C8  1  26 03                    rol $03                      ;thus in d1-d0, for upper left square
0087CA  1  26 03                    rol $03
0087CC  1  4C E5 87                 jmp SetAttrib
0087CF  1  A5 01        RightCheck: lda $01                      ;get LSB of current row we're rendering
0087D1  1  4A                       lsr                          ;branch if set (clear = top right, set = bottom right)
0087D2  1  B0 0F                    bcs NextMTRow
0087D4  1  46 03                    lsr $03                      ;shift attribute bits 4 to the right
0087D6  1  46 03                    lsr $03                      ;thus in d3-d2, for upper right square
0087D8  1  46 03                    lsr $03
0087DA  1  46 03                    lsr $03
0087DC  1  4C E5 87                 jmp SetAttrib
0087DF  1  46 03        LLeft:      lsr $03                      ;shift attribute bits 2 to the right
0087E1  1  46 03                    lsr $03                      ;thus in d5-d4 for lower left square
0087E3  1  E6 04        NextMTRow:  inc $04                      ;move onto next attribute row
0087E5  1  B9 F9 03     SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
0087E8  1  05 03                    ora $03                      ;if any, and put new bits, if any, onto
0087EA  1  99 F9 03                 sta AttributeBuffer,y        ;the old, and store
0087ED  1  E6 00                    inc $00                      ;increment vram buffer offset by 2
0087EF  1  E6 00                    inc $00
0087F1  1  A6 01                    ldx $01                      ;get current gfx buffer row, and check for
0087F3  1  E8                       inx                          ;the bottom of the screen
0087F4  1  E0 0D                    cpx #$0d
0087F6  1  90 8D                    bcc DrawMTLoop               ;if not there yet, loop back
0087F8  1  A4 00                    ldy $00                      ;get current vram buffer offset, increment by 3
0087FA  1  C8                       iny                          ;(for name table address and length bytes)
0087FB  1  C8                       iny
0087FC  1  C8                       iny
0087FD  1  A9 00                    lda #$00
0087FF  1  99 41 03                 sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
008802  1  8C 40 03                 sty VRAM_Buffer2_Offset      ;store new buffer offset
008805  1  EE 21 07                 inc CurrentNTAddr_Low        ;increment name table address low
008808  1  AD 21 07                 lda CurrentNTAddr_Low        ;check current low byte
00880B  1  29 1F                    and #%00011111               ;if no wraparound, just skip this part
00880D  1  D0 0D                    bne ExitDrawM
00880F  1  A9 80                    lda #$80                     ;if wraparound occurs, make sure low byte stays
008811  1  8D 21 07                 sta CurrentNTAddr_Low        ;just under the status bar
008814  1  AD 20 07                 lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
008817  1  49 04                    eor #%00000100               ;to move onto the next appropriate name table
008819  1  8D 20 07                 sta CurrentNTAddr_High
00881C  1  4C 72 88     ExitDrawM:  jmp SetVRAMCtrl              ;jump to set VRAM address controller
00881F  1               
00881F  1               RenderAttributeTables:
00881F  1  AD 21 07                  lda CurrentNTAddr_Low    ;get low byte of next name table address
008822  1  29 1F                     and #%00011111           ;to be written to, mask out all but 5 LSB,
008824  1  38                        sec                      ;subtract four
008825  1  E9 04                     sbc #$04
008827  1  29 1F                     and #%00011111           ;mask out bits again and store
008829  1  85 01                     sta $01
00882B  1  AD 20 07                  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
00882E  1  B0 02                     bcs SetATHigh
008830  1  49 04                     eor #%00000100           ;otherwise invert d2
008832  1  29 04        SetATHigh:   and #%00000100           ;mask out all other bits
008834  1  09 23                     ora #$23                 ;add $2300 (for attribute table) to the high byte
008836  1  85 00                     sta $00
008838  1  A5 01                     lda $01                  ;get low byte - 4, divide by 4, add offset for
00883A  1  4A                        lsr                      ;attribute table and store
00883B  1  4A                        lsr
00883C  1  69 C0                     adc #$c0                 ;we should now have the appropriate block of
00883E  1  85 01                     sta $01                  ;attribute table in our temp address
008840  1  A2 00                     ldx #$00
008842  1  AC 40 03                  ldy VRAM_Buffer2_Offset  ;get buffer offset
008845  1  A5 00        AttribLoop:  lda $00
008847  1  99 41 03                  sta VRAM_Buffer2,y       ;store high byte of attribute table address
00884A  1  A5 01                     lda $01
00884C  1  18                        clc                      ;get low byte, add 8 because we want to start
00884D  1  69 08                     adc #$08                 ;below the status bar, and store
00884F  1  99 42 03                  sta VRAM_Buffer2+1,y
008852  1  85 01                     sta $01                  ;also store in temp again
008854  1  BD F9 03                  lda AttributeBuffer,x    ;fetch current attribute table byte and store
008857  1  99 44 03                  sta VRAM_Buffer2+3,y     ;in the buffer
00885A  1  A9 01                     lda #$01
00885C  1  99 43 03                  sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
00885F  1  4A                        lsr
008860  1  9D F9 03                  sta AttributeBuffer,x    ;clear current byte in attribute buffer
008863  1  C8                        iny                      ;increment buffer offset by 4 bytes
008864  1  C8                        iny
008865  1  C8                        iny
008866  1  C8                        iny
008867  1  E8                        inx                      ;increment attribute offset and check to see
008868  1  E0 07                     cpx #$07                 ;if we're at the end yet
00886A  1  90 D9                     bcc AttribLoop
00886C  1  99 41 03                  sta VRAM_Buffer2,y       ;put null terminator at the end
00886F  1  8C 40 03                  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
008872  1  A9 06        SetVRAMCtrl: lda #$06
008874  1  8D 73 07                  sta VRAM_Buffer_AddrCtrl ;set VRAM address controller to second VRAM buffer
008877  1  60                        rts
008878  1               
008878  1               ;-------------------------------------------------------------------------------------
008878  1               ;$00 - used as temporary counter in ColorRotation
008878  1               
008878  1               ColorRotatePalette:
008878  1  27 27 27 17         .byte $27, $27, $27, $17, $07, $17
00887C  1  07 17        
00887E  1               
00887E  1               BlankPalette:
00887E  1  3F 0C 04 FF         .byte $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
008882  1  FF FF FF 00  
008886  1               
008886  1               ;used based on area type
008886  1               Palette3Data:
008886  1  0F 07 12 0F         .byte $0f, $07, $12, $0f
00888A  1  0F 07 17 0F         .byte $0f, $07, $17, $0f
00888E  1  0F 07 17 1C         .byte $0f, $07, $17, $1c
008892  1  0F 07 17 00         .byte $0f, $07, $17, $00
008896  1               
008896  1               ColorRotation:
008896  1  A5 09                      lda FrameCounter         ;get frame counter
008898  1  29 07                      and #$07                 ;mask out all but three LSB
00889A  1  D0 51                      bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
00889C  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;check vram buffer offset
00889F  1  E0 31                      cpx #$31
0088A1  1  B0 4A                      bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
0088A3  1  A8                         tay                      ;otherwise use frame counter's 3 LSB as offset here
0088A4  1  B9 7E 88     GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
0088A7  1  9D 01 03                   sta VRAM_Buffer1,x       ;store it in the vram buffer
0088AA  1  E8                         inx                      ;increment offsets
0088AB  1  C8                         iny
0088AC  1  C0 08                      cpy #$08
0088AE  1  90 F4                      bcc GetBlankPal          ;do this until all bytes are copied
0088B0  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0088B3  1  A9 03                      lda #$03
0088B5  1  85 00                      sta $00                  ;set counter here
0088B7  1  AD 4E 07                   lda AreaType             ;get area type
0088BA  1  0A                         asl                      ;multiply by 4 to get proper offset
0088BB  1  0A                         asl
0088BC  1  A8                         tay                      ;save as offset here
0088BD  1  B9 86 88     GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
0088C0  1  9D 04 03                   sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
0088C3  1  C8                         iny
0088C4  1  E8                         inx
0088C5  1  C6 00                      dec $00                  ;decrement counter
0088C7  1  10 F4                      bpl GetAreaPal           ;do this until the palette is all copied
0088C9  1  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0088CC  1  AC D4 06                   ldy ColorRotateOffset    ;get color cycling offset
0088CF  1  B9 78 88                   lda ColorRotatePalette,y
0088D2  1  9D 05 03                   sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
0088D5  1  AD 00 03                   lda VRAM_Buffer1_Offset
0088D8  1  18                         clc                      ;add seven bytes to vram buffer offset
0088D9  1  69 07                      adc #$07
0088DB  1  8D 00 03                   sta VRAM_Buffer1_Offset
0088DE  1  EE D4 06                   inc ColorRotateOffset    ;increment color cycling offset
0088E1  1  AD D4 06                   lda ColorRotateOffset
0088E4  1  C9 06                      cmp #$06                 ;check to see if it's still in range
0088E6  1  90 05                      bcc ExitColorRot         ;if so, branch to leave
0088E8  1  A9 00                      lda #$00
0088EA  1  8D D4 06                   sta ColorRotateOffset    ;otherwise, init to keep it in range
0088ED  1  60           ExitColorRot: rts                      ;leave
0088EE  1               
0088EE  1               ;-------------------------------------------------------------------------------------
0088EE  1               ;$00 - temp store for offset control bit
0088EE  1               ;$01 - temp vram buffer offset
0088EE  1               ;$02 - temp store for vertical high nybble in block buffer routine
0088EE  1               ;$03 - temp adder for high byte of name table address
0088EE  1               ;$04, $05 - name table address low/high
0088EE  1               ;$06, $07 - block buffer address low/high
0088EE  1               
0088EE  1               BlockGfxData:
0088EE  1  45 45 47 47         .byte $45, $45, $47, $47
0088F2  1  47 47 47 47         .byte $47, $47, $47, $47
0088F6  1  57 58 59 5A         .byte $57, $58, $59, $5a
0088FA  1  24 24 24 24         .byte $24, $24, $24, $24
0088FE  1  26 26 26 26         .byte $26, $26, $26, $26
008902  1               
008902  1               RemoveCoin_Axe:
008902  1  A0 41                      ldy #$41                 ;set low byte so offset points to second vram buffer
008904  1  A9 03                      lda #$03                 ;load offset for default blank metatile
008906  1  AE 4E 07                   ldx AreaType             ;check area type
008909  1  D0 02                      bne WriteBlankMT         ;if not water type, use offset
00890B  1  A9 04                      lda #$04                 ;otherwise load offset for blank metatile used in water
00890D  1  20 4C 89     WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
008910  1  A9 06                      lda #$06
008912  1  8D 73 07                   sta VRAM_Buffer_AddrCtrl ;set vram address controller to second vram buffer and leave
008915  1  60                         rts
008916  1               
008916  1               ReplaceBlockMetatile:
008916  1  20 22 89            jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
008919  1  EE F0 03            inc Block_ResidualCounter ;increment unused counter (residual code)
00891C  1  DE EC 03            dec Block_RepFlag,x       ;decrement flag (residual code)
00891F  1  60                  rts                       ;leave
008920  1               
008920  1               DestroyBlockMetatile:
008920  1  A9 00               lda #$00       ;force blank metatile if branched/jumped to this point
008922  1               
008922  1               WriteBlockMetatile:
008922  1  A0 03                     ldy #$03                ;load offset for blank metatile
008924  1  C9 00                     cmp #$00                ;check contents of A for blank metatile
008926  1  F0 14                     beq UseBOffset          ;branch if found (unconditional if destroying metatile)
008928  1  A0 00                     ldy #$00                ;load offset for brick metatile w/ line
00892A  1  C9 56                     cmp #$56
00892C  1  F0 0E                     beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
00892E  1  C9 4F                     cmp #$4f
008930  1  F0 0A                     beq UseBOffset          ;use offset if metatile is breakable brick w/ line
008932  1  C8                        iny                     ;increment offset for brick metatile w/o line
008933  1  C9 5C                     cmp #$5c
008935  1  F0 05                     beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
008937  1  C9 50                     cmp #$50
008939  1  F0 01                     beq UseBOffset          ;use offset if metatile is breakable brick w/o line
00893B  1  C8                        iny                     ;if any other metatile, increment offset for empty block
00893C  1  98           UseBOffset:  tya                     ;put Y in A
00893D  1  AC 00 03                  ldy VRAM_Buffer1_Offset ;get vram buffer offset
008940  1  C8                        iny                     ;move onto next byte
008941  1  20 4C 89                  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
008944  1  88           MoveVOffset: dey                     ;decrement vram buffer offset
008945  1  98                        tya                     ;add 10 bytes to it
008946  1  18                        clc
008947  1  69 0A                     adc #10
008949  1  4C 51 85                  jmp SetVRAMOffset       ;branch to store as new vram buffer offset
00894C  1               
00894C  1               PutBlockMetatile:
00894C  1  86 00                    stx $00               ;store control bit from SprDataOffset_Ctrl
00894E  1  84 01                    sty $01               ;store vram buffer offset for next byte
008950  1  0A                       asl
008951  1  0A                       asl                   ;multiply A by four and use as X
008952  1  AA                       tax
008953  1  A0 20                    ldy #$20              ;load high byte for name table 0
008955  1  A5 06                    lda $06               ;get low byte of block buffer pointer
008957  1  C9 D0                    cmp #$d0              ;check to see if we're on odd-page block buffer
008959  1  90 02                    bcc SaveHAdder        ;if not, use current high byte
00895B  1  A0 24                    ldy #$24              ;otherwise load high byte for name table 1
00895D  1  84 03        SaveHAdder: sty $03               ;save high byte here
00895F  1  29 0F                    and #$0f              ;mask out high nybble of block buffer pointer
008961  1  0A                       asl                   ;multiply by 2 to get appropriate name table low byte
008962  1  85 04                    sta $04               ;and then store it here
008964  1  A9 00                    lda #$00
008966  1  85 05                    sta $05               ;initialize temp high byte
008968  1  A5 02                    lda $02               ;get vertical high nybble offset used in block buffer routine
00896A  1  18                       clc
00896B  1  69 20                    adc #$20              ;add 32 pixels for the status bar
00896D  1  0A                       asl
00896E  1  26 05                    rol $05               ;shift and rotate d7 onto d0 and d6 into carry
008970  1  0A                       asl
008971  1  26 05                    rol $05               ;shift and rotate d6 onto d0 and d5 into carry
008973  1  65 04                    adc $04               ;add low byte of name table and carry to vertical high nybble
008975  1  85 04                    sta $04               ;and store here
008977  1  A5 05                    lda $05               ;get whatever was in d7 and d6 of vertical high nybble
008979  1  69 00                    adc #$00              ;add carry
00897B  1  18                       clc
00897C  1  65 03                    adc $03               ;then add high byte of name table
00897E  1  85 05                    sta $05               ;store here
008980  1  A4 01                    ldy $01               ;get vram buffer offset to be used
008982  1  BD EE 88     RemBridge:  lda BlockGfxData,x    ;write top left and top right
008985  1  99 03 03                 sta VRAM_Buffer1+2,y  ;tile numbers into first spot
008988  1  BD EF 88                 lda BlockGfxData+1,x
00898B  1  99 04 03                 sta VRAM_Buffer1+3,y
00898E  1  BD F0 88                 lda BlockGfxData+2,x  ;write bottom left and bottom
008991  1  99 08 03                 sta VRAM_Buffer1+7,y  ;right tiles numbers into
008994  1  BD F1 88                 lda BlockGfxData+3,x  ;second spot
008997  1  99 09 03                 sta VRAM_Buffer1+8,y
00899A  1  A5 04                    lda $04
00899C  1  99 01 03                 sta VRAM_Buffer1,y    ;write low byte of name table
00899F  1  18                       clc                   ;into first slot as read
0089A0  1  69 20                    adc #$20              ;add 32 bytes to value
0089A2  1  99 06 03                 sta VRAM_Buffer1+5,y  ;write low byte of name table
0089A5  1  A5 05                    lda $05               ;plus 32 bytes into second slot
0089A7  1  99 00 03                 sta VRAM_Buffer1-1,y  ;write high byte of name
0089AA  1  99 05 03                 sta VRAM_Buffer1+4,y  ;table address to both slots
0089AD  1  A9 02                    lda #$02
0089AF  1  99 02 03                 sta VRAM_Buffer1+1,y  ;put length of 2 in
0089B2  1  99 07 03                 sta VRAM_Buffer1+6,y  ;both slots
0089B5  1  A9 00                    lda #$00
0089B7  1  99 0A 03                 sta VRAM_Buffer1+9,y  ;put null terminator at end
0089BA  1  A6 00                    ldx $00               ;get offset control bit here
0089BC  1  60                       rts                   ;and leave
0089BD  1               
0089BD  1               ;-------------------------------------------------------------------------------------
0089BD  1               ;METATILE GRAPHICS TABLE
0089BD  1               
0089BD  1               MetatileGraphics_Low:
0089BD  1  C5 55 15 49    .byte <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
0089C1  1               
0089C1  1               MetatileGraphics_High:
0089C1  1  89 8A 8B 8B    .byte >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
0089C5  1               
0089C5  1               Palette0_MTiles:
0089C5  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank
0089C9  1  27 27 27 27    .byte $27, $27, $27, $27 ;black metatile
0089CD  1  24 24 24 35    .byte $24, $24, $24, $35 ;bush left
0089D1  1  36 25 37 25    .byte $36, $25, $37, $25 ;bush middle
0089D5  1  24 38 24 24    .byte $24, $38, $24, $24 ;bush right
0089D9  1  24 30 30 26    .byte $24, $30, $30, $26 ;mountain left
0089DD  1  26 26 34 26    .byte $26, $26, $34, $26 ;mountain left bottom/middle center
0089E1  1  24 31 24 32    .byte $24, $31, $24, $32 ;mountain middle top
0089E5  1  33 26 24 33    .byte $33, $26, $24, $33 ;mountain right
0089E9  1  34 26 26 26    .byte $34, $26, $26, $26 ;mountain right bottom
0089ED  1  26 26 26 26    .byte $26, $26, $26, $26 ;mountain middle bottom
0089F1  1  24 C0 24 C0    .byte $24, $c0, $24, $c0 ;bridge guardrail
0089F5  1  24 7F 7F 24    .byte $24, $7f, $7f, $24 ;chain
0089F9  1  B8 BA B9 BB    .byte $b8, $ba, $b9, $bb ;tall tree top, top half
0089FD  1  B8 BC B9 BD    .byte $b8, $bc, $b9, $bd ;short tree top
008A01  1  BA BC BB BD    .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
008A05  1  60 64 61 65    .byte $60, $64, $61, $65 ;warp pipe end left, points up
008A09  1  62 66 63 67    .byte $62, $66, $63, $67 ;warp pipe end right, points up
008A0D  1  60 64 61 65    .byte $60, $64, $61, $65 ;decoration pipe end left, points up
008A11  1  62 66 63 67    .byte $62, $66, $63, $67 ;decoration pipe end right, points up
008A15  1  68 68 69 69    .byte $68, $68, $69, $69 ;pipe shaft left
008A19  1  26 26 6A 6A    .byte $26, $26, $6a, $6a ;pipe shaft right
008A1D  1  4B 4C 4D 4E    .byte $4b, $4c, $4d, $4e ;tree ledge left edge
008A21  1  4D 4F 4D 4F    .byte $4d, $4f, $4d, $4f ;tree ledge middle
008A25  1  4D 4E 50 51    .byte $4d, $4e, $50, $51 ;tree ledge right edge
008A29  1  86 8A 87 8B    .byte $86, $8a, $87, $8b ;sideways pipe end top
008A2D  1  88 8C 88 8C    .byte $88, $8c, $88, $8c ;sideways pipe shaft top
008A31  1  89 8D 69 69    .byte $89, $8d, $69, $69 ;sideways pipe joint top
008A35  1  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
008A39  1  26 93 26 93    .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
008A3D  1  90 94 69 69    .byte $90, $94, $69, $69 ;sideways pipe joint bottom
008A41  1  A4 E9 EA EB    .byte $a4, $e9, $ea, $eb ;seaplant
008A45  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
008A49  1  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flagpole ball
008A4D  1  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;flagpole shaft
008A51  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
008A55  1               
008A55  1               Palette1_MTiles:
008A55  1  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;vertical rope
008A59  1  99 24 99 24    .byte $99, $24, $99, $24 ;horizontal rope
008A5D  1  24 A2 3E 3F    .byte $24, $a2, $3e, $3f ;left pulley
008A61  1  5B 5C 24 A3    .byte $5b, $5c, $24, $a3 ;right pulley
008A65  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for balance rope
008A69  1  9D 47 9E 47    .byte $9d, $47, $9e, $47 ;castle top
008A6D  1  47 47 27 27    .byte $47, $47, $27, $27 ;castle window left
008A71  1  47 47 47 47    .byte $47, $47, $47, $47 ;castle brick wall
008A75  1  27 27 47 47    .byte $27, $27, $47, $47 ;castle window right
008A79  1  A9 47 AA 47    .byte $a9, $47, $aa, $47 ;castle top w/ brick
008A7D  1  9B 27 9C 27    .byte $9b, $27, $9c, $27 ;entrance top
008A81  1  27 27 27 27    .byte $27, $27, $27, $27 ;entrance bottom
008A85  1  52 52 52 52    .byte $52, $52, $52, $52 ;green ledge stump
008A89  1  80 A0 81 A1    .byte $80, $a0, $81, $a1 ;fence
008A8D  1  BE BE BF BF    .byte $be, $be, $bf, $bf ;tree trunk
008A91  1  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick w/ line
008A95  1  47 47 47 47    .byte $47, $47, $47, $47 ;breakable brick
008A99  1  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick (not used)
008A9D  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (power-up)
008AA1  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (poison shroom)
008AA5  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (vine)
008AA9  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (star)
008AAD  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (coins)
008AB1  1  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (1-up)
008AB5  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (power-up)
008AB9  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (poison shroom)
008ABD  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (vine)
008AC1  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (star)
008AC5  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (coins)
008AC9  1  47 47 47 47    .byte $47, $47, $47, $47 ;brick (1-up)
008ACD  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1 coin)
008AD1  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1-up)
008AD5  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (poison shroom)
008AD9  1  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (power-up)
008ADD  1  AB AC AD AE    .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
008AE1  1  5D 5E 5D 5E    .byte $5d, $5e, $5d, $5e ;solid block (white wall)
008AE5  1  C1 24 C1 24    .byte $c1, $24, $c1, $24 ;bridge
008AE9  1  C6 C8 C7 C9    .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
008AED  1  CA CC CB CD    .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
008AF1  1  2A 2A 40 40    .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
008AF5  1  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for jumpspring
008AF9  1  24 47 24 47    .byte $24, $47, $24, $47 ;half brick used for jumpspring
008AFD  1  82 83 84 85    .byte $82, $83, $84, $85 ;solid block (water level, green rock)
008B01  1  B4 B6 B5 B7    .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
008B05  1  24 47 24 47    .byte $24, $47, $24, $47 ;half brick (not used)
008B09  1  86 8A 87 8B    .byte $86, $8a, $87, $8b ;water pipe top
008B0D  1  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;water pipe bottom
008B11  1  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flag ball (residual object)
008B15  1               
008B15  1               Palette2_MTiles:
008B15  1  24 24 24 35    .byte $24, $24, $24, $35 ;cloud left
008B19  1  36 25 37 25    .byte $36, $25, $37, $25 ;cloud middle
008B1D  1  24 38 24 24    .byte $24, $38, $24, $24 ;cloud right
008B21  1  24 24 39 24    .byte $24, $24, $39, $24 ;cloud bottom left
008B25  1  3A 24 3B 24    .byte $3a, $24, $3b, $24 ;cloud bottom middle
008B29  1  3C 24 24 24    .byte $3c, $24, $24, $24 ;cloud bottom right
008B2D  1  41 26 41 26    .byte $41, $26, $41, $26 ;water/lava top
008B31  1  26 26 26 26    .byte $26, $26, $26, $26 ;water/lava
008B35  1  B0 B1 B2 B3    .byte $b0, $b1, $b2, $b3 ;cloud level terrain
008B39  1  77 79 77 79    .byte $77, $79, $77, $79 ;bowser's bridge
008B3D  1  6B 70 2C 2D    .byte $6b, $70, $2c, $2d ;cloud ledge left edge
008B41  1  6C 71 6D 72    .byte $6c, $71, $6d, $72 ;cloud ledge middle
008B45  1  6E 73 6F 74    .byte $6e, $73, $6f, $74 ;cloud ledge right edge
008B49  1               
008B49  1               Palette3_MTiles:
008B49  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (coin)
008B4D  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (power-up)
008B51  1  53 55 54 56    .byte $53, $55, $54, $56 ;question block (poison shroom)
008B55  1  A5 A7 A6 A8    .byte $a5, $a7, $a6, $a8 ;coin
008B59  1  C2 C4 C3 C5    .byte $c2, $c4, $c3, $c5 ;underwater coin
008B5D  1  57 59 58 5A    .byte $57, $59, $58, $5a ;empty block
008B61  1  7B 7D 7C 7E    .byte $7b, $7d, $7c, $7e ;axe
008B65  1               
008B65  1               ;------------------------------------------------------------------------------------
008B65  1               
008B65  1               WaterPaletteData:
008B65  1  3F 00 20       .byte $3f, $00, $20
008B68  1  0F 15 12 25    .byte $0f, $15, $12, $25
008B6C  1  0F 3A 1A 0F    .byte $0f, $3a, $1a, $0f
008B70  1  0F 30 12 0F    .byte $0f, $30, $12, $0f
008B74  1  0F 27 12 0F    .byte $0f, $27, $12, $0f
008B78  1  22 16 27 18    .byte $22, $16, $27, $18
008B7C  1  0F 10 30 27    .byte $0f, $10, $30, $27
008B80  1  0F 16 30 27    .byte $0f, $16, $30, $27
008B84  1  0F 0F 30 10    .byte $0f, $0f, $30, $10
008B88  1  00             .byte $00
008B89  1               
008B89  1               GroundPaletteData:
008B89  1  3F 00 20       .byte $3f, $00, $20
008B8C  1  0F 29 1A 0F    .byte $0f, $29, $1a, $0f
008B90  1  0F 36 17 0F    .byte $0f, $36, $17, $0f
008B94  1  0F 30 21 0F    .byte $0f, $30, $21, $0f
008B98  1  0F 27 17 0F    .byte $0f, $27, $17, $0f
008B9C  1  0F 16 27 18    .byte $0f, $16, $27, $18
008BA0  1  0F 1A 30 27    .byte $0f, $1a, $30, $27
008BA4  1  0F 16 30 27    .byte $0f, $16, $30, $27
008BA8  1  0F 0F 36 17    .byte $0f, $0f, $36, $17
008BAC  1  00             .byte $00
008BAD  1               
008BAD  1               UndergroundPaletteData:
008BAD  1  3F 00 20       .byte $3f, $00, $20
008BB0  1  0F 29 1A 09    .byte $0f, $29, $1a, $09
008BB4  1  0F 3C 1C 0F    .byte $0f, $3c, $1c, $0f
008BB8  1  0F 30 21 1C    .byte $0f, $30, $21, $1c
008BBC  1  0F 27 17 1C    .byte $0f, $27, $17, $1c
008BC0  1  0F 16 27 18    .byte $0f, $16, $27, $18
008BC4  1  0F 1C 36 17    .byte $0f, $1c, $36, $17
008BC8  1  0F 16 30 27    .byte $0f, $16, $30, $27
008BCC  1  0F 0C 3C 1C    .byte $0f, $0c, $3c, $1c
008BD0  1  00             .byte $00
008BD1  1               
008BD1  1               CastlePaletteData:
008BD1  1  3F 00 20       .byte $3f, $00, $20
008BD4  1  0F 30 10 00    .byte $0f, $30, $10, $00
008BD8  1  0F 30 10 00    .byte $0f, $30, $10, $00
008BDC  1  0F 30 16 00    .byte $0f, $30, $16, $00
008BE0  1  0F 27 17 00    .byte $0f, $27, $17, $00
008BE4  1  0F 16 27 18    .byte $0f, $16, $27, $18
008BE8  1  0F 1C 36 17    .byte $0f, $1c, $36, $17
008BEC  1  0F 16 30 27    .byte $0f, $16, $30, $27
008BF0  1  0F 00 30 10    .byte $0f, $00, $30, $10
008BF4  1  00             .byte $00
008BF5  1               
008BF5  1               DaySnowPaletteData:
008BF5  1  3F 00 04       .byte $3f, $00, $04
008BF8  1  22 30 00 10    .byte $22, $30, $00, $10
008BFC  1  00             .byte $00
008BFD  1               
008BFD  1               NightSnowPaletteData:
008BFD  1  3F 00 04       .byte $3f, $00, $04
008C00  1  0F 30 00 10    .byte $0f, $30, $00, $10
008C04  1  00             .byte $00
008C05  1               
008C05  1               MushroomPaletteData:
008C05  1  3F 00 04       .byte $3f, $00, $04
008C08  1  22 27 16 0F    .byte $22, $27, $16, $0f
008C0C  1  00             .byte $00
008C0D  1               
008C0D  1               BowserPaletteData:
008C0D  1  3F 14 04       .byte $3f, $14, $04
008C10  1  0F 1A 30 27    .byte $0f, $1a, $30, $27
008C14  1  00             .byte $00
008C15  1               
008C15  1               MarioThankYouMsg:
008C15  1  25 48 10       .byte $25, $48, $10
008C18  1  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24, $22, $18
008C1C  1  14 24 22 18  
008C20  1  1E 24 16 0A    .byte $1e, $24, $16, $0a, $1b, $12, $18, $2b
008C24  1  1B 12 18 2B  
008C28  1  00             .byte $00
008C29  1               
008C29  1               LuigiThankYouMsg:
008C29  1  25 48 10       .byte $25, $48, $10
008C2C  1  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24, $22, $18
008C30  1  14 24 22 18  
008C34  1  1E 24 15 1E    .byte $1e, $24, $15, $1e, $12, $10, $12, $2b
008C38  1  12 10 12 2B  
008C3C  1  00             .byte $00
008C3D  1               
008C3D  1               MushroomRetainerMsg:
008C3D  1  25 C5 16       .byte $25, $c5, $16
008C40  1  0B 1E 1D 24    .byte $0b, $1e, $1d, $24, $18, $1e, $1b, $24
008C44  1  18 1E 1B 24  
008C48  1  19 1B 12 17    .byte $19, $1b, $12, $17, $0c, $0e, $1c, $1c
008C4C  1  0C 0E 1C 1C  
008C50  1  24 12 1C 24    .byte $24, $12, $1c, $24, $12, $17
008C54  1  12 17        
008C56  1  26 05 0F       .byte $26, $05, $0f
008C59  1  0A 17 18 1D    .byte $0a, $17, $18, $1d, $11, $0e, $1b, $24
008C5D  1  11 0E 1B 24  
008C61  1  0C 0A 1C 1D    .byte $0c, $0a, $1c, $1d, $15, $0e, $2b
008C65  1  15 0E 2B     
008C68  1  00             .byte $00
008C69  1               
008C69  1               ;------------------------------------------------------------------------------------
008C69  1               
008C69  1               JumpEngine:
008C69  1  0A                  asl          ;shift bit from contents of A
008C6A  1  A8                  tay
008C6B  1  68                  pla          ;pull saved return address from stack
008C6C  1  85 04               sta $04      ;save to indirect
008C6E  1  68                  pla
008C6F  1  85 05               sta $05
008C71  1  C8                  iny
008C72  1  B1 04               lda ($04),y  ;load pointer from indirect
008C74  1  85 06               sta $06      ;note that if an RTS is performed in next routine
008C76  1  C8                  iny          ;it will return to the execution before the sub
008C77  1  B1 04               lda ($04),y  ;that called this routine
008C79  1  85 07               sta $07
008C7B  1  6C 06 00            jmp ($0006)  ;jump to the address we loaded
008C7E  1               
008C7E  1               ;------------------------------------------------------------------------------------
008C7E  1               
008C7E  1               InitializeNameTables:
008C7E  1  AD 02 20                   lda PPU_STATUS            ;reset flip-flop
008C81  1  AD 78 07                   lda Mirror_PPU_CTRL       ;load mirror of first ppu control reg
008C84  1  09 08                      ora #%00001000            ;set background for first 4k and sprites for second 4k
008C86  1  29 E8                      and #%11101000            ;clear rest of lower nybble, leave higher alone
008C88  1  20 52 8D                   jsr WritePPUReg1
008C8B  1  A9 24                      lda #$24                  ;set vram address to start of name table 1
008C8D  1  20 92 8C                   jsr WriteNTAddr
008C90  1  A9 20                      lda #$20                  ;and then set it to name table 0
008C92  1  8D 06 20     WriteNTAddr:  sta PPU_ADDRESS
008C95  1  A9 00                      lda #$00
008C97  1  8D 06 20                   sta PPU_ADDRESS
008C9A  1  A2 04                      ldx #$04                  ;clear name table with blank tile $24
008C9C  1  A0 C0                      ldy #$c0
008C9E  1  A9 24                      lda #$24
008CA0  1  8D 07 20     InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
008CA3  1  88                         dey
008CA4  1  D0 FA                      bne InitNTLoop
008CA6  1  CA                         dex
008CA7  1  D0 F7                      bne InitNTLoop
008CA9  1  A0 40                      ldy #64                   ;now to clear the attribute table (with zero this time)
008CAB  1  8A                         txa
008CAC  1  8D 00 03                   sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
008CAF  1  8D 01 03                   sta VRAM_Buffer1          ;init vram buffer 1
008CB2  1  8D 07 20     InitATLoop:   sta PPU_DATA
008CB5  1  88                         dey
008CB6  1  D0 FA                      bne InitATLoop
008CB8  1  8D 3F 07                   sta HorizontalScroll      ;reset scroll variables
008CBB  1  8D 40 07                   sta VerticalScroll
008CBE  1  4C 4B 8D                   jmp InitScroll            ;initialize scroll registers to zero
008CC1  1               
008CC1  1               ;------------------------------------------------------------------------------------
008CC1  1               
008CC1  1               ReadJoypads:
008CC1  1  A9 01                      lda #$01               ;reset and clear strobe of joypad ports
008CC3  1  8D 16 40                   sta JOYPAD_PORT
008CC6  1  4A                         lsr
008CC7  1  AA                         tax                    ;start with joypad 1's port
008CC8  1  8D 16 40                   sta JOYPAD_PORT
008CCB  1  20 CF 8C                   jsr ReadPortBits
008CCE  1  E8                         inx                    ;increment for joypad 2's port
008CCF  1  A0 08        ReadPortBits: ldy #$08
008CD1  1  48           PortLoop:     pha                    ;push previous bit onto stack
008CD2  1  BD 16 40                   lda JOYPAD_PORT,x      ;read current bit on joypad port
008CD5  1  85 00                      sta $00                ;check d1 and d0 of port output
008CD7  1  4A                         lsr                    ;this is necessary on the old
008CD8  1  05 00                      ora $00                ;famicom systems in japan
008CDA  1  4A                         lsr
008CDB  1  68                         pla                    ;read bits from stack
008CDC  1  2A                         rol                    ;rotate bit from carry flag
008CDD  1  88                         dey
008CDE  1  D0 F1                      bne PortLoop           ;count down bits left
008CE0  1  9D FC 06                   sta SavedJoypadBits,x  ;save controller status here always
008CE3  1  48                         pha
008CE4  1  29 30                      and #%00110000         ;check for select or start
008CE6  1  3D 4A 07                   and JoypadBitMask,x    ;if neither saved state nor current state
008CE9  1  F0 07                      beq Save8Bits          ;have any of these two set, branch
008CEB  1  68                         pla
008CEC  1  29 CF                      and #%11001111         ;otherwise store without select
008CEE  1  9D FC 06                   sta SavedJoypadBits,x  ;or start bits and leave
008CF1  1  60                         rts
008CF2  1  68           Save8Bits:    pla
008CF3  1  9D 4A 07                   sta JoypadBitMask,x    ;save with all bits in another place and leave
008CF6  1  60                         rts
008CF7  1               
008CF7  1               ;------------------------------------------------------------------------------------
008CF7  1               
008CF7  1               WriteBufferToScreen:
008CF7  1  8D 06 20                    sta PPU_ADDRESS           ;store high byte of vram address
008CFA  1  C8                          iny
008CFB  1  B1 00                       lda ($00),y               ;load next byte (second)
008CFD  1  8D 06 20                    sta PPU_ADDRESS           ;store low byte of vram address
008D00  1  C8                          iny
008D01  1  B1 00                       lda ($00),y               ;load next byte (third)
008D03  1  0A                          asl                       ;shift to left and save in stack
008D04  1  48                          pha
008D05  1  AD 78 07                    lda Mirror_PPU_CTRL
008D08  1  09 04                       ora #%00000100            ;set ppu to increment by 32 by default
008D0A  1  B0 02                       bcs SetupWrites           ;if d7 of third byte was clear, ppu will
008D0C  1  29 FB                       and #%11111011            ;only increment by 1
008D0E  1  20 52 8D     SetupWrites:   jsr WritePPUReg1          ;write to register
008D11  1  68                          pla                       ;pull from stack and shift to left again
008D12  1  0A                          asl
008D13  1  90 03                       bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
008D15  1  09 02                       ora #%00000010            ;otherwise set d1 and increment Y
008D17  1  C8                          iny
008D18  1  4A           GetLength:     lsr                       ;shift back to the right to get proper length
008D19  1  4A                          lsr                       ;note that d1 will now be in carry
008D1A  1  AA                          tax
008D1B  1  B0 01        OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
008D1D  1  C8                          iny                       ;otherwise increment Y to load next byte
008D1E  1  B1 00        RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
008D20  1  8D 07 20                    sta PPU_DATA
008D23  1  CA                          dex                       ;done writing?
008D24  1  D0 F5                       bne OutputToVRAM
008D26  1  38                          sec
008D27  1  98                          tya
008D28  1  65 00                       adc $00                   ;add end length plus one to the indirect at $00
008D2A  1  85 00                       sta $00                   ;to allow this routine to read another set of updates
008D2C  1  A9 00                       lda #$00
008D2E  1  65 01                       adc $01
008D30  1  85 01                       sta $01
008D32  1  A9 3F                       lda #$3f                  ;sets vram address to palette memory
008D34  1  8D 06 20                    sta PPU_ADDRESS
008D37  1  A9 00                       lda #$00
008D39  1  8D 06 20                    sta PPU_ADDRESS
008D3C  1  8D 06 20                    sta PPU_ADDRESS           ;then reinitializes it for some reason
008D3F  1  8D 06 20                    sta PPU_ADDRESS
008D42  1  AE 02 20     UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
008D45  1  A0 00                       ldy #$00                  ;load first byte from indirect as a pointer
008D47  1  B1 00                       lda ($00),y
008D49  1  D0 AC                       bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
008D4B  1  8D 05 20     InitScroll:    sta PPU_SCROLL            ;store contents of A into scroll registers
008D4E  1  8D 05 20                    sta PPU_SCROLL            ;and end whatever subroutine led us here
008D51  1  60                          rts
008D52  1               
008D52  1               ;------------------------------------------------------------------------------------
008D52  1               
008D52  1               WritePPUReg1:
008D52  1  8D 00 20                   sta PPU_CTRL              ;write contents of A to PPU register 1
008D55  1  8D 78 07                   sta Mirror_PPU_CTRL       ;and its mirror
008D58  1  60                         rts
008D59  1               
008D59  1               ;------------------------------------------------------------------------------------
008D59  1               ;$00 - used to store status bar nybbles
008D59  1               ;$02 - used as temp vram offset
008D59  1               ;$03 - used to store length of status bar number
008D59  1               
008D59  1               ;status bar name table offset and length data
008D59  1               StatusBarData:
008D59  1  EF 06              .byte $ef, $06 ; top score display on title screen
008D5B  1  62 06              .byte $62, $06 ; player score
008D5D  1  6D 02              .byte $6d, $02 ; coin tally
008D5F  1  7A 03              .byte $7a, $03 ; game timer
008D61  1               
008D61  1               StatusBarOffset:
008D61  1  06 0C 12 18        .byte $06, $0c, $12, $18
008D65  1               
008D65  1               PrintStatusBarNumbers:
008D65  1  85 00              sta $00            ;store player-specific offset
008D67  1  20 70 8D           jsr OutputNumbers  ;use first nybble to print the coin display
008D6A  1  A5 00              lda $00            ;move high nybble to low
008D6C  1  4A                 lsr                ;and print the score display
008D6D  1  4A                 lsr
008D6E  1  4A                 lsr
008D6F  1  4A                 lsr
008D70  1               
008D70  1               OutputNumbers:
008D70  1  18                        clc                      ;add 1 to low nybble
008D71  1  69 01                     adc #$01
008D73  1  29 0F                     and #%00001111           ;mask out high nybble
008D75  1  C9 06                     cmp #$06
008D77  1  B0 44                     bcs ExitOutputN
008D79  1  48                        pha                      ;save incremented value to stack for now and
008D7A  1  0A                        asl                      ;multiply by 2 to use as offset
008D7B  1  A8                        tay
008D7C  1  AE 00 03                  ldx VRAM_Buffer1_Offset  ;get current buffer pointer
008D7F  1  A9 20                     lda #$20                 ;put at top of screen by default
008D81  1  C0 00                     cpy #$00                 ;are we writing top score on title screen?
008D83  1  D0 02                     bne SetupNums
008D85  1  A9 22                     lda #$22                 ;if so, put further down on the screen
008D87  1  9D 01 03     SetupNums:   sta VRAM_Buffer1,x
008D8A  1  B9 59 8D                  lda StatusBarData,y      ;write vram address low and length of thing
008D8D  1  9D 02 03                  sta VRAM_Buffer1+1,x     ;we're printing to the buffer
008D90  1  B9 5A 8D                  lda StatusBarData+1,y
008D93  1  9D 03 03                  sta VRAM_Buffer1+2,x
008D96  1  85 03                     sta $03                  ;save length byte in counter
008D98  1  86 02                     stx $02                  ;and buffer pointer elsewhere for now
008D9A  1  68                        pla                      ;pull original incremented value from stack
008D9B  1  AA                        tax
008D9C  1  BD 61 8D                  lda StatusBarOffset,x    ;load offset to value we want to write
008D9F  1  38                        sec
008DA0  1  F9 5A 8D                  sbc StatusBarData+1,y    ;subtract from length byte we read before
008DA3  1  A8                        tay                      ;use value as offset to display digits
008DA4  1  A6 02                     ldx $02
008DA6  1  B9 D7 07     DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
008DA9  1  9D 04 03                  sta VRAM_Buffer1+3,x
008DAC  1  E8                        inx
008DAD  1  C8                        iny
008DAE  1  C6 03                     dec $03                  ;do this until all the digits are written
008DB0  1  D0 F4                     bne DigitPLoop
008DB2  1  A9 00                     lda #$00                 ;put null terminator at end
008DB4  1  9D 04 03                  sta VRAM_Buffer1+3,x
008DB7  1  E8                        inx                      ;increment buffer pointer by 3
008DB8  1  E8                        inx
008DB9  1  E8                        inx
008DBA  1  8E 00 03                  stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
008DBD  1  60           ExitOutputN: rts
008DBE  1               
008DBE  1               DigitsMathRoutine:
008DBE  1  AD 70 07                 lda OperMode              ;check mode of operation
008DC1  1  F0 16                    beq EraseDMods            ;if in attract mode, branch to lock score
008DC3  1  A2 05                    ldx #$05
008DC5  1  BD 34 01     AddModLoop: lda DigitModifier,x       ;load digit amount to increment
008DC8  1  18                       clc
008DC9  1  79 D7 07                 adc DisplayDigits,y       ;add to current digit
008DCC  1  30 16                    bmi BorrowOne             ;if result is a negative number, branch to subtract
008DCE  1  C9 0A                    cmp #10
008DD0  1  B0 19                    bcs CarryOne              ;if digit greater than $09, branch to add
008DD2  1  99 D7 07     StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
008DD5  1  88                       dey                       ;move onto next digits in score or game timer
008DD6  1  CA                       dex                       ;and digit amounts to increment
008DD7  1  10 EC                    bpl AddModLoop            ;loop back if we're not done yet
008DD9  1  A9 00        EraseDMods: lda #$00                  ;now we need to erase the digit modifiers
008DDB  1  A2 06                    ldx #$06                  ;start with the last digit
008DDD  1  9D 33 01     EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
008DE0  1  CA                       dex
008DE1  1  10 FA                    bpl EraseMLoop            ;do this until they're all reset, then leave
008DE3  1  60                       rts
008DE4  1               
008DE4  1  DE 33 01     BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
008DE7  1  A9 09                    lda #$09                  ;the game timer digit we're currently on to "borrow
008DE9  1  D0 E7                    bne StoreNewD             ;the one", then do an unconditional branch back
008DEB  1  38           CarryOne:   sec                       ;subtract ten from our digit to make it a
008DEC  1  E9 0A                    sbc #10                   ;proper BCD number, then increment the digit
008DEE  1  FE 33 01                 inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
008DF1  1  4C D2 8D                 jmp StoreNewD             ;go back to just after we branched here
008DF4  1               
008DF4  1               UpdateTopScore:
008DF4  1  A2 05                      ldx #$05                 ;start with the lowest digit
008DF6  1  A0 05                      ldy #$05
008DF8  1  38                         sec
008DF9  1  BD DD 07     GetScoreDiff: lda PlayerScoreDisplay,x ;subtract the regular score digit from each high score digit
008DFC  1  F9 D7 07                   sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
008DFF  1  CA                         dex                      ;the player score digit, borrow will be set until a subsequent
008E00  1  88                         dey                      ;subtraction clears it (player digit is higher than top)
008E01  1  10 F6                      bpl GetScoreDiff
008E03  1  90 0E                      bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
008E05  1  E8                         inx                      ;increment X and Y once to the start of the score
008E06  1  C8                         iny
008E07  1  BD DD 07     CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
008E0A  1  99 D7 07                   sta TopScoreDisplay,y
008E0D  1  E8                         inx
008E0E  1  C8                         iny
008E0F  1  C0 06                      cpy #$06                 ;do this until we have stored them all
008E11  1  90 F4                      bcc CopyScore
008E13  1  60           NoTopSc:      rts
008E14  1               
008E14  1               ;-------------------------------------------------------------------------------------
008E14  1               
008E14  1               DefaultSprOffsets:
008E14  1  04 30 48 60        .byte $04, $30, $48, $60, $78, $90, $a8, $c0
008E18  1  78 90 A8 C0  
008E1C  1  D8 E8 24 F8        .byte $d8, $e8, $24, $f8, $fc, $28, $2c
008E20  1  FC 28 2C     
008E23  1               
008E23  1               Sprite0Data:
008E23  1  18 EE 23 58        .byte $18, $ee, $23, $58
008E27  1               
008E27  1               ;-------------------------------------------------------------------------------------
008E27  1               
008E27  1               InitializeArea:
008E27  1  A0 4B                       ldy #$4b                 ;clear all memory again, only as far as $074b
008E29  1  20 F3 8E                    jsr InitializeMemory     ;this is only necessary in game mode
008E2C  1  A2 21                       ldx #$21
008E2E  1  A9 00                       lda #$00
008E30  1  9D 80 07     ClrTimersLoop: sta Timers,x             ;clear out timer memory
008E33  1  CA                          dex
008E34  1  10 FA                       bpl ClrTimersLoop
008E36  1  AD 5B 07                    lda HalfwayPage
008E39  1  AC 52 07                    ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
008E3C  1  F0 03                       beq StartPage
008E3E  1  AD 51 07                    lda EntrancePage         ;otherwise use saved entry page number here
008E41  1  8D 1A 07     StartPage:     sta ScreenLeft_PageLoc   ;set as value here
008E44  1  8D 25 07                    sta CurrentPageLoc       ;also set as current page
008E47  1  8D 28 07                    sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
008E4A  1  20 8B 9B                    jsr GetScreenPosition    ;get pixel coordinates for screen borders
008E4D  1  A0 20                       ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
008E4F  1  29 01                       and #%00000001           ;otherwise use $2080, this address used later as name table
008E51  1  F0 02                       beq SetInitNTHigh        ;address for rendering of game area
008E53  1  A0 24                       ldy #$24
008E55  1  8C 20 07     SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
008E58  1  A0 80                       ldy #$80
008E5A  1  8C 21 07                    sty CurrentNTAddr_Low
008E5D  1  0A                          asl                      ;store LSB of page number in high nybble
008E5E  1  0A                          asl                      ;of block buffer column position
008E5F  1  0A                          asl
008E60  1  0A                          asl
008E61  1  8D A0 06                    sta BlockBufferColumnPos
008E64  1  CE 30 07                    dec AreaObjectLength     ;set area object lengths for all empty
008E67  1  CE 31 07                    dec AreaObjectLength+1
008E6A  1  CE 32 07                    dec AreaObjectLength+2
008E6D  1  A9 0B                       lda #$0b                 ;set value for renderer to update 12 column sets
008E6F  1  8D 1E 07                    sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
008E72  1  20 39 FF                    jsr RunGetAreaDataAddrs  ;get enemy and level addresses and load header
008E75  1  AD FB 07                    lda HardWorldFlag        ;check to see if we're in worlds A-D
008E78  1  D0 10                       bne SetSecHard           ;if so, activate the secondary no matter where we're at
008E7A  1  AD 5F 07                    lda WorldNumber          ;otherwise check world number
008E7D  1  C9 03                       cmp #World4              ;if less than 4, do not activate secondary
008E7F  1  90 0C                       bcc CheckHalfway
008E81  1  D0 07                       bne SetSecHard           ;if not equal to, then world > 4, thus activate
008E83  1  AD 5C 07                    lda LevelNumber          ;otherwise, world 4, so check level number
008E86  1  C9 03                       cmp #Level4              ;if not 4, do not set secondary hard mode flag
008E88  1  90 03                       bcc CheckHalfway
008E8A  1  EE CC 06     SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 4-4 and beyond
008E8D  1  AD 5B 07     CheckHalfway:  lda HalfwayPage
008E90  1  F0 05                       beq DoneInitArea
008E92  1  A9 02                       lda #$02                 ;if halfway page set, overwrite start position from header
008E94  1  8D 10 07                    sta PlayerEntranceCtrl
008E97  1  A9 80        DoneInitArea:  lda #Silence             ;silence music
008E99  1  85 FB                       sta AreaMusicQueue
008E9B  1  A9 01                       lda #$01                 ;disable screen output
008E9D  1  8D 74 07                    sta DisableScreenFlag
008EA0  1  EE 72 07                    inc OperMode_Task        ;increment task for this mode
008EA3  1  60                          rts
008EA4  1               
008EA4  1               ;-------------------------------------------------------------------------------------
008EA4  1               
008EA4  1               SecondaryGameSetup:
008EA4  1  A9 00               lda #$00
008EA6  1  8D 74 07            sta DisableScreenFlag    ;reenable screen, reset some flags
008EA9  1  8D F9 07            sta WindFlag
008EAC  1  8D F6 07            sta FlagpoleMusicFlag
008EAF  1  A8                  tay
008EB0  1  99 00 03     ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
008EB3  1  C8                        iny
008EB4  1  D0 FA                     bne ClearVRLoop
008EB6  1  8D 59 07                  sta GameTimerExpiredFlag  ;clear game timer exp flag
008EB9  1  8D 69 07                  sta DisableIntermediate   ;clear skip lives display flag
008EBC  1  8D 28 07                  sta BackloadingFlag       ;clear value here
008EBF  1  A9 FF                     lda #$ff
008EC1  1  8D A0 03                  sta BalPlatformAlignment  ;initialize balance platform assignment flag
008EC4  1  AD 1A 07                  lda ScreenLeft_PageLoc    ;get left side page location
008EC7  1  29 01                     and #$01
008EC9  1  8D 7A 07                  sta NameTableSelect
008ECC  1  20 18 8F                  jsr GetAreaMusic
008ECF  1  A9 38                     lda #$38                  ;load sprite shuffle amounts to be used later
008ED1  1  8D E3 06                  sta SprShuffleAmt+2
008ED4  1  A9 48                     lda #$48
008ED6  1  8D E2 06                  sta SprShuffleAmt+1
008ED9  1  A9 58                     lda #$58
008EDB  1  8D E1 06                  sta SprShuffleAmt
008EDE  1  A2 0E                     ldx #$0e                  ;load default OAM offsets
008EE0  1  BD 14 8E     ShufAmtLoop: lda DefaultSprOffsets,x
008EE3  1  9D E4 06                  sta SprDataOffset,x
008EE6  1  CA                        dex                       ;do this until they're all set
008EE7  1  10 F7                     bpl ShufAmtLoop
008EE9  1  20 rr rr                  jsr BANK_PractiseEnterStage
008EEC  1                            ;REPLACED;jsr DoNothing1
008EEC  1  EE 22 07                  inc IRQUpdateFlag
008EEF  1  EE 72 07                  inc OperMode_Task
008EF2  1  60                        rts
008EF3  1               ;-------------------------------------------------------------------------------------
008EF3  1               
008EF3  1               InitializeMemory:
008EF3  1  A2 07                      ldx #$07          ;set initial high byte to $0700-$07ff
008EF5  1  A9 00                      lda #$00          ;set initial low byte to start of page (at $00 of page)
008EF7  1  85 06                      sta $06
008EF9  1  86 07        InitPageLoop: stx $07
008EFB  1  E0 01        InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
008EFD  1  D0 08                      bne InitByte      ;if not, go ahead anyway
008EFF  1  C0 60                      cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
008F01  1  B0 06                      bcs SkipByte      ;if so, skip write
008F03  1  C0 09                      cpy #$09          ;otherwise, check to see if we're at $0100-$0108
008F05  1  90 02                      bcc SkipByte      ;if so, skip write
008F07  1  91 06        InitByte:     sta ($06),y       ;otherwise, initialize memory
008F09  1  88           SkipByte:     dey
008F0A  1  C0 FF                      cpy #$ff          ;do this until all bytes in page have been erased
008F0C  1  D0 ED                      bne InitByteLoop
008F0E  1  CA                         dex               ;go onto the next page
008F0F  1  10 E8                      bpl InitPageLoop  ;do this until all desired pages of memory have been erased
008F11  1  60                         rts
008F12  1               
008F12  1               ;-------------------------------------------------------------------------------------
008F12  1               
008F12  1               MusicSelectData:
008F12  1  02 01 04 08        .byte WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
008F16  1  10 20              .byte CloudMusic, PipeIntroMusic
008F18  1               
008F18  1               GetAreaMusic:
008F18  1  AD 70 07                  lda OperMode           ;if in attract mode, leave
008F1B  1  F0 23                     beq ExitGetM
008F1D  1  AD 52 07                  lda AltEntranceControl ;check for specific alternate mode of entry
008F20  1  C9 02                     cmp #$02               ;if found, branch without checking starting position
008F22  1  F0 0D                     beq ChkAreaType        ;from area object data header
008F24  1  A0 05                     ldy #$05               ;select music for pipe intro scene by default
008F26  1  AD 10 07                  lda PlayerEntranceCtrl ;check value from level header for certain values
008F29  1  C9 06                     cmp #$06
008F2B  1  F0 0E                     beq StoreMusic         ;load music for pipe intro scene if header
008F2D  1  C9 07                     cmp #$07               ;start position either value $06 or $07
008F2F  1  F0 0A                     beq StoreMusic
008F31  1  AC 4E 07     ChkAreaType: ldy AreaType           ;load area type as offset for music bit
008F34  1  AD 43 07                  lda CloudTypeOverride
008F37  1  F0 02                     beq StoreMusic         ;check for cloud type override
008F39  1  A0 04                     ldy #$04               ;select music for cloud type level if found
008F3B  1  B9 12 8F     StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
008F3E  1  85 FB                     sta AreaMusicQueue     ;store in queue and leave
008F40  1  60           ExitGetM:    rts
008F41  1               
008F41  1               ;-------------------------------------------------------------------------------------
008F41  1               
008F41  1               PlayerStarting_X_Pos:
008F41  1  28 18              .byte $28, $18
008F43  1  38 28              .byte $38, $28
008F45  1               
008F45  1               AltYPosOffset:
008F45  1  08 00              .byte $08, $00
008F47  1               
008F47  1               PlayerStarting_Y_Pos:
008F47  1  00 20 B0 50        .byte $00, $20, $b0, $50, $00, $00, $b0, $b0
008F4B  1  00 00 B0 B0  
008F4F  1  F0                 .byte $f0
008F50  1               
008F50  1               PlayerBGPriorityData:
008F50  1  00 20 00 00        .byte $00, $20, $00, $00, $00, $00, $00, $00
008F54  1  00 00 00 00  
008F58  1               
008F58  1               GameTimerData:
008F58  1  20                 .byte $20 ;dummy byte, used as part of bg priority data
008F59  1  04 03 02           .byte $04, $03, $02
008F5C  1               
008F5C  1               Entrance_GameTimerSetup:
008F5C  1  AD 1A 07               lda ScreenLeft_PageLoc      ;set current page for area objects
008F5F  1  85 6D                  sta Player_PageLoc          ;as page location for player
008F61  1  A9 28                  lda #$28                    ;store value here
008F63  1  8D 0A 07               sta VerticalForceDown       ;for fractional movement downwards if necessary
008F66  1  A9 01                  lda #$01                    ;set high byte of player position and
008F68  1  85 33                  sta PlayerFacingDir         ;set facing direction so that player faces right
008F6A  1  85 B5                  sta Player_Y_HighPos
008F6C  1  A9 00                  lda #$00                    ;set player state to on the ground by default
008F6E  1  85 1D                  sta Player_State
008F70  1  CE 90 04               dec Player_CollisionBits    ;initialize player's collision bits
008F73  1  A0 00                  ldy #$00                    ;initialize halfway page
008F75  1  8C 5B 07               sty HalfwayPage
008F78  1  AD 4E 07               lda AreaType                ;check area type
008F7B  1  D0 01                  bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
008F7D  1  C8                     iny
008F7E  1  8C 04 07     ChkStPos: sty SwimmingFlag
008F81  1  AE 10 07               ldx PlayerEntranceCtrl      ;get starting position loaded from header
008F84  1  AC 52 07               ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
008F87  1  F0 07                  beq SetStPos
008F89  1  C0 01                  cpy #$01
008F8B  1  F0 03                  beq SetStPos
008F8D  1  BE 43 8F               ldx AltYPosOffset-2,y       ;if not 0 or 1, override start pos from header with alt offset
008F90  1  B9 41 8F     SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
008F93  1  85 86                  sta Player_X_Position       ;and vertical positions for the player, using
008F95  1  BD 47 8F               lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either
008F98  1  85 CE                  sta Player_Y_Position       ;the original offset from the header or alt offset for vertical
008F9A  1  BD 50 8F               lda PlayerBGPriorityData,x
008F9D  1  8D C4 03               sta Player_SprAttrib        ;set player sprite attributes using offset in X
008FA0  1  20 03 85               jsr GetPlayerColors         ;get appropriate player palette
008FA3  1  AC 15 07               ldy GameTimerSetting        ;get timer control value from header
008FA6  1  F0 1A                  beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
008FA8  1  AD 57 07               lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
008FAB  1  F0 15                  beq ChkOverR                ;old game timer setting
008FAD  1  B9 58 8F               lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
008FB0  1  8D EC 07               sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
008FB3  1  A9 01                  lda #$01
008FB5  1  8D EE 07               sta GameTimerDisplay+2      ;set last digit of game timer to 1
008FB8  1  4A                     lsr
008FB9  1  8D ED 07               sta GameTimerDisplay+1      ;set second digit of game timer
008FBC  1  8D 57 07               sta FetchNewGameTimerFlag   ;clear flag for game timer reset
008FBF  1  8D 9F 07               sta StarInvincibleTimer     ;clear star mario timer
008FC2  1  AC 58 07     ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
008FC5  1  F0 14                  beq ChkSwimE
008FC7  1  A9 03                  lda #$03                    ;set player state to climbing
008FC9  1  85 1D                  sta Player_State
008FCB  1  A2 00                  ldx #$00                    ;set offset for first slot, for block object
008FCD  1  20 70 A9               jsr InitBlock_XY_Pos
008FD0  1  A9 F0                  lda #$f0                    ;set vertical coordinate for block object
008FD2  1  85 D7                  sta Block_Y_Position
008FD4  1  A2 05                  ldx #$05                    ;set offset in X for last enemy object buffer slot
008FD6  1  A0 00                  ldy #$00                    ;set offset in Y for object coordinates used earlier
008FD8  1  20 D5 A4               jsr Setup_Vine              ;do a sub to grow vine
008FDB  1  AC 4E 07     ChkSwimE: ldy AreaType                ;if level not water-type,
008FDE  1  D0 03                  bne SetPESub                ;skip this subroutine
008FE0  1  20 B0 A2               jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
008FE3  1  A9 07        SetPESub: lda #$07                    ;set to run player entrance subroutine
008FE5  1  85 0E                  sta GameEngineSubroutine    ;on the next frame of game engine
008FE7  1  60                     rts
008FE8  1               
008FE8  1               ;-------------------------------------------------------------------------------------
008FE8  1               
008FE8  1               ;page numbers are in order from level numbers 1 to 4
008FE8  1               HalfwayPageNybbles:
008FE8  1  66 60              .byte $66, $60
008FEA  1  88 60              .byte $88, $60
008FEC  1  66 70              .byte $66, $70
008FEE  1  77 60              .byte $77, $60
008FF0  1  D6 00              .byte $d6, $00
008FF2  1  77 80              .byte $77, $80
008FF4  1  70 B0              .byte $70, $b0
008FF6  1  00 00              .byte $00, $00
008FF8  1  00 00              .byte $00, $00
008FFA  1  76 50              .byte $76, $50 ;worlds A-D halfway pages
008FFC  1  65 50              .byte $65, $50
008FFE  1  75 B0              .byte $75, $b0
009000  1  00 00              .byte $00, $00
009002  1               
009002  1               PlayerLoseLife:
009002  1  EE 74 07                  inc DisableScreenFlag    ;disable screen and IRQs
009005  1  A9 00                     lda #$00
009007  1  8D 22 07                  sta IRQUpdateFlag
00900A  1  A9 80                     lda #Silence             ;silence music
00900C  1  85 FC                     sta EventMusicQueue
00900E  1  CE 5A 07                  dec NumberofLives        ;take one life from player
009011  1  10 0B                     bpl StillInGame          ;if player still has lives, branch
009013  1  A9 00                     lda #$00
009015  1  8D 72 07                  sta OperMode_Task        ;initialize mode task,
009018  1  A9 03                     lda #GameOverMode        ;switch to game over mode
00901A  1  8D 70 07                  sta OperMode             ;and leave
00901D  1  60                        rts
00901E  1  AD 5F 07     StillInGame: lda WorldNumber          ;retrieve world number for offset
009021  1  AC FB 07                  ldy HardWorldFlag        ;check if playing worlds A-D
009024  1  F0 03                     beq NrmlWorlds           ;if not, use world number as-is
009026  1  18                        clc                      ;otherwise add nine for correct halfway pages
009027  1  69 09                     adc #$09
009029  1  0A           NrmlWorlds:  asl                      ;multiply by 2 to get offset
00902A  1  AA                        tax
00902B  1  AD 5C 07                  lda LevelNumber          ;if in level 3 or 4, increment
00902E  1  29 02                     and #$02                 ;offset by one byte, otherwise
009030  1  F0 01                     beq GetHalfway           ;leave offset alone
009032  1  E8                        inx
009033  1  BC E8 8F     GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
009036  1  AD 5C 07                  lda LevelNumber          ;check area number's LSB
009039  1  4A                        lsr
00903A  1  98                        tya                      ;if in level 2 or 4, use lower nybble
00903B  1  B0 04                     bcs MaskHPNyb
00903D  1  4A                        lsr                      ;move higher nybble to lower if
00903E  1  4A                        lsr                      ;level number is 1 or 3
00903F  1  4A                        lsr
009040  1  4A                        lsr
009041  1  29 0F        MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
009043  1  CD 1A 07                  cmp ScreenLeft_PageLoc
009046  1  F0 04                     beq SetHalfway           ;left side of screen must be at the halfway page,
009048  1  90 02                     bcc SetHalfway           ;otherwise player must start at the
00904A  1  A9 00                     lda #$00                 ;beginning of the level
00904C  1  8D 5B 07     SetHalfway:  sta HalfwayPage          ;store as halfway page for player
00904F  1  4C 98 90                  jmp ContinueGame         ;continue the game
009052  1               
009052  1               ;-------------------------------------------------------------------------------------
009052  1               
009052  1               GameOverSubs:
009052  1  AD 72 07           lda OperMode_Task
009055  1  20 69 8C           jsr JumpEngine
009058  1               
009058  1  5E 90              .word SetupGameOver
00905A  1  77 84              .word ScreenRoutines
00905C  1  74 90              .word RunGameOver
00905E  1               
00905E  1               ;-------------------------------------------------------------------------------------
00905E  1               
00905E  1               SetupGameOver:
00905E  1  A9 00              lda #$00
009060  1  8D 3C 07           sta ScreenRoutineTask
009063  1  8D 22 07           sta IRQUpdateFlag  ;disable IRQ check
009066  1  8D F8 07           sta ContinueMenuSelect ;set continue as default choice
009069  1  A9 02              lda #$02
00906B  1  85 FC              sta EventMusicQueue    ;play game over music
00906D  1  EE 74 07           inc DisableScreenFlag
009070  1  EE 72 07           inc OperMode_Task
009073  1  60                 rts
009074  1               
009074  1               RunGameOver:
009074  1  A9 00               lda #$00
009076  1  8D 74 07            sta DisableScreenFlag
009079  1  AD 5F 07            lda WorldNumber       ;if on world 9, branch on to end the game
00907C  1  C9 08               cmp #World9
00907E  1  F0 03               beq W9End
009080  1  4C 81 E0            jmp GameOverMenu      ;otherwise run game over menu
009083  1  AD A0 07     W9End: lda ScreenTimer
009086  1  D0 0F               bne ExRGO
009088  1               
009088  1               TerminateGame:
009088  1  A9 80               lda #Silence          ;silence music
00908A  1  85 FC               sta EventMusicQueue
00908C  1  A9 00               lda #$00
00908E  1  8D 72 07            sta OperMode_Task     ;reset to attract mode and leave
009091  1  8D A0 07            sta ScreenTimer
009094  1  8D 70 07            sta OperMode
009097  1  60           ExRGO: rts
009098  1               
009098  1               ContinueGame:
009098  1  20 29 FF                jsr RunLoadAreaPointer    ;update level pointer with
00909B  1  A9 01                   lda #$01                  ;actual world and area numbers, then
00909D  1  8D 54 07                sta PlayerSize            ;reset player's size, status, and
0090A0  1  EE 57 07                inc FetchNewGameTimerFlag ;set game timer flag to reload
0090A3  1  A9 00                   lda #$00                  ;game timer from header
0090A5  1  8D 47 07                sta TimerControl          ;also set flag for timers to count again
0090A8  1  8D 56 07                sta PlayerStatus
0090AB  1  85 0E                   sta GameEngineSubroutine  ;reset task for game core
0090AD  1  8D 72 07                sta OperMode_Task         ;set modes and leave
0090B0  1  A9 01                   lda #$01                  ;if in game over mode, switch back to
0090B2  1  8D 70 07                sta OperMode              ;game mode, because game is still on
0090B5  1  60           GameIsOn:  rts
0090B6  1               
0090B6  1               ;-------------------------------------------------------------------------------------
0090B6  1               
0090B6  1               DoNothing:
0090B6  1  A9 FF              lda #$ff       ;this is residual code, this value is
0090B8  1  8D C9 06           sta $06c9      ;not used anywhere in the program
0090BB  1  60                 rts
0090BC  1               
0090BC  1               ;-------------------------------------------------------------------------------------
0090BC  1               
0090BC  1               AreaParserTaskHandler:
0090BC  1  AC 1F 07                   ldy AreaParserTaskNum     ;check number of tasks here
0090BF  1  D0 05                      bne DoAPTasks             ;if already set, go ahead
0090C1  1  A0 08                      ldy #$08
0090C3  1  8C 1F 07                   sty AreaParserTaskNum     ;otherwise, set eight by default
0090C6  1  88           DoAPTasks:    dey
0090C7  1  98                         tya
0090C8  1  20 D4 90                   jsr AreaParserTasks
0090CB  1  CE 1F 07                   dec AreaParserTaskNum     ;if all tasks not complete do not
0090CE  1  D0 03                      bne SkipATRender          ;render attribute table yet
0090D0  1  20 1F 88                   jsr RenderAttributeTables
0090D3  1  60           SkipATRender: rts
0090D4  1               
0090D4  1               AreaParserTasks:
0090D4  1  20 69 8C           jsr JumpEngine
0090D7  1               
0090D7  1  E7 90              .word IncrementColumnPos
0090D9  1  63 87              .word RenderAreaGraphics
0090DB  1  63 87              .word RenderAreaGraphics
0090DD  1  08 92              .word AreaParserCore
0090DF  1  E7 90              .word IncrementColumnPos
0090E1  1  63 87              .word RenderAreaGraphics
0090E3  1  63 87              .word RenderAreaGraphics
0090E5  1  08 92              .word AreaParserCore
0090E7  1               
0090E7  1               ;-------------------------------------------------------------------------------------
0090E7  1               
0090E7  1               IncrementColumnPos:
0090E7  1  EE 26 07                inc CurrentColumnPos     ;increment column where we're at
0090EA  1  AD 26 07                lda CurrentColumnPos
0090ED  1  29 0F                   and #%00001111           ;mask out higher nybble
0090EF  1  D0 06                   bne NoColWrap
0090F1  1  8D 26 07                sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
0090F4  1  EE 25 07                inc CurrentPageLoc       ;and increment page number where we're at
0090F7  1  EE A0 06     NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
0090FA  1  AD A0 06                lda BlockBufferColumnPos
0090FD  1  29 1F                   and #%00011111           ;mask out all but 5 LSB (0-1f)
0090FF  1  8D A0 06                sta BlockBufferColumnPos ;and save
009102  1  60                      rts
009103  1               
009103  1               ;-------------------------------------------------------------------------------------
009103  1               ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
009103  1               ;$01 - used to store floor byte for terrain
009103  1               ;$07 - used to store terrain metatile
009103  1               ;$06-$07 - used to store block buffer address
009103  1               
009103  1               BSceneDataOffsets:
009103  1  00 30 60           .byte $00, $30, $60
009106  1               
009106  1               BackSceneryData:
009106  1  93 00 00 11     .byte $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
00910A  1  12 12 13 00  
00910E  1  00 51 52 53     .byte $00, $51, $52, $53, $00, $00, $00, $00
009112  1  00 00 00 00  
009116  1  00 00 01 02     .byte $00, $00, $01, $02, $02, $03, $00, $00
00911A  1  02 03 00 00  
00911E  1  00 00 00 00     .byte $00, $00, $00, $00, $91, $92, $93, $00
009122  1  91 92 93 00  
009126  1  00 00 00 51     .byte $00, $00, $00, $51, $52, $53, $41, $42
00912A  1  52 53 41 42  
00912E  1  43 00 00 00     .byte $43, $00, $00, $00, $00, $00, $91, $92
009132  1  00 00 91 92  
009136  1               
009136  1  97 87 88 89     .byte $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
00913A  1  99 00 00 00  
00913E  1  11 12 13 A4     .byte $11, $12, $13, $a4, $a5, $a5, $a5, $a6
009142  1  A5 A5 A5 A6  
009146  1  97 98 99 01     .byte $97, $98, $99, $01, $02, $03, $00, $a4
00914A  1  02 03 00 A4  
00914E  1  A5 A6 00 11     .byte $a5, $a6, $00, $11, $12, $12, $12, $13
009152  1  12 12 12 13  
009156  1  00 00 00 00     .byte $00, $00, $00, $00, $01, $02, $02, $03
00915A  1  01 02 02 03  
00915E  1  00 A4 A5 A5     .byte $00, $a4, $a5, $a5, $a6, $00, $00, $00
009162  1  A6 00 00 00  
009166  1               
009166  1  11 12 12 13     .byte $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
00916A  1  00 00 00 00  
00916E  1  00 00 00 9C     .byte $00, $00, $00, $9c, $00, $8b, $aa, $aa
009172  1  00 8B AA AA  
009176  1  AA AA 11 12     .byte $aa, $aa, $11, $12, $13, $8b, $00, $9c
00917A  1  13 8B 00 9C  
00917E  1  9C 00 00 01     .byte $9c, $00, $00, $01, $02, $03, $11, $12
009182  1  02 03 11 12  
009186  1  12 13 00 00     .byte $12, $13, $00, $00, $00, $00, $aa, $aa
00918A  1  00 00 AA AA  
00918E  1  9C AA 00 8B     .byte $9c, $aa, $00, $8b, $00, $01, $02, $03
009192  1  00 01 02 03  
009196  1               
009196  1               BackSceneryMetatiles:
009196  1  80 83 00        .byte $80, $83, $00 ;cloud left
009199  1  81 84 00        .byte $81, $84, $00 ;cloud middle
00919C  1  82 85 00        .byte $82, $85, $00 ;cloud right
00919F  1  02 00 00        .byte $02, $00, $00 ;bush left
0091A2  1  03 00 00        .byte $03, $00, $00 ;bush middle
0091A5  1  04 00 00        .byte $04, $00, $00 ;bush right
0091A8  1  00 05 06        .byte $00, $05, $06 ;mountain left
0091AB  1  07 06 0A        .byte $07, $06, $0a ;mountain middle
0091AE  1  00 08 09        .byte $00, $08, $09 ;mountain right
0091B1  1  4D 00 00        .byte $4d, $00, $00 ;fence
0091B4  1  0D 0F 4E        .byte $0d, $0f, $4e ;tall tree
0091B7  1  0E 4E 4E        .byte $0e, $4e, $4e ;short tree
0091BA  1               
0091BA  1               FSceneDataOffsets:
0091BA  1  00 0D 1A           .byte $00, $0d, $1a
0091BD  1               
0091BD  1               ForeSceneryData:
0091BD  1  86 87 87 87     .byte $86, $87, $87, $87, $87, $87, $87   ;in water
0091C1  1  87 87 87     
0091C4  1  87 87 87 87     .byte $87, $87, $87, $87, $6a, $6a
0091C8  1  6A 6A        
0091CA  1               
0091CA  1  00 00 00 00     .byte $00, $00, $00, $00, $00, $45, $47   ;wall
0091CE  1  00 45 47     
0091D1  1  47 47 47 47     .byte $47, $47, $47, $47, $00, $00
0091D5  1  00 00        
0091D7  1               
0091D7  1  00 00 00 00     .byte $00, $00, $00, $00, $00, $00, $00   ;over water
0091DB  1  00 00 00     
0091DE  1  00 00 00 00     .byte $00, $00, $00, $00, $86, $87
0091E2  1  86 87        
0091E4  1               
0091E4  1               TerrainMetatiles:
0091E4  1  6A 6B 50 63        .byte $6a, $6b, $50, $63
0091E8  1               
0091E8  1               TerrainRenderBits:
0091E8  1  00 00              .byte %00000000, %00000000 ;no ceiling or floor
0091EA  1  00 18              .byte %00000000, %00011000 ;no ceiling, floor 2
0091EC  1  01 18              .byte %00000001, %00011000 ;ceiling 1, floor 2
0091EE  1  07 18              .byte %00000111, %00011000 ;ceiling 3, floor 2
0091F0  1  0F 18              .byte %00001111, %00011000 ;ceiling 4, floor 2
0091F2  1  FF 18              .byte %11111111, %00011000 ;ceiling 8, floor 2
0091F4  1  01 1F              .byte %00000001, %00011111 ;ceiling 1, floor 5
0091F6  1  07 1F              .byte %00000111, %00011111 ;ceiling 3, floor 5
0091F8  1  0F 1F              .byte %00001111, %00011111 ;ceiling 4, floor 5
0091FA  1  81 1F              .byte %10000001, %00011111 ;ceiling 1, floor 6
0091FC  1  01 00              .byte %00000001, %00000000 ;ceiling 1, no floor
0091FE  1  8F 1F              .byte %10001111, %00011111 ;ceiling 4, floor 6
009200  1  F1 1F              .byte %11110001, %00011111 ;ceiling 1, floor 9
009202  1  F9 18              .byte %11111001, %00011000 ;ceiling 1, middle 5, floor 2
009204  1  F1 18              .byte %11110001, %00011000 ;ceiling 1, middle 4, floor 2
009206  1  FF 1F              .byte %11111111, %00011111 ;completely solid top to bottom
009208  1               
009208  1               AreaParserCore:
009208  1  AD 28 07           lda BackloadingFlag       ;check to see if we are starting right of start
00920B  1  F0 03              beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
00920D  1  20 14 93           jsr ProcessAreaData       ;otherwise skip ahead and load level data
009210  1               
009210  1               RenderSceneryTerrain:
009210  1  A2 0C                  ldx #$0c
009212  1  A9 00                  lda #$00
009214  1  9D A1 06     ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
009217  1  CA                     dex
009218  1  10 FA                  bpl ClrMTBuf
00921A  1  AC 42 07               ldy BackgroundScenery      ;do we need to render the background scenery?
00921D  1  F0 42                  beq RendFore               ;if not, skip to check the foreground
00921F  1  AD 25 07               lda CurrentPageLoc         ;otherwise check for every third page
009222  1  C9 03        ThirdP:   cmp #$03
009224  1  30 05                  bmi RendBack               ;if less than three we're there
009226  1  38                     sec
009227  1  E9 03                  sbc #$03                   ;if 3 or more, subtract 3 and
009229  1  10 F7                  bpl ThirdP                 ;do an unconditional branch
00922B  1  0A           RendBack: asl                        ;move results to higher nybble
00922C  1  0A                     asl
00922D  1  0A                     asl
00922E  1  0A                     asl
00922F  1  79 02 91               adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
009232  1  6D 26 07               adc CurrentColumnPos       ;add to the result our current column position
009235  1  AA                     tax
009236  1  BD 06 91               lda BackSceneryData,x      ;load data from sum of offsets
009239  1  F0 26                  beq RendFore               ;if zero, no scenery for that part
00923B  1  48                     pha
00923C  1  29 0F                  and #$0f                   ;save to stack and clear high nybble
00923E  1  38                     sec
00923F  1  E9 01                  sbc #$01                   ;subtract one (because low nybble is $01-$0c)
009241  1  85 00                  sta $00                    ;save low nybble
009243  1  0A                     asl                        ;multiply by three (shift to left and add result to old one)
009244  1  65 00                  adc $00                    ;note that since d7 was nulled, the carry flag is always clear
009246  1  AA                     tax                        ;save as offset for background scenery metatile data
009247  1  68                     pla                        ;get high nybble from stack, move low
009248  1  4A                     lsr
009249  1  4A                     lsr
00924A  1  4A                     lsr
00924B  1  4A                     lsr
00924C  1  A8                     tay                        ;use as second offset (used to determine height)
00924D  1  A9 03                  lda #$03                   ;use previously saved memory location for counter
00924F  1  85 00                  sta $00
009251  1  BD 96 91     SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
009254  1  99 A1 06               sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
009257  1  E8                     inx
009258  1  C8                     iny
009259  1  C0 0B                  cpy #$0b                   ;if at this location, leave loop
00925B  1  F0 04                  beq RendFore
00925D  1  C6 00                  dec $00                    ;decrement until counter expires, barring exception
00925F  1  D0 F0                  bne SceLoop1
009261  1  AE 41 07     RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
009264  1  F0 13                  beq RendTerr               ;if not, skip this part
009266  1  BC B9 91               ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
009269  1  A2 00                  ldx #$00                   ;reinit X
00926B  1  B9 BD 91     SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
00926E  1  F0 03                  beq NoFore                 ;do not store if zero found
009270  1  9D A1 06               sta MetatileBuffer,x
009273  1  C8           NoFore:   iny
009274  1  E8                     inx
009275  1  E0 0D                  cpx #$0d                   ;store up to end of metatile buffer
009277  1  D0 F2                  bne SceLoop2
009279  1  AC 4E 07     RendTerr: ldy AreaType               ;check world type for water level
00927C  1  D0 0C                  bne TerMTile               ;if not water level, skip this part
00927E  1  AD 5F 07               lda WorldNumber            ;check world number, if not world number eight
009281  1  C9 07                  cmp #World8                ;then skip this part
009283  1  D0 05                  bne TerMTile
009285  1  A9 63                  lda #$63                   ;if set as water level and world number eight,
009287  1  4C 94 92               jmp StoreMT                ;use castle wall metatile as terrain type
00928A  1  B9 E4 91     TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
00928D  1  AC 43 07               ldy CloudTypeOverride      ;check for cloud type override
009290  1  F0 02                  beq StoreMT                ;if not set, keep value otherwise
009292  1  A9 88                  lda #$88                   ;use cloud block terrain
009294  1  85 07        StoreMT:  sta $07                    ;store value here
009296  1  A2 00                  ldx #$00                   ;initialize X, use as metatile buffer offset
009298  1  AD 27 07               lda TerrainControl         ;use yet another value from the header
00929B  1  0A                     asl                        ;multiply by 2 and use as yet another offset
00929C  1  A8                     tay
00929D  1  B9 E8 91     TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
0092A0  1  85 00                  sta $00
0092A2  1  C8                     iny                        ;increment Y and use as offset next time around
0092A3  1  84 01                  sty $01
0092A5  1  AD 43 07               lda CloudTypeOverride      ;skip if value here is zero
0092A8  1  F0 0A                  beq NoCloud2
0092AA  1  E0 00                  cpx #$00                   ;otherwise, check if we're doing the ceiling byte
0092AC  1  F0 06                  beq NoCloud2
0092AE  1  A5 00                  lda $00                    ;if not, mask out all but d3
0092B0  1  29 08                  and #%00001000
0092B2  1  85 00                  sta $00
0092B4  1  A0 00        NoCloud2: ldy #$00                   ;start at beginning of bitmasks
0092B6  1  B9 BB B2     TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
0092B9  1  24 00                  bit $00
0092BB  1  F0 05                  beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
0092BD  1  A5 07                  lda $07
0092BF  1  9D A1 06               sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
0092C2  1  E8           NextTBit: inx                        ;continue until end of buffer
0092C3  1  E0 0D                  cpx #$0d
0092C5  1  F0 18                  beq RendBBuf               ;if we're at the end, break out of this loop
0092C7  1  AD 4E 07               lda AreaType               ;check world type for underground area
0092CA  1  C9 02                  cmp #$02
0092CC  1  D0 08                  bne EndUChk                ;if not underground, skip this part
0092CE  1  E0 0B                  cpx #$0b
0092D0  1  D0 04                  bne EndUChk                ;if we're at the bottom of the screen, override
0092D2  1  A9 6B                  lda #$6b                   ;old terrain type with ground level terrain type
0092D4  1  85 07                  sta $07
0092D6  1  C8           EndUChk:  iny                        ;increment bitmasks offset in Y
0092D7  1  C0 08                  cpy #$08
0092D9  1  D0 DB                  bne TerrBChk               ;if not all bits checked, loop back
0092DB  1  A4 01                  ldy $01
0092DD  1  D0 BE                  bne TerrLoop               ;unconditional branch, use Y to load next byte
0092DF  1  20 14 93     RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
0092E2  1  AD A0 06               lda BlockBufferColumnPos
0092E5  1  20 1D 9A               jsr GetBlockBufferAddr     ;get block buffer address from where we're at
0092E8  1  A2 00                  ldx #$00
0092EA  1  A0 00                  ldy #$00                   ;init index regs and start at beginning of smaller buffer
0092EC  1  84 00        ChkMTLow: sty $00
0092EE  1  BD A1 06               lda MetatileBuffer,x       ;load stored metatile number
0092F1  1  29 C0                  and #%11000000             ;mask out all but 2 MSB
0092F3  1  0A                     asl
0092F4  1  2A                     rol                        ;make %xx000000 into %000000xx
0092F5  1  2A                     rol
0092F6  1  A8                     tay                        ;use as offset in Y
0092F7  1  BD A1 06               lda MetatileBuffer,x       ;reload original unmasked value here
0092FA  1  D9 10 93               cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
0092FD  1  B0 02                  bcs StrBlock               ;if equal or greater, branch
0092FF  1  A9 00                  lda #$00                   ;if less, init value before storing
009301  1  A4 00        StrBlock: ldy $00                    ;get offset for block buffer
009303  1  91 06                  sta ($06),y                ;store value into block buffer
009305  1  98                     tya
009306  1  18                     clc                        ;add 16 (move down one row) to offset
009307  1  69 10                  adc #$10
009309  1  A8                     tay
00930A  1  E8                     inx                        ;increment column value
00930B  1  E0 0D                  cpx #$0d
00930D  1  90 DD                  bcc ChkMTLow               ;continue until we pass last row, then leave
00930F  1  60                     rts
009310  1               
009310  1               ;numbers lower than these with the same attribute bits
009310  1               ;will not be stored in the block buffer
009310  1               BlockBuffLowBounds:
009310  1  10 4F 88 C0        .byte $10, $4f, $88, $c0
009314  1               
009314  1               ;-------------------------------------------------------------------------------------
009314  1               ;$00 - used to store area object identifier
009314  1               ;$07 - used as adder to find proper area object code
009314  1               
009314  1               ProcessAreaData:
009314  1  A2 02                    ldx #$02                 ;start at the end of area object buffer
009316  1  86 08        ProcADLoop: stx ObjectOffset
009318  1  A9 00                    lda #$00                 ;reset flag
00931A  1  8D 29 07                 sta BehindAreaParserFlag
00931D  1  AC 2C 07                 ldy AreaDataOffset       ;get offset of area data pointer
009320  1  B1 E7                    lda (AreaData),y         ;get first byte of area object
009322  1  C9 FD                    cmp #$fd                 ;if end-of-area, skip all this crap
009324  1  F0 4B                    beq RdyDecode
009326  1  BD 30 07                 lda AreaObjectLength,x   ;check area object buffer flag
009329  1  10 46                    bpl RdyDecode            ;if buffer not negative, branch, otherwise
00932B  1  C8                       iny
00932C  1  B1 E7                    lda (AreaData),y         ;get second byte of area object
00932E  1  0A                       asl                      ;check for page select bit (d7), branch if not set
00932F  1  90 0B                    bcc Chk1Row13
009331  1  AD 2B 07                 lda AreaObjectPageSel    ;check page select
009334  1  D0 06                    bne Chk1Row13
009336  1  EE 2B 07                 inc AreaObjectPageSel    ;if not already set, set it now
009339  1  EE 2A 07                 inc AreaObjectPageLoc    ;and increment page location
00933C  1  88           Chk1Row13:  dey
00933D  1  B1 E7                    lda (AreaData),y         ;reread first byte of level object
00933F  1  29 0F                    and #$0f                 ;mask out high nybble
009341  1  C9 0D                    cmp #$0d                 ;row 13?
009343  1  D0 1B                    bne Chk1Row14
009345  1  C8                       iny                      ;if so, reread second byte of level object
009346  1  B1 E7                    lda (AreaData),y
009348  1  88                       dey                      ;decrement to get ready to read first byte
009349  1  29 40                    and #%01000000           ;check for d6 set (if not, object is page control)
00934B  1  D0 1C                    bne CheckRear
00934D  1  AD 2B 07                 lda AreaObjectPageSel    ;if page select is set, do not reread
009350  1  D0 17                    bne CheckRear
009352  1  C8                       iny                      ;if d6 not set, reread second byte
009353  1  B1 E7                    lda (AreaData),y
009355  1  29 1F                    and #%00011111           ;mask out all but 5 LSB and store in page control
009357  1  8D 2A 07                 sta AreaObjectPageLoc
00935A  1  EE 2B 07                 inc AreaObjectPageSel    ;increment page select
00935D  1  4C 7A 93                 jmp NextAObj
009360  1  C9 0E        Chk1Row14:  cmp #$0e                 ;row 14?
009362  1  D0 05                    bne CheckRear
009364  1  AD 28 07                 lda BackloadingFlag      ;check flag for saved page number and branch if set
009367  1  D0 08                    bne RdyDecode            ;to render the object (otherwise bg might not look right)
009369  1  AD 2A 07     CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
00936C  1  CD 25 07                 cmp CurrentPageLoc       ;behind current page of renderer
00936F  1  90 06                    bcc SetBehind            ;if so branch
009371  1  20 A1 93     RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
009374  1  4C 7D 93                 jmp ChkLength
009377  1  EE 29 07     SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
00937A  1  20 95 93     NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
00937D  1  A6 08        ChkLength:  ldx ObjectOffset         ;get buffer offset
00937F  1  BD 30 07                 lda AreaObjectLength,x   ;check object length for anything stored here
009382  1  30 03                    bmi ProcLoopb            ;if not, branch to handle loopback
009384  1  DE 30 07                 dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
009387  1  CA           ProcLoopb:  dex                      ;decrement buffer offset
009388  1  10 8C                    bpl ProcADLoop           ;and loopback unless exceeded buffer
00938A  1  AD 29 07                 lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
00938D  1  D0 85                    bne ProcessAreaData      ;branch if true to load more level data, otherwise
00938F  1  AD 28 07                 lda BackloadingFlag      ;check for flag set if starting right of page $00
009392  1  D0 80                    bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
009394  1  60           EndAParse:  rts
009395  1               
009395  1               IncAreaObjOffset:
009395  1  EE 2C 07           inc AreaDataOffset    ;increment offset of level pointer
009398  1  EE 2C 07           inc AreaDataOffset
00939B  1  A9 00              lda #$00              ;reset page select
00939D  1  8D 2B 07           sta AreaObjectPageSel
0093A0  1  60                 rts
0093A1  1               
0093A1  1               DecodeAreaData:
0093A1  1  BD 30 07               lda AreaObjectLength,x     ;check current buffer flag
0093A4  1  30 03                  bmi Chk1stB
0093A6  1  BC 2D 07               ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
0093A9  1  A2 10        Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
0093AB  1  B1 E7                  lda (AreaData),y           ;get first byte of level object again
0093AD  1  C9 FD                  cmp #$fd
0093AF  1  F0 E3                  beq EndAParse              ;if end of level, leave this routine
0093B1  1  29 0F                  and #$0f                   ;otherwise, mask out low nybble
0093B3  1  C9 0F                  cmp #$0f                   ;row 15?
0093B5  1  F0 08                  beq ChkRow14               ;if so, keep the offset of 16
0093B7  1  A2 08                  ldx #$08                   ;otherwise load offset of 8 for special row 12
0093B9  1  C9 0C                  cmp #$0c                   ;row 12?
0093BB  1  F0 02                  beq ChkRow14               ;if so, keep the offset value of 8
0093BD  1  A2 00                  ldx #$00                   ;otherwise nullify value by default
0093BF  1  86 07        ChkRow14: stx $07                    ;store whatever value we just loaded here
0093C1  1  A6 08                  ldx ObjectOffset           ;get object offset again
0093C3  1  C9 0E                  cmp #$0e                   ;row 14?
0093C5  1  D0 08                  bne ChkRow13
0093C7  1  A9 00                  lda #$00                   ;if so, load offset with $00
0093C9  1  85 07                  sta $07
0093CB  1  A9 36                  lda #$36                   ;and load A with another value
0093CD  1  D0 53                  bne NormObj                ;unconditional branch
0093CF  1  C9 0D        ChkRow13: cmp #$0d                   ;row 13?
0093D1  1  D0 1B                  bne ChkSRows
0093D3  1  A9 28                  lda #$28                   ;if so, load offset with 40
0093D5  1  85 07                  sta $07
0093D7  1  C8                     iny                        ;get next byte
0093D8  1  B1 E7                  lda (AreaData),y
0093DA  1  29 40                  and #%01000000             ;mask out all but d6 (page control obj bit)
0093DC  1  F0 63                  beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
0093DE  1  B1 E7                  lda (AreaData),y           ;otherwise, get byte again
0093E0  1  29 7F                  and #%01111111             ;mask out d7
0093E2  1  C9 4B                  cmp #$4b                   ;check for loop command in low nybble
0093E4  1  D0 03                  bne Mask2MSB               ;(plus d6 set for object other than page control)
0093E6  1  EE 45 07               inc LoopCommand            ;if loop command, set loop command flag
0093E9  1  29 3F        Mask2MSB: and #%00111111             ;mask out d7 and d6
0093EB  1  4C 22 94               jmp NormObj                ;and jump
0093EE  1  C9 0C        ChkSRows: cmp #$0c                   ;row 12-15?
0093F0  1  B0 27                  bcs SpecObj
0093F2  1  C8                     iny                        ;if not, get second byte of level object
0093F3  1  B1 E7                  lda (AreaData),y
0093F5  1  29 70                  and #%01110000             ;mask out all but d6-d4
0093F7  1  D0 0B                  bne LrgObj                 ;if any bits set, branch to handle large object
0093F9  1  A9 18                  lda #$18
0093FB  1  85 07                  sta $07                    ;otherwise set offset of 24 for small object
0093FD  1  B1 E7                  lda (AreaData),y           ;reload second byte of level object
0093FF  1  29 0F                  and #%00001111             ;mask out higher nybble and jump
009401  1  4C 22 94               jmp NormObj
009404  1  85 00        LrgObj:   sta $00                    ;store value here (branch for large objects)
009406  1  C9 70                  cmp #$70                   ;check for vertical pipe object
009408  1  D0 0A                  bne NotWPipe
00940A  1  B1 E7                  lda (AreaData),y           ;if not, reload second byte
00940C  1  29 08                  and #%00001000             ;mask out all but d3 (usage control bit)
00940E  1  F0 04                  beq NotWPipe               ;if d3 clear, branch to get original value
009410  1  A9 00                  lda #$00                   ;otherwise, nullify value for warp pipe
009412  1  85 00                  sta $00
009414  1  A5 00        NotWPipe: lda $00                    ;get value and jump ahead
009416  1  4C 1E 94               jmp MoveAOId
009419  1  C8           SpecObj:  iny                        ;branch here for rows 12-15
00941A  1  B1 E7                  lda (AreaData),y
00941C  1  29 70                  and #%01110000             ;get next byte and mask out all but d6-d4
00941E  1  4A           MoveAOId: lsr                        ;move d6-d4 to lower nybble
00941F  1  4A                     lsr
009420  1  4A                     lsr
009421  1  4A                     lsr
009422  1  85 00        NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
009424  1  BD 30 07               lda AreaObjectLength,x     ;is there something stored here already?
009427  1  10 42                  bpl RunAObj                ;if so, branch to do its particular sub
009429  1  AD 2A 07               lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
00942C  1  CD 25 07               cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
00942F  1  F0 11                  beq InitRear
009431  1  AC 2C 07               ldy AreaDataOffset         ;if not, get old offset of level pointer
009434  1  B1 E7                  lda (AreaData),y           ;and reload first byte
009436  1  29 0F                  and #%00001111
009438  1  C9 0E                  cmp #$0e                   ;row 14?
00943A  1  D0 05                  bne LeavePar
00943C  1  AD 28 07               lda BackloadingFlag        ;if so, check backloading flag
00943F  1  D0 21                  bne StrAObj                ;if set, branch to render object, else leave
009441  1  60           LeavePar: rts
009442  1  AD 28 07     InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
009445  1  F0 0B                  beq BackColC               ;branch to column-wise check
009447  1  A9 00                  lda #$00                   ;if not, initialize both backloading and
009449  1  8D 28 07               sta BackloadingFlag        ;behind-renderer flags and leave
00944C  1  8D 29 07               sta BehindAreaParserFlag
00944F  1  85 08                  sta ObjectOffset
009451  1  60           LoopCmdE: rts
009452  1  AC 2C 07     BackColC: ldy AreaDataOffset         ;get first byte again
009455  1  B1 E7                  lda (AreaData),y
009457  1  29 F0                  and #%11110000             ;mask out low nybble and move high to low
009459  1  4A                     lsr
00945A  1  4A                     lsr
00945B  1  4A                     lsr
00945C  1  4A                     lsr
00945D  1  CD 26 07               cmp CurrentColumnPos       ;is this where we're at?
009460  1  D0 DF                  bne LeavePar               ;if not, branch to leave
009462  1  AD 2C 07     StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
009465  1  9D 2D 07               sta AreaObjOffsetBuffer,x
009468  1  20 95 93               jsr IncAreaObjOffset       ;do sub to increment to next object data
00946B  1  A5 00        RunAObj:  lda $00                    ;get stored value and add offset to it
00946D  1  18                     clc                        ;then use the jump engine with current contents of A
00946E  1  65 07                  adc $07
009470  1  20 69 8C               jsr JumpEngine
009473  1               
009473  1  2C 97         .word VerticalPipe
009475  1  92 95         .word AreaStyleObject
009477  1  70 98         .word RowOfBricks
009479  1  80 98         .word RowOfSolidBlocks
00947B  1  34 98         .word RowOfCoins
00947D  1  92 98         .word ColumnOfBricks
00947F  1  9B 98         .word ColumnOfSolidBlocks
009481  1  2C 97         .word VerticalPipe
009483  1               
009483  1  85 99         .word Hole_Empty
009485  1  01 96         .word PulleyRopeObject
009487  1  BB 97         .word Bridge_High
009489  1  BE 97         .word Bridge_Middle
00948B  1  C1 97         .word Bridge_Low
00948D  1  99 97         .word Hole_Water
00948F  1  AA 97         .word QuestionBlockRow_High
009491  1  AD 97         .word QuestionBlockRow_Low
009493  1               
009493  1  12 98         .word EndlessRope
009495  1  19 98         .word BalancePlatRope
009497  1  4D 96         .word CastleObject
009499  1  F9 98         .word StaircaseObject
00949B  1  F2 96         .word ExitPipe
00949D  1  D6 97         .word FlagBalls_Residual
00949F  1  F4 E3         .word UpsideDownPipe_High
0094A1  1  F9 E3         .word UpsideDownPipe_Low
0094A3  1               
0094A3  1  52 99         .word QuestionBlock
0094A5  1  52 99         .word QuestionBlock
0094A7  1  52 99         .word QuestionBlock
0094A9  1  52 99         .word QuestionBlock
0094AB  1  45 99         .word Hidden1UpBlock
0094AD  1  52 99         .word QuestionBlock
0094AF  1  52 99         .word QuestionBlock
0094B1  1  5D 99         .word BrickWithItem
0094B3  1  5D 99         .word BrickWithItem
0094B5  1  5D 99         .word BrickWithItem
0094B7  1  5D 99         .word BrickWithItem
0094B9  1  58 99         .word BrickWithCoins
0094BB  1  5D 99         .word BrickWithItem
0094BD  1  B6 96         .word WaterPipe
0094BF  1  5B 98         .word EmptyBlock
0094C1  1  15 99         .word Jumpspring
0094C3  1               
0094C3  1  C9 96         .word IntroPipe
0094C5  1  E0 97         .word FlagpoleObject
0094C7  1  4B 98         .word AxeObj
0094C9  1  50 98         .word ChainObj
0094CB  1  43 98         .word CastleBridgeObj
0094CD  1  0E 95         .word ScrollLockObject_Warp
0094CF  1  5F 95         .word ScrollLockObject
0094D1  1  5F 95         .word ScrollLockObject
0094D3  1  7D 95         .word AreaFrenzy
0094D5  1  7D 95         .word AreaFrenzy
0094D7  1  7D 95         .word AreaFrenzy
0094D9  1  51 94         .word LoopCmdE
0094DB  1  42 E5         .word WindOn                ;these two are in SM2DATA2 and SM2DATA4
0094DD  1  46 E5         .word WindOff
0094DF  1               
0094DF  1  E1 94         .word AlterAreaAttributes
0094E1  1               
0094E1  1               ;-------------------------------------------------------------------------------------
0094E1  1               ;(these apply to all area object subroutines in this section unless otherwise stated)
0094E1  1               ;$00 - used to store offset used to find object code
0094E1  1               ;$07 - starts with adder from area parser, used to store row offset
0094E1  1               
0094E1  1               AlterAreaAttributes:
0094E1  1  BC 2D 07              ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
0094E4  1  C8                    iny                       ;load second byte
0094E5  1  B1 E7                 lda (AreaData),y
0094E7  1  48                    pha                       ;save in stack for now
0094E8  1  29 40                 and #%01000000
0094EA  1  D0 12                 bne Alter2                ;branch if d6 is set
0094EC  1  68                    pla
0094ED  1  48                    pha                       ;pull and push offset to copy to A
0094EE  1  29 0F                 and #%00001111            ;mask out high nybble and store as
0094F0  1  8D 27 07              sta TerrainControl        ;new terrain height type bits
0094F3  1  68                    pla
0094F4  1  29 30                 and #%00110000            ;pull and mask out all but d5 and d4
0094F6  1  4A                    lsr                       ;move bits to lower nybble and store
0094F7  1  4A                    lsr                       ;as new background scenery bits
0094F8  1  4A                    lsr
0094F9  1  4A                    lsr
0094FA  1  8D 42 07              sta BackgroundScenery     ;then leave
0094FD  1  60                    rts
0094FE  1  68           Alter2:  pla
0094FF  1  29 07                 and #%00000111            ;mask out all but 3 LSB
009501  1  C9 04                 cmp #$04                  ;if four or greater, set color control bits
009503  1  90 05                 bcc SetFore               ;and nullify foreground scenery bits
009505  1  8D 44 07              sta BackgroundColorCtrl
009508  1  A9 00                 lda #$00
00950A  1  8D 41 07     SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
00950D  1  60                    rts
00950E  1               
00950E  1               ;--------------------------------
00950E  1               
00950E  1               ScrollLockObject_Warp:
00950E  1  A2 80                 ldx #$80                 ;use base number for warp to world 2
009510  1  AD FB 07              lda HardWorldFlag        ;if on worlds A-D, skip ahead to next part
009513  1  D0 15                 bne WarpWorldsAThruD     ;note d7 is set in all entries to prevent zero condition
009515  1  AD 5F 07              lda WorldNumber          ;from happening in warp zone code elsewhere
009518  1  D0 18                 bne WarpWorlds2Thru8     ;if not on world 1, branch to handle a different way
00951A  1  AC 4E 07              ldy AreaType             ;check to see if on ground level type
00951D  1  88                    dey                      ;branch if so to add one to the number
00951E  1  F0 06                 beq W1Warp2
009520  1  AD 4F 07              lda AreaAddrsLOffset     ;if on first underground level, branch to use base number
009523  1  F0 02                 beq W1Warp1
009525  1  E8                    inx                      ;otherwise add two to the number and use it
009526  1  E8           W1Warp2: inx
009527  1  4C 53 95     W1Warp1: jmp BaseW
00952A  1               
00952A  1               WarpWorldsAThruD:
00952A  1  A9 87              lda #$87                 ;use base number for worlds A-D
00952C  1  18                 clc
00952D  1  6D 5C 07           adc LevelNumber          ;add level number itself to it
009530  1  D0 22              bne DumpWarpCtrl         ;then branch to use it
009532  1               
009532  1               WarpWorlds2Thru8:
009532  1  A2 83              ldx #$83                 ;use base number for worlds 2-8
009534  1  AD 5F 07           lda WorldNumber
009537  1  C9 02              cmp #World3              ;branch if on world 3 to use
009539  1  F0 18              beq BaseW
00953B  1  E8                 inx                      ;otherwise add one to the number
00953C  1  C9 04              cmp #World5              ;if not on world 5, branch to add 3 more
00953E  1  D0 10              bne W678Warp
009540  1  AD 4F 07           lda AreaAddrsLOffset
009543  1  C9 0B              cmp #$0b                 ;if on the 12th ground area, branch to use
009545  1  F0 0C              beq BaseW                ;(in normal map data this corresponds to world 5-1)
009547  1  AC 4E 07           ldy AreaType             ;check to see if on ground level type
00954A  1  88                 dey                      ;branch if so to add 2 more to the number
00954B  1  F0 04              beq W5Warp3
00954D  1  4C 52 95           jmp W5Warp2              ;otherwise add 1 more
009550  1               
009550  1  E8           W678Warp: inx                  ;add 1, 2, or 3 to base number or use as-is
009551  1  E8           W5Warp3:  inx                  ;depending on where branched
009552  1  E8           W5Warp2:  inx
009553  1  8A           BaseW:    txa
009554  1               
009554  1               DumpWarpCtrl:
009554  1  8D D6 06           sta WarpZoneControl      ;set warp zone control
009557  1  20 36 87           jsr WriteWarpZoneMessage
00955A  1  A9 0D              lda #$0d                 ;kill piranha plants
00955C  1  20 68 95           jsr KillEnemies
00955F  1               
00955F  1               ScrollLockObject:
00955F  1  AD 23 07           lda ScrollLock      ;invert scroll lock to turn it on
009562  1  49 01              eor #%00000001
009564  1  8D 23 07           sta ScrollLock
009567  1  60                 rts
009568  1               
009568  1               ;--------------------------------
009568  1               ;$00 - used to store enemy identifier in KillEnemies
009568  1               
009568  1               KillEnemies:
009568  1  85 00                   sta $00           ;store identifier here
00956A  1  A9 00                   lda #$00
00956C  1  A2 04                   ldx #$04          ;check for identifier in enemy object buffer
00956E  1  B4 16        KillELoop: ldy Enemy_ID,x
009570  1  C4 00                   cpy $00           ;if not found, branch
009572  1  D0 02                   bne NoKillE
009574  1  95 0F                   sta Enemy_Flag,x  ;if found, deactivate enemy object flag
009576  1  CA           NoKillE:   dex               ;do this until all slots are checked
009577  1  10 F5                   bpl KillELoop
009579  1  60                      rts
00957A  1               
00957A  1               ;--------------------------------
00957A  1               
00957A  1               FrenzyIDData:
00957A  1  14 17 18           .byte FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
00957D  1               
00957D  1  A6 00        AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
00957F  1  BD 72 95                  lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
009582  1  A0 05                     ldy #$05
009584  1  88           FreCompLoop: dey                   ;check regular slots of enemy object buffer
009585  1  30 07                     bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
009587  1  D9 16 00                  cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
00958A  1  D0 F8                     bne FreCompLoop
00958C  1  A9 00                     lda #$00              ;if enemy object already present, nullify queue and leave
00958E  1  8D CD 06     ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
009591  1  60                        rts
009592  1               
009592  1               
009592  1               ;--------------------------------
009592  1               ;$06 - used by CloudLedge to store length
009592  1               
009592  1               AreaStyleObject:
009592  1  AD 33 07           lda AreaStyle        ;load level object style and jump to the right sub
009595  1  20 69 8C           jsr JumpEngine
009598  1  9E 95              .word TreeLedge        ;also used for cloud bonus levels
00959A  1  CA 95              .word CloudLedge
00959C  1  AB 98              .word BulletBillCannon
00959E  1               
00959E  1               TreeLedge:
00959E  1  20 F7 99               jsr GetLrgObjAttrib     ;get row and length of green ledge
0095A1  1  BD 30 07               lda AreaObjectLength,x  ;check length counter for expiration
0095A4  1  F0 1F                  beq EndTreeL
0095A6  1  10 11                  bpl MidTreeL
0095A8  1  98                     tya
0095A9  1  9D 30 07               sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
0095AC  1  AD 25 07               lda CurrentPageLoc
0095AF  1  0D 26 07               ora CurrentColumnPos    ;are we at the start of the level?
0095B2  1  F0 05                  beq MidTreeL
0095B4  1  A9 16                  lda #$16                ;render start of tree ledge
0095B6  1  4C F7 95               jmp NoUnder
0095B9  1  A6 07        MidTreeL: ldx $07
0095BB  1  A9 17                  lda #$17                ;render middle of tree ledge
0095BD  1  9D A1 06               sta MetatileBuffer,x    ;note that this is also used if ledge position is
0095C0  1  A9 4C                  lda #$4c                ;at the start of level for continuous effect
0095C2  1  4C F1 95               jmp AllUnder            ;now render the part underneath
0095C5  1  A9 18        EndTreeL: lda #$18                ;render end of tree ledge
0095C7  1  4C F7 95               jmp NoUnder
0095CA  1               
0095CA  1               ;note: This is the style utilized by world 8-3 and part of world 8-2, and not to
0095CA  1               ;be confused with the cloud-type bonus levels full of coins found throughout the game.
0095CA  1               CloudLedge:
0095CA  1  20 E8 99               jsr ChkLrgObjLength        ;get cloud dimensions
0095CD  1  84 06                  sty $06                    ;store length here for now
0095CF  1  90 0C                  bcc EndCloud
0095D1  1  BD 30 07               lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
0095D4  1  4A                     lsr
0095D5  1  9D 36 07               sta MushroomLedgeHalfLen,x
0095D8  1  A9 8A                  lda #$8a                   ;render start of cloud
0095DA  1  4C F7 95               jmp NoUnder
0095DD  1  A9 8C        EndCloud: lda #$8c                   ;if at the end, render end of cloud
0095DF  1  BC 30 07               ldy AreaObjectLength,x
0095E2  1  F0 13                  beq NoUnder
0095E4  1  BD 36 07               lda MushroomLedgeHalfLen,x ;get divided length and store where length
0095E7  1  85 06                  sta $06                    ;was stored originally
0095E9  1  A6 07                  ldx $07
0095EB  1  A9 8B                  lda #$8b
0095ED  1  9D A1 06               sta MetatileBuffer,x       ;render middle of cloud
0095F0  1  60                     rts
0095F1  1               
0095F1  1  E8           AllUnder: inx
0095F2  1  A0 0F                  ldy #$0f                   ;set $0f to render all way down
0095F4  1  4C C1 99               jmp RenderUnderPart        ;now render the support of the tree ledge
0095F7  1  A6 07        NoUnder:  ldx $07                    ;load row of ledge
0095F9  1  A0 00                  ldy #$00                   ;set 0 for no bottom on this part
0095FB  1  4C C1 99               jmp RenderUnderPart
0095FE  1               
0095FE  1               ;--------------------------------
0095FE  1               
0095FE  1               ;tiles used by pulleys and rope object
0095FE  1               PulleyRopeMetatiles:
0095FE  1  42 41 43           .byte $42, $41, $43
009601  1               
009601  1               PulleyRopeObject:
009601  1  20 E8 99                jsr ChkLrgObjLength       ;get length of pulley/rope object
009604  1  A0 00                   ldy #$00                  ;initialize metatile offset
009606  1  B0 07                   bcs RenderPul             ;if starting, render left pulley
009608  1  C8                      iny
009609  1  BD 30 07                lda AreaObjectLength,x    ;if not at the end, render rope
00960C  1  D0 01                   bne RenderPul
00960E  1  C8                      iny                       ;otherwise render right pulley
00960F  1  B9 FE 95     RenderPul: lda PulleyRopeMetatiles,y
009612  1  8D A1 06                sta MetatileBuffer        ;render at the top of the screen
009615  1  60           MushLExit: rts                       ;and leave
009616  1               
009616  1               ;--------------------------------
009616  1               ;$06 - used to store upper limit of rows for CastleObject
009616  1               
009616  1               CastleMetatiles:
009616  1  00 45 45 45        .byte $00, $45, $45, $45, $00
00961A  1  00           
00961B  1  00 48 47 46        .byte $00, $48, $47, $46, $00
00961F  1  00           
009620  1  45 49 49 49        .byte $45, $49, $49, $49, $45
009624  1  45           
009625  1  47 47 4A 47        .byte $47, $47, $4a, $47, $47
009629  1  47           
00962A  1  47 47 4B 47        .byte $47, $47, $4b, $47, $47
00962E  1  47           
00962F  1  49 49 49 49        .byte $49, $49, $49, $49, $49
009633  1  49           
009634  1  47 4A 47 4A        .byte $47, $4a, $47, $4a, $47
009638  1  47           
009639  1  47 4B 47 4B        .byte $47, $4b, $47, $4b, $47
00963D  1  47           
00963E  1  47 47 47 47        .byte $47, $47, $47, $47, $47
009642  1  47           
009643  1  4A 47 4A 47        .byte $4a, $47, $4a, $47, $4a
009647  1  4A           
009648  1  4B 47 4B 47        .byte $4b, $47, $4b, $47, $4b
00964C  1  4B           
00964D  1               
00964D  1               CastleObject:
00964D  1  20 F7 99                 jsr GetLrgObjAttrib      ;save lower nybble as starting row
009650  1  84 07                    sty $07                  ;if starting row is above $0a, game will crash!!!
009652  1  A0 04                    ldy #$04
009654  1  20 EB 99                 jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
009657  1  8A                       txa
009658  1  48                       pha                      ;save obj buffer offset to stack
009659  1  BC 30 07                 ldy AreaObjectLength,x   ;use current length as offset for castle data
00965C  1  A6 07                    ldx $07                  ;begin at starting row
00965E  1  A9 0B                    lda #$0b
009660  1  85 06                    sta $06                  ;load upper limit of number of rows to print
009662  1  B9 16 96     CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
009665  1  9D A1 06                 sta MetatileBuffer,x
009668  1  E8                       inx                      ;store in buffer and increment buffer offset
009669  1  A5 06                    lda $06
00966B  1  F0 07                    beq ChkCFloor            ;have we reached upper limit yet?
00966D  1  C8                       iny                      ;if not, increment column-wise
00966E  1  C8                       iny                      ;to byte in next row
00966F  1  C8                       iny
009670  1  C8                       iny
009671  1  C8                       iny
009672  1  C6 06                    dec $06                  ;move closer to upper limit
009674  1  E0 0B        ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
009676  1  D0 EA                    bne CRendLoop            ;if not, go back and do another row
009678  1  68                       pla
009679  1  AA                       tax                      ;get obj buffer offset from before
00967A  1  AD 25 07                 lda CurrentPageLoc
00967D  1  F0 36                    beq ExitCastle           ;if we're at page 0, we do not need to do anything else
00967F  1  BD 30 07                 lda AreaObjectLength,x   ;check length
009682  1  C9 01                    cmp #$01                 ;if length almost about to expire, put brick at floor
009684  1  F0 2A                    beq PlayerStop
009686  1  A4 07                    ldy $07                  ;check starting row for tall castle ($00)
009688  1  D0 04                    bne NotTall
00968A  1  C9 03                    cmp #$03                 ;if found, then check to see if we're at the second column
00968C  1  F0 22                    beq PlayerStop
00968E  1  C9 02        NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
009690  1  D0 23                    bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
009692  1  20 07 9A                 jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
009695  1  48                       pha
009696  1  20 8C 97                 jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
009699  1  68                       pla
00969A  1  95 87                    sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
00969C  1  AD 25 07                 lda CurrentPageLoc
00969F  1  95 6E                    sta Enemy_PageLoc,x      ;set page location for star flag
0096A1  1  A9 01                    lda #$01
0096A3  1  95 B6                    sta Enemy_Y_HighPos,x    ;set vertical high byte
0096A5  1  95 0F                    sta Enemy_Flag,x         ;set flag for buffer
0096A7  1  A9 90                    lda #$90
0096A9  1  95 CF                    sta Enemy_Y_Position,x   ;set vertical coordinate
0096AB  1  A9 31                    lda #StarFlagObject      ;set star flag value in buffer itself
0096AD  1  95 16                    sta Enemy_ID,x
0096AF  1  60                       rts
0096B0  1  A0 50        PlayerStop: ldy #$50                 ;put brick at floor to stop player at end of level
0096B2  1  8C AB 06                 sty MetatileBuffer+10    ;this is only done if we're on the second column
0096B5  1  60           ExitCastle: rts
0096B6  1               
0096B6  1               ;--------------------------------
0096B6  1               
0096B6  1               WaterPipe:
0096B6  1  20 F7 99           jsr GetLrgObjAttrib     ;get row and lower nybble
0096B9  1  BC 30 07           ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
0096BC  1  A6 07              ldx $07                 ;get row
0096BE  1  A9 6D              lda #$6d
0096C0  1  9D A1 06           sta MetatileBuffer,x    ;draw something here and below it
0096C3  1  A9 6E              lda #$6e
0096C5  1  9D A2 06           sta MetatileBuffer+1,x
0096C8  1  60                 rts
0096C9  1               
0096C9  1               ;--------------------------------
0096C9  1               ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
0096C9  1               ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
0096C9  1               ; and vertical length in VerticalPipe and GetPipeHeight
0096C9  1               
0096C9  1               IntroPipe:
0096C9  1  A0 03                       ldy #$03                 ;check if length set, if not set, set it
0096CB  1  20 EB 99                    jsr ChkLrgObjFixedLength
0096CE  1  A0 0A                       ldy #$0a                 ;set fixed value and render the sideways part
0096D0  1  20 FA 96                    jsr RenderSidewaysPipe
0096D3  1  B0 10                       bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
0096D5  1  A2 06                       ldx #$06                 ;blank everything above the vertical pipe part
0096D7  1  A9 00        VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
0096D9  1  9D A1 06                    sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
0096DC  1  CA                          dex
0096DD  1  10 F8                       bpl VPipeSectLoop
0096DF  1  B9 24 97                    lda VerticalPipeData,y   ;draw the end of the vertical pipe part
0096E2  1  8D A8 06                    sta MetatileBuffer+7
0096E5  1  60           NoBlankP:      rts
0096E6  1               
0096E6  1               SidePipeShaftData:
0096E6  1  15 14              .byte $15, $14  ;used to control whether or not vertical pipe shaft
0096E8  1  00 00              .byte $00, $00  ;is drawn, and if so, controls the metatile number
0096EA  1               SidePipeTopPart:
0096EA  1  15 1B              .byte $15, $1b  ;top part of sideways part of pipe
0096EC  1  1A 19              .byte $1a, $19
0096EE  1               SidePipeBottomPart:
0096EE  1  15 1E              .byte $15, $1e  ;bottom part of sideways part of pipe
0096F0  1  1D 1C              .byte $1d, $1c
0096F2  1               
0096F2  1               ExitPipe:
0096F2  1  A0 03              ldy #$03                 ;check if length set, if not set, set it
0096F4  1  20 EB 99           jsr ChkLrgObjFixedLength
0096F7  1  20 F7 99           jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
0096FA  1               
0096FA  1               RenderSidewaysPipe:
0096FA  1  88                         dey                       ;decrement twice to make room for shaft at bottom
0096FB  1  88                         dey                       ;and store here for now as vertical length
0096FC  1  84 05                      sty $05
0096FE  1  BC 30 07                   ldy AreaObjectLength,x    ;get length left over and store here
009701  1  84 06                      sty $06
009703  1  A6 05                      ldx $05                   ;get vertical length plus one, use as buffer offset
009705  1  E8                         inx
009706  1  B9 E6 96                   lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
009709  1  C9 00                      cmp #$00
00970B  1  F0 08                      beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
00970D  1  A2 00                      ldx #$00
00970F  1  A4 05                      ldy $05                   ;init buffer offset and get vertical length
009711  1  20 C1 99                   jsr RenderUnderPart       ;and render vertical shaft using tile number in A
009714  1  18                         clc                       ;clear carry flag to be used by IntroPipe
009715  1  A4 06        DrawSidePart: ldy $06                   ;render side pipe part at the bottom
009717  1  B9 EA 96                   lda SidePipeTopPart,y
00971A  1  9D A1 06                   sta MetatileBuffer,x      ;note that the pipe parts are stored
00971D  1  B9 EE 96                   lda SidePipeBottomPart,y  ;backwards horizontally
009720  1  9D A2 06                   sta MetatileBuffer+1,x
009723  1  60                         rts
009724  1               
009724  1               VerticalPipeData:
009724  1  11 10              .byte $11, $10 ;used by pipes that lead somewhere
009726  1  15 14              .byte $15, $14
009728  1  13 12              .byte $13, $12 ;used by decoration pipes
00972A  1  15 14              .byte $15, $14
00972C  1               
00972C  1               VerticalPipe:
00972C  1  20 5C 97               jsr GetPipeHeight
00972F  1  A5 00                  lda $00                  ;check to see if value was nullified earlier
009731  1  F0 04                  beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
009733  1  C8                     iny
009734  1  C8                     iny
009735  1  C8                     iny
009736  1  C8                     iny                      ;add four if usage control bit was not set
009737  1  98           WarpPipe: tya                      ;save value in stack
009738  1  48                     pha
009739  1  BC 30 07               ldy AreaObjectLength,x   ;if on second column of pipe, branch
00973C  1  F0 0A                  beq DrawPipe             ;(because we only need to do this once)
00973E  1  20 8C 97               jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
009741  1  B0 05                  bcs DrawPipe             ;if not found, too many enemies, thus skip
009743  1  A9 0D                  lda #PiranhaPlant
009745  1  20 6D 97               jsr SetupPiranhaPlant
009748  1               
009748  1  68           DrawPipe: pla                      ;get value saved earlier and use as Y
009749  1  A8                     tay
00974A  1  A6 07                  ldx $07                  ;get buffer offset
00974C  1  B9 24 97               lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
00974F  1  9D A1 06               sta MetatileBuffer,x     ;render the top of the pipe
009752  1  E8                     inx
009753  1  B9 26 97               lda VerticalPipeData+2,y ;render the rest of the pipe
009756  1  A4 06                  ldy $06                  ;subtract one from length and render the part underneath
009758  1  88                     dey
009759  1  4C C1 99               jmp RenderUnderPart
00975C  1               
00975C  1               GetPipeHeight:
00975C  1  A0 01              ldy #$01       ;check for length loaded, if not, load
00975E  1  20 EB 99           jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
009761  1  20 F7 99           jsr GetLrgObjAttrib
009764  1  98                 tya            ;get saved lower nybble as height
009765  1  29 07              and #$07       ;save only the three lower bits as
009767  1  85 06              sta $06        ;vertical length, then load Y with
009769  1  BC 30 07           ldy AreaObjectLength,x    ;length left over
00976C  1  60                 rts
00976D  1               
00976D  1               SetupPiranhaPlant:
00976D  1  95 16                  sta Enemy_ID,x
00976F  1  20 07 9A               jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
009772  1  18                     clc
009773  1  69 08                  adc #$08                 ;add eight to put the piranha plant in the center
009775  1  95 87                  sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
009777  1  AD 25 07               lda CurrentPageLoc       ;add carry to current page number
00977A  1  69 00                  adc #$00
00977C  1  95 6E                  sta Enemy_PageLoc,x      ;store as enemy's page coordinate
00977E  1  A9 01                  lda #$01
009780  1  95 B6                  sta Enemy_Y_HighPos,x
009782  1  95 0F                  sta Enemy_Flag,x         ;activate enemy flag
009784  1  20 0F 9A               jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
009787  1  95 CF                  sta Enemy_Y_Position,x
009789  1  4C B8 B3               jmp InitPiranhaPlant
00978C  1               
00978C  1               FindEmptyEnemySlot:
00978C  1  A2 00                      ldx #$00          ;start at first enemy slot
00978E  1  18           EmptyChkLoop: clc               ;clear carry flag by default
00978F  1  B5 0F                      lda Enemy_Flag,x  ;check enemy buffer for nonzero
009791  1  F0 05                      beq ExitEmptyChk  ;if zero, leave
009793  1  E8                         inx
009794  1  E0 05                      cpx #$05          ;if nonzero, check next value
009796  1  D0 F6                      bne EmptyChkLoop
009798  1  60           ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
009799  1               
009799  1               ;--------------------------------
009799  1               
009799  1               Hole_Water:
009799  1  20 E8 99           jsr ChkLrgObjLength   ;get low nybble and save as length
00979C  1  A9 86              lda #$86              ;render waves
00979E  1  8D AB 06           sta MetatileBuffer+10
0097A1  1  A2 0B              ldx #$0b
0097A3  1  A0 01              ldy #$01              ;now render the water underneath
0097A5  1  A9 87              lda #$87
0097A7  1  4C C1 99           jmp RenderUnderPart
0097AA  1               
0097AA  1               QuestionBlockRow_High:
0097AA  1  A9 03              lda #$03              ;start on the fourth row
0097AC  1  2C                 .byte $2c               ;BIT instruction opcode
0097AD  1               
0097AD  1               QuestionBlockRow_Low:
0097AD  1  A9 07              lda #$07             ;start on the eighth row
0097AF  1  48                 pha                  ;save whatever row to the stack for now
0097B0  1  20 E8 99           jsr ChkLrgObjLength  ;get low nybble and save as length
0097B3  1  68                 pla
0097B4  1  AA                 tax                  ;render question boxes with coins
0097B5  1  A9 C0              lda #$c0
0097B7  1  9D A1 06           sta MetatileBuffer,x
0097BA  1  60                 rts
0097BB  1               
0097BB  1               ;--------------------------------
0097BB  1               
0097BB  1               Bridge_High:
0097BB  1  A9 06              lda #$06  ;start on the seventh row from top of screen
0097BD  1  2C                 .byte $2c   ;BIT instruction opcode
0097BE  1               
0097BE  1               Bridge_Middle:
0097BE  1  A9 07              lda #$07  ;start on the eighth row
0097C0  1  2C                 .byte $2c   ;BIT instruction opcode
0097C1  1               
0097C1  1               Bridge_Low:
0097C1  1  A9 09              lda #$09             ;start on the tenth row
0097C3  1  48                 pha                  ;save whatever row to the stack for now
0097C4  1  20 E8 99           jsr ChkLrgObjLength  ;get low nybble and save as length
0097C7  1  68                 pla
0097C8  1  AA                 tax                  ;render bridge railing
0097C9  1  A9 0B              lda #$0b
0097CB  1  9D A1 06           sta MetatileBuffer,x
0097CE  1  E8                 inx
0097CF  1  A0 00              ldy #$00             ;now render the bridge itself
0097D1  1  A9 64              lda #$64
0097D3  1  4C C1 99           jmp RenderUnderPart
0097D6  1               
0097D6  1               ;--------------------------------
0097D6  1               
0097D6  1               FlagBalls_Residual:
0097D6  1  20 F7 99           jsr GetLrgObjAttrib  ;get low nybble from object byte
0097D9  1  A2 02              ldx #$02             ;render flag balls on third row from top
0097DB  1  A9 6F              lda #$6f             ;of screen downwards based on low nybble
0097DD  1  4C C1 99           jmp RenderUnderPart
0097E0  1               
0097E0  1               ;--------------------------------
0097E0  1               
0097E0  1               FlagpoleObject:
0097E0  1  A9 21              lda #$21                 ;render flagpole ball on top
0097E2  1  8D A1 06           sta MetatileBuffer
0097E5  1  A2 01              ldx #$01                 ;now render the flagpole shaft
0097E7  1  A0 08              ldy #$08
0097E9  1  A9 22              lda #$22
0097EB  1  20 C1 99           jsr RenderUnderPart
0097EE  1  A9 62              lda #$62                 ;render solid block at the bottom
0097F0  1  8D AB 06           sta MetatileBuffer+10
0097F3  1  20 07 9A           jsr GetAreaObjXPosition
0097F6  1  38                 sec                      ;get pixel coordinate of where the flagpole is,
0097F7  1  E9 08              sbc #$08                 ;subtract eight pixels and use as horizontal
0097F9  1  85 8C              sta Enemy_X_Position+5   ;coordinate for the flag
0097FB  1  AD 25 07           lda CurrentPageLoc
0097FE  1  E9 00              sbc #$00                 ;subtract borrow from page location and use as
009800  1  85 73              sta Enemy_PageLoc+5      ;page location for the flag
009802  1  A9 30              lda #$30
009804  1  85 D4              sta Enemy_Y_Position+5   ;set vertical coordinate for flag
009806  1  A9 B0              lda #$b0
009808  1  8D 0D 01           sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
00980B  1  A9 30              lda #FlagpoleFlagObject
00980D  1  85 1B              sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
00980F  1  E6 14              inc Enemy_Flag+5         ;use last space in enemy object buffer
009811  1  60                 rts
009812  1               
009812  1               ;--------------------------------
009812  1               
009812  1               EndlessRope:
009812  1  A2 00              ldx #$00       ;render rope from the top to the bottom of screen
009814  1  A0 0F              ldy #$0f
009816  1  4C 2B 98           jmp DrawRope
009819  1               
009819  1               BalancePlatRope:
009819  1  8A                     txa                 ;save object buffer offset for now
00981A  1  48                     pha
00981B  1  A2 01                  ldx #$01            ;blank out all from second row to the bottom
00981D  1  A0 0F                  ldy #$0f            ;with blank used for balance platform rope
00981F  1  A9 44                  lda #$44
009821  1  20 C1 99               jsr RenderUnderPart
009824  1  68                     pla                 ;get back object buffer offset
009825  1  AA                     tax
009826  1  20 F7 99               jsr GetLrgObjAttrib ;get vertical length from lower nybble
009829  1  A2 01                  ldx #$01
00982B  1  A9 40        DrawRope: lda #$40            ;render the actual rope
00982D  1  4C C1 99               jmp RenderUnderPart
009830  1               
009830  1               ;--------------------------------
009830  1               
009830  1               CoinMetatileData:
009830  1  C4 C3 C3 C3        .byte $c4, $c3, $c3, $c3
009834  1               
009834  1               RowOfCoins:
009834  1  AC 4E 07           ldy AreaType            ;get area type
009837  1  B9 30 98           lda CoinMetatileData,y  ;load appropriate coin metatile
00983A  1  4C 86 98           jmp GetRow
00983D  1               
00983D  1               ;--------------------------------
00983D  1               
00983D  1               C_ObjectRow:
00983D  1  06 07 08           .byte $06, $07, $08
009840  1               
009840  1               C_ObjectMetatile:
009840  1  C6 0C 89           .byte $c6, $0c, $89
009843  1               
009843  1               CastleBridgeObj:
009843  1  A0 0C              ldy #$0c                  ;load length of 13 columns
009845  1  20 EB 99           jsr ChkLrgObjFixedLength
009848  1  4C 50 98           jmp ChainObj
00984B  1               
00984B  1               AxeObj:
00984B  1  A9 08              lda #$08                  ;load bowser's palette into sprite portion of palette
00984D  1  8D 73 07           sta VRAM_Buffer_AddrCtrl
009850  1               
009850  1               ChainObj:
009850  1  A4 00              ldy $00                   ;get value loaded earlier from decoder
009852  1  BE 3B 98           ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
009855  1  B9 3E 98           lda C_ObjectMetatile-2,y
009858  1  4C 62 98           jmp ColObj
00985B  1               
00985B  1               EmptyBlock:
00985B  1  20 F7 99             jsr GetLrgObjAttrib  ;get row location
00985E  1  A6 07                ldx $07
009860  1  A9 C5                lda #$c5
009862  1  A0 00        ColObj: ldy #$00             ;column length of 1
009864  1  4C C1 99             jmp RenderUnderPart
009867  1               
009867  1               ;--------------------------------
009867  1               
009867  1               SolidBlockMetatiles:
009867  1  6A 62 62 63        .byte $6a, $62, $62, $63
00986B  1               
00986B  1               BrickMetatiles:
00986B  1  1F 4F 50 50        .byte $1f, $4f, $50, $50
00986F  1  88                 .byte $88 ;used only by row of bricks object
009870  1               
009870  1               RowOfBricks:
009870  1  AC 4E 07                 ldy AreaType           ;load area type obtained from area offset pointer
009873  1  AD 43 07                 lda CloudTypeOverride  ;check for cloud type override
009876  1  F0 02                    beq DrawBricks
009878  1  A0 04                    ldy #$04               ;if cloud type, override area type
00987A  1  B9 6B 98     DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
00987D  1  4C 86 98                 jmp GetRow             ;and go render it
009880  1               
009880  1               RowOfSolidBlocks:
009880  1  AC 4E 07              ldy AreaType               ;load area type obtained from area offset pointer
009883  1  B9 67 98              lda SolidBlockMetatiles,y  ;get metatile
009886  1  48           GetRow:  pha                        ;store metatile here
009887  1  20 E8 99              jsr ChkLrgObjLength        ;get row number, load length
00988A  1  A6 07        DrawRow: ldx $07
00988C  1  A0 00                 ldy #$00                   ;set vertical height of 1
00988E  1  68                    pla
00988F  1  4C C1 99              jmp RenderUnderPart        ;render object
009892  1               
009892  1               ColumnOfBricks:
009892  1  AC 4E 07           ldy AreaType          ;load area type obtained from area offset
009895  1  B9 6B 98           lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
009898  1  4C A1 98           jmp GetRow2
00989B  1               
00989B  1               ColumnOfSolidBlocks:
00989B  1  AC 4E 07              ldy AreaType               ;load area type obtained from area offset
00989E  1  B9 67 98              lda SolidBlockMetatiles,y  ;get metatile
0098A1  1  48           GetRow2: pha                        ;save metatile to stack for now
0098A2  1  20 F7 99              jsr GetLrgObjAttrib        ;get length and row
0098A5  1  68                    pla                        ;restore metatile
0098A6  1  A6 07                 ldx $07                    ;get starting row
0098A8  1  4C C1 99              jmp RenderUnderPart        ;now render the column
0098AB  1               
0098AB  1               ;--------------------------------
0098AB  1               
0098AB  1               BulletBillCannon:
0098AB  1  20 F7 99                  jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
0098AE  1  A6 07                     ldx $07                  ;start at first row
0098B0  1  A9 65                     lda #$65                 ;render bullet bill cannon
0098B2  1  9D A1 06                  sta MetatileBuffer,x
0098B5  1  E8                        inx
0098B6  1  88                        dey                      ;done yet?
0098B7  1  30 0E                     bmi SetupCannon
0098B9  1  A9 66                     lda #$66                 ;if not, render middle part
0098BB  1  9D A1 06                  sta MetatileBuffer,x
0098BE  1  E8                        inx
0098BF  1  88                        dey                      ;done yet?
0098C0  1  30 05                     bmi SetupCannon
0098C2  1  A9 67                     lda #$67                 ;if not, render bottom until length expires
0098C4  1  20 C1 99                  jsr RenderUnderPart
0098C7  1  AE 6A 04     SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
0098CA  1  20 0F 9A                  jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
0098CD  1  9D 77 04                  sta Cannon_Y_Position,x  ;and store it here
0098D0  1  AD 25 07                  lda CurrentPageLoc
0098D3  1  9D 6B 04                  sta Cannon_PageLoc,x     ;store page number for cannon here
0098D6  1  20 07 9A                  jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
0098D9  1  9D 71 04                  sta Cannon_X_Position,x  ;and store it here
0098DC  1  E8                        inx
0098DD  1  E0 06                     cpx #$06                 ;increment and check offset
0098DF  1  90 02                     bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
0098E1  1  A2 00                     ldx #$00                 ;otherwise initialize it
0098E3  1  8E 6A 04     StrCOffset:  stx Cannon_Offset        ;save new offset and leave
0098E6  1  60                        rts
0098E7  1               
0098E7  1               ;--------------------------------
0098E7  1               
0098E7  1               StaircaseHeightData:
0098E7  1  07 07 06 05        .byte $07, $07, $06, $05, $04, $03, $02, $01, $00
0098EB  1  04 03 02 01  
0098EF  1  00           
0098F0  1               
0098F0  1               StaircaseRowData:
0098F0  1  03 03 04 05        .byte $03, $03, $04, $05, $06, $07, $08, $09, $0a
0098F4  1  06 07 08 09  
0098F8  1  0A           
0098F9  1               
0098F9  1               StaircaseObject:
0098F9  1  20 E8 99                jsr ChkLrgObjLength       ;check and load length
0098FC  1  90 05                   bcc NextStair             ;if length already loaded, skip init part
0098FE  1  A9 09                   lda #$09                  ;start past the end for the bottom
009900  1  8D 34 07                sta StaircaseControl      ;of the staircase
009903  1  CE 34 07     NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
009906  1  AC 34 07                ldy StaircaseControl
009909  1  BE F0 98                ldx StaircaseRowData,y    ;get starting row and height to render
00990C  1  B9 E7 98                lda StaircaseHeightData,y
00990F  1  A8                      tay
009910  1  A9 62                   lda #$62                  ;now render solid block staircase
009912  1  4C C1 99                jmp RenderUnderPart
009915  1               
009915  1               ;--------------------------------
009915  1               
009915  1               Jumpspring:
009915  1  20 F7 99           jsr GetLrgObjAttrib
009918  1  20 8C 97           jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
00991B  1  B0 27              bcs NoJs                    ;if none, cancel (potentially problematic!)
00991D  1  20 07 9A           jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
009920  1  95 87              sta Enemy_X_Position,x      ;and store
009922  1  AD 25 07           lda CurrentPageLoc          ;store page location of jumpspring
009925  1  95 6E              sta Enemy_PageLoc,x
009927  1  20 0F 9A           jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
00992A  1  95 CF              sta Enemy_Y_Position,x      ;and store
00992C  1  95 58              sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
00992E  1  A9 32              lda #JumpspringObject
009930  1  95 16              sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
009932  1  A0 01              ldy #$01
009934  1  94 B6              sty Enemy_Y_HighPos,x       ;store vertical high byte
009936  1  F6 0F              inc Enemy_Flag,x            ;set flag for enemy object buffer
009938  1  A6 07              ldx $07
00993A  1  A9 68              lda #$68                    ;draw metatiles in two rows where jumpspring is
00993C  1  9D A1 06           sta MetatileBuffer,x
00993F  1  A9 69              lda #$69
009941  1  9D A2 06           sta MetatileBuffer+1,x
009944  1  60           NoJs: rts
009945  1               
009945  1               ;--------------------------------
009945  1               ;$07 - used to save ID of brick object
009945  1               
009945  1               Hidden1UpBlock:
009945  1  AD 5D 07           lda Hidden1UpFlag  ;if flag not set, do not render object
009948  1  F0 36              beq ExitDecBlock
00994A  1  A9 00              lda #$00           ;if set, init for the next one
00994C  1  8D 5D 07           sta Hidden1UpFlag
00994F  1  4C 5D 99           jmp BrickWithItem  ;jump to code shared with unbreakable bricks
009952  1               
009952  1               QuestionBlock:
009952  1  20 7A 99           jsr GetAreaObjectID ;get value from level decoder routine
009955  1  4C 70 99           jmp DrawQBlk        ;go to render it
009958  1               
009958  1               BrickWithCoins:
009958  1  A9 00              lda #$00                 ;initialize multi-coin timer flag
00995A  1  8D BC 06           sta BrickCoinTimerFlag
00995D  1               
00995D  1               BrickWithItem:
00995D  1  20 7A 99               jsr GetAreaObjectID         ;save area object ID
009960  1  84 07                  sty $07
009962  1  A9 00                  lda #$00                    ;load default adder for bricks with lines
009964  1  AC 4E 07               ldy AreaType                ;check level type for ground level
009967  1  88                     dey
009968  1  F0 02                  beq BWithL                  ;if ground type, do not start with 6
00996A  1  A9 06                  lda #$06                    ;otherwise use adder for bricks without lines
00996C  1  18           BWithL:   clc                         ;add object ID to adder
00996D  1  65 07                  adc $07
00996F  1  A8                     tay                         ;use as offset for metatile
009970  1  B9 DF A9     DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
009973  1  48                     pha                         ;if branched to here from question block routine)
009974  1  20 F7 99               jsr GetLrgObjAttrib         ;get row from location byte
009977  1  4C 8A 98               jmp DrawRow                 ;now render the object
00997A  1               
00997A  1               GetAreaObjectID:
00997A  1  A5 00                      lda $00    ;get value saved from area parser routine
00997C  1  38                         sec
00997D  1  E9 00                      sbc #$00   ;possibly residual code
00997F  1  A8                         tay        ;save to Y
009980  1  60           ExitDecBlock: rts
009981  1               
009981  1               ;--------------------------------
009981  1               
009981  1               HoleMetatiles:
009981  1  87 00 00 00        .byte $87, $00, $00, $00
009985  1               
009985  1               Hole_Empty:
009985  1  20 E8 99                 jsr ChkLrgObjLength          ;get lower nybble and save as length
009988  1  90 2D                    bcc NoWhirlP                 ;skip this part if length already loaded
00998A  1  AD 4E 07                 lda AreaType                 ;check for water type level
00998D  1  D0 28                    bne NoWhirlP                 ;if not water type, skip this part
00998F  1  AE 6A 04                 ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
009992  1  20 07 9A                 jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
009995  1  38                       sec
009996  1  E9 10                    sbc #$10                     ;subtract 16 pixels
009998  1  9D 71 04                 sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
00999B  1  AD 25 07                 lda CurrentPageLoc           ;get page location of where we're at
00999E  1  E9 00                    sbc #$00                     ;subtract borrow
0099A0  1  9D 6B 04                 sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
0099A3  1  C8                       iny
0099A4  1  C8                       iny                          ;increment length by 2
0099A5  1  98                       tya
0099A6  1  0A                       asl                          ;multiply by 16 to get size of whirlpool
0099A7  1  0A                       asl                          ;note that whirlpool will always be
0099A8  1  0A                       asl                          ;two blocks bigger than actual size of hole
0099A9  1  0A                       asl                          ;and extend one block beyond each edge
0099AA  1  9D 77 04                 sta Whirlpool_Length,x       ;save size of whirlpool here
0099AD  1  E8                       inx
0099AE  1  E0 05                    cpx #$05                     ;increment and check offset
0099B0  1  90 02                    bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
0099B2  1  A2 00                    ldx #$00                     ;otherwise initialize it
0099B4  1  8E 6A 04     StrWOffset: stx Whirlpool_Offset         ;save new offset here
0099B7  1  AE 4E 07     NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
0099BA  1  BD 81 99                 lda HoleMetatiles,x          ;render the hole proper
0099BD  1  A2 08                    ldx #$08
0099BF  1  A0 0F                    ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
0099C1  1               
0099C1  1               ;--------------------------------
0099C1  1               
0099C1  1               RenderUnderPart:
0099C1  1  8C 35 07                  sty AreaObjectHeight  ;store vertical length to render
0099C4  1  BC A1 06                  ldy MetatileBuffer,x  ;check current spot to see if there's something
0099C7  1  F0 10                     beq DrawThisRow       ;we need to keep, if nothing, go ahead
0099C9  1  C0 17                     cpy #$17
0099CB  1  F0 0F                     beq WaitOneRow        ;if middle part (tree ledge), wait until next row
0099CD  1  C0 8B                     cpy #$8b
0099CF  1  F0 0B                     beq WaitOneRow        ;if middle part (cloud ledge), wait until next row
0099D1  1  C0 C0                     cpy #$c0
0099D3  1  F0 04                     beq DrawThisRow       ;if question block w/ coin, overwrite
0099D5  1  C0 C0                     cpy #$c0
0099D7  1  B0 03                     bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
0099D9  1  9D A1 06     DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
0099DC  1  E8           WaitOneRow:  inx
0099DD  1  E0 0D                     cpx #$0d              ;stop rendering if we're at the bottom of the screen
0099DF  1  B0 06                     bcs ExitUPartR
0099E1  1  AC 35 07                  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
0099E4  1  88                        dey
0099E5  1  10 DA                     bpl RenderUnderPart
0099E7  1  60           ExitUPartR:  rts
0099E8  1               
0099E8  1               
0099E8  1               ChkLrgObjLength:
0099E8  1  20 F7 99             jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
0099EB  1               
0099EB  1               ChkLrgObjFixedLength:
0099EB  1  BD 30 07             lda AreaObjectLength,x  ;check for set length counter
0099EE  1  18                   clc                     ;clear carry flag for not just starting
0099EF  1  10 05                bpl LenSet              ;if counter not set, load it, otherwise leave alone
0099F1  1  98                   tya                     ;save length into length counter
0099F2  1  9D 30 07             sta AreaObjectLength,x
0099F5  1  38                   sec                     ;set carry flag if just starting
0099F6  1  60           LenSet: rts
0099F7  1               
0099F7  1               GetLrgObjAttrib:
0099F7  1  BC 2D 07           ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
0099FA  1  B1 E7              lda (AreaData),y          ;get first byte of level object
0099FC  1  29 0F              and #%00001111
0099FE  1  85 07              sta $07                   ;save row location
009A00  1  C8                 iny
009A01  1  B1 E7              lda (AreaData),y          ;get next byte, save lower nybble (length or height)
009A03  1  29 0F              and #%00001111            ;as Y, then leave
009A05  1  A8                 tay
009A06  1  60                 rts
009A07  1               
009A07  1               ;--------------------------------
009A07  1               
009A07  1               GetAreaObjXPosition:
009A07  1  AD 26 07           lda CurrentColumnPos    ;multiply current offset where we're at by 16
009A0A  1  0A                 asl                     ;to obtain horizontal pixel coordinate
009A0B  1  0A                 asl
009A0C  1  0A                 asl
009A0D  1  0A                 asl
009A0E  1  60                 rts
009A0F  1               
009A0F  1               ;--------------------------------
009A0F  1               
009A0F  1               GetAreaObjYPosition:
009A0F  1  A5 07              lda $07  ;multiply value by 16
009A11  1  0A                 asl
009A12  1  0A                 asl      ;this will give us the proper vertical pixel coordinate
009A13  1  0A                 asl
009A14  1  0A                 asl
009A15  1  18                 clc
009A16  1  69 20              adc #32  ;add 32 pixels for the status bar
009A18  1  60                 rts
009A19  1               
009A19  1               ;-------------------------------------------------------------------------------------
009A19  1               ;$06-$07 - used to store block buffer address used as indirect
009A19  1               
009A19  1               BlockBufferAddr:
009A19  1  00 D0              .byte <Block_Buffer_1, <Block_Buffer_2
009A1B  1  05 05              .byte >Block_Buffer_1, >Block_Buffer_2
009A1D  1               
009A1D  1               GetBlockBufferAddr:
009A1D  1  48                 pha                      ;take value of A, save
009A1E  1  4A                 lsr                      ;move high nybble to low
009A1F  1  4A                 lsr
009A20  1  4A                 lsr
009A21  1  4A                 lsr
009A22  1  A8                 tay                      ;use nybble as pointer to high byte
009A23  1  B9 1B 9A           lda BlockBufferAddr+2,y  ;of indirect here
009A26  1  85 07              sta $07
009A28  1  68                 pla
009A29  1  29 0F              and #%00001111           ;pull from stack, mask out high nybble
009A2B  1  18                 clc
009A2C  1  79 19 9A           adc BlockBufferAddr,y    ;add to low byte
009A2F  1  85 06              sta $06                  ;store here and leave
009A31  1  60                 rts
009A32  1               
009A32  1               ;-------------------------------------------------------------------------------------
009A32  1               
009A32  1               GameModeSubs:
009A32  1  AD 72 07           lda OperMode_Task
009A35  1  20 69 8C           jsr JumpEngine
009A38  1               
009A38  1  09 E0              .word GameModeDiskRoutines
009A3A  1  27 8E              .word InitializeArea
009A3C  1  77 84              .word ScreenRoutines
009A3E  1  A4 8E              .word SecondaryGameSetup
009A40  1  42 9A              .word GameCoreRoutine
009A42  1               
009A42  1               GameCoreRoutine:
009A42  1  20 9D 9B           jsr GameRoutines           ;execute one of many possible subs
009A45  1  AD 72 07           lda OperMode_Task          ;check major task of operating mode
009A48  1  C9 04              cmp #$04                   ;if we are supposed to be here,
009A4A  1  B0 01              bcs GameEngine             ;branch to the game engine itself
009A4C  1  60                 rts
009A4D  1               
009A4D  1               GameEngine:
009A4D  1  20 C9 A1                   jsr ProcFireball_Bubble    ;process fireballs and air bubbles
009A50  1  A2 00                      ldx #$00
009A52  1  86 08        ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
009A54  1  20 43 AC                   jsr EnemiesAndLoopsCore    ;process enemy objects
009A57  1  20 D3 83                   jsr FloateyNumbersRoutine  ;process floatey numbers
009A5A  1  E8                         inx
009A5B  1  E0 06                      cpx #$06                   ;do these two subroutines until the whole buffer is done
009A5D  1  D0 F3                      bne ProcELoop
009A5F  1  20 4A DE                   jsr GetPlayerOffscreenBits ;get offscreen bits for player object
009A62  1  20 F4 DD                   jsr RelativePlayerPosition ;get relative coordinates for player object
009A65  1  20 A9 DB                   jsr PlayerGfxHandler       ;draw the player
009A68  1  20 D0 AA                   jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
009A6B  1  A2 01                      ldx #$01
009A6D  1  86 08                      stx ObjectOffset           ;set offset for second
009A6F  1  20 6C AA                   jsr BlockObjectsCore       ;process second block object
009A72  1  CA                         dex
009A73  1  86 08                      stx ObjectOffset           ;set offset for first
009A75  1  20 6C AA                   jsr BlockObjectsCore       ;process first block object
009A78  1  20 8C A7                   jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
009A7B  1  20 B2 A5                   jsr ProcessCannons         ;process bullet bill cannons
009A7E  1  20 5A A3                   jsr ProcessWhirlpools      ;process whirlpools
009A81  1  20 F7 A3                   jsr FlagpoleRoutine        ;process the flagpole
009A84  1  20 F4 A2                   jsr RunGameTimer           ;count down the game timer
009A87  1  20 96 88                   jsr ColorRotation          ;cycle one of the background colors
009A8A  1  AD F7 07                   lda FileListNumber
009A8D  1  F0 03                      beq NoWind                 ;if in worlds 1-4, skip ahead
009A8F  1  20 D4 E4                   jsr SimulateWind           ;otherwise, simulate wind where needed
009A92  1  A5 B5        NoWind:       lda Player_Y_HighPos
009A94  1  C9 02                      cmp #$02                   ;if player is below the screen, don't bother with the music
009A96  1  10 11                      bpl NoChgMus
009A98  1  AD 9F 07                   lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
009A9B  1  F0 1E                      beq ClrPlrPal              ;skip this part
009A9D  1  C9 04                      cmp #$04
009A9F  1  D0 08                      bne NoChgMus               ;if not yet at a certain point, continue
009AA1  1  AD 7F 07                   lda IntervalTimerControl   ;if interval timer not yet expired,
009AA4  1  D0 03                      bne NoChgMus               ;branch ahead, don't bother with the music
009AA6  1  20 18 8F                   jsr GetAreaMusic           ;to re-attain appropriate level music
009AA9  1  AC 9F 07     NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
009AAC  1  A5 09                      lda FrameCounter           ;get frame counter
009AAE  1  C0 08                      cpy #$08                   ;if timer still above certain point,
009AB0  1  B0 02                      bcs CycleTwo               ;branch to cycle player's palette quickly
009AB2  1  4A                         lsr                        ;otherwise, divide by 8 to cycle every eighth frame
009AB3  1  4A                         lsr
009AB4  1  4A           CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
009AB5  1  20 DB 9D                   jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
009AB8  1  4C BE 9A                   jmp SaveAB                 ;then skip this sub to finish up the game engine
009ABB  1  20 ED 9D     ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
009ABE  1  A5 0A        SaveAB:       lda A_B_Buttons            ;save current A and B button
009AC0  1  85 0D                      sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
009AC2  1  A9 00                      lda #$00
009AC4  1  85 0C                      sta Left_Right_Buttons     ;nullify left and right buttons temp variable
009AC6  1  AD 73 07     UpdScrollVar: lda VRAM_Buffer_AddrCtrl
009AC9  1  C9 06                      cmp #$06                   ;if vram address controller set to 6
009ACB  1  F0 1C                      beq ExitEng                ;then branch to leave
009ACD  1  AD 1F 07                   lda AreaParserTaskNum      ;otherwise check number of tasks
009AD0  1  D0 14                      bne RunParser
009AD2  1  AD 3D 07                   lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
009AD5  1  C9 20                      cmp #$20                   ;check to see if exceeded $21
009AD7  1  30 10                      bmi ExitEng                ;branch to leave if not
009AD9  1  AD 3D 07                   lda ScrollThirtyTwo
009ADC  1  E9 20                      sbc #$20                   ;otherwise subtract $20 to set appropriately
009ADE  1  8D 3D 07                   sta ScrollThirtyTwo        ;and store
009AE1  1  A9 00                      lda #$00                   ;reset vram buffer offset used in conjunction with
009AE3  1  8D 40 03                   sta VRAM_Buffer2_Offset    ;level graphics buffer in second VRAM buffer
009AE6  1  20 BC 90     RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
009AE9  1  60           ExitEng:      rts                        ;and after all that, we're finally done!
009AEA  1               
009AEA  1               ScrollHandler:
009AEA  1  AD FF 06                 lda Player_X_Scroll       ;load value saved here
009AED  1  18                       clc
009AEE  1  6D A1 03                 adc Platform_X_Scroll     ;add value used by left/right platforms
009AF1  1  8D FF 06                 sta Player_X_Scroll       ;save as new value here to impose force on scroll
009AF4  1  AD 23 07                 lda ScrollLock            ;check scroll lock flag
009AF7  1  D0 55                    bne InitScrlAmt           ;skip a bunch of code here if set
009AF9  1  AD 55 07                 lda Player_Pos_ForScroll
009AFC  1  C9 50                    cmp #$50                  ;check player's horizontal screen position
009AFE  1  90 4E                    bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
009B00  1  AD 85 07                 lda SideCollisionTimer    ;if timer related to player's side collision
009B03  1  D0 49                    bne InitScrlAmt           ;not expired, branch
009B05  1  AC FF 06                 ldy Player_X_Scroll       ;get value and decrement by one
009B08  1  88                       dey                       ;if value originally set to zero or otherwise
009B09  1  30 43                    bmi InitScrlAmt           ;negative for left movement, branch
009B0B  1  C8                       iny
009B0C  1  C0 02                    cpy #$02                  ;if value $01, branch and do not decrement
009B0E  1  90 01                    bcc ChkNearMid
009B10  1  88                       dey                       ;otherwise decrement by one
009B11  1  AD 55 07     ChkNearMid: lda Player_Pos_ForScroll
009B14  1  C9 70                    cmp #$70                  ;check player's horizontal screen position
009B16  1  90 03                    bcc ScrollScreen          ;if less than 112 pixels to the right, branch
009B18  1  AC FF 06                 ldy Player_X_Scroll       ;otherwise get original value undecremented
009B1B  1               
009B1B  1               ScrollScreen:
009B1B  1  AD 7B 07                   lda IRQAckFlag
009B1E  1  D0 FB                      bne ScrollScreen           ;loop if IRQ has not yet happened
009B20  1  98                         tya
009B21  1  8D 75 07                   sta ScrollAmount           ;save value here
009B24  1  18                         clc
009B25  1  6D 3D 07                   adc ScrollThirtyTwo        ;add to value already set here
009B28  1  8D 3D 07                   sta ScrollThirtyTwo        ;save as new value here
009B2B  1  98                         tya
009B2C  1  18                         clc
009B2D  1  6D 1C 07                   adc ScreenLeft_X_Pos       ;add to left side coordinate
009B30  1  8D 1C 07                   sta ScreenLeft_X_Pos       ;save as new left side coordinate
009B33  1  8D 3F 07                   sta HorizontalScroll       ;save here also
009B36  1  AD 1A 07                   lda ScreenLeft_PageLoc
009B39  1  69 00                      adc #$00                   ;add carry to page location for left
009B3B  1  8D 1A 07                   sta ScreenLeft_PageLoc     ;side of the screen
009B3E  1  29 01                      and #$01                   ;get LSB of page location
009B40  1  8D 7A 07                   sta NameTableSelect        ;save as name table select for later use
009B43  1  20 8B 9B                   jsr GetScreenPosition
009B46  1  A9 08                      lda #$08
009B48  1  8D 95 07                   sta ScrollIntervalTimer    ;set scroll timer (residual, not used elsewhere)
009B4B  1  4C 53 9B                   jmp ChkPOffscr             ;skip this part
009B4E  1  A9 00        InitScrlAmt:  lda #$00
009B50  1  8D 75 07                   sta ScrollAmount           ;initialize value here
009B53  1  A2 00        ChkPOffscr:   ldx #$00                   ;set X for player offset
009B55  1  20 C0 DE                   jsr GetXOffscreenBits      ;get horizontal offscreen bits for player
009B58  1  85 00                      sta $00                    ;save them here
009B5A  1  A0 00                      ldy #$00                   ;load default offset (left side)
009B5C  1  0A                         asl                        ;if d7 of offscreen bits are set,
009B5D  1  B0 07                      bcs KeepOnscr              ;branch with default offset
009B5F  1  C8                         iny                        ;otherwise use different offset (right side)
009B60  1  A5 00                      lda $00
009B62  1  29 20                      and #%00100000             ;check offscreen bits for d5 set
009B64  1  F0 1B                      beq InitPlatScrl           ;if not set, branch ahead of this part
009B66  1  B9 1C 07     KeepOnscr:    lda ScreenEdge_X_Pos,y     ;get left or right side coordinate based on offset
009B69  1  38                         sec
009B6A  1  F9 87 9B                   sbc X_SubtracterData,y     ;subtract amount based on offset
009B6D  1  85 86                      sta Player_X_Position      ;store as player position to prevent movement further
009B6F  1  B9 1A 07                   lda ScreenEdge_PageLoc,y   ;get left or right page location based on offset
009B72  1  E9 00                      sbc #$00                   ;subtract borrow
009B74  1  85 6D                      sta Player_PageLoc         ;save as player's page location
009B76  1  A5 0C                      lda Left_Right_Buttons     ;check saved controller bits
009B78  1  D9 89 9B                   cmp OffscrJoypadBitsData,y ;against bits based on offset
009B7B  1  F0 04                      beq InitPlatScrl           ;if not equal, branch
009B7D  1  A9 00                      lda #$00
009B7F  1  85 57                      sta Player_X_Speed         ;otherwise nullify horizontal speed of player
009B81  1  A9 00        InitPlatScrl: lda #$00                   ;nullify platform force imposed on scroll
009B83  1  8D A1 03                   sta Platform_X_Scroll
009B86  1  60                         rts
009B87  1               
009B87  1               X_SubtracterData:
009B87  1  00 10              .byte $00, $10
009B89  1               
009B89  1               OffscrJoypadBitsData:
009B89  1  01 02              .byte $01, $02
009B8B  1               
009B8B  1               ;-------------------------------------------------------------------------------------
009B8B  1               
009B8B  1               GetScreenPosition:
009B8B  1  AD 1C 07           lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
009B8E  1  18                 clc
009B8F  1  69 FF              adc #$ff                ;add 255 pixels
009B91  1  8D 1D 07           sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
009B94  1  AD 1A 07           lda ScreenLeft_PageLoc  ;get page number where left boundary is
009B97  1  69 00              adc #$00                ;add carry from before
009B99  1  8D 1B 07           sta ScreenRight_PageLoc ;store as page number where right boundary is
009B9C  1  60                 rts
009B9D  1               
009B9D  1               ;-------------------------------------------------------------------------------------
009B9D  1               
009B9D  1               GameRoutines:
009B9D  1  A5 0E              lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
009B9F  1  20 69 8C           jsr JumpEngine            ;merely placeholders as conditions for other routines)
009BA2  1               
009BA2  1  5C 8F              .word Entrance_GameTimerSetup
009BA4  1  1A 9D              .word Vine_AutoClimb
009BA6  1  59 9D              .word SideExitPipeEntry
009BA8  1  38 9D              .word VerticalPipeEntry
009BAA  1  F6 9D              .word FlagpoleSlide
009BAC  1  14 9E              .word PlayerEndLevel
009BAE  1  02 90              .word PlayerLoseLife
009BB0  1  BC 9B              .word PlayerEntrance
009BB2  1  3C 9C              .word PlayerCtrlRoutine
009BB4  1  86 9D              .word PlayerChangeSize
009BB6  1  98 9D              .word PlayerInjuryBlink
009BB8  1  BC 9D              .word PlayerDeath
009BBA  1  D0 9D              .word PlayerFireFlower
009BBC  1               
009BBC  1               PlayerEntrance:
009BBC  1  AD 52 07                 lda AltEntranceControl    ;check for mode of alternate entry
009BBF  1  C9 02                    cmp #$02
009BC1  1  F0 2B                    beq EntrMode2             ;if found, branch to enter from pipe or with vine
009BC3  1  A9 00                    lda #$00
009BC5  1  A4 CE                    ldy Player_Y_Position     ;if vertical position above a certain
009BC7  1  C0 30                    cpy #$30                  ;point, nullify controller bits and continue
009BC9  1  90 6E                    bcc AutoControlPlayer     ;with player movement code, do not return
009BCB  1  AD 10 07                 lda PlayerEntranceCtrl    ;check player entry bits from header
009BCE  1  C9 06                    cmp #$06
009BD0  1  F0 04                    beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
009BD2  1  C9 07                    cmp #$07                  ;otherwise branch to normal entry
009BD4  1  D0 50                    bne PlayerRdy
009BD6  1  AD C4 03     ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
009BD9  1  D0 05                    bne IntroEntr             ;branch if found
009BDB  1  A9 01                    lda #$01
009BDD  1  4C 39 9C                 jmp AutoControlPlayer     ;force player to walk to the right
009BE0  1  20 72 9D     IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
009BE3  1  CE DE 06                 dec ChangeAreaTimer       ;decrement timer for change of area
009BE6  1  D0 50                    bne ExitEntr              ;branch to exit if not yet expired
009BE8  1  EE 69 07                 inc DisableIntermediate   ;set flag to skip world and lives display
009BEB  1  4C 61 9E                 jmp NextArea              ;jump to increment to next area and set modes
009BEE  1  AD 58 07     EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
009BF1  1  D0 0C                    bne VineEntr              ;branch to enter with vine
009BF3  1  A9 FF                    lda #$ff                  ;otherwise, set value here then execute sub
009BF5  1  20 53 9D                 jsr MovePlayerYAxis       ;to move player upwards
009BF8  1  A5 CE                    lda Player_Y_Position     ;check to see if player is at a specific coordinate
009BFA  1  C9 91                    cmp #$91                  ;if player risen to a certain point (this requires pipes
009BFC  1  90 28                    bcc PlayerRdy             ;to be at specific height to look/function right) branch
009BFE  1  60                       rts                       ;to the last part, otherwise leave
009BFF  1  AD 99 03     VineEntr:   lda VineHeight
009C02  1  C9 60                    cmp #$60                  ;check vine height
009C04  1  D0 32                    bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
009C06  1  A5 CE                    lda Player_Y_Position     ;get player's vertical coordinate
009C08  1  C9 99                    cmp #$99                  ;check player's vertical coordinate against preset value
009C0A  1  A0 00                    ldy #$00                  ;load default values to be written to
009C0C  1  A9 01                    lda #$01                  ;this value moves player to the right off the vine
009C0E  1  90 0A                    bcc OffVine               ;if vertical coordinate < preset value, use defaults
009C10  1  A9 03                    lda #$03
009C12  1  85 1D                    sta Player_State          ;otherwise set player state to climbing
009C14  1  C8                       iny                       ;increment value in Y
009C15  1  A9 08                    lda #$08                  ;set block in block buffer to cover hole, then
009C17  1  8D B4 05                 sta Block_Buffer_1+$b4    ;use same value to force player to climb
009C1A  1  8C 16 07     OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
009C1D  1  20 39 9C                 jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
009C20  1  A5 86                    lda Player_X_Position
009C22  1  C9 48                    cmp #$48                  ;check player's horizontal position
009C24  1  90 12                    bcc ExitEntr              ;if not far enough to the right, branch to leave
009C26  1  A9 08        PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
009C28  1  85 0E                    sta GameEngineSubroutine
009C2A  1  A9 01                    lda #$01                  ;set to face player to the right
009C2C  1  85 33                    sta PlayerFacingDir
009C2E  1  4A                       lsr                       ;init A
009C2F  1  8D 52 07                 sta AltEntranceControl    ;init mode of entry
009C32  1  8D 16 07                 sta DisableCollisionDet   ;init collision detection disable flag
009C35  1  8D 58 07                 sta JoypadOverride        ;nullify controller override bits
009C38  1  60           ExitEntr:   rts                       ;leave!
009C39  1               
009C39  1               ;-------------------------------------------------------------------------------------
009C39  1               ;$07 - used to hold upper limit of high byte when player falls down hole
009C39  1               
009C39  1               AutoControlPlayer:
009C39  1  8D FC 06           sta SavedJoypadBits         ;override controller bits with contents of A if executing here
009C3C  1               
009C3C  1               PlayerCtrlRoutine:
009C3C  1  A5 0E                    lda GameEngineSubroutine    ;check task here
009C3E  1  C9 0B                    cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
009C40  1  F0 3C                    beq SizeChk
009C42  1  AD 4E 07                 lda AreaType                ;are we in a water type area?
009C45  1  D0 10                    bne SaveJoyp                ;if not, branch
009C47  1  A4 B5                    ldy Player_Y_HighPos
009C49  1  88                       dey                         ;if not in vertical area between
009C4A  1  D0 06                    bne DisJoyp                 ;status bar and bottom, branch
009C4C  1  A5 CE                    lda Player_Y_Position
009C4E  1  C9 D0                    cmp #$d0                    ;if nearing the bottom of the screen or
009C50  1  90 05                    bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
009C52  1  A9 00        DisJoyp:    lda #$00                    ;disable controller bits
009C54  1  8D FC 06                 sta SavedJoypadBits
009C57  1  AD FC 06     SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
009C5A  1  29 C0                    and #%11000000
009C5C  1  85 0A                    sta A_B_Buttons
009C5E  1  AD FC 06                 lda SavedJoypadBits         ;store left and right buttons in $0c
009C61  1  29 03                    and #%00000011
009C63  1  85 0C                    sta Left_Right_Buttons
009C65  1  AD FC 06                 lda SavedJoypadBits         ;store up and down buttons in $0b
009C68  1  29 0C                    and #%00001100
009C6A  1  85 0B                    sta Up_Down_Buttons
009C6C  1  29 04                    and #%00000100              ;check for pressing down
009C6E  1  F0 0E                    beq SizeChk                 ;if not, branch
009C70  1  A5 1D                    lda Player_State            ;check player's state
009C72  1  D0 0A                    bne SizeChk                 ;if not on the ground, branch
009C74  1  A4 0C                    ldy Left_Right_Buttons      ;check left and right
009C76  1  F0 06                    beq SizeChk                 ;if neither pressed, branch
009C78  1  A9 00                    lda #$00
009C7A  1  85 0C                    sta Left_Right_Buttons      ;if pressing down while on the ground,
009C7C  1  85 0B                    sta Up_Down_Buttons         ;nullify directional bits
009C7E  1  20 8B 9E     SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
009C81  1  A0 01                    ldy #$01                    ;is player small?
009C83  1  AD 54 07                 lda PlayerSize
009C86  1  D0 09                    bne ChkMoveDir
009C88  1  A0 00                    ldy #$00                    ;check for if crouching
009C8A  1  AD 14 07                 lda CrouchingFlag
009C8D  1  F0 02                    beq ChkMoveDir              ;if not, branch ahead
009C8F  1  A0 02                    ldy #$02                    ;if big and crouching, load y with 2
009C91  1  8C 99 04     ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
009C94  1  A9 01                    lda #$01                    ;set moving direction to right by default
009C96  1  A4 57                    ldy Player_X_Speed          ;check player's horizontal speed
009C98  1  F0 05                    beq PlayerSubs              ;if not moving at all horizontally, skip this part
009C9A  1  10 01                    bpl SetMoveDir              ;if moving to the right, use default moving direction
009C9C  1  0A                       asl                         ;otherwise change to move to the left
009C9D  1  85 45        SetMoveDir: sta Player_MovingDir        ;set moving direction
009C9F  1  20 EA 9A     PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
009CA2  1  20 4A DE                 jsr GetPlayerOffscreenBits  ;get player's offscreen bits
009CA5  1  20 F4 DD                 jsr RelativePlayerPosition  ;get coordinates relative to the screen
009CA8  1  A2 00                    ldx #$00                    ;set offset for player object
009CAA  1  20 1D CF                 jsr BoundingBoxCore         ;get player's bounding box coordinates
009CAD  1  20 CA C8                 jsr PlayerBGCollision       ;do collision detection and process
009CB0  1  A5 CE                    lda Player_Y_Position
009CB2  1  C9 40                    cmp #$40                    ;check to see if player is higher than 64th pixel
009CB4  1  90 16                    bcc PlayerHole              ;if so, branch ahead
009CB6  1  A5 0E                    lda GameEngineSubroutine
009CB8  1  C9 05                    cmp #$05                    ;if running end-of-level routine, branch ahead
009CBA  1  F0 10                    beq PlayerHole
009CBC  1  C9 07                    cmp #$07                    ;if running player entrance routine, branch ahead
009CBE  1  F0 0C                    beq PlayerHole
009CC0  1  C9 04                    cmp #$04                    ;if running routines $00-$03, branch ahead
009CC2  1  90 08                    bcc PlayerHole
009CC4  1  AD C4 03                 lda Player_SprAttrib
009CC7  1  29 DF                    and #%11011111              ;otherwise nullify player's
009CC9  1  8D C4 03                 sta Player_SprAttrib        ;background priority flag
009CCC  1  A5 B5        PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
009CCE  1  C9 02                    cmp #$02                    ;for below the screen
009CD0  1  30 3B                    bmi ExitCtrl                ;branch to leave if not that far down
009CD2  1  A2 01                    ldx #$01
009CD4  1  8E 23 07                 stx ScrollLock              ;set scroll lock
009CD7  1  A0 04                    ldy #$04
009CD9  1  84 07                    sty $07                     ;set value here
009CDB  1  A2 00                    ldx #$00                    ;use X as flag, and clear for cloud level
009CDD  1  AC 59 07                 ldy GameTimerExpiredFlag    ;check game timer expiration flag
009CE0  1  D0 05                    bne HoleDie                 ;if set, branch
009CE2  1  AC 43 07                 ldy CloudTypeOverride       ;check for cloud type override
009CE5  1  D0 16                    bne ChkHoleX                ;skip to last part if found
009CE7  1  E8           HoleDie:    inx                         ;set flag in X for player death
009CE8  1  A4 0E                    ldy GameEngineSubroutine
009CEA  1  C0 0B                    cpy #$0b                    ;check for some other routine running
009CEC  1  F0 0F                    beq ChkHoleX                ;if so, branch ahead
009CEE  1  AC 12 07                 ldy DeathMusicLoaded        ;check value here
009CF1  1  D0 06                    bne HoleBottom              ;if already set, branch to next part
009CF3  1  C8                       iny
009CF4  1  84 FC                    sty EventMusicQueue         ;otherwise play death music
009CF6  1  8C 12 07                 sty DeathMusicLoaded        ;and set value here
009CF9  1  A0 06        HoleBottom: ldy #$06
009CFB  1  84 07                    sty $07                     ;change value here
009CFD  1  C5 07        ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
009CFF  1  30 0C                    bmi ExitCtrl                ;if less, branch to leave
009D01  1  CA                       dex                         ;otherwise decrement flag in X
009D02  1  30 0A                    bmi CloudExit               ;if flag was clear, branch to set modes and other values
009D04  1  AC B1 07                 ldy EventMusicBuffer        ;check to see if music is still playing
009D07  1  D0 04                    bne ExitCtrl                ;branch to leave if so
009D09  1  A9 06                    lda #$06                    ;otherwise set to run lose life routine
009D0B  1  85 0E                    sta GameEngineSubroutine    ;on next frame
009D0D  1  60           ExitCtrl:   rts                         ;leave
009D0E  1               
009D0E  1               CloudExit:
009D0E  1  A9 00              lda #$00
009D10  1  8D 58 07           sta JoypadOverride      ;clear controller override bits if any are set
009D13  1  20 30 9D           jsr SetEntr             ;do sub to set secondary mode
009D16  1  EE 52 07           inc AltEntranceControl  ;set mode of entry to 3
009D19  1  60                 rts
009D1A  1               
009D1A  1               ;-------------------------------------------------------------------------------------
009D1A  1               
009D1A  1               Vine_AutoClimb:
009D1A  1  A5 B5                   lda Player_Y_HighPos   ;check to see whether player reached position
009D1C  1  D0 06                   bne AutoClimb          ;above the status bar yet and if so, set modes
009D1E  1  A5 CE                   lda Player_Y_Position
009D20  1  C9 E4                   cmp #$e4
009D22  1  90 0C                   bcc SetEntr
009D24  1  A9 08        AutoClimb: lda #%00001000         ;set controller bits override to up
009D26  1  8D 58 07                sta JoypadOverride
009D29  1  A0 03                   ldy #$03               ;set player state to climbing
009D2B  1  84 1D                   sty Player_State
009D2D  1  4C 39 9C                jmp AutoControlPlayer
009D30  1  A9 02        SetEntr:   lda #$02               ;set starting position to override
009D32  1  8D 52 07                sta AltEntranceControl
009D35  1  4C 66 9D                jmp ChgAreaMode        ;set modes
009D38  1               
009D38  1               ;-------------------------------------------------------------------------------------
009D38  1               
009D38  1               VerticalPipeEntry:
009D38  1  A9 01              lda #$01             ;set 1 as movement amount
009D3A  1  20 53 9D           jsr MovePlayerYAxis  ;do sub to move player downwards
009D3D  1  20 EA 9A           jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
009D40  1  A0 00              ldy #$00             ;load default mode of entry
009D42  1  AD D6 06           lda WarpZoneControl  ;check warp zone control variable/flag
009D45  1  D0 17              bne ChgAreaPipe      ;if set, branch to use mode 0
009D47  1  C8                 iny
009D48  1  AD 4E 07           lda AreaType         ;check for castle level type
009D4B  1  C9 03              cmp #$03
009D4D  1  D0 0F              bne ChgAreaPipe      ;if not castle type level, use mode 1
009D4F  1  C8                 iny
009D50  1  4C 5E 9D           jmp ChgAreaPipe      ;otherwise use mode 2
009D53  1               
009D53  1               MovePlayerYAxis:
009D53  1  18                 clc
009D54  1  65 CE              adc Player_Y_Position ;add contents of A to player position
009D56  1  85 CE              sta Player_Y_Position
009D58  1  60                 rts
009D59  1               
009D59  1               ;-------------------------------------------------------------------------------------
009D59  1               
009D59  1               SideExitPipeEntry:
009D59  1  20 72 9D                  jsr EnterSidePipe         ;execute sub to move player to the right
009D5C  1  A0 02                     ldy #$02
009D5E  1  CE DE 06     ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
009D61  1  D0 0E                     bne ExitCAPipe
009D63  1  8C 52 07                  sty AltEntranceControl    ;when timer expires set mode of alternate entry
009D66  1  EE 74 07     ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
009D69  1  A9 00                     lda #$00
009D6B  1  8D 72 07                  sta OperMode_Task         ;set secondary mode of operation
009D6E  1  8D 22 07                  sta IRQUpdateFlag  ;disable IRQ check
009D71  1  60           ExitCAPipe:  rts                       ;leave
009D72  1               
009D72  1               EnterSidePipe:
009D72  1  A9 08                   lda #$08               ;set player's horizontal speed
009D74  1  85 57                   sta Player_X_Speed
009D76  1  A0 01                   ldy #$01               ;set controller right button by default
009D78  1  A5 86                   lda Player_X_Position  ;mask out higher nybble of player's
009D7A  1  29 0F                   and #%00001111         ;horizontal position
009D7C  1  D0 03                   bne RightPipe
009D7E  1  85 57                   sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
009D80  1  A8                      tay                    ;and nullify controller bit override here
009D81  1  98           RightPipe: tya                    ;use contents of Y to
009D82  1  20 39 9C                jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
009D85  1  60                      rts
009D86  1               
009D86  1               ;-------------------------------------------------------------------------------------
009D86  1               
009D86  1               PlayerChangeSize:
009D86  1  AD 47 07                  lda TimerControl    ;check master timer control
009D89  1  C9 F8                     cmp #$f8            ;for specific moment in time
009D8B  1  D0 03                     bne EndChgSize      ;branch if before or after that point
009D8D  1  4C A8 9D                  jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
009D90  1  C9 C4        EndChgSize:  cmp #$c4            ;check again for another specific moment
009D92  1  D0 03                     bne ExitChgSize     ;and branch to leave if before or after that point
009D94  1  20 C6 9D                  jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
009D97  1  60           ExitChgSize: rts                 ;and then leave
009D98  1               
009D98  1               ;-------------------------------------------------------------------------------------
009D98  1               
009D98  1               PlayerInjuryBlink:
009D98  1  AD 47 07                lda TimerControl       ;check master timer control
009D9B  1  C9 F0                   cmp #$f0               ;for specific moment in time
009D9D  1  B0 07                   bcs ExitBlink          ;branch if before that point
009D9F  1  C9 C8                   cmp #$c8               ;check again for another specific point
009DA1  1  F0 23                   beq DonePlayerTask     ;branch if at that point, and not before or after
009DA3  1  4C 3C 9C                jmp PlayerCtrlRoutine  ;otherwise run player control routine
009DA6  1  D0 13        ExitBlink: bne ExitBoth           ;do unconditional branch to leave
009DA8  1               
009DA8  1               InitChangeSize:
009DA8  1  AC 0B 07               ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
009DAB  1  D0 0E                  bne ExitBoth              ;then branch to leave
009DAD  1  8C 0D 07               sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
009DB0  1  EE 0B 07               inc PlayerChangeSizeFlag  ;set growing/shrinking flag
009DB3  1  AD 54 07               lda PlayerSize
009DB6  1  49 01                  eor #$01                  ;invert player's size
009DB8  1  8D 54 07               sta PlayerSize
009DBB  1  60           ExitBoth: rts                       ;leave
009DBC  1               
009DBC  1               ;-------------------------------------------------------------------------------------
009DBC  1               ;$00 - used in CyclePlayerPalette to store current palette to cycle
009DBC  1               
009DBC  1               PlayerDeath:
009DBC  1  AD 47 07           lda TimerControl       ;check master timer control
009DBF  1  C9 F0              cmp #$f0               ;for specific moment in time
009DC1  1  B0 32              bcs ExitDeath          ;branch to leave if before that point
009DC3  1  4C 3C 9C           jmp PlayerCtrlRoutine  ;otherwise run player control routine
009DC6  1               
009DC6  1               DonePlayerTask:
009DC6  1  A9 00              lda #$00
009DC8  1  8D 47 07           sta TimerControl          ;initialize master timer control to continue timers
009DCB  1  A9 08              lda #$08
009DCD  1  85 0E              sta GameEngineSubroutine  ;set player control routine to run next frame
009DCF  1  60                 rts                       ;leave
009DD0  1               
009DD0  1               PlayerFireFlower:
009DD0  1  AD 47 07           lda TimerControl       ;check master timer control
009DD3  1  C9 C0              cmp #$c0               ;for specific moment in time
009DD5  1  F0 13              beq ResetPalFireFlower ;branch if at moment, not before or after
009DD7  1  A5 09              lda FrameCounter       ;get frame counter
009DD9  1  4A                 lsr
009DDA  1  4A                 lsr                    ;divide by four to change every four frames
009DDB  1               
009DDB  1               CyclePlayerPalette:
009DDB  1  29 03              and #$03              ;mask out all but d1-d0 (previously d3-d2)
009DDD  1  85 00              sta $00               ;store result here to use as palette bits
009DDF  1  AD C4 03           lda Player_SprAttrib  ;get player attributes
009DE2  1  29 FC              and #%11111100        ;save any other bits but palette bits
009DE4  1  05 00              ora $00               ;add palette bits
009DE6  1  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
009DE9  1  60                 rts                   ;and leave
009DEA  1               
009DEA  1               ResetPalFireFlower:
009DEA  1  20 C6 9D           jsr DonePlayerTask    ;do sub to init timer control and run player control routine
009DED  1               
009DED  1               ResetPalStar:
009DED  1  AD C4 03           lda Player_SprAttrib  ;get player attributes
009DF0  1  29 FC              and #%11111100        ;mask out palette bits to force palette 0
009DF2  1  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
009DF5  1               ExitDeath:
009DF5  1  60                 rts                   ;and leave
009DF6  1               
009DF6  1               ;-------------------------------------------------------------------------------------
009DF6  1               
009DF6  1               FlagpoleSlide:
009DF6  1  A5 1B                     lda Enemy_ID+5           ;check special use enemy slot
009DF8  1  C9 30                     cmp #FlagpoleFlagObject  ;for flagpole flag object
009DFA  1  D0 15                     bne NoFPObj              ;if not found, branch to something residual
009DFC  1  AD 13 07                  lda FlagpoleSoundQueue   ;load flagpole sound
009DFF  1  85 FF                     sta Square1SoundQueue    ;into square 1's sfx queue
009E01  1  A9 00                     lda #$00
009E03  1  8D 13 07                  sta FlagpoleSoundQueue   ;init flagpole sound queue
009E06  1  A4 CE                     ldy Player_Y_Position
009E08  1  C0 9E                     cpy #$9e                 ;check to see if player has slid down
009E0A  1  B0 02                     bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
009E0C  1  A9 04                     lda #$04                 ;otherwise force player to climb down (to slide)
009E0E  1  4C 39 9C     SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
009E11  1  E6 0E        NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
009E13  1  60                        rts                      ;be residual code)
009E14  1               
009E14  1               ;-------------------------------------------------------------------------------------
009E14  1               
009E14  1               PlayerEndLevel:
009E14  1  A9 01                  lda #$01                  ;force player to walk to the right
009E16  1  20 39 9C               jsr AutoControlPlayer
009E19  1  A5 CE                  lda Player_Y_Position     ;check player's vertical position
009E1B  1  C9 AE                  cmp #$ae
009E1D  1  90 11                  bcc ChkStop               ;if player is not yet off the flagpole, skip this part
009E1F  1  A9 00                  lda #$00
009E21  1  8D 23 07               sta ScrollLock            ;reactivate scroll
009E24  1  AD F6 07               lda FlagpoleMusicFlag     ;check flag to see if music was already queued
009E27  1  D0 07                  bne ChkStop               ;if so, skip this
009E29  1  A9 20                  lda #EndOfLevelMusic
009E2B  1  85 FC                  sta EventMusicQueue       ;load win level music in event music queue
009E2D  1  EE F6 07               inc FlagpoleMusicFlag     ;set flag to keep music from getting queued more than once
009E30  1  AD 90 04     ChkStop:  lda Player_CollisionBits  ;get player collision bits
009E33  1  4A                     lsr                       ;check for d0 set
009E34  1  B0 0D                  bcs RdyNextA              ;if d0 set, skip to next part
009E36  1  AD 46 07               lda StarFlagTaskControl   ;if star flag task control already set,
009E39  1  D0 03                  bne InCastle              ;go ahead with the rest of the code
009E3B  1  EE 46 07               inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
009E3E  1  A9 20        InCastle: lda #%00100000            ;set player's background priority bit to
009E40  1  8D C4 03               sta Player_SprAttrib      ;give illusion of being inside the castle
009E43  1  AD 46 07     RdyNextA: lda StarFlagTaskControl
009E46  1  C9 05                  cmp #$05                  ;if star flag task control not yet set
009E48  1  D0 40                  bne ExitNA                ;beyond last valid task number, branch to leave
009E4A  1  EE 5C 07               inc LevelNumber           ;increment level number used for game logic
009E4D  1  AD 5C 07               lda LevelNumber
009E50  1  C9 03                  cmp #$03                  ;check to see if we have yet reached level -4
009E52  1  D0 0D                  bne NextArea              ;and skip this last part here if not
009E54  1  AC 5F 07               ldy WorldNumber           ;get world number as offset
009E57  1  AD 48 07               lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
009E5A  1  C9 0A                  cmp #$0a                  ;against minimum value, if player has not collected
009E5C  1  90 03                  bcc NextArea              ;at least this number of coins, leave flag clear
009E5E  1  EE 5D 07               inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
009E61  1  EE 60 07     NextArea: inc AreaNumber            ;increment area number used for address loader
009E64  1  AD 5F 07               lda WorldNumber
009E67  1  C9 08                  cmp #$08
009E69  1  D0 0F                  bne NotW9                 ;if not at end of world 9-4, branch
009E6B  1  AD 5C 07               lda LevelNumber           ;otherwise reset level and area numbers properly
009E6E  1  C9 04                  cmp #$04
009E70  1  D0 08                  bne NotW9
009E72  1  A9 00                  lda #$00
009E74  1  8D 5C 07               sta LevelNumber
009E77  1  8D 60 07               sta AreaNumber
009E7A  1  20 29 FF     NotW9:    jsr RunLoadAreaPointer    ;get new level pointer
009E7D  1  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
009E80  1  20 66 9D               jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and IRQ
009E83  1  8D 5B 07               sta HalfwayPage           ;reset halfway page to 0 (beginning)
009E86  1  A9 80                  lda #Silence
009E88  1  85 FC                  sta EventMusicQueue       ;silence music and leave
009E8A  1  60           ExitNA:   rts
009E8B  1               
009E8B  1               ;-------------------------------------------------------------------------------------
009E8B  1               
009E8B  1               PlayerMovementSubs:
009E8B  1  A9 00                   lda #$00                  ;set A to init crouch flag by default
009E8D  1  AC 54 07                ldy PlayerSize            ;is player small?
009E90  1  D0 08                   bne SetCrouch             ;if so, branch
009E92  1  A5 1D                   lda Player_State          ;check state of player
009E94  1  D0 07                   bne ProcMove              ;if not on the ground, branch
009E96  1  A5 0B                   lda Up_Down_Buttons       ;load controller bits for up and down
009E98  1  29 04                   and #%00000100            ;single out bit for down button
009E9A  1  8D 14 07     SetCrouch: sta CrouchingFlag         ;store value in crouch flag
009E9D  1  20 C8 9F     ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
009EA0  1  AD 0B 07                lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
009EA3  1  D0 16                   bne NoMoveSub             ;branch to leave
009EA5  1  A5 1D                   lda Player_State
009EA7  1  C9 03                   cmp #$03                  ;get player state
009EA9  1  F0 05                   beq MoveSubs              ;if climbing, branch ahead, leave timer unset
009EAB  1  A0 18                   ldy #$18
009EAD  1  8C 89 07                sty ClimbSideTimer        ;otherwise reset timer now
009EB0  1  20 69 8C     MoveSubs:  jsr JumpEngine
009EB3  1               
009EB3  1  BC 9E              .word OnGroundStateSub
009EB5  1  E0 9E              .word JumpSwimSub
009EB7  1  D7 9E              .word FallingSub
009EB9  1  36 9F              .word ClimbingSub
009EBB  1               
009EBB  1  60           NoMoveSub: rts
009EBC  1               
009EBC  1               ;-------------------------------------------------------------------------------------
009EBC  1               ;$00 - used by ClimbingSub to store high vertical adder
009EBC  1               
009EBC  1               OnGroundStateSub:
009EBC  1  20 34 A1              jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
009EBF  1  A5 0C                 lda Left_Right_Buttons
009EC1  1  F0 02                 beq GndMove                ;if left/right controller bits not set, skip instruction
009EC3  1  85 33                 sta PlayerFacingDir        ;otherwise set new facing direction
009EC5  1  20 71 A1     GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
009EC8  1  20 05 AB     JmpMove: jsr MovePlayerHorizontally ;do another sub to move player horizontally
009ECB  1  8D FF 06              sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
009ECE  1  AD F7 07              lda FileListNumber         ;if in worlds 1-4 don't bother checking for wind
009ED1  1  F0 03                 beq ExOGSS
009ED3  1  20 82 E4              jsr BlowPlayerAround
009ED6  1  60           ExOGSS:  rts
009ED7  1               
009ED7  1               ;--------------------------------
009ED7  1               
009ED7  1               FallingSub:
009ED7  1  AD 0A 07           lda VerticalForceDown
009EDA  1  8D 09 07           sta VerticalForce      ;dump vertical movement force for falling into main one
009EDD  1  4C 16 9F           jmp LRAir              ;movement force, then skip ahead to process left/right movement
009EE0  1               
009EE0  1               ;--------------------------------
009EE0  1               
009EE0  1               JumpSwimSub:
009EE0  1  A4 9F                  ldy Player_Y_Speed         ;if player's vertical speed zero
009EE2  1  10 13                  bpl DumpFall               ;or moving downwards, branch to falling
009EE4  1  A5 0A                  lda A_B_Buttons
009EE6  1  29 80                  and #A_Button              ;check to see if A button is being pressed
009EE8  1  25 0D                  and PreviousA_B_Buttons    ;and was pressed in previous frame
009EEA  1  D0 11                  bne ProcSwim               ;if so, branch elsewhere
009EEC  1  AD 08 07               lda JumpOrigin_Y_Position  ;get vertical position player jumped from
009EEF  1  38                     sec
009EF0  1  E5 CE                  sbc Player_Y_Position      ;subtract current from original vertical coordinate
009EF2  1  CD 06 07               cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
009EF5  1  90 06                  bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
009EF7  1  AD 0A 07     DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
009EFA  1  8D 09 07               sta VerticalForce
009EFD  1  AD 04 07     ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
009F00  1  F0 14                  beq LRAir                  ;branch ahead to last part
009F02  1  20 34 A1               jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
009F05  1  A5 CE                  lda Player_Y_Position
009F07  1  C9 14                  cmp #$14                   ;check vertical position against preset value
009F09  1  B0 05                  bcs LRWater                ;if not yet reached a certain position, branch ahead
009F0B  1  A9 18                  lda #$18
009F0D  1  8D 09 07               sta VerticalForce          ;otherwise set fractional
009F10  1  A5 0C        LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
009F12  1  F0 02                  beq LRAir                  ;if not pressing any, skip
009F14  1  85 33                  sta PlayerFacingDir        ;otherwise set facing direction accordingly
009F16  1  A5 0C        LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
009F18  1  F0 03                  beq JSMove                 ;if not pressing any, skip
009F1A  1  20 71 A1               jsr ImposeFriction         ;otherwise process horizontal movement
009F1D  1  20 C8 9E     JSMove:   jsr JmpMove
009F20  1  A5 0E                  lda GameEngineSubroutine
009F22  1  C9 0B                  cmp #$0b                   ;check for specific routine selected
009F24  1  D0 05                  bne ExitMov1               ;branch if not set to run
009F26  1  A9 28                  lda #$28
009F28  1  8D 09 07               sta VerticalForce          ;otherwise set fractional
009F2B  1  4C 49 AB     ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
009F2E  1               
009F2E  1               ;--------------------------------
009F2E  1               
009F2E  1               ClimbAdderLow:
009F2E  1  0E 04 FC F2        .byte $0e, $04, $fc, $f2
009F32  1               ClimbAdderHigh:
009F32  1  00 00 FF FF        .byte $00, $00, $ff, $ff
009F36  1               
009F36  1               ClimbingSub:
009F36  1  AD 16 04                  lda Player_YMF_Dummy
009F39  1  18                        clc                      ;add movement force to dummy variable
009F3A  1  6D 33 04                  adc Player_Y_MoveForce   ;save with carry
009F3D  1  8D 16 04                  sta Player_YMF_Dummy
009F40  1  A0 00                     ldy #$00                 ;set default adder here
009F42  1  A5 9F                     lda Player_Y_Speed       ;get player's vertical speed
009F44  1  10 01                     bpl MoveOnVine           ;if not moving upwards, branch
009F46  1  88                        dey                      ;otherwise set adder to $ff
009F47  1  84 00        MoveOnVine:  sty $00                  ;store adder here
009F49  1  65 CE                     adc Player_Y_Position    ;add carry to player's vertical position
009F4B  1  85 CE                     sta Player_Y_Position    ;and store to move player up or down
009F4D  1  A5 B5                     lda Player_Y_HighPos
009F4F  1  65 00                     adc $00                  ;add carry to player's page location
009F51  1  85 B5                     sta Player_Y_HighPos     ;and store
009F53  1  A5 0C                     lda Left_Right_Buttons   ;compare left/right controller bits
009F55  1  2D 90 04                  and Player_CollisionBits ;to collision flag
009F58  1  F0 2D                     beq InitCSTimer          ;if not set, skip to end
009F5A  1  AC 89 07                  ldy ClimbSideTimer       ;otherwise check timer
009F5D  1  D0 27                     bne ExitCSub             ;if timer not expired, branch to leave
009F5F  1  A0 18                     ldy #$18
009F61  1  8C 89 07                  sty ClimbSideTimer       ;otherwise set timer now
009F64  1  A2 00                     ldx #$00                 ;set default offset here
009F66  1  A4 33                     ldy PlayerFacingDir      ;get facing direction
009F68  1  4A                        lsr                      ;move right button controller bit to carry
009F69  1  B0 02                     bcs ClimbFD              ;if controller right pressed, branch ahead
009F6B  1  E8                        inx
009F6C  1  E8                        inx                      ;otherwise increment offset by 2 bytes
009F6D  1  88           ClimbFD:     dey                      ;check to see if facing right
009F6E  1  F0 01                     beq CSetFDir             ;if so, branch, do not increment
009F70  1  E8                        inx                      ;otherwise increment by 1 byte
009F71  1  A5 86        CSetFDir:    lda Player_X_Position
009F73  1  18                        clc                      ;add or subtract from player's horizontal position
009F74  1  7D 2E 9F                  adc ClimbAdderLow,x      ;using value here as adder and X as offset
009F77  1  85 86                     sta Player_X_Position
009F79  1  A5 6D                     lda Player_PageLoc       ;add or subtract carry or borrow using value here
009F7B  1  7D 32 9F                  adc ClimbAdderHigh,x     ;from the player's page location
009F7E  1  85 6D                     sta Player_PageLoc
009F80  1  A5 0C                     lda Left_Right_Buttons   ;get left/right controller bits again
009F82  1  49 03                     eor #%00000011           ;invert them and store them while player
009F84  1  85 33                     sta PlayerFacingDir      ;is on vine to face player in opposite direction
009F86  1  60           ExitCSub:    rts                      ;then leave
009F87  1  8D 89 07     InitCSTimer: sta ClimbSideTimer       ;initialize timer here
009F8A  1  60                        rts
009F8B  1               
009F8B  1               ;-------------------------------------------------------------------------------------
009F8B  1               ;$00 - used to store offset to friction data
009F8B  1               
009F8B  1               MarioJumpMForceData:
009F8B  1  20 20 1E 28        .byte $20, $20, $1e, $28, $28, $0d, $04
009F8F  1  28 0D 04     
009F92  1               
009F92  1               MarioFallMForceData:
009F92  1  70 70 60 90        .byte $70, $70, $60, $90, $90, $0a, $09
009F96  1  90 0A 09     
009F99  1               
009F99  1               MarioFrictionData:
009F99  1  E4 98 D0           .byte $e4, $98, $d0
009F9C  1               
009F9C  1               LuigiJumpMForceData:
009F9C  1  18 18 18 22        .byte $18, $18, $18, $22, $22, $0d, $04
009FA0  1  22 0D 04     
009FA3  1               
009FA3  1               LuigiFallMForceData:
009FA3  1  42 42 3E 5D        .byte $42, $42, $3e, $5d, $5d, $0a, $09
009FA7  1  5D 0A 09     
009FAA  1               
009FAA  1               LuigiFrictionData:
009FAA  1  B4 68 A0           .byte $b4, $68, $a0
009FAD  1               
009FAD  1               PlayerYSpdData:
009FAD  1  FC FC FC FB        .byte $fc, $fc, $fc, $fb, $fb, $fe, $ff
009FB1  1  FB FE FF     
009FB4  1               
009FB4  1               InitMForceData:
009FB4  1  00 00 00 00        .byte $00, $00, $00, $00, $00, $80, $00
009FB8  1  00 80 00     
009FBB  1               
009FBB  1               MaxLeftXSpdData:
009FBB  1  D8 E8 F0           .byte $d8, $e8, $f0
009FBE  1               
009FBE  1               MaxRightXSpdData:
009FBE  1  28 18 10           .byte $28, $18, $10
009FC1  1  0C                 .byte $0c ;used for pipe intros
009FC2  1               
009FC2  1               Climb_Y_SpeedData:
009FC2  1  00 FF 01           .byte $00, $ff, $01
009FC5  1               
009FC5  1               Climb_Y_MForceData:
009FC5  1  00 20 FF           .byte $00, $20, $ff
009FC8  1               
009FC8  1               PlayerPhysicsSub:
009FC8  1  A5 1D                   lda Player_State          ;check player state
009FCA  1  C9 03                   cmp #$03
009FCC  1  D0 23                   bne CheckForJumping       ;if not climbing, branch
009FCE  1  A0 00                   ldy #$00
009FD0  1  A5 0B                   lda Up_Down_Buttons       ;get controller bits for up/down
009FD2  1  2D 90 04                and Player_CollisionBits  ;check against player's collision detection bits
009FD5  1  F0 06                   beq ProcClimb             ;if not pressing up or down, branch
009FD7  1  C8                      iny
009FD8  1  29 08                   and #%00001000            ;check for pressing up
009FDA  1  D0 01                   bne ProcClimb
009FDC  1  C8                      iny
009FDD  1  BE C5 9F     ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
009FE0  1  8E 33 04                stx Player_Y_MoveForce    ;store as vertical movement force
009FE3  1  A9 08                   lda #$08                  ;load default animation timing
009FE5  1  BE C2 9F                ldx Climb_Y_SpeedData,y   ;load some other value here
009FE8  1  86 9F                   stx Player_Y_Speed        ;store as vertical speed
009FEA  1  30 01                   bmi SetCAnim              ;if climbing down, use default animation timing value
009FEC  1  4A                      lsr                       ;otherwise divide timer setting by 2
009FED  1  8D 0C 07     SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
009FF0  1  60                      rts
009FF1  1               
009FF1  1               CheckForJumping:
009FF1  1  AD 0E 07             lda JumpspringAnimCtrl    ;if jumpspring animating,
009FF4  1  D0 0A                bne NoJump                ;skip ahead to something else
009FF6  1  A5 0A                lda A_B_Buttons           ;check for A button press
009FF8  1  29 80                and #A_Button
009FFA  1  F0 04                beq NoJump                ;if not, branch to something else
009FFC  1  25 0D                and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
009FFE  1  F0 03                beq ProcJumping
00A000  1  4C AE A0     NoJump: jmp X_Physics             ;otherwise, jump to something else
00A003  1               
00A003  1               ProcJumping:
00A003  1  A5 1D                   lda Player_State           ;check player state
00A005  1  F0 11                   beq InitJS                 ;if on the ground, branch
00A007  1  AD 04 07                lda SwimmingFlag           ;if swimming flag not set, jump to do something else
00A00A  1  F0 F4                   beq NoJump                 ;to prevent midair jumping, otherwise continue
00A00C  1  AD 82 07                lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
00A00F  1  D0 07                   bne InitJS
00A011  1  A5 9F                   lda Player_Y_Speed         ;check player's vertical speed
00A013  1  10 03                   bpl InitJS                 ;if player's vertical speed motionless or down, branch
00A015  1  4C AE A0                jmp X_Physics              ;if timer at zero and player still rising, do not swim
00A018  1  A9 20        InitJS:    lda #$20                   ;set jump/swim timer
00A01A  1  8D 82 07                sta JumpSwimTimer
00A01D  1  A0 00                   ldy #$00                   ;initialize vertical force and dummy variable
00A01F  1  8C 16 04                sty Player_YMF_Dummy
00A022  1  8C 33 04                sty Player_Y_MoveForce
00A025  1  A5 B5                   lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
00A027  1  8D 07 07                sta JumpOrigin_Y_HighPos   ;and store them next to each other here
00A02A  1  A5 CE                   lda Player_Y_Position
00A02C  1  8D 08 07                sta JumpOrigin_Y_Position
00A02F  1  A9 01                   lda #$01                   ;set player state to jumping/swimming
00A031  1  85 1D                   sta Player_State
00A033  1  AD 00 07                lda Player_XSpeedAbsolute  ;check value related to walking/running speed
00A036  1  C9 09                   cmp #$09
00A038  1  90 10                   bcc ChkWtr                 ;branch if below certain values, increment Y
00A03A  1  C8                      iny                        ;for each amount equal or exceeded
00A03B  1  C9 10                   cmp #$10
00A03D  1  90 0B                   bcc ChkWtr
00A03F  1  C8                      iny
00A040  1  C9 19                   cmp #$19
00A042  1  90 06                   bcc ChkWtr
00A044  1  C8                      iny
00A045  1  C9 1C                   cmp #$1c
00A047  1  90 01                   bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
00A049  1  C8                      iny
00A04A  1  A9 01        ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
00A04C  1  8D 06 07                sta DiffToHaltJump
00A04F  1  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00A052  1  F0 08                   beq GetYPhy
00A054  1  A0 05                   ldy #$05                   ;otherwise set Y to 5, range is 5-6
00A056  1  AD 7D 04                lda Whirlpool_Flag         ;if whirlpool flag not set, branch
00A059  1  F0 01                   beq GetYPhy
00A05B  1  C8                      iny                        ;otherwise increment to 6
00A05C  1  AD 53 07     GetYPhy:   lda SelectedPlayer         ;check selected player
00A05F  1  F0 15                   beq MarioYPhy              ;if mario, branch
00A061  1  AD 70 07                lda OperMode               ;get primary mode of operation
00A064  1  C9 02                   cmp #VictoryMode
00A066  1  F0 0E                   beq MarioYPhy              ;if victory mode, branch
00A068  1  B9 9C 9F                lda LuigiJumpMForceData,y  ;store appropriate jump/swim
00A06B  1  8D 09 07                sta VerticalForce          ;data here
00A06E  1  B9 A3 9F                lda LuigiFallMForceData,y
00A071  1  8D 0A 07                sta VerticalForceDown
00A074  1  D0 0C                   bne ContYPhy               ;unconditional branch
00A076  1  B9 8B 9F     MarioYPhy: lda MarioJumpMForceData,y  ;store appropriate jump/swim
00A079  1  8D 09 07                sta VerticalForce          ;data here
00A07C  1  B9 92 9F                lda MarioFallMForceData,y
00A07F  1  8D 0A 07                sta VerticalForceDown
00A082  1  B9 B4 9F     ContYPhy:  lda InitMForceData,y
00A085  1  8D 33 04                sta Player_Y_MoveForce
00A088  1  B9 AD 9F                lda PlayerYSpdData,y
00A08B  1  85 9F                   sta Player_Y_Speed
00A08D  1  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00A090  1  F0 11                   beq PJumpSnd
00A092  1  A9 04                   lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
00A094  1  85 FF                   sta Square1SoundQueue      ;square 1's sfx queue
00A096  1  A5 CE                   lda Player_Y_Position
00A098  1  C9 14                   cmp #$14                   ;check vertical low byte of player position
00A09A  1  B0 12                   bcs X_Physics              ;if below a certain point, branch
00A09C  1  A9 00                   lda #$00                   ;otherwise reset player's vertical speed
00A09E  1  85 9F                   sta Player_Y_Speed         ;and jump to something else to keep player
00A0A0  1  4C AE A0                jmp X_Physics              ;from swimming above water level
00A0A3  1  A9 01        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
00A0A5  1  AC 54 07                ldy PlayerSize             ;is mario big?
00A0A8  1  F0 02                   beq SJumpSnd
00A0AA  1  A9 80                   lda #Sfx_SmallJump         ;if not, load small mario's jump sound
00A0AC  1  85 FF        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
00A0AE  1  A0 00        X_Physics: ldy #$00
00A0B0  1  84 00                   sty $00                    ;init value here
00A0B2  1  A5 1D                   lda Player_State           ;if mario is on the ground, branch
00A0B4  1  F0 09                   beq ProcPRun
00A0B6  1  AD 00 07                lda Player_XSpeedAbsolute  ;check something that seems to be related
00A0B9  1  C9 19                   cmp #$19                   ;to mario's speed
00A0BB  1  B0 33                   bcs GetXPhy                ;if =>$19 branch here
00A0BD  1  90 18                   bcc ChkRFast               ;if not branch elsewhere
00A0BF  1  C8           ProcPRun:  iny                        ;if mario on the ground, increment Y
00A0C0  1  AD 4E 07                lda AreaType               ;check area type
00A0C3  1  F0 12                   beq ChkRFast               ;if water type, branch
00A0C5  1  88                      dey                        ;decrement Y by default for non-water type area
00A0C6  1  A5 0C                   lda Left_Right_Buttons     ;get left/right controller bits
00A0C8  1  C5 45                   cmp Player_MovingDir       ;check against moving direction
00A0CA  1  D0 0B                   bne ChkRFast               ;if controller bits <> moving direction, skip this part
00A0CC  1  A5 0A                   lda A_B_Buttons            ;check for b button pressed
00A0CE  1  29 40                   and #B_Button
00A0D0  1  D0 19                   bne SetRTmr                ;if pressed, skip ahead to set timer
00A0D2  1  AD 83 07                lda RunningTimer           ;check for running timer set
00A0D5  1  D0 19                   bne GetXPhy                ;if set, branch
00A0D7  1  C8           ChkRFast:  iny                        ;if running timer not set or level type is water,
00A0D8  1  E6 00                   inc $00                    ;increment Y again and temp variable in memory
00A0DA  1  AD 03 07                lda RunningSpeed
00A0DD  1  D0 07                   bne FastXSp                ;if running speed set here, branch
00A0DF  1  AD 00 07                lda Player_XSpeedAbsolute
00A0E2  1  C9 21                   cmp #$21                   ;otherwise check player's walking/running speed
00A0E4  1  90 0A                   bcc GetXPhy                ;if less than a certain amount, branch ahead
00A0E6  1  E6 00        FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
00A0E8  1  4C F0 A0                jmp GetXPhy                ;and jump ahead
00A0EB  1  A9 0A        SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
00A0ED  1  8D 83 07                sta RunningTimer
00A0F0  1  B9 BB 9F     GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
00A0F3  1  8D 50 04                sta MaximumLeftSpeed
00A0F6  1  A5 0E                   lda GameEngineSubroutine   ;check for specific routine running
00A0F8  1  C9 07                   cmp #$07                   ;(player entrance)
00A0FA  1  D0 02                   bne GetXPhy2               ;if not running, skip and use old value of Y
00A0FC  1  A0 03                   ldy #$03                   ;otherwise set Y to 3
00A0FE  1  B9 BE 9F     GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
00A101  1  8D 56 04                sta MaximumRightSpeed
00A104  1  A9 00                   lda #$00
00A106  1  8D 01 07                sta FrictionAdderHigh      ;init something here
00A109  1  A4 00                   ldy $00                    ;get other value in memory
00A10B  1  AD 53 07                lda SelectedPlayer         ;check selected player
00A10E  1  F0 0E                   beq MarioXPhy              ;if mario, branch
00A110  1  AD 70 07                lda OperMode               ;get primary mode of operation
00A113  1  C9 02                   cmp #VictoryMode
00A115  1  F0 07                   beq MarioXPhy              ;if victory mode, branch
00A117  1  B9 AA 9F                lda LuigiFrictionData,y    ;get value using value in memory as offset
00A11A  1  8D 02 07                sta FrictionAdderLow       ;then leave
00A11D  1  60                      rts
00A11E  1               MarioXPhy:
00A11E  1  B9 99 9F                lda MarioFrictionData,y    ;get value using value in memory as offset
00A121  1  8D 02 07                sta FrictionAdderLow
00A124  1  A5 33                   lda PlayerFacingDir
00A126  1  C5 45                   cmp Player_MovingDir       ;check facing direction against moving direction
00A128  1  F0 06                   beq ExitPhy                ;if the same, branch to leave
00A12A  1  0E 02 07                asl FrictionAdderLow       ;otherwise multiply friction by 2
00A12D  1  2E 01 07                rol FrictionAdderHigh      ;then leave
00A130  1  60           ExitPhy:   rts
00A131  1               
00A131  1               ;-------------------------------------------------------------------------------------
00A131  1               
00A131  1               PlayerAnimTmrData:
00A131  1  02 04 07           .byte $02, $04, $07
00A134  1               
00A134  1               GetPlayerAnimSpeed:
00A134  1  A0 00                    ldy #$00                   ;initialize offset in Y
00A136  1  AD 00 07                 lda Player_XSpeedAbsolute  ;check player's walking/running speed
00A139  1  C9 1C                    cmp #$1c                   ;against preset amount
00A13B  1  B0 15                    bcs SetRunSpd              ;if greater than a certain amount, branch ahead
00A13D  1  C8                       iny                        ;otherwise increment Y
00A13E  1  C9 0E                    cmp #$0e                   ;compare against lower amount
00A140  1  B0 01                    bcs ChkSkid                ;if greater than this but not greater than first, skip increment
00A142  1  C8                       iny                        ;otherwise increment Y again
00A143  1  AD FC 06     ChkSkid:    lda SavedJoypadBits        ;get controller bits
00A146  1  29 7F                    and #%01111111             ;mask out A button
00A148  1  F0 20                    beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
00A14A  1  29 03                    and #$03                   ;mask out all others except left and right
00A14C  1  C5 45                    cmp Player_MovingDir       ;check against moving direction
00A14E  1  D0 08                    bne ProcSkid               ;if left/right controller bits <> moving direction, branch
00A150  1  A9 00                    lda #$00                   ;otherwise set zero value here
00A152  1  8D 03 07     SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
00A155  1  4C 6A A1                 jmp SetAnimSpd
00A158  1  AD 00 07     ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
00A15B  1  C9 0B                    cmp #$0b                   ;against one last amount
00A15D  1  B0 0B                    bcs SetAnimSpd             ;if greater than this amount, branch
00A15F  1  A5 33                    lda PlayerFacingDir
00A161  1  85 45                    sta Player_MovingDir       ;otherwise use facing direction to set moving direction
00A163  1  A9 00                    lda #$00
00A165  1  85 57                    sta Player_X_Speed         ;nullify player's horizontal speed
00A167  1  8D 05 07                 sta Player_X_MoveForce     ;and dummy variable for player
00A16A  1  B9 31 A1     SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
00A16D  1  8D 0C 07                 sta PlayerAnimTimerSet
00A170  1  60                       rts
00A171  1               
00A171  1               ;-------------------------------------------------------------------------------------
00A171  1               
00A171  1               ImposeFriction:
00A171  1  2D 90 04                and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
00A174  1  C9 00                   cmp #$00                  ;then compare to zero (this instruction is redundant)
00A176  1  D0 08                   bne JoypFrict             ;if any bits set, branch to next part
00A178  1  A5 57                   lda Player_X_Speed
00A17A  1  F0 49                   beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
00A17C  1  10 23                   bpl RghtFrict             ;if player moving to the right, branch to slow
00A17E  1  30 03                   bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
00A180  1  4A           JoypFrict: lsr                       ;put right controller bit into carry
00A181  1  90 1E                   bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
00A183  1  AD 05 07     LeftFrict: lda Player_X_MoveForce    ;load value set here
00A186  1  18                      clc
00A187  1  6D 02 07                adc FrictionAdderLow      ;add to it another value set here
00A18A  1  8D 05 07                sta Player_X_MoveForce    ;store here
00A18D  1  A5 57                   lda Player_X_Speed
00A18F  1  6D 01 07                adc FrictionAdderHigh     ;add value plus carry to horizontal speed
00A192  1  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00A194  1  CD 56 04                cmp MaximumRightSpeed     ;compare against maximum value for right movement
00A197  1  30 23                   bmi XSpdSign              ;if horizontal speed greater negatively, branch
00A199  1  AD 56 04                lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
00A19C  1  85 57                   sta Player_X_Speed        ;thus slowing the player's left movement down
00A19E  1  4C C5 A1                jmp SetAbsSpd             ;skip to the end
00A1A1  1  AD 05 07     RghtFrict: lda Player_X_MoveForce    ;load value set here
00A1A4  1  38                      sec
00A1A5  1  ED 02 07                sbc FrictionAdderLow      ;subtract from it another value set here
00A1A8  1  8D 05 07                sta Player_X_MoveForce    ;store here
00A1AB  1  A5 57                   lda Player_X_Speed
00A1AD  1  ED 01 07                sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
00A1B0  1  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00A1B2  1  CD 50 04                cmp MaximumLeftSpeed      ;compare against maximum value for left movement
00A1B5  1  10 05                   bpl XSpdSign              ;if horizontal speed greater positively, branch
00A1B7  1  AD 50 04                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
00A1BA  1  85 57                   sta Player_X_Speed        ;thus slowing the player's right movement down
00A1BC  1  C9 00        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
00A1BE  1  10 05                   bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
00A1C0  1  49 FF                   eor #$ff
00A1C2  1  18                      clc                       ;otherwise get two's compliment to get absolute
00A1C3  1  69 01                   adc #$01                  ;unsigned walking/running speed
00A1C5  1  8D 00 07     SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
00A1C8  1  60                      rts
00A1C9  1               
00A1C9  1               ;-------------------------------------------------------------------------------------
00A1C9  1               ;$00 - used to store downward movement force in FireballObjCore
00A1C9  1               ;$02 - used to store maximum vertical speed in FireballObjCore
00A1C9  1               ;$07 - used to store pseudorandom bit in BubbleCheck
00A1C9  1               
00A1C9  1               ProcFireball_Bubble:
00A1C9  1  AD 56 07           lda PlayerStatus           ;check player's status
00A1CC  1  C9 02              cmp #$02
00A1CE  1  90 43              bcc ProcAirBubbles         ;if not fiery, branch
00A1D0  1  A5 0A              lda A_B_Buttons
00A1D2  1  29 40              and #B_Button              ;check for b button pressed
00A1D4  1  F0 33              beq ProcFireballs          ;branch if not pressed
00A1D6  1  25 0D              and PreviousA_B_Buttons
00A1D8  1  D0 2F              bne ProcFireballs          ;if button pressed in previous frame, branch
00A1DA  1  AD CE 06           lda FireballCounter        ;load fireball counter
00A1DD  1  29 01              and #%00000001             ;get LSB and use as offset for buffer
00A1DF  1  AA                 tax
00A1E0  1  B5 24              lda Fireball_State,x       ;load fireball state
00A1E2  1  D0 25              bne ProcFireballs          ;if not inactive, branch
00A1E4  1  A4 B5              ldy Player_Y_HighPos       ;if player too high or too low, branch
00A1E6  1  88                 dey
00A1E7  1  D0 20              bne ProcFireballs
00A1E9  1  AD 14 07           lda CrouchingFlag          ;if player crouching, branch
00A1EC  1  D0 1B              bne ProcFireballs
00A1EE  1  A5 1D              lda Player_State           ;if player's state = climbing, branch
00A1F0  1  C9 03              cmp #$03
00A1F2  1  F0 15              beq ProcFireballs
00A1F4  1  A9 20              lda #Sfx_Fireball          ;play fireball sound effect
00A1F6  1  85 FF              sta Square1SoundQueue
00A1F8  1  A9 02              lda #$02                   ;load state
00A1FA  1  95 24              sta Fireball_State,x
00A1FC  1  AC 0C 07           ldy PlayerAnimTimerSet     ;copy animation frame timer setting
00A1FF  1  8C 11 07           sty FireballThrowingTimer  ;into fireball throwing timer
00A202  1  88                 dey
00A203  1  8C 81 07           sty PlayerAnimTimer        ;decrement and store in player's animation timer
00A206  1  EE CE 06           inc FireballCounter        ;increment fireball counter
00A209  1               
00A209  1               ProcFireballs:
00A209  1  A2 00              ldx #$00
00A20B  1  20 2E A2           jsr FireballObjCore  ;process first fireball object
00A20E  1  A2 01              ldx #$01
00A210  1  20 2E A2           jsr FireballObjCore  ;process second fireball object, then do air bubbles
00A213  1               
00A213  1               ProcAirBubbles:
00A213  1  AD 4E 07               lda AreaType                ;if not water type level, skip the rest of this
00A216  1  D0 13                  bne BublExit
00A218  1  A2 02                  ldx #$02                    ;otherwise load counter and use as offset
00A21A  1  86 08        BublLoop: stx ObjectOffset            ;store offset
00A21C  1  20 9E A2               jsr BubbleCheck             ;check timers and coordinates, create air bubble
00A21F  1  20 FB DD               jsr RelativeBubblePosition  ;get relative coordinates
00A222  1  20 5B DE               jsr GetBubbleOffscreenBits  ;get offscreen information
00A225  1  20 A1 DA               jsr DrawBubble              ;draw the air bubble
00A228  1  CA                     dex
00A229  1  10 EF                  bpl BublLoop                ;do this until all three are handled
00A22B  1  60           BublExit: rts                         ;then leave
00A22C  1               
00A22C  1               FireballXSpdData:
00A22C  1  40 C0              .byte $40, $c0
00A22E  1               
00A22E  1               FireballObjCore:
00A22E  1  86 08                 stx ObjectOffset             ;store offset as current object
00A230  1  B5 24                 lda Fireball_State,x         ;check for d7 = 1
00A232  1  0A                    asl
00A233  1  B0 63                 bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
00A235  1  B4 24                 ldy Fireball_State,x         ;if fireball inactive, branch to leave
00A237  1  F0 5E                 beq NoFBall
00A239  1  88                    dey                          ;if fireball state set to 1, skip this part and just run it
00A23A  1  F0 27                 beq RunFB
00A23C  1  A5 86                 lda Player_X_Position        ;get player's horizontal position
00A23E  1  69 04                 adc #$04                     ;add four pixels and store as fireball's horizontal position
00A240  1  95 8D                 sta Fireball_X_Position,x
00A242  1  A5 6D                 lda Player_PageLoc           ;get player's page location
00A244  1  69 00                 adc #$00                     ;add carry and store as fireball's page location
00A246  1  95 74                 sta Fireball_PageLoc,x
00A248  1  A5 CE                 lda Player_Y_Position        ;get player's vertical position and store
00A24A  1  95 D5                 sta Fireball_Y_Position,x
00A24C  1  A9 01                 lda #$01                     ;set high byte of vertical position
00A24E  1  95 BC                 sta Fireball_Y_HighPos,x
00A250  1  A4 33                 ldy PlayerFacingDir          ;get player's facing direction
00A252  1  88                    dey                          ;decrement to use as offset here
00A253  1  B9 2C A2              lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
00A256  1  95 5E                 sta Fireball_X_Speed,x
00A258  1  A9 04                 lda #$04                     ;set vertical speed of fireball
00A25A  1  95 A6                 sta Fireball_Y_Speed,x
00A25C  1  A9 07                 lda #$07
00A25E  1  9D A0 04              sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
00A261  1  D6 24                 dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
00A263  1  8A           RunFB:   txa                          ;add 7 to offset to use
00A264  1  18                    clc                          ;as fireball offset for next routines
00A265  1  69 07                 adc #$07
00A267  1  AA                    tax
00A268  1  A9 50                 lda #$50                     ;set downward movement force here
00A26A  1  85 00                 sta $00
00A26C  1  A9 03                 lda #$03                     ;set maximum speed here
00A26E  1  85 02                 sta $02
00A270  1  A9 00                 lda #$00
00A272  1  20 D3 AB              jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
00A275  1  20 0B AB              jsr MoveObjectHorizontally   ;do another sub to move it horizontally
00A278  1  A6 08                 ldx ObjectOffset             ;return fireball offset to X
00A27A  1  20 05 DE              jsr RelativeFireballPosition ;get relative coordinates
00A27D  1  20 51 DE              jsr GetFireballOffscreenBits ;get offscreen information
00A280  1  20 AE CE              jsr GetFireballBoundBox      ;get bounding box coordinates
00A283  1  20 49 CE              jsr FireballBGCollision      ;do fireball to background collision detection
00A286  1  AD D2 03              lda FBall_OffscreenBits      ;get fireball offscreen bits
00A289  1  29 CC                 and #%11001100               ;mask out certain bits
00A28B  1  D0 06                 bne EraseFB                  ;if any bits still set, branch to kill fireball
00A28D  1  20 11 C3              jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
00A290  1  4C 9E D9              jmp DrawFireball             ;draw fireball appropriately and leave
00A293  1  A9 00        EraseFB: lda #$00                     ;erase fireball state
00A295  1  95 24                 sta Fireball_State,x
00A297  1  60           NoFBall: rts                          ;leave
00A298  1               
00A298  1               FireballExplosion:
00A298  1  20 05 DE           jsr RelativeFireballPosition
00A29B  1  4C C9 D9           jmp DrawExplosion_Fireball
00A29E  1               
00A29E  1               BubbleCheck:
00A29E  1  BD A8 07           lda PseudoRandomBitReg+1,x  ;get part of LSFR
00A2A1  1  29 01              and #$01
00A2A3  1  85 07              sta $07                     ;store pseudorandom bit here
00A2A5  1  B5 E4              lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
00A2A7  1  C9 F8              cmp #$f8                    ;if offscreen coordinate not set,
00A2A9  1  D0 2C              bne MoveBubl                ;branch to move air bubble
00A2AB  1  AD 92 07           lda AirBubbleTimer          ;if air bubble timer not expired,
00A2AE  1  D0 3F              bne ExitBubl                ;branch to leave, otherwise create new air bubble
00A2B0  1               
00A2B0  1               SetupBubble:
00A2B0  1  A0 00                  ldy #$00                 ;load default value here
00A2B2  1  A5 33                  lda PlayerFacingDir      ;get player's facing direction
00A2B4  1  4A                     lsr                      ;move d0 to carry
00A2B5  1  90 02                  bcc PosBubl              ;branch to use default value if facing left
00A2B7  1  A0 08                  ldy #$08                 ;otherwise load alternate value here
00A2B9  1  98           PosBubl:  tya                      ;use value loaded as adder
00A2BA  1  65 86                  adc Player_X_Position    ;add to player's horizontal position
00A2BC  1  95 9C                  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
00A2BE  1  A5 6D                  lda Player_PageLoc
00A2C0  1  69 00                  adc #$00                 ;add carry to player's page location
00A2C2  1  95 83                  sta Bubble_PageLoc,x     ;save as page location for airbubble
00A2C4  1  A5 CE                  lda Player_Y_Position
00A2C6  1  18                     clc                      ;add eight pixels to player's vertical position
00A2C7  1  69 08                  adc #$08
00A2C9  1  95 E4                  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
00A2CB  1  A9 01                  lda #$01
00A2CD  1  95 CB                  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
00A2CF  1  A4 07                  ldy $07                  ;get pseudorandom bit, use as offset
00A2D1  1  B9 F2 A2               lda BubbleTimerData,y    ;get data for air bubble timer
00A2D4  1  8D 92 07               sta AirBubbleTimer       ;set air bubble timer
00A2D7  1  A4 07        MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
00A2D9  1  BD 2C 04               lda Bubble_YMF_Dummy,x
00A2DC  1  38                     sec                      ;subtract pseudorandom amount from dummy variable
00A2DD  1  F9 F0 A2               sbc Bubble_MForceData,y
00A2E0  1  9D 2C 04               sta Bubble_YMF_Dummy,x   ;save dummy variable
00A2E3  1  B5 E4                  lda Bubble_Y_Position,x
00A2E5  1  E9 00                  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
00A2E7  1  C9 20                  cmp #$20                 ;if below the status bar,
00A2E9  1  B0 02                  bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
00A2EB  1  A9 F8                  lda #$f8                 ;otherwise set offscreen coordinate
00A2ED  1  95 E4        Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
00A2EF  1  60           ExitBubl: rts                      ;leave
00A2F0  1               
00A2F0  1               Bubble_MForceData:
00A2F0  1  FF 50              .byte $ff, $50
00A2F2  1               
00A2F2  1               BubbleTimerData:
00A2F2  1  40 20              .byte $40, $20
00A2F4  1               
00A2F4  1               ;-------------------------------------------------------------------------------------
00A2F4  1               
00A2F4  1               RunGameTimer:
00A2F4  1  AD 70 07                lda OperMode               ;get primary mode of operation
00A2F7  1  F0 4F                   beq ExGTimer               ;branch to leave if in attract mode
00A2F9  1  A5 0E                   lda GameEngineSubroutine
00A2FB  1  C9 08                   cmp #$08                   ;if routine number less than eight running,
00A2FD  1  90 49                   bcc ExGTimer               ;branch to leave
00A2FF  1  C9 0B                   cmp #$0b                   ;if running death routine,
00A301  1  F0 45                   beq ExGTimer               ;branch to leave
00A303  1  A5 B5                   lda Player_Y_HighPos
00A305  1  C9 02                   cmp #$02                   ;if player below the screen,
00A307  1  10 3F                   bpl ExGTimer               ;branch to leave regardless of level type
00A309  1  AD 87 07                lda GameTimerCtrlTimer     ;if game timer control not yet expired,
00A30C  1  D0 3A                   bne ExGTimer               ;branch to leave
00A30E  1  AD EC 07                lda GameTimerDisplay
00A311  1  0D ED 07                ora GameTimerDisplay+1     ;otherwise check game timer digits
00A314  1  0D EE 07                ora GameTimerDisplay+2
00A317  1  F0 26                   beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
00A319  1  AC EC 07                ldy GameTimerDisplay       ;otherwise check first digit
00A31C  1  88                      dey                        ;if first digit not on 1,
00A31D  1  D0 0C                   bne ResGTCtrl              ;branch to reset game timer control
00A31F  1  AD ED 07                lda GameTimerDisplay+1     ;otherwise check second and third digits
00A322  1  0D EE 07                ora GameTimerDisplay+2
00A325  1  D0 04                   bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
00A327  1  A9 40                   lda #TimeRunningOutMusic
00A329  1  85 FC                   sta EventMusicQueue        ;otherwise load time running out music
00A32B  1  A9 18        ResGTCtrl: lda #$18                   ;reset game timer control
00A32D  1  8D 87 07                sta GameTimerCtrlTimer
00A330  1  A0 17                   ldy #$17                   ;set offset for last digit
00A332  1  A9 FF                   lda #$ff                   ;set value to decrement game timer digit
00A334  1  8D 39 01                sta DigitModifier+5
00A337  1  20 BE 8D                jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
00A33A  1  A9 A2                   lda #$a2                   ;set status nybbles to update game timer display
00A33C  1  4C 65 8D                jmp PrintStatusBarNumbers  ;do sub to update the display
00A33F  1  8D 56 07     TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
00A342  1  20 87 C5                jsr ForceInjury            ;do sub to kill the player (note player is small here)
00A345  1  EE 59 07                inc GameTimerExpiredFlag   ;set game timer expiration flag
00A348  1  60           ExGTimer:  rts                        ;leave
00A349  1               
00A349  1               ;-------------------------------------------------------------------------------------
00A349  1               
00A349  1               WarpZoneObject:
00A349  1  AD 23 07           lda ScrollLock         ;check for scroll lock flag
00A34C  1  F0 FA              beq ExGTimer           ;branch if not set to leave
00A34E  1  A5 CE              lda Player_Y_Position  ;check to see if player's vertical coordinate has
00A350  1  25 B5              and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
00A352  1  D0 F4              bne ExGTimer           ;if so, branch to leave
00A354  1  8D 23 07           sta ScrollLock         ;otherwise nullify scroll lock flag
00A357  1  4C C9 B5           jmp EraseEnemyObject   ;kill this object
00A35A  1               
00A35A  1               ;-------------------------------------------------------------------------------------
00A35A  1               ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
00A35A  1               ;and also to store movement force exerted on player
00A35A  1               ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
00A35A  1               ;and in WhirlpoolActivate to store center of whirlpool
00A35A  1               ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
00A35A  1               ;WhirlpoolActivate to store maximum vertical speed
00A35A  1               
00A35A  1               ProcessWhirlpools:
00A35A  1  AD 4E 07             lda AreaType                ;check for water type level
00A35D  1  D0 37                bne ExitWh                  ;branch to leave if not found
00A35F  1  8D 7D 04             sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
00A362  1  AD 47 07             lda TimerControl            ;if master timer control set,
00A365  1  D0 2F                bne ExitWh                  ;branch to leave
00A367  1  A0 04                ldy #$04                    ;otherwise start with last whirlpool data
00A369  1  B9 71 04     WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00A36C  1  18                   clc
00A36D  1  79 77 04             adc Whirlpool_Length,y      ;add length of whirlpool
00A370  1  85 02                sta $02                     ;store result as right extent here
00A372  1  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00A375  1  F0 1C                beq NextWh                  ;if none or page 0, branch to get next data
00A377  1  69 00                adc #$00                    ;add carry
00A379  1  85 01                sta $01                     ;store result as page location of right extent here
00A37B  1  A5 86                lda Player_X_Position       ;get player's horizontal position
00A37D  1  38                   sec
00A37E  1  F9 71 04             sbc Whirlpool_LeftExtent,y  ;subtract left extent
00A381  1  A5 6D                lda Player_PageLoc          ;get player's page location
00A383  1  F9 6B 04             sbc Whirlpool_PageLoc,y     ;subtract borrow
00A386  1  30 0B                bmi NextWh                  ;if player too far left, branch to get next data
00A388  1  A5 02                lda $02                     ;otherwise get right extent
00A38A  1  38                   sec
00A38B  1  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00A38D  1  A5 01                lda $01                     ;get right extent's page location
00A38F  1  E5 6D                sbc Player_PageLoc          ;subtract borrow
00A391  1  10 04                bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
00A393  1  88           NextWh: dey                         ;move onto next whirlpool data
00A394  1  10 D3                bpl WhLoop                  ;do this until all whirlpools are checked
00A396  1  60           ExitWh: rts                         ;leave
00A397  1               
00A397  1               WhirlpoolActivate:
00A397  1  B9 77 04             lda Whirlpool_Length,y      ;get length of whirlpool
00A39A  1  4A                   lsr                         ;divide by 2
00A39B  1  85 00                sta $00                     ;save here
00A39D  1  B9 71 04             lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00A3A0  1  18                   clc
00A3A1  1  65 00                adc $00                     ;add length divided by 2
00A3A3  1  85 01                sta $01                     ;save as center of whirlpool
00A3A5  1  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00A3A8  1  69 00                adc #$00                    ;add carry
00A3AA  1  85 00                sta $00                     ;save as page location of whirlpool center
00A3AC  1  A5 09                lda FrameCounter            ;get frame counter
00A3AE  1  4A                   lsr                         ;shift d0 into carry (to run on every other frame)
00A3AF  1  90 2C                bcc WhPull                  ;if d0 not set, branch to last part of code
00A3B1  1  A5 01                lda $01                     ;get center
00A3B3  1  38                   sec
00A3B4  1  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00A3B6  1  A5 00                lda $00                     ;get page location of center
00A3B8  1  E5 6D                sbc Player_PageLoc          ;subtract borrow
00A3BA  1  10 0E                bpl LeftWh                  ;if player to the left of center, branch
00A3BC  1  A5 86                lda Player_X_Position       ;otherwise slowly pull player left, towards the center
00A3BE  1  38                   sec
00A3BF  1  E9 01                sbc #$01                    ;subtract one pixel
00A3C1  1  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00A3C3  1  A5 6D                lda Player_PageLoc
00A3C5  1  E9 00                sbc #$00                    ;subtract borrow
00A3C7  1  4C DB A3             jmp SetPWh                  ;jump to set player's new page location
00A3CA  1  AD 90 04     LeftWh: lda Player_CollisionBits    ;get player's collision bits
00A3CD  1  4A                   lsr                         ;shift d0 into carry
00A3CE  1  90 0D                bcc WhPull                  ;if d0 not set, branch
00A3D0  1  A5 86                lda Player_X_Position       ;otherwise slowly pull player right, towards the center
00A3D2  1  18                   clc
00A3D3  1  69 01                adc #$01                    ;add one pixel
00A3D5  1  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00A3D7  1  A5 6D                lda Player_PageLoc
00A3D9  1  69 00                adc #$00                    ;add carry
00A3DB  1  85 6D        SetPWh: sta Player_PageLoc          ;set player's new page location
00A3DD  1  A9 10        WhPull: lda #$10
00A3DF  1  85 00                sta $00                     ;set vertical movement force
00A3E1  1  A9 01                lda #$01
00A3E3  1  8D 7D 04             sta Whirlpool_Flag          ;set whirlpool flag to be used later
00A3E6  1  85 02                sta $02                     ;also set maximum vertical speed
00A3E8  1  4A                   lsr
00A3E9  1  AA                   tax                         ;set X for player offset
00A3EA  1  4C D3 AB             jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
00A3ED  1               
00A3ED  1               ;-------------------------------------------------------------------------------------
00A3ED  1               
00A3ED  1               FlagpoleScoreMods:
00A3ED  1  05 02 08 04        .byte $05, $02, $08, $04, $01
00A3F1  1  01           
00A3F2  1               
00A3F2  1               FlagpoleScoreDigits:
00A3F2  1  03 03 04 04        .byte $03, $03, $04, $04, $04
00A3F6  1  04           
00A3F7  1               
00A3F7  1               FlagpoleRoutine:
00A3F7  1  A2 05                   ldx #$05                  ;set enemy object offset
00A3F9  1  86 08                   stx ObjectOffset          ;to special use slot
00A3FB  1  B5 16                   lda Enemy_ID,x
00A3FD  1  C9 30                   cmp #FlagpoleFlagObject   ;if flagpole flag not found,
00A3FF  1  D0 56                   bne ExitFlagP             ;branch to leave
00A401  1  A5 0E                   lda GameEngineSubroutine
00A403  1  C9 04                   cmp #$04                  ;if flagpole slide routine not running,
00A405  1  D0 31                   bne SkipScore             ;branch to near the end of code
00A407  1  A5 1D                   lda Player_State
00A409  1  C9 03                   cmp #$03                  ;if player state not climbing,
00A40B  1  D0 2B                   bne SkipScore             ;branch to near the end of code
00A40D  1  B5 CF                   lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
00A40F  1  C9 AA                   cmp #$aa                  ;if flagpole flag down to a certain point,
00A411  1  B0 28                   bcs GiveFPScr             ;branch to end the level
00A413  1  A5 CE                   lda Player_Y_Position     ;check player's vertical coordinate
00A415  1  C9 A2                   cmp #$a2                  ;if player down to a certain point,
00A417  1  B0 22                   bcs GiveFPScr             ;branch to end the level
00A419  1  BD 17 04                lda Enemy_YMF_Dummy,x
00A41C  1  69 FF                   adc #$ff                  ;add movement amount to dummy variable
00A41E  1  9D 17 04                sta Enemy_YMF_Dummy,x     ;save dummy variable
00A421  1  B5 CF                   lda Enemy_Y_Position,x    ;get flag's vertical coordinate
00A423  1  69 01                   adc #$01                  ;add 1 plus carry to move flag, and
00A425  1  95 CF                   sta Enemy_Y_Position,x    ;store vertical coordinate
00A427  1  AD 0E 01                lda FlagpoleFNum_YMFDummy
00A42A  1  38                      sec                       ;subtract movement amount from dummy variable
00A42B  1  E9 FF                   sbc #$ff
00A42D  1  8D 0E 01                sta FlagpoleFNum_YMFDummy ;save dummy variable
00A430  1  AD 0D 01                lda FlagpoleFNum_Y_Pos
00A433  1  E9 01                   sbc #$01                  ;subtract one plus borrow to move floatey number,
00A435  1  8D 0D 01                sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
00A438  1  4C 4E A4     SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
00A43B  1  AC 0F 01     GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
00A43E  1                          ;cpy #$05
00A43E  1                          ;bne NoEL4F                ;if set to give player an extra life, do so now
00A43E  1                          ;inc NumberofLives
00A43E  1                          ;lda #$40
00A43E  1                          ;sta $fe
00A43E  1                          ;jmp NoSc4F
00A43E  1  B9 ED A3     NoEL4F:    lda FlagpoleScoreMods,y   ;get amount to award player points
00A441  1  BE F2 A3                ldx FlagpoleScoreDigits,y ;get digit with which to award points
00A444  1  9D 34 01                sta DigitModifier,x       ;store in digit modifier
00A447  1  20 13 A8                jsr AddToScore            ;do sub to award player points depending on height of collision
00A44A  1  A9 05        NoSc4F:    lda #$05
00A44C  1  85 0E                   sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
00A44E  1  20 79 DE     FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
00A451  1  20 1C DE                jsr RelativeEnemyPosition ;get relative coordinates
00A454  1  20 CD D1                jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
00A457  1  60           ExitFlagP: rts
00A458  1               
00A458  1               ;-------------------------------------------------------------------------------------
00A458  1               
00A458  1               Jumpspring_Y_PosData:
00A458  1  08 10 08 00        .byte $08, $10, $08, $00
00A45C  1               
00A45C  1               JumpspringHandler:
00A45C  1  20 79 DE                jsr GetEnemyOffscreenBits   ;get offscreen information
00A45F  1  AD 47 07                lda TimerControl            ;check master timer control
00A462  1  D0 55                   bne DrawJSpr                ;branch to last section if set
00A464  1  AD 0E 07                lda JumpspringAnimCtrl      ;check jumpspring frame control
00A467  1  F0 50                   beq DrawJSpr                ;branch to last section if not set
00A469  1  A8                      tay
00A46A  1  88                      dey                         ;subtract one from frame control in A,
00A46B  1  98                      tya                         ;the only way a poor NMOS 6502 can
00A46C  1  29 02                   and #%00000010              ;mask out all but d1, original value still in Y
00A46E  1  D0 07                   bne DownJSpr                ;if set, branch to move player up
00A470  1  E6 CE                   inc Player_Y_Position
00A472  1  E6 CE                   inc Player_Y_Position       ;move player's vertical position down two pixels
00A474  1  4C 7B A4                jmp PosJSpr                 ;skip to next part
00A477  1  C6 CE        DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
00A479  1  C6 CE                   dec Player_Y_Position
00A47B  1  B5 58        PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
00A47D  1  18                      clc
00A47E  1  79 58 A4                adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
00A481  1  95 CF                   sta Enemy_Y_Position,x      ;store as new vertical position
00A483  1  C0 01                   cpy #$01                    ;check frame control offset (second frame is $00)
00A485  1  90 24                   bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
00A487  1  A5 0A                   lda A_B_Buttons
00A489  1  29 80                   and #A_Button               ;check saved controller bits for A button press
00A48B  1  F0 1E                   beq BounceJS                ;skip to next part if A not pressed
00A48D  1  25 0D                   and PreviousA_B_Buttons     ;check for A button pressed in previous frame
00A48F  1  D0 1A                   bne BounceJS                ;skip to next part if so
00A491  1  98                      tya
00A492  1  48                      pha
00A493  1  A9 F4                   lda #$f4                    ;set jumpspring force for red jumpsprings
00A495  1  AC 5F 07                ldy WorldNumber
00A498  1  C0 01                   cpy #World2
00A49A  1  F0 08                   beq GreenJS                 ;if world number is 2, 3 or 7
00A49C  1  C0 02                   cpy #World3                 ;set jumpspring force for green jumpsprings
00A49E  1  F0 04                   beq GreenJS
00A4A0  1  C0 06                   cpy #World7                 ;otherwise use red jumpspring force
00A4A2  1  D0 02                   bne SetJSF
00A4A4  1  A9 E0        GreenJS:   lda #$e0
00A4A6  1  8D DB 06     SetJSF:    sta JumpspringForce         ;otherwise write new jumpspring force here
00A4A9  1  68                      pla
00A4AA  1  A8                      tay
00A4AB  1  C0 03        BounceJS:  cpy #$03                    ;check frame control offset again
00A4AD  1  D0 0A                   bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
00A4AF  1  AD DB 06                lda JumpspringForce
00A4B2  1  85 9F                   sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
00A4B4  1  A9 00                   lda #$00
00A4B6  1  8D 0E 07                sta JumpspringAnimCtrl      ;initialize jumpspring frame control
00A4B9  1  20 1C DE     DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
00A4BC  1  20 08 D5                jsr EnemyGfxHandler         ;draw jumpspring
00A4BF  1  20 AD C2                jsr OffscreenBoundsCheck    ;check to see if we need to kill it
00A4C2  1  AD 0E 07                lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
00A4C5  1  F0 0D                   beq ExJSpring               ;trying to animate it, just leave
00A4C7  1  AD 86 07                lda JumpspringTimer
00A4CA  1  D0 08                   bne ExJSpring               ;if jumpspring timer not expired yet, leave
00A4CC  1  A9 04                   lda #$04
00A4CE  1  8D 86 07                sta JumpspringTimer         ;otherwise initialize jumpspring timer
00A4D1  1  EE 0E 07                inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
00A4D4  1  60           ExJSpring: rts                         ;leave
00A4D5  1               
00A4D5  1               ;-------------------------------------------------------------------------------------
00A4D5  1               
00A4D5  1               Setup_Vine:
00A4D5  1  A9 2F                lda #VineObject          ;load identifier for vine object
00A4D7  1  95 16                sta Enemy_ID,x           ;store in buffer
00A4D9  1  A9 01                lda #$01
00A4DB  1  95 0F                sta Enemy_Flag,x         ;set flag for enemy object buffer
00A4DD  1  B9 76 00             lda Block_PageLoc,y
00A4E0  1  95 6E                sta Enemy_PageLoc,x      ;copy page location from previous object
00A4E2  1  B9 8F 00             lda Block_X_Position,y
00A4E5  1  95 87                sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
00A4E7  1  B9 D7 00             lda Block_Y_Position,y
00A4EA  1  95 CF                sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
00A4EC  1  AC 98 03             ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
00A4EF  1  D0 03                bne NextVO               ;if set at all, don't bother to store vertical
00A4F1  1  8D 9D 03             sta VineStart_Y_Position ;otherwise store vertical coordinate here
00A4F4  1  8A           NextVO: txa                      ;store object offset to next available vine slot
00A4F5  1  99 9A 03             sta VineObjOffset,y      ;using vine flag as offset
00A4F8  1  EE 98 03             inc VineFlagOffset       ;increment vine flag offset
00A4FB  1  A9 04                lda #Sfx_GrowVine
00A4FD  1  85 FE                sta Square2SoundQueue    ;load vine grow sound
00A4FF  1  60                   rts
00A500  1               
00A500  1               ;-------------------------------------------------------------------------------------
00A500  1               ;$06-$07 - used as address to block buffer data
00A500  1               ;$02 - used as vertical high nybble of block buffer offset
00A500  1               
00A500  1               VineHeightData:
00A500  1  30 60              .byte $30, $60
00A502  1               
00A502  1               VineObjectHandler:
00A502  1  E0 05                    cpx #$05                  ;check enemy offset for special use slot
00A504  1  F0 01                    beq ProcVO                ;if in special use slot, continue
00A506  1  60                       rts
00A507  1  AC 98 03     ProcVO:     ldy VineFlagOffset
00A50A  1  88                       dey                       ;decrement vine flag in Y, use as offset
00A50B  1  AD 99 03                 lda VineHeight
00A50E  1  D9 00 A5                 cmp VineHeightData,y      ;if vine has reached certain height,
00A511  1  F0 0F                    beq RunVSubs              ;branch ahead to skip this part
00A513  1  A5 09                    lda FrameCounter          ;get frame counter
00A515  1  4A                       lsr                       ;shift d1 into carry
00A516  1  4A                       lsr
00A517  1  90 09                    bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
00A519  1  A5 D4                    lda Enemy_Y_Position+5
00A51B  1  E9 01                    sbc #$01                  ;subtract vertical position of vine
00A51D  1  85 D4                    sta Enemy_Y_Position+5    ;one pixel every frame it's time
00A51F  1  EE 99 03                 inc VineHeight            ;increment vine height
00A522  1  AD 99 03     RunVSubs:   lda VineHeight            ;if vine still very small,
00A525  1  C9 08                    cmp #$08                  ;branch to last part
00A527  1  90 46                    bcc ChkVOffscr
00A529  1  20 1C DE                 jsr RelativeEnemyPosition ;get relative coordinates of vine,
00A52C  1  20 79 DE                 jsr GetEnemyOffscreenBits ;and any offscreen bits
00A52F  1  A0 00                    ldy #$00                  ;initialize offset used in draw vine sub
00A531  1  20 B5 D0     VDrawLoop:  jsr DrawVine              ;draw vine
00A534  1  C8                       iny                       ;increment offset
00A535  1  CC 98 03                 cpy VineFlagOffset        ;if offset in Y and offset here
00A538  1  D0 F7                    bne VDrawLoop             ;do not yet match, loop back to draw more vine
00A53A  1  AD D1 03                 lda Enemy_OffscreenBits
00A53D  1  29 0C                    and #%00001100            ;mask offscreen bits
00A53F  1  F0 10                    beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
00A541  1  88                       dey                       ;otherwise decrement Y to get proper offset again
00A542  1  BE 9A 03     KillVine:   ldx VineObjOffset,y       ;get enemy object offset for this vine object
00A545  1  20 C9 B5                 jsr EraseEnemyObject      ;kill this vine object
00A548  1  88                       dey                       ;decrement Y
00A549  1  10 F7                    bpl KillVine              ;if any vine objects left, loop back to kill it
00A54B  1  8D 98 03                 sta VineFlagOffset        ;initialize vine flag/offset
00A54E  1  8D 99 03                 sta VineHeight            ;initialize vine height
00A551  1  AD 99 03     WrCMTile:   lda VineHeight            ;check vine height
00A554  1  C9 20                    cmp #$20                  ;if vine small (less than 32 pixels tall)
00A556  1  90 17                    bcc ChkVOffscr            ;then branch ahead to last part to skip this
00A558  1  A2 06                    ldx #$06                  ;set offset in X to last enemy slot
00A55A  1  A9 01                    lda #$01                  ;set A to obtain horizontal in $04, but we don't care
00A55C  1  A0 1B                    ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
00A55E  1  20 71 D0                 jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
00A561  1  A4 02                    ldy $02
00A563  1  C0 D0                    cpy #$d0                  ;if vertical high nybble offset beyond extent of
00A565  1  B0 08                    bcs ChkVOffscr            ;current block buffer, branch to leave, do not write
00A567  1  B1 06                    lda ($06),y               ;otherwise check contents of block buffer at
00A569  1  D0 04                    bne ChkVOffscr            ;current offset, if not empty, branch to leave
00A56B  1  A9 23                    lda #$23
00A56D  1  91 06                    sta ($06),y               ;otherwise, write climbing metatile to block buffer
00A56F  1  A5 8C        ChkVOffscr: lda Enemy_X_Position+5
00A571  1  38                       sec
00A572  1  ED 1C 07                 sbc ScreenLeft_X_Pos
00A575  1  A8                       tay
00A576  1  A5 73                    lda Enemy_PageLoc+5       ;compare horizontal position of vine
00A578  1  ED 1A 07                 sbc ScreenLeft_PageLoc    ;to that of the left side of the screen
00A57B  1  30 04                    bmi VineOffscr            ;if vine isn't within 8 pixels of the edge
00A57D  1  C0 09                    cpy #$09                  ;or past the left edge, branch to leave
00A57F  1  B0 2C                    bcs ExitVH
00A581  1  A9 00        VineOffscr: lda #$00                  ;erase vine's flag to kill it
00A583  1  85 14                    sta Enemy_Flag+5
00A585  1  A5 73                    lda Enemy_PageLoc+5
00A587  1  29 01                    and #$01                  ;fetch the right block buffer address
00A589  1  A8                       tay
00A58A  1  B9 19 9A                 lda BlockBufferAddr,y
00A58D  1  85 06                    sta $06
00A58F  1  B9 1B 9A                 lda BlockBufferAddr+2,y
00A592  1  85 07                    sta $07
00A594  1  A5 8C                    lda Enemy_X_Position+5    ;divide upper nybble of X position by 16
00A596  1  4A                       lsr                       ;to get appropriate offset
00A597  1  4A                       lsr
00A598  1  4A                       lsr
00A599  1  4A                       lsr
00A59A  1  A8           EraseClM:   tay
00A59B  1  B1 06                    lda ($06),y               ;check for climbing metatile
00A59D  1  C9 23                    cmp #$23                  ;if not found, move down a row
00A59F  1  D0 04                    bne NoClimbM
00A5A1  1  A9 00                    lda #$00                  ;otherwise erase climbing metatile
00A5A3  1  91 06                    sta ($06),y
00A5A5  1  98           NoClimbM:   tya
00A5A6  1  18                       clc
00A5A7  1  69 10                    adc #$10                  ;move 16 bytes (one row) ahead in block buffer
00A5A9  1  C9 D0                    cmp #$d0                  ;if not at bottom row, loop
00A5AB  1  90 ED                    bcc EraseClM
00A5AD  1  A6 08        ExitVH:     ldx ObjectOffset          ;get enemy object offset and leave
00A5AF  1  60                       rts
00A5B0  1               
00A5B0  1               ;-------------------------------------------------------------------------------------
00A5B0  1               
00A5B0  1               CannonBitmasks:
00A5B0  1  0F 07              .byte %00001111, %00000111
00A5B2  1               
00A5B2  1               ProcessCannons:
00A5B2  1  AD 4E 07                lda AreaType                ;get area type
00A5B5  1  F0 6F                   beq ExCannon                ;if water type area, branch to leave
00A5B7  1  A2 02                   ldx #$02
00A5B9  1  86 08        ThreeSChk: stx ObjectOffset            ;start at third enemy slot
00A5BB  1  B5 0F                   lda Enemy_Flag,x            ;check enemy buffer flag
00A5BD  1  D0 51                   bne Chk_BB                  ;if set, branch to check enemy
00A5BF  1  BD A8 07                lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
00A5C2  1  AC CC 06                ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
00A5C5  1  39 B0 A5                and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
00A5C8  1  C9 06                   cmp #$06                    ;check to see if lower nybble is above certain value
00A5CA  1  B0 44                   bcs Chk_BB                  ;if so, branch to check enemy
00A5CC  1  A8                      tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
00A5CD  1  B9 6B 04                lda Cannon_PageLoc,y        ;get page location
00A5D0  1  F0 3E                   beq Chk_BB                  ;if not set or on page 0, branch to check enemy
00A5D2  1  B9 7D 04                lda Cannon_Timer,y          ;get cannon timer
00A5D5  1  F0 08                   beq FireCannon              ;if expired, branch to fire cannon
00A5D7  1  E9 00                   sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
00A5D9  1  99 7D 04                sta Cannon_Timer,y          ;to count timer down
00A5DC  1  4C 10 A6                jmp Chk_BB                  ;then jump ahead to check enemy
00A5DF  1               
00A5DF  1               FireCannon:
00A5DF  1  AD 47 07               lda TimerControl           ;if master timer control set,
00A5E2  1  D0 2C                  bne Chk_BB                 ;branch to check enemy
00A5E4  1  A9 0E                  lda #$0e                   ;otherwise we start creating one
00A5E6  1  99 7D 04               sta Cannon_Timer,y         ;first, reset cannon timer
00A5E9  1  B9 6B 04               lda Cannon_PageLoc,y       ;get page location of cannon
00A5EC  1  95 6E                  sta Enemy_PageLoc,x        ;save as page location of bullet bill
00A5EE  1  B9 71 04               lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
00A5F1  1  95 87                  sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
00A5F3  1  B9 77 04               lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
00A5F6  1  38                     sec
00A5F7  1  E9 08                  sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
00A5F9  1  95 CF                  sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
00A5FB  1  A9 01                  lda #$01
00A5FD  1  95 B6                  sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
00A5FF  1  95 0F                  sta Enemy_Flag,x           ;set buffer flag
00A601  1  4A                     lsr                        ;shift right once to init A
00A602  1  95 1E                  sta Enemy_State,x          ;then initialize enemy's state
00A604  1  A9 09                  lda #$09
00A606  1  9D 9A 04               sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
00A609  1  A9 33                  lda #BulletBill_CannonVar
00A60B  1  95 16                  sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
00A60D  1  4C 23 A6               jmp Next3Slt               ;move onto next slot
00A610  1  B5 16        Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
00A612  1  C9 33                  cmp #BulletBill_CannonVar
00A614  1  D0 0D                  bne Next3Slt               ;if not found, branch to get next slot
00A616  1  20 AD C2               jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
00A619  1  B5 0F                  lda Enemy_Flag,x           ;check enemy buffer flag
00A61B  1  F0 06                  beq Next3Slt               ;if not set, branch to get next slot
00A61D  1  20 79 DE               jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
00A620  1  20 29 A6               jsr BulletBillHandler      ;then do sub to handle bullet bill
00A623  1  CA           Next3Slt: dex                        ;move onto next slot
00A624  1  10 93                  bpl ThreeSChk              ;do this until first three slots are checked
00A626  1  60           ExCannon: rts                        ;then leave
00A627  1               
00A627  1               ;--------------------------------
00A627  1               
00A627  1               BulletBillXSpdData:
00A627  1  18 E8              .byte $18, $e8
00A629  1               
00A629  1               BulletBillHandler:
00A629  1  AD 47 07                lda TimerControl          ;if master timer control set,
00A62C  1  D0 3E                   bne RunBBSubs             ;branch to run subroutines except movement sub
00A62E  1  B5 1E                   lda Enemy_State,x
00A630  1  D0 2E                   bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
00A632  1  AD D1 03                lda Enemy_OffscreenBits   ;otherwise load offscreen bits
00A635  1  29 0C                   and #%00001100            ;mask out bits
00A637  1  C9 0C                   cmp #%00001100            ;check to see if all bits are set
00A639  1  F0 40                   beq KillBB                ;if so, branch to kill this object
00A63B  1  A0 01                   ldy #$01                  ;set to move right by default
00A63D  1  20 BC CD                jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
00A640  1  30 01                   bmi SetupBB               ;if enemy to the left of player, branch
00A642  1  C8                      iny                       ;otherwise increment to move left
00A643  1  94 46        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
00A645  1  88                      dey                       ;decrement to use as offset
00A646  1  B9 27 A6                lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
00A649  1  95 58                   sta Enemy_X_Speed,x       ;and store it
00A64B  1  A5 00                   lda $00                   ;get horizontal difference
00A64D  1  69 28                   adc #$28                  ;add 40 pixels
00A64F  1  C9 50                   cmp #$50                  ;if less than a certain amount, player is too close
00A651  1  90 28                   bcc KillBB                ;to cannon either on left or right side, thus branch
00A653  1  A9 01                   lda #$01
00A655  1  95 1E                   sta Enemy_State,x         ;otherwise set bullet bill's state
00A657  1  A9 0A                   lda #$0a
00A659  1  9D 8A 07                sta EnemyFrameTimer,x     ;set enemy frame timer
00A65C  1  A9 08                   lda #Sfx_Blast
00A65E  1  85 FE                   sta Square2SoundQueue     ;play fireworks/gunfire sound
00A660  1  B5 1E        ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
00A662  1  29 20                   and #%00100000
00A664  1  F0 03                   beq BBFly                 ;if not set, skip to move horizontally
00A666  1  20 5F AB                jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
00A669  1  20 FE AA     BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
00A66C  1  20 79 DE     RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
00A66F  1  20 1C DE                jsr RelativeEnemyPosition ;get relative coordinates
00A672  1  20 C4 CE                jsr GetEnemyBoundBox      ;get bounding box coordinates
00A675  1  20 A3 C4                jsr PlayerEnemyCollision  ;handle player to enemy collisions
00A678  1  4C 08 D5                jmp EnemyGfxHandler       ;draw the bullet bill and leave
00A67B  1  20 C9 B5     KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
00A67E  1  60                      rts
00A67F  1               
00A67F  1               ;-------------------------------------------------------------------------------------
00A67F  1               
00A67F  1               HammerEnemyOfsData:
00A67F  1  04 04 04 05        .byte $04, $04, $04, $05, $05, $05
00A683  1  05 05        
00A685  1  06 06 06           .byte $06, $06, $06
00A688  1               
00A688  1               HammerXSpdData:
00A688  1  10 F0              .byte $10, $f0
00A68A  1               
00A68A  1               SpawnHammerObj:
00A68A  1  AD A8 07               lda PseudoRandomBitReg+1 ;get a pseudorandom number from 0 to 8
00A68D  1  29 07                  and #%00000111           ;from the second part of LSFR
00A68F  1  D0 05                  bne SetMOfs
00A691  1  AD A8 07               lda PseudoRandomBitReg+1
00A694  1  29 08                  and #%00001000
00A696  1  A8           SetMOfs:  tay                      ;use as misc object offset
00A697  1  B9 2A 00               lda Misc_State,y         ;check for enemy state, if found, branch to leave
00A69A  1  D0 19                  bne NoHammer
00A69C  1  BE 7F A6               ldx HammerEnemyOfsData,y ;get enemy slot offset number using misc obj offset
00A69F  1  B5 0F                  lda Enemy_Flag,x         ;then check enemy buffer flag at that offset
00A6A1  1  D0 12                  bne NoHammer             ;if buffer flag set, branch to leave with carry clear
00A6A3  1  A6 08                  ldx ObjectOffset         ;get original enemy object offset
00A6A5  1  8A                     txa
00A6A6  1  99 AE 06               sta HammerEnemyOffset,y  ;save here
00A6A9  1  A9 90                  lda #$90
00A6AB  1  99 2A 00               sta Misc_State,y         ;save hammer's state here
00A6AE  1  A9 07                  lda #$07
00A6B0  1  99 A2 04               sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
00A6B3  1  38                     sec                      ;return with carry set
00A6B4  1  60                     rts
00A6B5  1  A6 08        NoHammer: ldx ObjectOffset         ;get original enemy object offset
00A6B7  1  18                     clc                      ;return with carry clear
00A6B8  1  60                     rts
00A6B9  1               
00A6B9  1               ;--------------------------------
00A6B9  1               ;$00 - used to set downward force
00A6B9  1               ;$01 - used to set upward force (residual)
00A6B9  1               ;$02 - used to set maximum speed
00A6B9  1               
00A6B9  1               ProcHammerObj:
00A6B9  1  AD 47 07               lda TimerControl           ;if master timer control set
00A6BC  1  D0 63                  bne RunHSubs               ;skip all of this code and go to last subs at the end
00A6BE  1  B5 2A                  lda Misc_State,x           ;otherwise get hammer's state
00A6C0  1  29 7F                  and #%01111111             ;mask out d7
00A6C2  1  BC AE 06               ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
00A6C5  1  C9 02                  cmp #$02                   ;check hammer's state
00A6C7  1  F0 20                  beq SetHSpd                ;if currently at 2, branch
00A6C9  1  B0 34                  bcs SetHPos                ;if greater than 2, branch elsewhere
00A6CB  1  8A                     txa
00A6CC  1  18                     clc                        ;add 13 bytes to use
00A6CD  1  69 0D                  adc #$0d                   ;proper misc object
00A6CF  1  AA                     tax                        ;return offset to X
00A6D0  1  A9 10                  lda #$10
00A6D2  1  85 00                  sta $00                    ;set downward movement force
00A6D4  1  A9 0F                  lda #$0f
00A6D6  1  85 01                  sta $01                    ;set upward movement force (not used)
00A6D8  1  A9 04                  lda #$04
00A6DA  1  85 02                  sta $02                    ;set maximum vertical speed
00A6DC  1  A9 00                  lda #$00                   ;set A to impose gravity on hammer
00A6DE  1  20 D3 AB               jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
00A6E1  1  20 0B AB               jsr MoveObjectHorizontally ;do sub to move it horizontally
00A6E4  1  A6 08                  ldx ObjectOffset           ;get original misc object offset
00A6E6  1  4C 1E A7               jmp RunAllH                ;branch to essential subroutines
00A6E9  1  A9 FE        SetHSpd:  lda #$fe
00A6EB  1  95 AC                  sta Misc_Y_Speed,x         ;set hammer's vertical speed
00A6ED  1  B9 1E 00               lda Enemy_State,y          ;get enemy object state
00A6F0  1  29 F7                  and #%11110111             ;mask out d3
00A6F2  1  99 1E 00               sta Enemy_State,y          ;store new state
00A6F5  1  B6 46                  ldx Enemy_MovingDir,y      ;get enemy's moving direction
00A6F7  1  CA                     dex                        ;decrement to use as offset
00A6F8  1  BD 88 A6               lda HammerXSpdData,x       ;get proper speed to use based on moving direction
00A6FB  1  A6 08                  ldx ObjectOffset           ;reobtain hammer's buffer offset
00A6FD  1  95 64                  sta Misc_X_Speed,x         ;set hammer's horizontal speed
00A6FF  1  D6 2A        SetHPos:  dec Misc_State,x           ;decrement hammer's state
00A701  1  B9 87 00               lda Enemy_X_Position,y     ;get enemy's horizontal position
00A704  1  18                     clc
00A705  1  69 02                  adc #$02                   ;set position 2 pixels to the right
00A707  1  95 93                  sta Misc_X_Position,x      ;store as hammer's horizontal position
00A709  1  B9 6E 00               lda Enemy_PageLoc,y        ;get enemy's page location
00A70C  1  69 00                  adc #$00                   ;add carry
00A70E  1  95 7A                  sta Misc_PageLoc,x         ;store as hammer's page location
00A710  1  B9 CF 00               lda Enemy_Y_Position,y     ;get enemy's vertical position
00A713  1  38                     sec
00A714  1  E9 0A                  sbc #$0a                   ;move position 10 pixels upward
00A716  1  95 DB                  sta Misc_Y_Position,x      ;store as hammer's vertical position
00A718  1  A9 01                  lda #$01
00A71A  1  95 C2                  sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
00A71C  1  D0 03                  bne RunHSubs               ;unconditional branch to skip first routine
00A71E  1  20 08 C4     RunAllH:  jsr PlayerHammerCollision  ;handle collisions
00A721  1  20 65 DE     RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
00A724  1  20 12 DE               jsr RelativeMiscPosition   ;get relative coordinates
00A727  1  20 B7 CE               jsr GetMiscBoundBox        ;get bounding box coordinates
00A72A  1  20 5C D1               jsr DrawHammer             ;draw the hammer
00A72D  1  60                     rts                        ;and we are done here
00A72E  1               
00A72E  1               ;-------------------------------------------------------------------------------------
00A72E  1               ;$02 - used to store vertical high nybble offset from block buffer routine
00A72E  1               ;$06 - used to store low byte of block buffer address
00A72E  1               
00A72E  1               CoinBlock:
00A72E  1  20 7A A7           jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
00A731  1  B5 76              lda Block_PageLoc,x     ;get page location of block object
00A733  1  99 7A 00           sta Misc_PageLoc,y      ;store as page location of misc object
00A736  1  B5 8F              lda Block_X_Position,x  ;get horizontal coordinate of block object
00A738  1  09 05              ora #$05                ;add 5 pixels
00A73A  1  99 93 00           sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
00A73D  1  B5 D7              lda Block_Y_Position,x  ;get vertical coordinate of block object
00A73F  1  E9 10              sbc #$10                ;subtract 16 pixels
00A741  1  99 DB 00           sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
00A744  1  4C 62 A7           jmp JCoinC              ;jump to rest of code as applies to this misc object
00A747  1               
00A747  1               SetupJumpCoin:
00A747  1  20 7A A7             jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
00A74A  1  BD EA 03             lda Block_PageLoc2,x   ;get page location saved earlier
00A74D  1  99 7A 00             sta Misc_PageLoc,y     ;and save as page location for misc object
00A750  1  A5 06                lda $06                ;get low byte of block buffer offset
00A752  1  0A                   asl
00A753  1  0A                   asl                    ;multiply by 16 to use lower nybble
00A754  1  0A                   asl
00A755  1  0A                   asl
00A756  1  09 05                ora #$05               ;add five pixels
00A758  1  99 93 00             sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
00A75B  1  A5 02                lda $02                ;get vertical high nybble offset from earlier
00A75D  1  69 20                adc #$20               ;add 32 pixels for the status bar
00A75F  1  99 DB 00             sta Misc_Y_Position,y  ;store as vertical coordinate
00A762  1  A9 FB        JCoinC: lda #$fb
00A764  1  99 AC 00             sta Misc_Y_Speed,y     ;set vertical speed
00A767  1  A9 01                lda #$01
00A769  1  99 C2 00             sta Misc_Y_HighPos,y   ;set vertical high byte
00A76C  1  99 2A 00             sta Misc_State,y       ;set state for misc object
00A76F  1  85 FE                sta Square2SoundQueue  ;load coin grab sound
00A771  1  86 08                stx ObjectOffset       ;store current control bit as misc object offset
00A773  1  20 EE A7             jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
00A776  1  EE 48 07             inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
00A779  1  60                   rts
00A77A  1               
00A77A  1               FindEmptyMiscSlot:
00A77A  1  A0 08                   ldy #$08                ;start at end of misc objects buffer
00A77C  1  B9 2A 00     FMiscLoop: lda Misc_State,y        ;get misc object state
00A77F  1  F0 07                   beq UseMiscS            ;branch if none found to use current offset
00A781  1  88                      dey                     ;decrement offset
00A782  1  C0 05                   cpy #$05                ;do this for three slots
00A784  1  D0 F6                   bne FMiscLoop           ;do this until all slots are checked
00A786  1  A0 08                   ldy #$08                ;if no empty slots found, use last slot
00A788  1  8C B7 06     UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
00A78B  1  60                      rts
00A78C  1               
00A78C  1               ;-------------------------------------------------------------------------------------
00A78C  1               
00A78C  1               MiscObjectsCore:
00A78C  1  A2 08                  ldx #$08          ;set at end of misc object buffer
00A78E  1  86 08        MiscLoop: stx ObjectOffset  ;store misc object offset here
00A790  1  B5 2A                  lda Misc_State,x  ;check misc object state
00A792  1  F0 56                  beq MiscLoopBack  ;branch to check next slot
00A794  1  0A                     asl               ;otherwise shift d7 into carry
00A795  1  90 06                  bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
00A797  1  20 B9 A6               jsr ProcHammerObj ;otherwise go to process hammer,
00A79A  1  4C EA A7               jmp MiscLoopBack  ;then check next slot
00A79D  1               
00A79D  1               ;--------------------------------
00A79D  1               ;$00 - used to set downward force
00A79D  1               ;$01 - used to set upward force (residual)
00A79D  1               ;$02 - used to set maximum speed
00A79D  1               
00A79D  1               ProcJumpCoin:
00A79D  1  B4 2A                   ldy Misc_State,x          ;check misc object state
00A79F  1  88                      dey                       ;decrement to see if it's set to 1
00A7A0  1  F0 1D                   beq JCoinRun              ;if so, branch to handle jumping coin
00A7A2  1  F6 2A                   inc Misc_State,x          ;otherwise increment state to either start off or as timer
00A7A4  1  B5 93                   lda Misc_X_Position,x     ;get horizontal coordinate for misc object
00A7A6  1  18                      clc                       ;whether its jumping coin (state 0 only) or floatey number
00A7A7  1  6D 75 07                adc ScrollAmount          ;add current scroll speed
00A7AA  1  95 93                   sta Misc_X_Position,x     ;store as new horizontal coordinate
00A7AC  1  B5 7A                   lda Misc_PageLoc,x        ;get page location
00A7AE  1  69 00                   adc #$00                  ;add carry
00A7B0  1  95 7A                   sta Misc_PageLoc,x        ;store as new page location
00A7B2  1  B5 2A                   lda Misc_State,x
00A7B4  1  C9 30                   cmp #$30                  ;check state of object for preset value
00A7B6  1  D0 26                   bne RunJCSubs             ;if not yet reached, branch to subroutines
00A7B8  1  A9 00                   lda #$00
00A7BA  1  95 2A                   sta Misc_State,x          ;otherwise nullify object state
00A7BC  1  4C EA A7                jmp MiscLoopBack          ;and move onto next slot
00A7BF  1  8A           JCoinRun:  txa
00A7C0  1  18                      clc                       ;add 13 bytes to offset for next subroutine
00A7C1  1  69 0D                   adc #$0d
00A7C3  1  AA                      tax
00A7C4  1  A9 50                   lda #$50                  ;set downward movement amount
00A7C6  1  85 00                   sta $00
00A7C8  1  A9 06                   lda #$06                  ;set maximum vertical speed
00A7CA  1  85 02                   sta $02
00A7CC  1  4A                      lsr                       ;divide by 2 and set
00A7CD  1  85 01                   sta $01                   ;as upward movement amount (apparently residual)
00A7CF  1  A9 00                   lda #$00                  ;set A to impose gravity on jumping coin
00A7D1  1  20 D3 AB                jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
00A7D4  1  A6 08                   ldx ObjectOffset          ;get original misc object offset
00A7D6  1  B5 AC                   lda Misc_Y_Speed,x        ;check vertical speed
00A7D8  1  C9 05                   cmp #$05
00A7DA  1  D0 02                   bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
00A7DC  1  F6 2A                   inc Misc_State,x          ;otherwise increment state to change to floatey number
00A7DE  1  20 12 DE     RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
00A7E1  1  20 65 DE                jsr GetMiscOffscreenBits  ;get offscreen information
00A7E4  1  20 B7 CE                jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
00A7E7  1  20 08 D3                jsr JCoinGfxHandler       ;draw the coin or floatey number
00A7EA  1               
00A7EA  1               MiscLoopBack:
00A7EA  1  CA                      dex                       ;decrement misc object offset
00A7EB  1  10 A1                   bpl MiscLoop              ;loop back until all misc objects handled
00A7ED  1  60                      rts                       ;then leave
00A7EE  1               
00A7EE  1               ;-------------------------------------------------------------------------------------
00A7EE  1               
00A7EE  1               GiveOneCoin:
00A7EE  1  A9 01              lda #$01               ;set digit modifier to add 1 coin
00A7F0  1  8D 39 01           sta DigitModifier+5    ;to the current player's coin tally
00A7F3  1  A0 11              ldy #$11               ;set offset for coin tally
00A7F5  1  20 BE 8D           jsr DigitsMathRoutine  ;update the coin tally
00A7F8  1  EE 5E 07           inc CoinTally          ;increment onscreen player's coin amount
00A7FB  1  AD 5E 07           lda CoinTally
00A7FE  1  C9 64              cmp #100               ;does player have 100 coins yet?
00A800  1  D0 0C              bne CoinPoints         ;if not, skip all of this
00A802  1  A9 00              lda #$00
00A804  1  8D 5E 07           sta CoinTally          ;otherwise, reinitialize coin amount
00A807  1  EE 5A 07           inc NumberofLives      ;give the player an extra life
00A80A  1  A9 40              lda #Sfx_ExtraLife
00A80C  1  85 FE              sta Square2SoundQueue  ;play 1-up sound
00A80E  1               
00A80E  1               CoinPoints:
00A80E  1  A9 02              lda #$02               ;set digit modifier to award
00A810  1  8D 38 01           sta DigitModifier+4    ;200 points to the player
00A813  1               
00A813  1               AddToScore:
00A813  1  A0 0B              ldy #$0b               ;get offset for player's score
00A815  1  20 BE 8D           jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
00A818  1               
00A818  1               WriteScoreAndCoinTally:
00A818  1  A9 01                lda #$01
00A81A  1               WriteDigits:
00A81A  1  4C rr rr             jmp BANK_PractisePrintScore
00A81D  1                       ;REPLACED;jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
00A81D  1  AC 00 03             ldy VRAM_Buffer1_Offset
00A820  1  B9 FB 02             lda VRAM_Buffer1-6,y      ;check highest digit of score
00A823  1  D0 05                bne NoZSup                ;if zero, overwrite with space tile for zero suppression
00A825  1  A9 24                lda #$24
00A827  1  99 FB 02             sta VRAM_Buffer1-6,y
00A82A  1  A6 08        NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
00A82C  1  60                   rts
00A82D  1               
00A82D  1               ;-------------------------------------------------------------------------------------
00A82D  1               
00A82D  1               SetupPowerUp:
00A82D  1  A9 2E                   lda #PowerUpObject        ;load power-up identifier into
00A82F  1  85 1B                   sta Enemy_ID+5            ;special use slot of enemy object buffer
00A831  1  B5 76                   lda Block_PageLoc,x       ;store page location of block object
00A833  1  85 73                   sta Enemy_PageLoc+5       ;as page location of power-up object
00A835  1  B5 8F                   lda Block_X_Position,x    ;store horizontal coordinate of block object
00A837  1  85 8C                   sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
00A839  1  A9 01                   lda #$01
00A83B  1  85 BB                   sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
00A83D  1  B5 D7                   lda Block_Y_Position,x    ;get vertical coordinate of block object
00A83F  1  38                      sec
00A840  1  E9 08                   sbc #$08                  ;subtract 8 pixels
00A842  1  85 D4                   sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
00A844  1  A9 01        PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
00A846  1  85 23                   sta Enemy_State+5         ;set power-up object's state
00A848  1  85 14                   sta Enemy_Flag+5          ;set buffer flag
00A84A  1  A9 03                   lda #$03
00A84C  1  8D 9F 04                sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
00A84F  1  A5 39                   lda PowerUpType
00A851  1  C9 02                   cmp #$02                  ;check currently loaded power-up type
00A853  1  B0 0A                   bcs PutBehind             ;if star or 1-up, branch ahead
00A855  1  AD 56 07                lda PlayerStatus          ;otherwise check player's current status
00A858  1  C9 02                   cmp #$02
00A85A  1  90 01                   bcc StrType               ;if player not fiery, use status as power-up type
00A85C  1  4A                      lsr                       ;otherwise shift right to force fire flower type
00A85D  1  85 39        StrType:   sta PowerUpType           ;store type here
00A85F  1  A9 20        PutBehind: lda #%00100000
00A861  1  8D CA 03                sta Enemy_SprAttrib+5     ;set background priority bit
00A864  1  A9 02                   lda #Sfx_GrowPowerUp
00A866  1  85 FE                   sta Square2SoundQueue     ;load power-up reveal sound and leave
00A868  1  60                      rts
00A869  1               
00A869  1               ;-------------------------------------------------------------------------------------
00A869  1               
00A869  1               PowerUpObjHandler:
00A869  1  A2 05                 ldx #$05                   ;set object offset for last slot in enemy object buffer
00A86B  1  86 08                 stx ObjectOffset
00A86D  1  A5 23                 lda Enemy_State+5          ;check power-up object's state
00A86F  1  F0 65                 beq ExitPUp                ;if not set, branch to leave
00A871  1  0A                    asl                        ;shift to check if d7 was set in object state
00A872  1  90 2B                 bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
00A874  1  AD 47 07              lda TimerControl           ;if master timer control set,
00A877  1  D0 4B                 bne RunPUSubs              ;branch ahead to enemy object routines
00A879  1  A5 39                 lda PowerUpType            ;check power-up type
00A87B  1  F0 19                 beq ShroomM                ;if normal mushroom, branch ahead to move it
00A87D  1  C9 03                 cmp #$03
00A87F  1  F0 15                 beq ShroomM                ;if 1-up mushroom, branch ahead to move it
00A881  1  C9 04                 cmp #$04
00A883  1  F0 11                 beq ShroomM
00A885  1  C9 05                 cmp #$05
00A887  1  F0 0D                 beq ShroomM
00A889  1  C9 02                 cmp #$02
00A88B  1  D0 37                 bne RunPUSubs              ;if not star, branch elsewhere to skip movement
00A88D  1  20 2A B7              jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
00A890  1  20 DC CD              jsr EnemyJump              ;note that green paratroopa shares the same code here
00A893  1  4C C4 A8              jmp RunPUSubs              ;then jump to other power-up subroutines
00A896  1  20 A8 B6     ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
00A899  1  20 2D CC              jsr EnemyToBGCollisionDet  ;deal with collisions
00A89C  1  4C C4 A8              jmp RunPUSubs              ;run the other subroutines
00A89F  1               
00A89F  1               GrowThePowerUp:
00A89F  1  A5 09                   lda FrameCounter           ;get frame counter
00A8A1  1  29 03                   and #$03                   ;mask out all but 2 LSB
00A8A3  1  D0 19                   bne ChkPUSte               ;if any bits set here, branch
00A8A5  1  C6 D4                   dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
00A8A7  1  A5 23                   lda Enemy_State+5          ;load power-up object state
00A8A9  1  E6 23                   inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
00A8AB  1  C9 11                   cmp #$11                   ;if power-up object state not yet past 16th pixel,
00A8AD  1  90 0F                   bcc ChkPUSte               ;branch ahead to last part here
00A8AF  1  A9 10                   lda #$10
00A8B1  1  95 58                   sta Enemy_X_Speed,x        ;otherwise set horizontal speed
00A8B3  1  A9 80                   lda #%10000000
00A8B5  1  85 23                   sta Enemy_State+5          ;and then set d7 in power-up object's state
00A8B7  1  0A                      asl                        ;shift once to init A
00A8B8  1  8D CA 03                sta Enemy_SprAttrib+5      ;initialize background priority bit set here
00A8BB  1  2A                      rol                        ;rotate A to set right moving direction
00A8BC  1  95 46                   sta Enemy_MovingDir,x      ;set moving direction
00A8BE  1  A5 23        ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
00A8C0  1  C9 06                   cmp #$06                   ;for if power-up has risen enough
00A8C2  1  90 12                   bcc ExitPUp                ;if not, don't even bother running these routines
00A8C4  1  20 1C DE     RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
00A8C7  1  20 79 DE                jsr GetEnemyOffscreenBits  ;get offscreen bits
00A8CA  1  20 C4 CE                jsr GetEnemyBoundBox       ;get bounding box coordinates
00A8CD  1  20 59 D3                jsr DrawPowerUp            ;draw the power-up object
00A8D0  1  20 A3 C4                jsr PlayerEnemyCollision   ;check for collision with player
00A8D3  1  20 AD C2                jsr OffscreenBoundsCheck   ;check to see if it went offscreen
00A8D6  1  60           ExitPUp:   rts                        ;and we're done
00A8D7  1               
00A8D7  1               ;-------------------------------------------------------------------------------------
00A8D7  1               ;These apply to all routines in this section unless otherwise noted:
00A8D7  1               ;$00 - used to store metatile from block buffer routine
00A8D7  1               ;$02 - used to store vertical high nybble offset from block buffer routine
00A8D7  1               ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
00A8D7  1               ;$06-$07 - used as block buffer address indirect
00A8D7  1               
00A8D7  1               BlockYPosAdderData:
00A8D7  1  04 12              .byte $04, $12
00A8D9  1               
00A8D9  1               PlayerHeadCollision:
00A8D9  1  48                      pha                      ;store metatile number to stack
00A8DA  1  A9 11                   lda #$11                 ;load unbreakable block object state by default
00A8DC  1  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit here
00A8DF  1  AC 54 07                ldy PlayerSize           ;check player's size
00A8E2  1  D0 02                   bne DBlockSte            ;if small, branch
00A8E4  1  A9 12                   lda #$12                 ;otherwise load breakable block object state
00A8E6  1  95 26        DBlockSte: sta Block_State,x        ;store into block object buffer
00A8E8  1  20 20 89                jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
00A8EB  1  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit
00A8EE  1  A5 02                   lda $02                  ;get vertical high nybble offset used in block buffer routine
00A8F0  1  9D E4 03                sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
00A8F3  1  A8                      tay
00A8F4  1  A5 06                   lda $06                  ;get low byte of block buffer address used in same routine
00A8F6  1  9D E6 03                sta Block_BBuf_Low,x     ;save as offset here to be used later
00A8F9  1  B1 06                   lda ($06),y              ;get contents of block buffer at old address at $06, $07
00A8FB  1  20 F2 A9                jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
00A8FE  1  85 00                   sta $00                  ;store metatile here
00A900  1  AC 54 07                ldy PlayerSize           ;check player's size
00A903  1  D0 01                   bne ChkBrick             ;if small, use metatile itself as contents of A
00A905  1  98                      tya                      ;otherwise init A (note: big = 0)
00A906  1  90 25        ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
00A908  1  A0 11                   ldy #$11                 ;otherwise load unbreakable state into block object buffer
00A90A  1  94 26                   sty Block_State,x        ;note this applies to both player sizes
00A90C  1  A9 C5                   lda #$c5                 ;load empty block metatile into A for now
00A90E  1  A4 00                   ldy $00                  ;get metatile from before
00A910  1  C0 56                   cpy #$56                 ;is it brick with coins (with line)?
00A912  1  F0 04                   beq StartBTmr            ;if so, branch
00A914  1  C0 5C                   cpy #$5c                 ;is it brick with coins (without line)?
00A916  1  D0 15                   bne PutMTileB            ;if not, branch ahead to store empty block metatile
00A918  1  AD BC 06     StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
00A91B  1  D0 08                   bne ContBTmr             ;if set, timer expired or counting down, thus branch
00A91D  1  A9 0B                   lda #$0b
00A91F  1  8D 9D 07                sta BrickCoinTimer       ;if not set, set brick coin timer
00A922  1  EE BC 06                inc BrickCoinTimerFlag   ;and set flag linked to it
00A925  1  AD 9D 07     ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
00A928  1  D0 02                   bne PutOldMT             ;if not yet expired, branch to use current metatile
00A92A  1  A0 C5                   ldy #$c5                 ;otherwise use empty block metatile
00A92C  1  98           PutOldMT:  tya                      ;put metatile into A
00A92D  1  9D E8 03     PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
00A930  1  20 70 A9                jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
00A933  1  A4 02                   ldy $02                  ;get vertical high nybble offset
00A935  1  A9 20                   lda #$20
00A937  1  91 06                   sta ($06),y              ;write blank metatile $20 to block buffer
00A939  1  A9 10                   lda #$10
00A93B  1  8D 84 07                sta BlockBounceTimer     ;set block bounce timer
00A93E  1  68                      pla                      ;pull original metatile from stack
00A93F  1  85 05                   sta $05                  ;and save here
00A941  1  A0 00                   ldy #$00                 ;set default offset
00A943  1  AD 14 07                lda CrouchingFlag        ;is player crouching?
00A946  1  D0 05                   bne SmallBP              ;if so, branch to increment offset
00A948  1  AD 54 07                lda PlayerSize           ;is player big?
00A94B  1  F0 01                   beq BigBP                ;if so, branch to use default offset
00A94D  1  C8           SmallBP:   iny                      ;increment for small or big and crouching
00A94E  1  A5 CE        BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
00A950  1  18                      clc
00A951  1  79 D7 A8                adc BlockYPosAdderData,y ;add value determined by size
00A954  1  29 F0                   and #$f0                 ;mask out low nybble to get 16-pixel correspondence
00A956  1  95 D7                   sta Block_Y_Position,x   ;save as vertical coordinate for block object
00A958  1  B4 26                   ldy Block_State,x        ;get block object state
00A95A  1  C0 11                   cpy #$11
00A95C  1  F0 06                   beq Unbreak              ;if set to value loaded for unbreakable, branch
00A95E  1  20 FE A9                jsr BrickShatter         ;execute code for breakable brick
00A961  1  4C 67 A9                jmp InvOBit              ;skip subroutine to do last part of code here
00A964  1  20 87 A9     Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
00A967  1  AD EE 03     InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
00A96A  1  49 01                   eor #$01                 ;and floatey numbers
00A96C  1  8D EE 03                sta SprDataOffset_Ctrl
00A96F  1  60                      rts                      ;leave!
00A970  1               
00A970  1               ;--------------------------------
00A970  1               
00A970  1               InitBlock_XY_Pos:
00A970  1  A5 86              lda Player_X_Position   ;get player's horizontal coordinate
00A972  1  18                 clc
00A973  1  69 08              adc #$08                ;add eight pixels
00A975  1  29 F0              and #$f0                ;mask out low nybble to give 16-pixel correspondence
00A977  1  95 8F              sta Block_X_Position,x  ;save as horizontal coordinate for block object
00A979  1  A5 6D              lda Player_PageLoc
00A97B  1  69 00              adc #$00                ;add carry to page location of player
00A97D  1  95 76              sta Block_PageLoc,x     ;save as page location of block object
00A97F  1  9D EA 03           sta Block_PageLoc2,x    ;save elsewhere to be used later
00A982  1  A5 B5              lda Player_Y_HighPos
00A984  1  95 BE              sta Block_Y_HighPos,x   ;save vertical high byte of player into
00A986  1  60                 rts                     ;vertical high byte of block object and leave
00A987  1               
00A987  1               ;--------------------------------
00A987  1               
00A987  1               BumpBlock:
00A987  1  20 1B AA                jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
00A98A  1  A9 02                   lda #Sfx_Bump
00A98C  1  85 FF                   sta Square1SoundQueue   ;play bump sound
00A98E  1  A9 00                   lda #$00
00A990  1  95 60                   sta Block_X_Speed,x     ;initialize horizontal speed for block object
00A992  1  9D 3C 04                sta Block_Y_MoveForce,x ;init fractional movement force
00A995  1  85 9F                   sta Player_Y_Speed      ;init player's vertical speed
00A997  1  A9 FE                   lda #$fe
00A999  1  95 A8                   sta Block_Y_Speed,x     ;set vertical speed for block object
00A99B  1  A5 05                   lda $05                 ;get original metatile from stack
00A99D  1  20 F2 A9                jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
00A9A0  1  90 3C                   bcc ExitBlockChk        ;if no match was found, branch to leave
00A9A2  1  98                      tya                     ;move block number to A
00A9A3  1  C9 0D                   cmp #$0d                ;if block number was within 0-$c range,
00A9A5  1  90 02                   bcc BlockCode           ;branch to use current number
00A9A7  1  E9 06                   sbc #$06                ;otherwise subtract 6 for second set to get proper number
00A9A9  1  20 69 8C     BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
00A9AC  1               
00A9AC  1  C6 A9              .word MushFlowerBlock
00A9AE  1  CC A9              .word PoisonMushBlock
00A9B0  1  2E A7              .word CoinBlock
00A9B2  1  2E A7              .word CoinBlock
00A9B4  1  CF A9              .word ExtraLifeMushBlock
00A9B6  1  CC A9              .word PoisonMushBlock
00A9B8  1  C6 A9              .word MushFlowerBlock
00A9BA  1  C6 A9              .word MushFlowerBlock
00A9BC  1  CC A9              .word PoisonMushBlock
00A9BE  1  D6 A9              .word VineBlock
00A9C0  1  C9 A9              .word StarBlock
00A9C2  1  2E A7              .word CoinBlock
00A9C4  1  CF A9              .word ExtraLifeMushBlock
00A9C6  1               
00A9C6  1               MushFlowerBlock:
00A9C6  1  A9 00              lda #$00                ;load mushroom/flower type
00A9C8  1  2C                 .byte $2c
00A9C9  1               
00A9C9  1               StarBlock:
00A9C9  1  A9 02              lda #$02                ;load star type
00A9CB  1  2C                 .byte $2c
00A9CC  1               
00A9CC  1               PoisonMushBlock:
00A9CC  1  A9 04              lda #$04                ;load poison mushroom type
00A9CE  1  2C                 .byte $2c
00A9CF  1               
00A9CF  1               ExtraLifeMushBlock:
00A9CF  1  A9 03              lda #$03                ;load 1-up mushroom type
00A9D1  1  85 39              sta $39                 ;store correct power-up type
00A9D3  1  4C 2D A8           jmp SetupPowerUp
00A9D6  1               
00A9D6  1               VineBlock:
00A9D6  1  A2 05              ldx #$05                ;load last slot for enemy object buffer
00A9D8  1  AC EE 03           ldy SprDataOffset_Ctrl  ;get control bit
00A9DB  1  20 D5 A4           jsr Setup_Vine          ;set up vine object
00A9DE  1               
00A9DE  1               ExitBlockChk:
00A9DE  1  60                 rts                     ;leave
00A9DF  1               
00A9DF  1               ;--------------------------------
00A9DF  1               
00A9DF  1               BrickQBlockMetatiles:
00A9DF  1  C1 C2 C0 5E        .byte $c1, $c2, $c0, $5e, $5f, $60, $61 ;used by question blocks
00A9E3  1  5F 60 61     
00A9E6  1               
00A9E6  1  52 53 54 55        .byte $52, $53, $54, $55, $56, $57 ;used by ground level bricks
00A9EA  1  56 57        
00A9EC  1  58 59 5A 5B        .byte $58, $59, $5a, $5b, $5c, $5d ;used by other level bricks
00A9F0  1  5C 5D        
00A9F2  1               
00A9F2  1               BlockBumpedChk:
00A9F2  1  A0 12                     ldy #$12                    ;start at end of metatile data
00A9F4  1  D9 DF A9     BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
00A9F7  1  F0 04                     beq MatchBump               ;metatile found in block buffer, branch if so
00A9F9  1  88                        dey                         ;otherwise move onto next metatile
00A9FA  1  10 F8                     bpl BumpChkLoop             ;do this until all metatiles are checked
00A9FC  1  18                        clc                         ;if none match, return with carry clear
00A9FD  1  60           MatchBump:   rts                         ;note carry is set if found match
00A9FE  1               
00A9FE  1               ;--------------------------------
00A9FE  1               
00A9FE  1               BrickShatter:
00A9FE  1  20 1B AA           jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
00AA01  1  A9 01              lda #Sfx_BrickShatter
00AA03  1  9D EC 03           sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
00AA06  1  85 FD              sta NoiseSoundQueue    ;load brick shatter sound
00AA08  1  20 3D AA           jsr SpawnBrickChunks   ;create brick chunk objects
00AA0B  1  A9 FE              lda #$fe
00AA0D  1  85 9F              sta Player_Y_Speed     ;set vertical speed for player
00AA0F  1  A9 05              lda #$05
00AA11  1  8D 39 01           sta DigitModifier+5    ;set digit modifier to give player 50 points
00AA14  1  20 13 A8           jsr AddToScore         ;do sub to update the score
00AA17  1  AE EE 03           ldx SprDataOffset_Ctrl ;load control bit and leave
00AA1A  1  60                 rts
00AA1B  1               
00AA1B  1               ;--------------------------------
00AA1B  1               
00AA1B  1               CheckTopOfBlock:
00AA1B  1  AE EE 03            ldx SprDataOffset_Ctrl  ;load control bit
00AA1E  1  A4 02               ldy $02                 ;get vertical high nybble offset used in block buffer
00AA20  1  F0 1A               beq TopEx               ;branch to leave if set to zero, because we're at the top
00AA22  1  98                  tya                     ;otherwise set to A
00AA23  1  38                  sec
00AA24  1  E9 10               sbc #$10                ;subtract $10 to move up one row in the block buffer
00AA26  1  85 02               sta $02                 ;store as new vertical high nybble offset
00AA28  1  A8                  tay
00AA29  1  B1 06               lda ($06),y             ;get contents of block buffer in same column, one row up
00AA2B  1  C9 C3               cmp #$c3                ;is it a coin? (not underwater)
00AA2D  1  D0 0D               bne TopEx               ;if not, branch to leave
00AA2F  1  A9 00               lda #$00
00AA31  1  91 06               sta ($06),y             ;otherwise put blank metatile where coin was
00AA33  1  20 02 89            jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
00AA36  1  AE EE 03            ldx SprDataOffset_Ctrl  ;get control bit
00AA39  1  20 47 A7            jsr SetupJumpCoin       ;create jumping coin object and update coin variables
00AA3C  1  60           TopEx: rts                     ;leave!
00AA3D  1               
00AA3D  1               ;--------------------------------
00AA3D  1               
00AA3D  1               SpawnBrickChunks:
00AA3D  1  B5 8F              lda Block_X_Position,x     ;set horizontal coordinate of block object
00AA3F  1  9D F1 03           sta Block_Orig_XPos,x      ;as original horizontal coordinate here
00AA42  1  A9 F0              lda #$f0
00AA44  1  95 60              sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
00AA46  1  95 62              sta Block_X_Speed+2,x
00AA48  1  A9 FA              lda #$fa
00AA4A  1  95 A8              sta Block_Y_Speed,x        ;set vertical speed for one
00AA4C  1  A9 FC              lda #$fc
00AA4E  1  95 AA              sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
00AA50  1  A9 00              lda #$00
00AA52  1  9D 3C 04           sta Block_Y_MoveForce,x    ;init fractional movement force for both
00AA55  1  9D 3E 04           sta Block_Y_MoveForce+2,x
00AA58  1  B5 76              lda Block_PageLoc,x
00AA5A  1  95 78              sta Block_PageLoc+2,x      ;copy page location
00AA5C  1  B5 8F              lda Block_X_Position,x
00AA5E  1  95 91              sta Block_X_Position+2,x   ;copy horizontal coordinate
00AA60  1  B5 D7              lda Block_Y_Position,x
00AA62  1  18                 clc                        ;add 8 pixels to vertical coordinate
00AA63  1  69 08              adc #$08                   ;and save as vertical coordinate for one of them
00AA65  1  95 D9              sta Block_Y_Position+2,x
00AA67  1  A9 FA              lda #$fa
00AA69  1  95 A8              sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
00AA6B  1  60                 rts
00AA6C  1               
00AA6C  1               ;-------------------------------------------------------------------------------------
00AA6C  1               
00AA6C  1               BlockObjectsCore:
00AA6C  1  B5 26                lda Block_State,x           ;get state of block object
00AA6E  1  F0 5D                beq UpdSte                  ;if not set, branch to leave
00AA70  1  29 0F                and #$0f                    ;mask out high nybble
00AA72  1  48                   pha                         ;push to stack
00AA73  1  A8                   tay                         ;put in Y for now
00AA74  1  8A                   txa
00AA75  1  18                   clc
00AA76  1  69 09                adc #$09                    ;add 9 bytes to offset (note two block objects are created
00AA78  1  AA                   tax                         ;when using brick chunks, but only one offset for both)
00AA79  1  88                   dey                         ;decrement Y to check for solid block state
00AA7A  1  F0 33                beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
00AA7C  1  20 A0 AB             jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
00AA7F  1  20 0B AB             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00AA82  1  8A                   txa
00AA83  1  18                   clc                         ;move onto next block object
00AA84  1  69 02                adc #$02
00AA86  1  AA                   tax
00AA87  1  20 A0 AB             jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
00AA8A  1  20 0B AB             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00AA8D  1  A6 08                ldx ObjectOffset            ;get block object offset used for both
00AA8F  1  20 23 DE             jsr RelativeBlockPosition   ;get relative coordinates
00AA92  1  20 80 DE             jsr GetBlockOffscreenBits   ;get offscreen information
00AA95  1  20 13 D9             jsr DrawBrickChunks         ;draw the brick chunks
00AA98  1  68                   pla                         ;get lower nybble of saved state
00AA99  1  B4 BE                ldy Block_Y_HighPos,x       ;check vertical high byte of block object
00AA9B  1  F0 30                beq UpdSte                  ;if above the screen, branch to kill it
00AA9D  1  48                   pha                         ;otherwise save state back into stack
00AA9E  1  A9 F0                lda #$f0
00AAA0  1  D5 D9                cmp Block_Y_Position+2,x    ;check to see if bottom block object went
00AAA2  1  B0 02                bcs ChkTop                  ;to the bottom of the screen, and branch if not
00AAA4  1  95 D9                sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
00AAA6  1  B5 D7        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
00AAA8  1  C9 F0                cmp #$f0                    ;see if it went to the bottom of the screen
00AAAA  1  68                   pla                         ;pull block object state from stack
00AAAB  1  90 20                bcc UpdSte                  ;if not, branch to save state
00AAAD  1  B0 1C                bcs KillBlock               ;otherwise do unconditional branch to kill it
00AAAF  1               
00AAAF  1               BouncingBlockHandler:
00AAAF  1  20 A0 AB                jsr ImposeGravityBlock     ;do sub to impose gravity on block object
00AAB2  1  A6 08                   ldx ObjectOffset           ;get block object offset
00AAB4  1  20 23 DE                jsr RelativeBlockPosition  ;get relative coordinates
00AAB7  1  20 80 DE                jsr GetBlockOffscreenBits  ;get offscreen information
00AABA  1  20 91 D8                jsr DrawBlock              ;draw the block
00AABD  1  B5 D7                   lda Block_Y_Position,x     ;get vertical coordinate
00AABF  1  29 0F                   and #$0f                   ;mask out high nybble
00AAC1  1  C9 05                   cmp #$05                   ;check to see if low nybble wrapped around
00AAC3  1  68                      pla                        ;pull state from stack
00AAC4  1  B0 07                   bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
00AAC6  1  A9 01                   lda #$01
00AAC8  1  9D EC 03                sta Block_RepFlag,x        ;otherwise set flag to replace metatile
00AACB  1  A9 00        KillBlock: lda #$00                   ;if branched here, nullify object state
00AACD  1  95 26        UpdSte:    sta Block_State,x          ;store contents of A in block object state
00AACF  1  60                      rts
00AAD0  1               
00AAD0  1               ;-------------------------------------------------------------------------------------
00AAD0  1               ;$02 - used to store offset to block buffer
00AAD0  1               ;$06-$07 - used to store block buffer address
00AAD0  1               
00AAD0  1               BlockObjMT_Updater:
00AAD0  1  A2 01                    ldx #$01                  ;set offset to start with second block object
00AAD2  1  86 08        UpdateLoop: stx ObjectOffset          ;set offset here
00AAD4  1  AD 01 03                 lda VRAM_Buffer1          ;if vram buffer already being used here,
00AAD7  1  D0 21                    bne NextBUpd              ;branch to move onto next block object
00AAD9  1  BD EC 03                 lda Block_RepFlag,x       ;if flag for block object already clear,
00AADC  1  F0 1C                    beq NextBUpd              ;branch to move onto next block object
00AADE  1  BD E6 03                 lda Block_BBuf_Low,x      ;get low byte of block buffer
00AAE1  1  85 06                    sta $06                   ;store into block buffer address
00AAE3  1  A9 05                    lda #$05
00AAE5  1  85 07                    sta $07                   ;set high byte of block buffer address
00AAE7  1  BD E4 03                 lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
00AAEA  1  85 02                    sta $02                   ;store here and use as offset to block buffer
00AAEC  1  A8                       tay
00AAED  1  BD E8 03                 lda Block_Metatile,x      ;get metatile to be written
00AAF0  1  91 06                    sta ($06),y               ;write it to the block buffer
00AAF2  1  20 16 89                 jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
00AAF5  1  A9 00                    lda #$00
00AAF7  1  9D EC 03                 sta Block_RepFlag,x       ;clear block object flag
00AAFA  1  CA           NextBUpd:   dex                       ;decrement block object offset
00AAFB  1  10 D5                    bpl UpdateLoop            ;do this until both block objects are dealt with
00AAFD  1  60                       rts                       ;then leave
00AAFE  1               
00AAFE  1               ;-------------------------------------------------------------------------------------
00AAFE  1               ;$00 - used to store high nybble of horizontal speed as adder
00AAFE  1               ;$01 - used to store low nybble of horizontal speed
00AAFE  1               ;$02 - used to store adder to page location
00AAFE  1               
00AAFE  1               MoveEnemyHorizontally:
00AAFE  1  E8                 inx                         ;increment offset for enemy offset
00AAFF  1  20 0B AB           jsr MoveObjectHorizontally  ;position object horizontally according to
00AB02  1  A6 08              ldx ObjectOffset            ;counters, return with saved value in A,
00AB04  1  60                 rts                         ;put enemy offset back in X and leave
00AB05  1               
00AB05  1               MovePlayerHorizontally:
00AB05  1  AD 0E 07           lda JumpspringAnimCtrl  ;if jumpspring currently animating,
00AB08  1  D0 3E              bne ExXMove             ;branch to leave
00AB0A  1  AA                 tax                     ;otherwise set zero for offset to use player's stuff
00AB0B  1               
00AB0B  1               MoveObjectHorizontally:
00AB0B  1  B5 57                  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
00AB0D  1  0A                     asl                         ;speed, secondary counter, whatever)
00AB0E  1  0A                     asl                         ;and move low nybble to high
00AB0F  1  0A                     asl
00AB10  1  0A                     asl
00AB11  1  85 01                  sta $01                     ;store result here
00AB13  1  B5 57                  lda SprObject_X_Speed,x     ;get saved value again
00AB15  1  4A                     lsr                         ;move high nybble to low
00AB16  1  4A                     lsr
00AB17  1  4A                     lsr
00AB18  1  4A                     lsr
00AB19  1  C9 08                  cmp #$08                    ;if < 8, branch, do not change
00AB1B  1  90 02                  bcc SaveXSpd
00AB1D  1  09 F0                  ora #%11110000              ;otherwise alter high nybble
00AB1F  1  85 00        SaveXSpd: sta $00                     ;save result here
00AB21  1  A0 00                  ldy #$00                    ;load default Y value here
00AB23  1  C9 00                  cmp #$00                    ;if result positive, leave Y alone
00AB25  1  10 01                  bpl UseAdder
00AB27  1  88                     dey                         ;otherwise decrement Y
00AB28  1  84 02        UseAdder: sty $02                     ;save Y here
00AB2A  1  BD 00 04               lda SprObject_X_MoveForce,x ;get whatever number's here
00AB2D  1  18                     clc
00AB2E  1  65 01                  adc $01                     ;add low nybble moved to high
00AB30  1  9D 00 04               sta SprObject_X_MoveForce,x ;store result here
00AB33  1  A9 00                  lda #$00                    ;init A
00AB35  1  2A                     rol                         ;rotate carry into d0
00AB36  1  48                     pha                         ;push onto stack
00AB37  1  6A                     ror                         ;rotate d0 back onto carry
00AB38  1  B5 86                  lda SprObject_X_Position,x
00AB3A  1  65 00                  adc $00                     ;add carry plus saved value (high nybble moved to low
00AB3C  1  95 86                  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
00AB3E  1  B5 6D                  lda SprObject_PageLoc,x
00AB40  1  65 02                  adc $02                     ;add carry plus other saved value to the
00AB42  1  95 6D                  sta SprObject_PageLoc,x     ;object's page location and save
00AB44  1  68                     pla
00AB45  1  18                     clc                         ;pull old carry from stack and add
00AB46  1  65 00                  adc $00                     ;to high nybble moved to low
00AB48  1  60           ExXMove:  rts                         ;and leave
00AB49  1               
00AB49  1               ;-------------------------------------------------------------------------------------
00AB49  1               ;$00 - used for downward force
00AB49  1               ;$01 - used for upward force
00AB49  1               ;$02 - used for maximum vertical speed
00AB49  1               
00AB49  1               MovePlayerVertically:
00AB49  1  A2 00                 ldx #$00                ;set X for player offset
00AB4B  1  AD 47 07              lda TimerControl
00AB4E  1  D0 05                 bne NoJSChk             ;if master timer control set, branch ahead
00AB50  1  AD 0E 07              lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
00AB53  1  D0 F3                 bne ExXMove             ;branch to leave if so
00AB55  1  AD 09 07     NoJSChk: lda VerticalForce       ;dump vertical force
00AB58  1  85 00                 sta $00
00AB5A  1  A9 04                 lda #$04                ;set maximum vertical speed here
00AB5C  1  4C A9 AB              jmp ImposeGravitySprObj ;then jump to move player vertically
00AB5F  1               
00AB5F  1               ;--------------------------------
00AB5F  1               
00AB5F  1               MoveD_EnemyVertically:
00AB5F  1  A0 3D              ldy #$3d           ;set quick movement amount downwards
00AB61  1  B5 1E              lda Enemy_State,x  ;then check enemy state
00AB63  1  C9 05              cmp #$05           ;if not set to unique state for spiny's egg, go ahead
00AB65  1  D0 02              bne ContVMove      ;and use, otherwise set different movement amount, continue on
00AB67  1               
00AB67  1               MoveFallingPlatform:
00AB67  1  A0 20                   ldy #$20       ;set movement amount
00AB69  1  4C 90 AB     ContVMove: jmp SetHiMax   ;jump to skip the rest of this
00AB6C  1               
00AB6C  1               ;--------------------------------
00AB6C  1               
00AB6C  1               MoveRedPTroopaDown:
00AB6C  1  A0 00              ldy #$00            ;set Y to move downwards
00AB6E  1  4C 73 AB           jmp MoveRedPTroopa  ;skip to movement routine
00AB71  1               
00AB71  1               MoveRedPTroopaUp:
00AB71  1  A0 01              ldy #$01            ;set Y to move upwards
00AB73  1               
00AB73  1               MoveRedPTroopa:
00AB73  1  E8                 inx                 ;increment X for enemy offset
00AB74  1  A9 03              lda #$03
00AB76  1  85 00              sta $00             ;set downward movement amount here
00AB78  1  A9 06              lda #$06
00AB7A  1  85 01              sta $01             ;set upward movement amount here
00AB7C  1  A9 02              lda #$02
00AB7E  1  85 02              sta $02             ;set maximum speed here
00AB80  1  98                 tya                 ;set movement direction in A, and
00AB81  1  4C CD AB           jmp RedPTroopaGrav  ;jump to move this thing
00AB84  1               
00AB84  1               ;--------------------------------
00AB84  1               
00AB84  1               MoveDropPlatform:
00AB84  1  A0 7F              ldy #$7f      ;set movement amount for drop platform
00AB86  1  D0 02              bne SetMdMax  ;skip ahead of other value set here
00AB88  1               
00AB88  1               MoveEnemySlowVert:
00AB88  1  A0 0F                  ldy #$0f         ;set movement amount for bowser/other objects
00AB8A  1  A9 02        SetMdMax: lda #$02         ;set maximum speed in A
00AB8C  1  D0 04                  bne SetXMoveAmt  ;unconditional branch
00AB8E  1               
00AB8E  1               ;--------------------------------
00AB8E  1               
00AB8E  1               MoveJ_EnemyVertically:
00AB8E  1  A0 1C                     ldy #$1c                ;set movement amount for podoboo/other objects
00AB90  1  A9 03        SetHiMax:    lda #$03                ;set maximum speed in A
00AB92  1  84 00        SetXMoveAmt: sty $00                 ;set movement amount here
00AB94  1  E8                        inx                     ;increment X for enemy offset
00AB95  1  20 A9 AB                  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
00AB98  1  A6 08                     ldx ObjectOffset        ;get enemy object buffer offset and leave
00AB9A  1  60                        rts
00AB9B  1               
00AB9B  1               ;--------------------------------
00AB9B  1               
00AB9B  1               MaxSpdBlockData:
00AB9B  1  06 08              .byte $06, $08
00AB9D  1               
00AB9D  1               ResidualGravityCode:
00AB9D  1  A0 00              ldy #$00       ;this part appears to be residual,
00AB9F  1  2C                 .byte $2c        ;no code branches or jumps to it...
00ABA0  1               
00ABA0  1               ImposeGravityBlock:
00ABA0  1  A0 01              ldy #$01       ;set offset for maximum speed
00ABA2  1  A9 50              lda #$50       ;set movement amount here
00ABA4  1  85 00              sta $00
00ABA6  1  B9 9B AB           lda MaxSpdBlockData,y    ;get maximum speed
00ABA9  1               
00ABA9  1               ImposeGravitySprObj:
00ABA9  1  85 02              sta $02            ;set maximum speed here
00ABAB  1  A9 00              lda #$00           ;set value to move downwards
00ABAD  1  4C D3 AB           jmp ImposeGravity  ;jump to the code that actually moves it
00ABB0  1               
00ABB0  1               ;--------------------------------
00ABB0  1               
00ABB0  1               MovePlatformDown:
00ABB0  1  A9 00              lda #$00    ;save value to stack (if branching here, execute next
00ABB2  1  2C                 .byte $2c     ;part as BIT instruction)
00ABB3  1               
00ABB3  1               MovePlatformUp:
00ABB3  1  A9 01                   lda #$01        ;save value to stack
00ABB5  1  48                      pha
00ABB6  1  B4 16                   ldy Enemy_ID,x  ;get enemy object identifier
00ABB8  1  E8                      inx             ;increment offset for enemy object
00ABB9  1  A9 05                   lda #$05        ;load default value here
00ABBB  1  C0 29                   cpy #$29        ;residual comparison, object #29 never executes
00ABBD  1  D0 02                   bne SetDplSpd   ;this code, thus unconditional branch here
00ABBF  1  A9 09                   lda #$09        ;residual code
00ABC1  1  85 00        SetDplSpd: sta $00         ;save downward movement amount here
00ABC3  1  A9 0A                   lda #$0a        ;save upward movement amount here
00ABC5  1  85 01                   sta $01
00ABC7  1  A9 03                   lda #$03        ;save maximum vertical speed here
00ABC9  1  85 02                   sta $02
00ABCB  1  68                      pla             ;get value from stack
00ABCC  1  A8                      tay             ;use as Y, then move onto code shared by red koopa
00ABCD  1               
00ABCD  1               RedPTroopaGrav:
00ABCD  1  20 D3 AB           jsr ImposeGravity  ;do a sub to move object gradually
00ABD0  1  A6 08              ldx ObjectOffset   ;get enemy object offset and leave
00ABD2  1  60                 rts
00ABD3  1               
00ABD3  1               ;-------------------------------------------------------------------------------------
00ABD3  1               ;$00 - used for downward force
00ABD3  1               ;$01 - used for upward force
00ABD3  1               ;$07 - used as adder for vertical position
00ABD3  1               
00ABD3  1               ImposeGravity:
00ABD3  1  48                    pha                          ;push value to stack
00ABD4  1  BD 16 04              lda SprObject_YMF_Dummy,x
00ABD7  1  18                    clc                          ;add value in movement force to contents of dummy variable
00ABD8  1  7D 33 04              adc SprObject_Y_MoveForce,x
00ABDB  1  9D 16 04              sta SprObject_YMF_Dummy,x
00ABDE  1  A0 00                 ldy #$00                     ;set Y to zero by default
00ABE0  1  B5 9F                 lda SprObject_Y_Speed,x      ;get current vertical speed
00ABE2  1  10 01                 bpl AlterYP                  ;if currently moving downwards, do not decrement Y
00ABE4  1  88                    dey                          ;otherwise decrement Y
00ABE5  1  84 07        AlterYP: sty $07                      ;store Y here
00ABE7  1  75 CE                 adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
00ABE9  1  95 CE                 sta SprObject_Y_Position,x   ;store as new vertical position
00ABEB  1  B5 B5                 lda SprObject_Y_HighPos,x
00ABED  1  65 07                 adc $07                      ;add carry plus contents of $07 to vertical high byte
00ABEF  1  95 B5                 sta SprObject_Y_HighPos,x    ;store as new vertical high byte
00ABF1  1  BD 33 04              lda SprObject_Y_MoveForce,x
00ABF4  1  18                    clc
00ABF5  1  65 00                 adc $00                      ;add downward movement amount to contents of $0433
00ABF7  1  9D 33 04              sta SprObject_Y_MoveForce,x
00ABFA  1  B5 9F                 lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
00ABFC  1  69 00                 adc #$00
00ABFE  1  95 9F                 sta SprObject_Y_Speed,x
00AC00  1  C5 02                 cmp $02                      ;compare to maximum speed
00AC02  1  30 10                 bmi ChkUpM                   ;if less than preset value, skip this part
00AC04  1  BD 33 04              lda SprObject_Y_MoveForce,x
00AC07  1  C9 80                 cmp #$80                     ;if less positively than preset maximum, skip this part
00AC09  1  90 09                 bcc ChkUpM
00AC0B  1  A5 02                 lda $02
00AC0D  1  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00AC0F  1  A9 00                 lda #$00
00AC11  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00AC14  1  68           ChkUpM:  pla                          ;get value from stack
00AC15  1  F0 2B                 beq ExVMove                  ;if set to zero, branch to leave
00AC17  1  A5 02                 lda $02
00AC19  1  49 FF                 eor #%11111111               ;otherwise get two's compliment of maximum speed
00AC1B  1  A8                    tay
00AC1C  1  C8                    iny
00AC1D  1  84 07                 sty $07                      ;store two's compliment here
00AC1F  1  BD 33 04              lda SprObject_Y_MoveForce,x
00AC22  1  38                    sec                          ;subtract upward movement amount from contents
00AC23  1  E5 01                 sbc $01                      ;of movement force, note that $01 is twice as large as $00,
00AC25  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
00AC28  1  B5 9F                 lda SprObject_Y_Speed,x
00AC2A  1  E9 00                 sbc #$00                     ;subtract borrow from vertical speed and store
00AC2C  1  95 9F                 sta SprObject_Y_Speed,x
00AC2E  1  C5 07                 cmp $07                      ;compare vertical speed to two's compliment
00AC30  1  10 10                 bpl ExVMove                  ;if less negatively than preset maximum, skip this part
00AC32  1  BD 33 04              lda SprObject_Y_MoveForce,x
00AC35  1  C9 80                 cmp #$80                     ;check if fractional part is above certain amount,
00AC37  1  B0 09                 bcs ExVMove                  ;and if so, branch to leave
00AC39  1  A5 07                 lda $07
00AC3B  1  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00AC3D  1  A9 FF                 lda #$ff
00AC3F  1  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00AC42  1  60           ExVMove: rts                          ;leave!
00AC43  1               
00AC43  1               ;-------------------------------------------------------------------------------------
00AC43  1               
00AC43  1               EnemiesAndLoopsCore:
00AC43  1  B5 0F                    lda Enemy_Flag,x         ;check data here for MSB set
00AC45  1  48                       pha                      ;save in stack
00AC46  1  0A                       asl
00AC47  1  B0 12                    bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
00AC49  1  68                       pla                      ;get from stack
00AC4A  1  F0 03                    beq ChkAreaTsk           ;if data zero, branch
00AC4C  1  4C B3 B4                 jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
00AC4F  1  AD 1F 07     ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
00AC52  1  29 07                    and #$07
00AC54  1  C9 07                    cmp #$07                 ;if at a specific task, jump and leave
00AC56  1  F0 0E                    beq ExitELCore
00AC58  1  4C D7 AC                 jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
00AC5B  1  68           ChkBowserF: pla                      ;get data from stack
00AC5C  1  29 0F                    and #%00001111           ;mask out high nybble
00AC5E  1  A8                       tay
00AC5F  1  B9 0F 00                 lda Enemy_Flag,y         ;use as pointer and load same place with different offset
00AC62  1  D0 02                    bne ExitELCore
00AC64  1  95 0F                    sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
00AC66  1  60           ExitELCore: rts
00AC67  1               
00AC67  1               ;-------------------------------------------------------------------------------------
00AC67  1               
00AC67  1               ;loop command data
00AC67  1               ;note that some data is never used (it may have been
00AC67  1               ;used at one point, but the area data that ref'd it
00AC67  1               ;is now missing the loop command object)
00AC67  1               
00AC67  1               LoopCmdWorldNumber:
00AC67  1  02 02 02 02    .byte $02, $02, $02, $02, $05, $05, $05, $05, $06, $07, $07, $04
00AC6B  1  05 05 05 05  
00AC6F  1  06 07 07 04  
00AC73  1               
00AC73  1               LoopCmdPageNumber:
00AC73  1  03 05 08 09    .byte $03, $05, $08, $09, $03, $06, $07, $0a, $05, $05, $0b, $05
00AC77  1  03 06 07 0A  
00AC7B  1  05 05 0B 05  
00AC7F  1               
00AC7F  1               LoopCmdYPosition:
00AC7F  1  B0 B0 40 30    .byte $b0, $b0, $40, $30, $b0, $30, $b0, $b0, $f0, $f0, $b0, $f0
00AC83  1  B0 30 B0 B0  
00AC87  1  F0 F0 B0 F0  
00AC8B  1               
00AC8B  1               MultiLoopCount:
00AC8B  1  02 02 02 02    .byte $02, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01
00AC8F  1  02 02 02 02  
00AC93  1  01 01 01 01  
00AC97  1               
00AC97  1               ExecGameLoopback:
00AC97  1  A5 6D              lda Player_PageLoc        ;send player back four pages
00AC99  1  38                 sec
00AC9A  1  E9 04              sbc #$04
00AC9C  1  85 6D              sta Player_PageLoc
00AC9E  1  AD 25 07           lda CurrentPageLoc        ;send current page back four pages
00ACA1  1  38                 sec
00ACA2  1  E9 04              sbc #$04
00ACA4  1  8D 25 07           sta CurrentPageLoc
00ACA7  1  AD 1A 07           lda ScreenLeft_PageLoc    ;subtract four from page location
00ACAA  1  38                 sec                       ;of screen's left border
00ACAB  1  E9 04              sbc #$04
00ACAD  1  8D 1A 07           sta ScreenLeft_PageLoc
00ACB0  1  AD 1B 07           lda ScreenRight_PageLoc   ;do the same for the page location
00ACB3  1  38                 sec                       ;of screen's right border
00ACB4  1  E9 04              sbc #$04
00ACB6  1  8D 1B 07           sta ScreenRight_PageLoc
00ACB9  1  AD 2A 07           lda AreaObjectPageLoc     ;subtract four from page control
00ACBC  1  38                 sec                       ;for area objects
00ACBD  1  E9 04              sbc #$04
00ACBF  1  8D 2A 07           sta AreaObjectPageLoc
00ACC2  1  A9 00              lda #$00                  ;initialize page select for both
00ACC4  1  8D 3B 07           sta EnemyObjectPageSel    ;area and enemy objects
00ACC7  1  8D 2B 07           sta AreaObjectPageSel
00ACCA  1  8D 39 07           sta EnemyDataOffset       ;initialize enemy object data offset
00ACCD  1  8D 3A 07           sta EnemyObjectPageLoc    ;and enemy object page control
00ACD0  1  B9 DE E0           lda AreaDataOfsLoopback,y ;adjust area object offset based on
00ACD3  1  8D 2C 07           sta AreaDataOffset        ;which loop command we encountered
00ACD6  1  60                 rts
00ACD7  1               
00ACD7  1               ProcLoopCommand:
00ACD7  1  AD 45 07               lda LoopCommand           ;check if loop command was found
00ACDA  1  F0 50                  beq ChkEnemyFrenzy
00ACDC  1  AD 26 07               lda CurrentColumnPos      ;check to see if we're still on the first page
00ACDF  1  D0 4B                  bne ChkEnemyFrenzy        ;if not, do not loop yet
00ACE1  1  A0 0C                  ldy #$0c                  ;start at the end of each set of loop data
00ACE3  1  88           FindLoop: dey
00ACE4  1  30 46                  bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
00ACE6  1  AD 5F 07               lda WorldNumber           ;check to see if one of the world numbers
00ACE9  1  D9 67 AC               cmp LoopCmdWorldNumber,y  ;matches our current world number
00ACEC  1  D0 F5                  bne FindLoop
00ACEE  1  AD 25 07               lda CurrentPageLoc        ;check to see if one of the page numbers
00ACF1  1  D9 73 AC               cmp LoopCmdPageNumber,y   ;matches the page we're currently on
00ACF4  1  D0 ED                  bne FindLoop
00ACF6  1  A5 CE                  lda Player_Y_Position     ;check to see if the player is at the correct position
00ACF8  1  D9 7F AC               cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
00ACFB  1  D0 09                  bne WrongChk
00ACFD  1  A5 1D                  lda Player_State          ;check to see if the player is
00ACFF  1  C9 00                  cmp #$00                  ;on solid ground (i.e. not jumping or falling)
00AD01  1  D0 03                  bne WrongChk              ;if not, player fails to pass loop, and loopback
00AD03  1  EE D9 06               inc MultiLoopCorrectCntr  ;increment counter for correct progression
00AD06  1  EE DA 06     WrongChk: inc MultiLoopPassCntr     ;increment master multi-part counter
00AD09  1  AD DA 06               lda MultiLoopPassCntr     ;have we done all parts?
00AD0C  1  D9 8B AC               cmp MultiLoopCount,y
00AD0F  1  D0 16                  bne InitLCmd              ;if not, skip this part
00AD11  1  AD D9 06               lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
00AD14  1  D9 8B AC               cmp MultiLoopCount,y
00AD17  1  F0 06                  beq InitMLp               ;if so, branch past unnecessary check here
00AD19  1  20 97 AC               jsr ExecGameLoopback      ;if player is not in right place, loop back
00AD1C  1  20 A2 BC               jsr KillAllEnemies
00AD1F  1  A9 00        InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
00AD21  1  8D DA 06               sta MultiLoopPassCntr
00AD24  1  8D D9 06               sta MultiLoopCorrectCntr
00AD27  1  A9 00        InitLCmd: lda #$00                  ;initialize loop command flag
00AD29  1  8D 45 07               sta LoopCommand
00AD2C  1               
00AD2C  1               ;--------------------------------
00AD2C  1               
00AD2C  1               ChkEnemyFrenzy:
00AD2C  1  AD CD 06           lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
00AD2F  1  F0 10              beq ProcessEnemyData  ;if not, skip this part
00AD31  1  95 16              sta Enemy_ID,x        ;store as enemy object identifier here
00AD33  1  A9 01              lda #$01
00AD35  1  95 0F              sta Enemy_Flag,x      ;activate enemy object flag
00AD37  1  A9 00              lda #$00
00AD39  1  95 1E              sta Enemy_State,x     ;initialize state and frenzy queue
00AD3B  1  8D CD 06           sta EnemyFrenzyQueue
00AD3E  1  4C 23 AE           jmp InitEnemyObject   ;and then jump to deal with this enemy
00AD41  1               
00AD41  1               ;--------------------------------
00AD41  1               ;$06 - used to hold page location of extended right boundary
00AD41  1               ;$07 - used to hold high nybble of position of extended right boundary
00AD41  1               
00AD41  1               ProcessEnemyData:
00AD41  1  AC 39 07             ldy EnemyDataOffset      ;get offset of enemy object data
00AD44  1  B1 E9                lda (EnemyData),y        ;load first byte
00AD46  1  C9 FF                cmp #$ff                 ;check for EOD terminator
00AD48  1  D0 03                bne CheckEndofBuffer
00AD4A  1  4C 13 AE             jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
00AD4D  1               
00AD4D  1               CheckEndofBuffer:
00AD4D  1  29 0F                and #%00001111           ;check for special row $0e
00AD4F  1  C9 0E                cmp #$0e
00AD51  1  F0 0E                beq CheckRightBounds     ;if found, branch, otherwise
00AD53  1  E0 05                cpx #$05                 ;check for end of buffer
00AD55  1  90 0A                bcc CheckRightBounds     ;if not at end of buffer, branch
00AD57  1  C8                   iny
00AD58  1  B1 E9                lda (EnemyData),y        ;check for specific value here
00AD5A  1  29 3F                and #%00111111           ;not sure what this was intended for, exactly
00AD5C  1  C9 2E                cmp #$2e                 ;this part is quite possibly residual code
00AD5E  1  F0 01                beq CheckRightBounds     ;but it has the effect of keeping enemies out of
00AD60  1  60                   rts                      ;the sixth slot
00AD61  1               
00AD61  1               CheckRightBounds:
00AD61  1  AD 1D 07             lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
00AD64  1  18                   clc
00AD65  1  69 30                adc #$30
00AD67  1  29 F0                and #%11110000           ;store high nybble
00AD69  1  85 07                sta $07
00AD6B  1  AD 1B 07             lda ScreenRight_PageLoc  ;add carry to page location of right boundary
00AD6E  1  69 00                adc #$00
00AD70  1  85 06                sta $06                  ;store page location + carry
00AD72  1  AC 39 07             ldy EnemyDataOffset
00AD75  1  C8                   iny
00AD76  1  B1 E9                lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
00AD78  1  0A                   asl
00AD79  1  90 0B                bcc CheckPageCtrlRow
00AD7B  1  AD 3B 07             lda EnemyObjectPageSel   ;if page select already set, do not set again
00AD7E  1  D0 06                bne CheckPageCtrlRow
00AD80  1  EE 3B 07             inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
00AD83  1  EE 3A 07             inc EnemyObjectPageLoc   ;and increment page control
00AD86  1               
00AD86  1               CheckPageCtrlRow:
00AD86  1  88                   dey
00AD87  1  B1 E9                lda (EnemyData),y        ;reread first byte
00AD89  1  29 0F                and #$0f
00AD8B  1  C9 0F                cmp #$0f                 ;check for special row $0f
00AD8D  1  D0 19                bne PositionEnemyObj     ;if not found, branch to position enemy object
00AD8F  1  AD 3B 07             lda EnemyObjectPageSel   ;if page select set,
00AD92  1  D0 14                bne PositionEnemyObj     ;branch without reading second byte
00AD94  1  C8                   iny
00AD95  1  B1 E9                lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
00AD97  1  29 3F                and #%00111111
00AD99  1  8D 3A 07             sta EnemyObjectPageLoc   ;store as page control for enemy object data
00AD9C  1  EE 39 07             inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
00AD9F  1  EE 39 07             inc EnemyDataOffset
00ADA2  1  EE 3B 07             inc EnemyObjectPageSel   ;set page select for enemy object data and
00ADA5  1  4C D7 AC             jmp ProcLoopCommand      ;jump back to process loop commands again
00ADA8  1               
00ADA8  1               PositionEnemyObj:
00ADA8  1  AD 3A 07             lda EnemyObjectPageLoc   ;store page control as page location
00ADAB  1  95 6E                sta Enemy_PageLoc,x      ;for enemy object
00ADAD  1  B1 E9                lda (EnemyData),y        ;get first byte of enemy object
00ADAF  1  29 F0                and #%11110000
00ADB1  1  95 87                sta Enemy_X_Position,x   ;store column position
00ADB3  1  CD 1D 07             cmp ScreenRight_X_Pos    ;check column position against right boundary
00ADB6  1  B5 6E                lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
00ADB8  1  ED 1B 07             sbc ScreenRight_PageLoc  ;from page location
00ADBB  1  B0 0B                bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
00ADBD  1  B1 E9                lda (EnemyData),y
00ADBF  1  29 0F                and #%00001111           ;check for special row $0e
00ADC1  1  C9 0E                cmp #$0e                 ;if found, jump elsewhere
00ADC3  1  F0 69                beq ParseRow0e
00ADC5  1  4C 54 AE             jmp CheckThreeBytes      ;if not found, unconditional jump
00ADC8  1               
00ADC8  1               CheckRightExtBounds:
00ADC8  1  A5 07                lda $07                  ;check right boundary + 48 against
00ADCA  1  D5 87                cmp Enemy_X_Position,x   ;column position without subtracting,
00ADCC  1  A5 06                lda $06                  ;then subtract borrow from page control temp
00ADCE  1  F5 6E                sbc Enemy_PageLoc,x      ;plus carry
00ADD0  1  90 41                bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
00ADD2  1  A9 01                lda #$01                 ;store value in vertical high byte
00ADD4  1  95 B6                sta Enemy_Y_HighPos,x
00ADD6  1  B1 E9                lda (EnemyData),y        ;get first byte again
00ADD8  1  0A                   asl                      ;multiply by four to get the vertical
00ADD9  1  0A                   asl                      ;coordinate
00ADDA  1  0A                   asl
00ADDB  1  0A                   asl
00ADDC  1  95 CF                sta Enemy_Y_Position,x
00ADDE  1  C9 E0                cmp #$e0                 ;do one last check for special row $0e
00ADE0  1  F0 4C                beq ParseRow0e           ;(necessary if branched to $c1cb)
00ADE2  1  C8                   iny
00ADE3  1  B1 E9                lda (EnemyData),y        ;get second byte of object
00ADE5  1  29 40                and #%01000000           ;check to see if hard mode bit is set
00ADE7  1  F0 05                beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
00ADE9  1  AD CC 06             lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
00ADEC  1  F0 74                beq Inc2B                ;is on, and if not, branch to skip this object completely
00ADEE  1               
00ADEE  1               CheckForEnemyGroup:
00ADEE  1  B1 E9                lda (EnemyData),y      ;get second byte and mask out 2 MSB
00ADF0  1  29 3F                and #%00111111
00ADF2  1  C9 37                cmp #$37               ;check for value below $37
00ADF4  1  90 04                bcc BuzzyBeetleMutate
00ADF6  1  C9 3F                cmp #$3f               ;if $37 or greater, check for value
00ADF8  1  90 31                bcc DoGroup            ;below $3f, branch if below $3f
00ADFA  1               
00ADFA  1               BuzzyBeetleMutate:
00ADFA  1  C9 06                cmp #Goomba          ;if below $37, check for goomba
00ADFC  1  D0 07                bne StrID            ;value ($3f or more always fails)
00ADFE  1  AC 6A 07             ldy PrimaryHardMode  ;check if primary hard mode flag is set
00AE01  1  F0 02                beq StrID            ;and if so, change goomba to buzzy beetle
00AE03  1  A9 02                lda #BuzzyBeetle
00AE05  1  95 16        StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
00AE07  1  A9 01                lda #$01
00AE09  1  95 0F                sta Enemy_Flag,x     ;set flag for enemy in buffer
00AE0B  1  20 23 AE             jsr InitEnemyObject
00AE0E  1  B5 0F                lda Enemy_Flag,x     ;check to see if flag is set
00AE10  1  D0 50                bne Inc2B            ;if not, leave, otherwise branch
00AE12  1  60                   rts
00AE13  1               
00AE13  1               CheckFrenzyBuffer:
00AE13  1  AD CB 06             lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
00AE16  1  D0 09                bne StrFre               ;then branch ahead to store in enemy object buffer
00AE18  1  AD 98 03             lda VineFlagOffset       ;otherwise check vine flag offset
00AE1B  1  C9 01                cmp #$01
00AE1D  1  D0 0B                bne ExEPar               ;if other value <> 1, leave
00AE1F  1  A9 2F                lda #VineObject          ;otherwise put vine in enemy identifier
00AE21  1  95 16        StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
00AE23  1               
00AE23  1               InitEnemyObject:
00AE23  1  A9 00                lda #$00                 ;initialize enemy state
00AE25  1  95 1E                sta Enemy_State,x
00AE27  1  20 70 AE             jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
00AE2A  1  60           ExEPar: rts                      ;then leave
00AE2B  1               
00AE2B  1               DoGroup:
00AE2B  1  4C 4C B3             jmp HandleGroupEnemies   ;handle enemy group objects
00AE2E  1               
00AE2E  1               ParseRow0e:
00AE2E  1  C8                   iny                      ;increment Y to load third byte of object
00AE2F  1  C8                   iny
00AE30  1  AD 5F 07             lda WorldNumber
00AE33  1  C9 08                cmp #World9              ;skip world number check if on world 9
00AE35  1  F0 0C                beq W9Skip
00AE37  1  B1 E9                lda (EnemyData),y
00AE39  1  4A                   lsr                      ;move 3 MSB to the bottom, effectively
00AE3A  1  4A                   lsr                      ;making %xxx00000 into %00000xxx
00AE3B  1  4A                   lsr
00AE3C  1  4A                   lsr
00AE3D  1  4A                   lsr
00AE3E  1  CD 5F 07             cmp WorldNumber          ;is it the same world number as we're on?
00AE41  1  D0 0E                bne NotUse               ;if not, do not use (this allows multiple uses
00AE43  1  88           W9Skip: dey                      ;of the same area, like the underground bonus areas)
00AE44  1  B1 E9                lda (EnemyData),y        ;otherwise, get second byte and use as offset
00AE46  1  8D 50 07             sta AreaPointer          ;to addresses for level and enemy object data
00AE49  1  C8                   iny
00AE4A  1  B1 E9                lda (EnemyData),y        ;get third byte again, and this time mask out
00AE4C  1  29 1F                and #%00011111           ;the 3 MSB from before, save as page number to be
00AE4E  1  8D 51 07             sta EntrancePage         ;used upon entry to area, if area is entered
00AE51  1  4C 5F AE     NotUse: jmp Inc3B
00AE54  1               
00AE54  1               CheckThreeBytes:
00AE54  1  AC 39 07             ldy EnemyDataOffset      ;load current offset for enemy object data
00AE57  1  B1 E9                lda (EnemyData),y        ;get first byte
00AE59  1  29 0F                and #%00001111           ;check for special row $0e
00AE5B  1  C9 0E                cmp #$0e
00AE5D  1  D0 03                bne Inc2B
00AE5F  1  EE 39 07     Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
00AE62  1  EE 39 07     Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
00AE65  1  EE 39 07             inc EnemyDataOffset
00AE68  1  A9 00                lda #$00                 ;init page select for enemy objects
00AE6A  1  8D 3B 07             sta EnemyObjectPageSel
00AE6D  1  A6 08                ldx ObjectOffset         ;reload current offset in enemy buffers
00AE6F  1  60                   rts                      ;and leave
00AE70  1               
00AE70  1               CheckpointEnemyID:
00AE70  1  B5 16                lda Enemy_ID,x
00AE72  1  C9 15                cmp #$15                     ;check enemy object identifier for $15 or greater
00AE74  1  B0 0D                bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
00AE76  1  A8                   tay                          ;save identifier in Y register for now
00AE77  1  B5 CF                lda Enemy_Y_Position,x
00AE79  1  69 08                adc #$08                     ;add eight pixels to what will eventually be the
00AE7B  1  95 CF                sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
00AE7D  1  A9 01                lda #$01
00AE7F  1  9D D8 03             sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
00AE82  1  98                   tya                          ;get identifier back and use as offset for jump engine
00AE83  1               
00AE83  1               InitEnemyRoutines:
00AE83  1  20 69 8C             jsr JumpEngine
00AE86  1               
00AE86  1  12 AF                .word InitNormalEnemy
00AE88  1  12 AF                .word InitNormalEnemy
00AE8A  1  12 AF                .word InitNormalEnemy
00AE8C  1  22 AF                .word InitRedKoopa
00AE8E  1  B8 B3                .word InitPiranhaPlant
00AE90  1  2C AF                .word InitHammerBro
00AE92  1  F5 AE                .word InitGoomba
00AE94  1  4D AF                .word InitBloober
00AE96  1  76 AF                .word InitBulletBill
00AE98  1  F4 AE                .word NoInitCode
00AE9A  1  80 AF                .word InitCheepCheep
00AE9C  1  80 AF                .word InitCheepCheep
00AE9E  1  FB AE                .word InitPodoboo
00AEA0  1  B8 B3                .word InitPiranhaPlant
00AEA2  1  02 B4                .word InitJumpGPTroopa
00AEA4  1  55 AF                .word InitRedPTroopa
00AEA6  1               
00AEA6  1  48 AF                .word InitHorizFlySwimEnemy
00AEA8  1  90 AF                .word InitLakitu
00AEAA  1  D1 B3                .word InitEnemyFrenzy
00AEAC  1  F4 AE                .word NoInitCode
00AEAE  1  D1 B3                .word InitEnemyFrenzy
00AEB0  1  D1 B3                .word InitEnemyFrenzy
00AEB2  1  D1 B3                .word InitEnemyFrenzy
00AEB4  1  D1 B3                .word InitEnemyFrenzy
00AEB6  1  E9 B3                .word EndFrenzy
00AEB8  1  F4 AE                .word NoInitCode
00AEBA  1  F4 AE                .word NoInitCode
00AEBC  1  75 B0                .word InitShortFirebar
00AEBE  1  75 B0                .word InitShortFirebar
00AEC0  1  75 B0                .word InitShortFirebar
00AEC2  1  75 B0                .word InitShortFirebar
00AEC4  1  72 B0                .word InitLongFirebar
00AEC6  1               
00AEC6  1  F4 AE                .word NoInitCode
00AEC8  1  F4 AE                .word NoInitCode
00AECA  1  F4 AE                .word NoInitCode
00AECC  1  F4 AE                .word NoInitCode
00AECE  1  10 B4                .word InitBalPlatform
00AED0  1  43 B4                .word InitVertPlatform
00AED2  1  70 B4                .word LargeLiftUp
00AED4  1  76 B4                .word LargeLiftDown
00AED6  1  3C B4                .word InitHoriPlatform
00AED8  1  34 B4                .word InitDropPlatform
00AEDA  1  3C B4                .word InitHoriPlatform
00AEDC  1  7C B4                .word PlatLiftUp
00AEDE  1  88 B4                .word PlatLiftDown
00AEE0  1  62 B1                .word InitBowser
00AEE2  1  44 A8                .word PwrUpJmp
00AEE4  1  D5 A4                .word Setup_Vine
00AEE6  1               
00AEE6  1  F4 AE                .word NoInitCode
00AEE8  1  F4 AE                .word NoInitCode
00AEEA  1  F4 AE                .word NoInitCode
00AEEC  1  F4 AE                .word NoInitCode
00AEEE  1  F4 AE                .word NoInitCode
00AEF0  1  0B AF                .word InitRetainerObj
00AEF2  1  B2 B4                .word EndOfEnemyInitCode
00AEF4  1               
00AEF4  1               NoInitCode:
00AEF4  1  60                   rts
00AEF5  1               
00AEF5  1               InitGoomba:
00AEF5  1  20 12 AF           jsr InitNormalEnemy  ;set appropriate horizontal speed
00AEF8  1  4C 51 AF           jmp SmallBBox        ;set $09 as bounding box control, set other values
00AEFB  1               
00AEFB  1               InitPodoboo:
00AEFB  1  A9 02              lda #$02                  ;set enemy position to below
00AEFD  1  95 B6              sta Enemy_Y_HighPos,x     ;the bottom of the screen
00AEFF  1  95 CF              sta Enemy_Y_Position,x
00AF01  1  4A                 lsr
00AF02  1  9D 96 07           sta EnemyIntervalTimer,x  ;set timer for enemy
00AF05  1  4A                 lsr
00AF06  1  95 1E              sta Enemy_State,x         ;initialize enemy state, then jump to use
00AF08  1  4C 51 AF           jmp SmallBBox             ;$09 as bounding box size and set other things
00AF0B  1               
00AF0B  1               InitRetainerObj:
00AF0B  1  A9 B8              lda #$b8                ;set fixed vertical position for
00AF0D  1  95 CF              sta Enemy_Y_Position,x  ;princess/mushroom retainer object
00AF0F  1  60                 rts
00AF10  1               
00AF10  1               NormalXSpdData:
00AF10  1  F8 F4              .byte $f8, $f4
00AF12  1               
00AF12  1               InitNormalEnemy:
00AF12  1  A0 01                 ldy #$01              ;load offset of 1 by default
00AF14  1  AD 6A 07              lda PrimaryHardMode   ;check for primary hard mode flag set
00AF17  1  D0 01                 bne GetESpd
00AF19  1  88                    dey                   ;if not set, decrement offset
00AF1A  1  B9 10 AF     GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
00AF1D  1  95 58        SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
00AF1F  1  4C 65 AF              jmp TallBBox          ;branch to set bounding box control and other data
00AF22  1               
00AF22  1               InitRedKoopa:
00AF22  1  20 12 AF           jsr InitNormalEnemy   ;load appropriate horizontal speed
00AF25  1  A9 01              lda #$01              ;set enemy state for red koopa troopa $03
00AF27  1  95 1E              sta Enemy_State,x
00AF29  1  60                 rts
00AF2A  1               
00AF2A  1               HBroWalkingTimerData:
00AF2A  1  80 50              .byte $80, $50
00AF2C  1               
00AF2C  1               InitHammerBro:
00AF2C  1  A9 00               lda #$00                    ;init horizontal speed and timer used by hammer bro
00AF2E  1  9D A2 03            sta HammerThrowingTimer,x   ;apparently to time hammer throwing
00AF31  1  95 58               sta Enemy_X_Speed,x
00AF33  1  AD 5F 07            lda WorldNumber             ;if on worlds 7-9, branch to skip the walk delay
00AF36  1  C9 06               cmp #World7
00AF38  1  B0 09               bcs NoHBI
00AF3A  1  AC CC 06            ldy SecondaryHardMode       ;get secondary hard mode flag
00AF3D  1  B9 2A AF            lda HBroWalkingTimerData,y
00AF40  1  9D 96 07            sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
00AF43  1  A9 0B        NoHBI: lda #$0b                    ;set specific value for bounding box size control
00AF45  1  4C 67 AF            jmp SetBBox
00AF48  1               
00AF48  1               ;--------------------------------
00AF48  1               
00AF48  1               InitHorizFlySwimEnemy:
00AF48  1  A9 00              lda #$00        ;initialize horizontal speed
00AF4A  1  4C 1D AF           jmp SetESpd
00AF4D  1               
00AF4D  1               ;--------------------------------
00AF4D  1               
00AF4D  1               InitBloober:
00AF4D  1  A9 00                   lda #$00               ;initialize horizontal speed
00AF4F  1  95 58                   sta BlooperMoveSpeed,x
00AF51  1  A9 09        SmallBBox: lda #$09               ;set specific bounding box size control
00AF53  1  D0 12                   bne SetBBox            ;unconditional branch
00AF55  1               
00AF55  1               InitRedPTroopa:
00AF55  1  A0 30                  ldy #$30                    ;load central position adder for 48 pixels down
00AF57  1  B5 CF                  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
00AF59  1  9D 01 04               sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
00AF5C  1  10 02                  bpl GetCent                 ;if vertical coordinate < $80
00AF5E  1  A0 E0                  ldy #$e0                    ;if => $80, load position adder for 32 pixels up
00AF60  1  98           GetCent:  tya                         ;send central position adder to A
00AF61  1  75 CF                  adc Enemy_Y_Position,x      ;add to current vertical coordinate
00AF63  1  95 58                  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
00AF65  1  A9 03        TallBBox: lda #$03                    ;set specific bounding box size control
00AF67  1  9D 9A 04     SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
00AF6A  1  A9 02                  lda #$02                    ;set moving direction for left
00AF6C  1  95 46                  sta Enemy_MovingDir,x
00AF6E  1  A9 00        InitVStf: lda #$00                    ;initialize vertical speed
00AF70  1  95 A0                  sta Enemy_Y_Speed,x         ;and movement force
00AF72  1  9D 34 04               sta Enemy_Y_MoveForce,x
00AF75  1  60                     rts
00AF76  1               
00AF76  1               InitBulletBill:
00AF76  1  A9 02              lda #$02                  ;set moving direction for left
00AF78  1  95 46              sta Enemy_MovingDir,x
00AF7A  1  A9 09              lda #$09                  ;set bounding box control for $09
00AF7C  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00AF7F  1  60                 rts
00AF80  1               
00AF80  1               InitCheepCheep:
00AF80  1  20 51 AF           jsr SmallBBox              ;set vertical bounding box, speed, init others
00AF83  1  BD A7 07           lda PseudoRandomBitReg,x   ;check one portion of LSFR
00AF86  1  29 10              and #%00010000             ;get d4 from it
00AF88  1  95 58              sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
00AF8A  1  B5 CF              lda Enemy_Y_Position,x
00AF8C  1  9D 34 04           sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
00AF8F  1  60                 rts
00AF90  1               
00AF90  1               InitLakitu:
00AF90  1  AD CB 06           lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
00AF93  1  D0 0B              bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
00AF95  1               
00AF95  1               SetupLakitu:
00AF95  1  A9 00              lda #$00                   ;erase counter for lakitu's reappearance
00AF97  1  8D D1 06           sta LakituReappearTimer
00AF9A  1  20 48 AF           jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
00AF9D  1  4C 0A B4           jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
00AFA0  1               
00AFA0  1               KillLakitu:
00AFA0  1  4C C9 B5           jmp EraseEnemyObject
00AFA3  1               
00AFA3  1               ;--------------------------------
00AFA3  1               ;$01-$03 - used to hold pseudorandom difference adjusters
00AFA3  1               
00AFA3  1               PRDiffAdjustData:
00AFA3  1  26 2C 32 38        .byte $26, $2c, $32, $38
00AFA7  1  20 22 24 26        .byte $20, $22, $24, $26
00AFAB  1  13 14 15 16        .byte $13, $14, $15, $16
00AFAF  1               
00AFAF  1               LakituAndSpinyHandler:
00AFAF  1  AD 8F 07               lda FrenzyEnemyTimer    ;if timer here not expired, leave
00AFB2  1  D0 4A                  bne ExLSHand
00AFB4  1  E0 05                  cpx #$05                ;if we are on the special use slot, leave
00AFB6  1  B0 46                  bcs ExLSHand
00AFB8  1  A9 80                  lda #$80                ;set timer
00AFBA  1  8D 8F 07               sta FrenzyEnemyTimer
00AFBD  1  A0 04                  ldy #$04                ;start with the last enemy slot
00AFBF  1  B9 16 00     ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
00AFC2  1  C9 11                  cmp #Lakitu             ;if lakitu is on one of them
00AFC4  1  F0 39                  beq CreateSpiny         ;if so, branch out of this loop
00AFC6  1  88                     dey                     ;otherwise check another slot
00AFC7  1  10 F6                  bpl ChkLak              ;loop until all slots are checked
00AFC9  1  EE D1 06               inc LakituReappearTimer ;increment reappearance timer
00AFCC  1  AD D1 06               lda LakituReappearTimer
00AFCF  1  C9 03                  cmp #$03                ;check to see if we're up to a certain value yet
00AFD1  1  90 2B                  bcc ExLSHand            ;if not, leave
00AFD3  1  A2 04                  ldx #$04                ;start with the last enemy slot again
00AFD5  1  B5 0F        ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
00AFD7  1  F0 05                  beq CreateL             ;branch out of loop if found
00AFD9  1  CA                     dex                     ;otherwise check next slot
00AFDA  1  10 F9                  bpl ChkNoEn             ;branch until all slots are checked
00AFDC  1  30 1E                  bmi RetEOfs             ;if no empty slots were found, branch to leave
00AFDE  1  A9 00        CreateL:  lda #$00                ;initialize enemy state
00AFE0  1  95 1E                  sta Enemy_State,x
00AFE2  1  A9 11                  lda #Lakitu             ;create lakitu enemy object
00AFE4  1  95 16                  sta Enemy_ID,x
00AFE6  1  20 95 AF               jsr SetupLakitu         ;do a sub to set up lakitu
00AFE9  1  A9 20                  lda #$20
00AFEB  1  AC FB 07               ldy HardWorldFlag
00AFEE  1  D0 07                  bne SetLowLY            ;if in worlds A-D, put lakitu lower on the screen
00AFF0  1  AC 5F 07               ldy WorldNumber
00AFF3  1  C0 06                  cpy #$06                ;if in worlds 1-6, branch to use default high position
00AFF5  1  90 02                  bcc SetLakXY            ;otherwise put lakitu lower on the screen
00AFF7  1  A9 60        SetLowLY: lda #$60
00AFF9  1  20 09 B2     SetLakXY: jsr PutAtRightExtent    ;finish setting up lakitu
00AFFC  1  A6 08        RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
00AFFE  1  60           ExLSHand: rts
00AFFF  1               
00AFFF  1               CreateSpiny:
00AFFF  1  A5 CE                  lda Player_Y_Position      ;if player above a certain point, branch to leave
00B001  1  C9 2C                  cmp #$2c
00B003  1  90 F9                  bcc ExLSHand
00B005  1  B9 1E 00               lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
00B008  1  D0 F4                  bne ExLSHand
00B00A  1  B9 6E 00               lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
00B00D  1  95 6E                  sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
00B00F  1  B9 87 00               lda Enemy_X_Position,y
00B012  1  95 87                  sta Enemy_X_Position,x
00B014  1  A9 01                  lda #$01                   ;put spiny within vertical screen unit
00B016  1  95 B6                  sta Enemy_Y_HighPos,x
00B018  1  B9 CF 00               lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
00B01B  1  38                     sec
00B01C  1  E9 08                  sbc #$08
00B01E  1  95 CF                  sta Enemy_Y_Position,x
00B020  1  BD A7 07               lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
00B023  1  29 03                  and #%00000011
00B025  1  A8                     tay
00B026  1  A2 02                  ldx #$02
00B028  1  B9 A3 AF     DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
00B02B  1  95 01                  sta $01,x                  ;to $01-$03
00B02D  1  C8                     iny
00B02E  1  C8                     iny                        ;increment Y four bytes for each value
00B02F  1  C8                     iny
00B030  1  C8                     iny
00B031  1  CA                     dex                        ;decrement X for each one
00B032  1  10 F4                  bpl DifLoop                ;loop until all three are written
00B034  1  A6 08                  ldx ObjectOffset           ;get enemy object buffer offset
00B036  1  20 9D BB               jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
00B039  1  A4 57                  ldy Player_X_Speed         ;check player's horizontal speed
00B03B  1  C0 08                  cpy #$08
00B03D  1  B0 0E                  bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
00B03F  1  A8                     tay                        ;otherwise save value in A to Y for now
00B040  1  BD A8 07               lda PseudoRandomBitReg+1,x
00B043  1  29 03                  and #%00000011             ;get one of the LSFR parts and save the 2 LSB
00B045  1  F0 05                  beq UsePosv                ;branch if neither bits are set
00B047  1  98                     tya
00B048  1  49 FF                  eor #%11111111             ;otherwise get two's compliment of Y
00B04A  1  A8                     tay
00B04B  1  C8                     iny
00B04C  1  98           UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
00B04D  1  20 51 AF     SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
00B050  1  A0 02                  ldy #$02                   ;(putting this call elsewhere will preserve A)
00B052  1  95 58                  sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
00B054  1  C9 00                  cmp #$00                   ;of A were lost...branch here will never be taken for
00B056  1  30 01                  bmi SpinyRte               ;the same reason
00B058  1  88                     dey
00B059  1  94 46        SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
00B05B  1  A9 FD                  lda #$fd
00B05D  1  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
00B05F  1  A9 01                  lda #$01
00B061  1  95 0F                  sta Enemy_Flag,x           ;enable enemy object by setting flag
00B063  1  A9 05                  lda #$05
00B065  1  95 1E                  sta Enemy_State,x          ;put spiny in egg state and leave
00B067  1  60           ChpChpEx: rts
00B068  1               
00B068  1               ;--------------------------------
00B068  1               
00B068  1               FirebarSpinSpdData:
00B068  1  28 38 28 38        .byte $28, $38, $28, $38, $28
00B06C  1  28           
00B06D  1               
00B06D  1               FirebarSpinDirData:
00B06D  1  00 00 10 10        .byte $00, $00, $10, $10, $00
00B071  1  00           
00B072  1               
00B072  1               InitLongFirebar:
00B072  1  20 A6 B1           jsr DuplicateEnemyObj       ;create enemy object for long firebar
00B075  1               
00B075  1               InitShortFirebar:
00B075  1  A9 00              lda #$00                    ;initialize low byte of spin state
00B077  1  95 58              sta FirebarSpinState_Low,x
00B079  1  B5 16              lda Enemy_ID,x              ;subtract $1b from enemy identifier
00B07B  1  38                 sec                         ;to get proper offset for firebar data
00B07C  1  E9 1B              sbc #$1b
00B07E  1  A8                 tay
00B07F  1  B9 68 B0           lda FirebarSpinSpdData,y    ;get spinning speed of firebar
00B082  1  9D 88 03           sta FirebarSpinSpeed,x
00B085  1  B9 6D B0           lda FirebarSpinDirData,y    ;get spinning direction of firebar
00B088  1  95 34              sta FirebarSpinDirection,x
00B08A  1  B5 CF              lda Enemy_Y_Position,x
00B08C  1  18                 clc                         ;add four pixels to vertical coordinate
00B08D  1  69 04              adc #$04
00B08F  1  95 CF              sta Enemy_Y_Position,x
00B091  1  B5 87              lda Enemy_X_Position,x
00B093  1  18                 clc                         ;add four pixels to horizontal coordinate
00B094  1  69 04              adc #$04
00B096  1  95 87              sta Enemy_X_Position,x
00B098  1  B5 6E              lda Enemy_PageLoc,x
00B09A  1  69 00              adc #$00                    ;add carry to page location
00B09C  1  95 6E              sta Enemy_PageLoc,x
00B09E  1  4C 0A B4           jmp TallBBox2               ;set bounding box control (not used) and leave
00B0A1  1               
00B0A1  1               ;--------------------------------
00B0A1  1               ;$00-$01 - used to hold pseudorandom bits
00B0A1  1               
00B0A1  1               FlyCCXPositionData:
00B0A1  1  80 30 40 80        .byte $80, $30, $40, $80
00B0A5  1  30 50 50 70        .byte $30, $50, $50, $70
00B0A9  1  20 40 80 A0        .byte $20, $40, $80, $a0
00B0AD  1  70 40 90 68        .byte $70, $40, $90, $68
00B0B1  1               
00B0B1  1               FlyCCXSpeedData:
00B0B1  1  0E 05 06 0E        .byte $0e, $05, $06, $0e
00B0B5  1  1C 20 10 0C        .byte $1c, $20, $10, $0c
00B0B9  1  1E 22 18 14        .byte $1e, $22, $18, $14
00B0BD  1               
00B0BD  1               FlyCCTimerData:
00B0BD  1  10 60 20 48        .byte $10, $60, $20, $48
00B0C1  1               
00B0C1  1               InitFlyingCheepCheep:
00B0C1  1  AD 8F 07              lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
00B0C4  1  D0 A1                 bne ChpChpEx
00B0C6  1  20 51 AF              jsr SmallBBox              ;jump to set bounding box size $09 and init other values
00B0C9  1  BD A8 07              lda PseudoRandomBitReg+1,x
00B0CC  1  29 03                 and #%00000011             ;set pseudorandom offset here
00B0CE  1  A8                    tay
00B0CF  1  B9 BD B0              lda FlyCCTimerData,y       ;load timer with pseudorandom offset
00B0D2  1  8D 8F 07              sta FrenzyEnemyTimer
00B0D5  1  A0 03                 ldy #$03                   ;load Y with default value
00B0D7  1  AD CC 06              lda SecondaryHardMode
00B0DA  1  F0 01                 beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
00B0DC  1  C8                    iny                        ;otherwise, increment Y to allow as many as four onscreen
00B0DD  1  84 00        MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
00B0DF  1  E4 00                 cpx $00                    ;compare enemy object buffer offset with Y
00B0E1  1  B0 84                 bcs ChpChpEx               ;if X => Y, branch to leave
00B0E3  1  BD A7 07              lda PseudoRandomBitReg,x
00B0E6  1  29 03                 and #%00000011             ;get last two bits of LSFR, first part
00B0E8  1  85 00                 sta $00                    ;and store in two places
00B0EA  1  85 01                 sta $01
00B0EC  1  A9 FB                 lda #$fb                   ;set vertical speed for cheep-cheep
00B0EE  1  95 A0                 sta Enemy_Y_Speed,x
00B0F0  1  A9 00                 lda #$00                   ;load default value
00B0F2  1  A4 57                 ldy Player_X_Speed         ;check player's horizontal speed
00B0F4  1  F0 07                 beq GSeed                  ;if player not moving left or right, skip this part
00B0F6  1  A9 04                 lda #$04
00B0F8  1  C0 19                 cpy #$19                   ;if moving to the right but not very quickly,
00B0FA  1  90 01                 bcc GSeed                  ;do not change A
00B0FC  1  0A                    asl                        ;otherwise, multiply A by 2
00B0FD  1  48           GSeed:   pha                        ;save to stack
00B0FE  1  18                    clc
00B0FF  1  65 00                 adc $00                    ;add to last two bits of LSFR we saved earlier
00B101  1  85 00                 sta $00                    ;save it there
00B103  1  BD A8 07              lda PseudoRandomBitReg+1,x
00B106  1  29 03                 and #%00000011             ;if neither of the last two bits of second LSFR set,
00B108  1  F0 07                 beq RSeed                  ;skip this part and save contents of $00
00B10A  1  BD A9 07              lda PseudoRandomBitReg+2,x
00B10D  1  29 0F                 and #%00001111             ;otherwise overwrite with lower nybble of
00B10F  1  85 00                 sta $00                    ;third LSFR part
00B111  1  68           RSeed:   pla                        ;get value from stack we saved earlier
00B112  1  18                    clc
00B113  1  65 01                 adc $01                    ;add to last two bits of LSFR we saved in other place
00B115  1  A8                    tay                        ;use as pseudorandom offset here
00B116  1  B9 B1 B0              lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
00B119  1  95 58                 sta Enemy_X_Speed,x
00B11B  1  A9 01                 lda #$01                   ;set to move towards the right
00B11D  1  95 46                 sta Enemy_MovingDir,x
00B11F  1  A5 57                 lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
00B121  1  D0 12                 bne D2XPos1
00B123  1  A4 00                 ldy $00                    ;get first LSFR or third LSFR lower nybble
00B125  1  98                    tya                        ;and check for d1 set
00B126  1  29 02                 and #%00000010
00B128  1  F0 0B                 beq D2XPos1                ;if d1 not set, branch
00B12A  1  B5 58                 lda Enemy_X_Speed,x
00B12C  1  49 FF                 eor #$ff                   ;if d1 set, change horizontal speed
00B12E  1  18                    clc                        ;into two's compliment, thus moving in the opposite
00B12F  1  69 01                 adc #$01                   ;direction
00B131  1  95 58                 sta Enemy_X_Speed,x
00B133  1  F6 46                 inc Enemy_MovingDir,x      ;increment to move towards the left
00B135  1  98           D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
00B136  1  29 02                 and #%00000010
00B138  1  F0 0F                 beq D2XPos2                ;check for d1 set again, branch again if not set
00B13A  1  A5 86                 lda Player_X_Position      ;get player's horizontal position
00B13C  1  18                    clc
00B13D  1  79 A1 B0              adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
00B140  1  95 87                 sta Enemy_X_Position,x     ;and save as enemy's horizontal position
00B142  1  A5 6D                 lda Player_PageLoc         ;get player's page location
00B144  1  69 00                 adc #$00                   ;add carry and jump past this part
00B146  1  4C 55 B1              jmp FinCCSt
00B149  1  A5 86        D2XPos2: lda Player_X_Position      ;get player's horizontal position
00B14B  1  38                    sec
00B14C  1  F9 A1 B0              sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
00B14F  1  95 87                 sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
00B151  1  A5 6D                 lda Player_PageLoc         ;get player's page location
00B153  1  E9 00                 sbc #$00                   ;subtract borrow
00B155  1  95 6E        FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
00B157  1  A9 01                 lda #$01
00B159  1  95 0F                 sta Enemy_Flag,x           ;set enemy's buffer flag
00B15B  1  95 B6                 sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
00B15D  1  A9 F8                 lda #$f8
00B15F  1  95 CF                 sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
00B161  1  60                    rts
00B162  1               
00B162  1               InitBowser:
00B162  1  A0 04                  ldy #$04              ;if the slot about to be checked is the slot
00B164  1  C4 08        KKCheck:  cpy ObjectOffset      ;where bowser is being initialized, skip it
00B166  1  F0 0F                  beq NoBowser
00B168  1  B9 16 00               lda Enemy_ID,y        ;otherwise check to see if a bowser object
00B16B  1  C9 2D                  cmp #Bowser           ;exists in another slot
00B16D  1  D0 08                  bne NoBowser          ;if not, branch to check another enemy slot
00B16F  1  A9 00                  lda #$00
00B171  1  99 16 00               sta Enemy_ID,y        ;do this until any previous bowser objects are erased
00B174  1  99 0F 00               sta Enemy_Flag,y
00B177  1  88           NoBowser: dey                   ;loop until all slots are checked
00B178  1  10 EA                  bpl KKCheck           ;except the slot where bowser is being initialized
00B17A  1               
00B17A  1               CreateBowser:
00B17A  1  20 A6 B1           jsr DuplicateEnemyObj     ;jump to create another bowser object
00B17D  1  8E 68 03           stx BowserFront_Offset    ;save offset of first here
00B180  1  A9 00              lda #$00
00B182  1  8D 63 03           sta BowserBodyControls    ;initialize bowser's body controls
00B185  1  8D 69 03           sta BridgeCollapseOffset  ;and bridge collapse offset
00B188  1  B5 87              lda Enemy_X_Position,x
00B18A  1  8D 66 03           sta BowserOrigXPos        ;store original horizontal position here
00B18D  1  A9 DF              lda #$df
00B18F  1  8D 90 07           sta BowserFireBreathTimer ;store something here
00B192  1  95 46              sta Enemy_MovingDir,x     ;and in moving direction
00B194  1  A9 20              lda #$20
00B196  1  8D 64 03           sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
00B199  1  9D 8A 07           sta EnemyFrameTimer,x
00B19C  1  A9 05              lda #$05
00B19E  1  8D 83 04           sta BowserHitPoints       ;give bowser 5 hit points
00B1A1  1  4A                 lsr
00B1A2  1  8D 65 03           sta BowserMovementSpeed   ;set default movement speed here
00B1A5  1  60                 rts
00B1A6  1               
00B1A6  1               DuplicateEnemyObj:
00B1A6  1  A0 FF                ldy #$ff                ;start at beginning of enemy slots
00B1A8  1  C8           FSLoop: iny                     ;increment one slot
00B1A9  1  B9 0F 00             lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
00B1AC  1  D0 FA                bne FSLoop              ;if set, branch and keep checking
00B1AE  1  8C CF 06             sty DuplicateObj_Offset ;otherwise set offset here
00B1B1  1  8A                   txa                     ;transfer original enemy buffer offset
00B1B2  1  09 80                ora #%10000000          ;store with d7 set as flag in new enemy
00B1B4  1  99 0F 00             sta Enemy_Flag,y        ;slot as well as enemy offset
00B1B7  1  B5 6E                lda Enemy_PageLoc,x
00B1B9  1  99 6E 00             sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
00B1BC  1  B5 87                lda Enemy_X_Position,x  ;from original enemy to new enemy
00B1BE  1  99 87 00             sta Enemy_X_Position,y
00B1C1  1  A9 01                lda #$01
00B1C3  1  95 0F                sta Enemy_Flag,x        ;set flag as normal for original enemy
00B1C5  1  99 B6 00             sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
00B1C8  1  B5 CF                lda Enemy_Y_Position,x
00B1CA  1  99 CF 00             sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
00B1CD  1  60           FlmEx:  rts                     ;and then leave
00B1CE  1               
00B1CE  1               ;--------------------------------
00B1CE  1               
00B1CE  1               FlameYPosData:
00B1CE  1  90 80 70 90        .byte $90, $80, $70, $90
00B1D2  1               
00B1D2  1               FlameYMFAdderData:
00B1D2  1  FF 01              .byte $ff, $01
00B1D4  1               
00B1D4  1               InitBowserFlame:
00B1D4  1  AD 8F 07             lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
00B1D7  1  D0 F4                bne FlmEx
00B1D9  1  9D 34 04             sta Enemy_Y_MoveForce,x     ;reset something here
00B1DC  1  A5 FD                lda NoiseSoundQueue
00B1DE  1  09 02                ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
00B1E0  1  85 FD                sta NoiseSoundQueue
00B1E2  1  AC 68 03             ldy BowserFront_Offset      ;get bowser's buffer offset
00B1E5  1  B9 16 00             lda Enemy_ID,y              ;check for bowser
00B1E8  1  C9 2D                cmp #Bowser
00B1EA  1  F0 31                beq SpawnFromMouth          ;branch if found
00B1EC  1  20 0A BE             jsr SetFlameTimer           ;get timer data based on flame counter
00B1EF  1  18                   clc
00B1F0  1  69 20                adc #$20                    ;add 32 frames by default
00B1F2  1  AC CC 06             ldy SecondaryHardMode
00B1F5  1  F0 03                beq SetFrT                  ;if secondary mode flag not set, use as timer setting
00B1F7  1  38                   sec
00B1F8  1  E9 10                sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
00B1FA  1  8D 8F 07     SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
00B1FD  1  BD A7 07             lda PseudoRandomBitReg,x
00B200  1  29 03                and #%00000011              ;get 2 LSB from first part of LSFR
00B202  1  9D 17 04             sta BowserFlamePRandomOfs,x ;set here
00B205  1  A8                   tay                         ;use as offset
00B206  1  B9 CE B1             lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
00B209  1               
00B209  1               PutAtRightExtent:
00B209  1  95 CF              sta Enemy_Y_Position,x    ;set vertical position
00B20B  1  AD 1D 07           lda ScreenRight_X_Pos
00B20E  1  18                 clc
00B20F  1  69 20              adc #$20                  ;place enemy 32 pixels beyond right side of screen
00B211  1  95 87              sta Enemy_X_Position,x
00B213  1  AD 1B 07           lda ScreenRight_PageLoc
00B216  1  69 00              adc #$00                  ;add carry
00B218  1  95 6E              sta Enemy_PageLoc,x
00B21A  1  4C 50 B2           jmp FinishFlame           ;skip this part to finish setting values
00B21D  1               
00B21D  1               SpawnFromMouth:
00B21D  1  B9 87 00            lda Enemy_X_Position,y    ;get bowser's horizontal position
00B220  1  38                  sec
00B221  1  E9 0E               sbc #$0e                  ;subtract 14 pixels
00B223  1  95 87               sta Enemy_X_Position,x    ;save as flame's horizontal position
00B225  1  B9 6E 00            lda Enemy_PageLoc,y
00B228  1  95 6E               sta Enemy_PageLoc,x       ;copy page location from bowser to flame
00B22A  1  B9 CF 00            lda Enemy_Y_Position,y
00B22D  1  18                  clc                       ;add 8 pixels to bowser's vertical position
00B22E  1  69 08               adc #$08
00B230  1  95 CF               sta Enemy_Y_Position,x    ;save as flame's vertical position
00B232  1  BD A7 07            lda PseudoRandomBitReg,x
00B235  1  29 03               and #%00000011            ;get 2 LSB from first part of LSFR
00B237  1  9D 17 04            sta Enemy_YMF_Dummy,x     ;save here
00B23A  1  A8                  tay                       ;use as offset
00B23B  1  B9 CE B1            lda FlameYPosData,y       ;get value here using bits as offset
00B23E  1  A0 00               ldy #$00                  ;load default offset
00B240  1  D5 CF               cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
00B242  1  90 01               bcc SetMF                 ;if less, do not increment offset
00B244  1  C8                  iny                       ;otherwise increment now
00B245  1  B9 D2 B1     SetMF: lda FlameYMFAdderData,y   ;get value here and save
00B248  1  9D 34 04            sta Enemy_Y_MoveForce,x   ;to vertical movement force
00B24B  1  A9 00               lda #$00
00B24D  1  8D CB 06            sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
00B250  1               
00B250  1               FinishFlame:
00B250  1  A9 08              lda #$08                 ;set $08 for bounding box control
00B252  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00B255  1  A9 01              lda #$01                 ;set high byte of vertical and
00B257  1  95 B6              sta Enemy_Y_HighPos,x    ;enemy buffer flag
00B259  1  95 0F              sta Enemy_Flag,x
00B25B  1  4A                 lsr
00B25C  1  9D 01 04           sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
00B25F  1  95 1E              sta Enemy_State,x        ;enemy state
00B261  1  60                 rts
00B262  1               
00B262  1               ;--------------------------------
00B262  1               
00B262  1               FireworksXPosData:
00B262  1  00 30 60 60        .byte $00, $30, $60, $60, $00, $20
00B266  1  00 20        
00B268  1               
00B268  1               FireworksYPosData:
00B268  1  60 40 70 40        .byte $60, $40, $70, $40, $60, $30
00B26C  1  60 30        
00B26E  1               
00B26E  1               InitFireworks:
00B26E  1  AD 8F 07               lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
00B271  1  D0 47                  bne ExitFWk
00B273  1  A9 20                  lda #$20                     ;otherwise reset timer
00B275  1  8D 8F 07               sta FrenzyEnemyTimer
00B278  1  CE D7 06               dec FireworksCounter         ;decrement for each explosion
00B27B  1  A0 06                  ldy #$06                     ;start at last slot
00B27D  1  88           StarFChk: dey
00B27E  1  B9 16 00               lda Enemy_ID,y               ;check for presence of star flag object
00B281  1  C9 31                  cmp #StarFlagObject          ;if there isn't a star flag object,
00B283  1  D0 F8                  bne StarFChk                 ;routine goes into infinite loop = crash
00B285  1  B9 87 00               lda Enemy_X_Position,y
00B288  1  38                     sec                          ;get horizontal coordinate of star flag object, then
00B289  1  E9 30                  sbc #$30                     ;subtract 48 pixels from it and save to
00B28B  1  48                     pha                          ;the stack
00B28C  1  B9 6E 00               lda Enemy_PageLoc,y
00B28F  1  E9 00                  sbc #$00                     ;subtract the carry from the page location
00B291  1  85 00                  sta $00                      ;of the star flag object
00B293  1  AD D7 06               lda FireworksCounter         ;get fireworks counter
00B296  1  18                     clc
00B297  1  79 1E 00               adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
00B29A  1  A8                     tay                          ;use as offset
00B29B  1  68                     pla                          ;get saved horizontal coordinate of star flag - 48 pixels
00B29C  1  18                     clc
00B29D  1  79 62 B2               adc FireworksXPosData,y      ;add number based on offset of fireworks counter
00B2A0  1  95 87                  sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
00B2A2  1  A5 00                  lda $00
00B2A4  1  69 00                  adc #$00                     ;add carry and store as page location for
00B2A6  1  95 6E                  sta Enemy_PageLoc,x          ;the fireworks object
00B2A8  1  B9 68 B2               lda FireworksYPosData,y      ;get vertical position using same offset
00B2AB  1  95 CF                  sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
00B2AD  1  A9 01                  lda #$01
00B2AF  1  95 B6                  sta Enemy_Y_HighPos,x        ;store in vertical high byte
00B2B1  1  95 0F                  sta Enemy_Flag,x             ;and activate enemy buffer flag
00B2B3  1  4A                     lsr
00B2B4  1  95 58                  sta ExplosionGfxCounter,x    ;initialize explosion counter
00B2B6  1  A9 08                  lda #$08
00B2B8  1  95 A0                  sta ExplosionTimerCounter,x  ;set explosion timing counter
00B2BA  1  60           ExitFWk:  rts
00B2BB  1               
00B2BB  1               ;--------------------------------
00B2BB  1               
00B2BB  1               Bitmasks:
00B2BB  1  01 02 04 08        .byte %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
00B2BF  1  10 20 40 80  
00B2C3  1               
00B2C3  1               Enemy17YPosData:
00B2C3  1  40 30 90 50        .byte $40, $30, $90, $50, $20, $60, $a0, $70
00B2C7  1  20 60 A0 70  
00B2CB  1               
00B2CB  1               SwimCC_IDData:
00B2CB  1  0A 0B              .byte $0a, $0b
00B2CD  1               
00B2CD  1               BulletBillCheepCheep:
00B2CD  1  AD 8F 07              lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
00B2D0  1  D0 6F                 bne ExF17
00B2D2  1  AD 4E 07              lda AreaType              ;are we in a water-type level?
00B2D5  1  D0 57                 bne DoBulletBills         ;if not, branch elsewhere
00B2D7  1  E0 03                 cpx #$03                  ;are we past third enemy slot?
00B2D9  1  B0 66                 bcs ExF17                 ;if so, branch to leave
00B2DB  1  A0 00                 ldy #$00                  ;load default offset
00B2DD  1  BD A7 07              lda PseudoRandomBitReg,x
00B2E0  1  C9 AA                 cmp #$aa                  ;check first part of LSFR against preset value
00B2E2  1  90 01                 bcc ChkW2                 ;if less than preset, do not increment offset
00B2E4  1  C8                    iny                       ;otherwise increment
00B2E5  1  AD 5F 07     ChkW2:   lda WorldNumber           ;check world number
00B2E8  1  C9 01                 cmp #World2
00B2EA  1  F0 01                 beq Get17ID               ;if we're on world 2, do not increment offset
00B2EC  1  C8                    iny                       ;otherwise increment
00B2ED  1  98           Get17ID: tya
00B2EE  1  29 01                 and #%00000001            ;mask out all but last bit of offset
00B2F0  1  A8                    tay
00B2F1  1  B9 CB B2              lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
00B2F4  1  95 16        Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
00B2F6  1  AD DD 06              lda BitMFilter
00B2F9  1  C9 FF                 cmp #$ff                  ;if not all bits set, skip init part and compare bits
00B2FB  1  D0 05                 bne GetRBit
00B2FD  1  A9 00                 lda #$00                  ;initialize vertical position filter
00B2FF  1  8D DD 06              sta BitMFilter
00B302  1  BD A7 07     GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
00B305  1  29 07                 and #%00000111            ;mask out all but 3 LSB
00B307  1  A8           ChkRBit: tay                       ;use as offset
00B308  1  B9 BB B2              lda Bitmasks,y            ;load bitmask
00B30B  1  2C DD 06              bit BitMFilter            ;perform AND on filter without changing it
00B30E  1  F0 07                 beq AddFBit
00B310  1  C8                    iny                       ;increment offset
00B311  1  98                    tya
00B312  1  29 07                 and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
00B314  1  4C 07 B3              jmp ChkRBit               ;do another check
00B317  1  0D DD 06     AddFBit: ora BitMFilter            ;add bit to already set bits in filter
00B31A  1  8D DD 06              sta BitMFilter            ;and store
00B31D  1  B9 C3 B2              lda Enemy17YPosData,y     ;load vertical position using offset
00B320  1  20 09 B2              jsr PutAtRightExtent      ;set vertical position and other values
00B323  1  9D 17 04              sta Enemy_YMF_Dummy,x     ;initialize dummy variable
00B326  1  A9 20                 lda #$20                  ;set timer
00B328  1  8D 8F 07              sta FrenzyEnemyTimer
00B32B  1  4C 70 AE              jmp CheckpointEnemyID     ;process our new enemy object
00B32E  1               
00B32E  1               DoBulletBills:
00B32E  1  A0 FF                  ldy #$ff                   ;start at beginning of enemy slots
00B330  1  C8           BB_SLoop: iny                        ;move onto the next slot
00B331  1  C0 05                  cpy #$05                   ;branch to play sound if we've done all slots
00B333  1  B0 0D                  bcs FireBulletBill
00B335  1  B9 0F 00               lda Enemy_Flag,y           ;if enemy buffer flag not set,
00B338  1  F0 F6                  beq BB_SLoop               ;loop back and check another slot
00B33A  1  B9 16 00               lda Enemy_ID,y
00B33D  1  C9 08                  cmp #BulletBill_FrenzyVar  ;check enemy identifier for
00B33F  1  D0 EF                  bne BB_SLoop               ;bullet bill object (frenzy variant)
00B341  1  60           ExF17:    rts                        ;if found, leave
00B342  1               
00B342  1               FireBulletBill:
00B342  1  A5 FE              lda Square2SoundQueue
00B344  1  09 08              ora #Sfx_Blast            ;play fireworks/gunfire sound
00B346  1  85 FE              sta Square2SoundQueue
00B348  1  A9 08              lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
00B34A  1  D0 A8              bne Set17ID               ;unconditional branch
00B34C  1               
00B34C  1               ;--------------------------------
00B34C  1               ;$00 - used to store Y position of group enemies
00B34C  1               ;$01 - used to store enemy ID
00B34C  1               ;$02 - used to store page location of right side of screen
00B34C  1               ;$03 - used to store X position of right side of screen
00B34C  1               
00B34C  1               HandleGroupEnemies:
00B34C  1  A0 00                ldy #$00                  ;load value for green koopa troopa
00B34E  1  38                   sec
00B34F  1  E9 37                sbc #$37                  ;subtract $37 from second byte read
00B351  1  48                   pha                       ;save result in stack for now
00B352  1  C9 04                cmp #$04                  ;was byte in $3b-$3e range?
00B354  1  B0 0B                bcs SnglID                ;if so, branch
00B356  1  48                   pha                       ;save another copy to stack
00B357  1  A0 06                ldy #Goomba               ;load value for goomba enemy
00B359  1  AD 6A 07             lda PrimaryHardMode       ;if primary hard mode flag not set,
00B35C  1  F0 02                beq PullID                ;branch, otherwise change to value
00B35E  1  A0 02                ldy #BuzzyBeetle          ;for buzzy beetle
00B360  1  68           PullID: pla                       ;get second copy from stack
00B361  1  84 01        SnglID: sty $01                   ;save enemy id here
00B363  1  A0 B0                ldy #$b0                  ;load default y coordinate
00B365  1  29 02                and #$02                  ;check to see if d1 was set
00B367  1  F0 02                beq SetYGp                ;if so, move y coordinate up,
00B369  1  A0 70                ldy #$70                  ;otherwise branch and use default
00B36B  1  84 00        SetYGp: sty $00                   ;save y coordinate here
00B36D  1  AD 1B 07             lda ScreenRight_PageLoc   ;get page number of right edge of screen
00B370  1  85 02                sta $02                   ;save here
00B372  1  AD 1D 07             lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
00B375  1  85 03                sta $03                   ;save here
00B377  1  A0 02                ldy #$02                  ;load two enemies by default
00B379  1  68                   pla                       ;get first copy from stack
00B37A  1  4A                   lsr                       ;check to see if d0 was set
00B37B  1  90 01                bcc CntGrp                ;if not, use default value
00B37D  1  C8                   iny                       ;otherwise increment to three enemies
00B37E  1  8C D3 06     CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
00B381  1  A2 FF        GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
00B383  1  E8           GSltLp: inx                       ;increment and branch if past
00B384  1  E0 05                cpx #$05                  ;end of buffers
00B386  1  B0 2D                bcs NextED
00B388  1  B5 0F                lda Enemy_Flag,x          ;check to see if enemy is already
00B38A  1  D0 F7                bne GSltLp                ;stored in buffer, and branch if so
00B38C  1  A5 01                lda $01
00B38E  1  95 16                sta Enemy_ID,x            ;store enemy object identifier
00B390  1  A5 02                lda $02
00B392  1  95 6E                sta Enemy_PageLoc,x       ;store page location for enemy object
00B394  1  A5 03                lda $03
00B396  1  95 87                sta Enemy_X_Position,x    ;store x coordinate for enemy object
00B398  1  18                   clc
00B399  1  69 18                adc #$18                  ;add 24 pixels for next enemy
00B39B  1  85 03                sta $03
00B39D  1  A5 02                lda $02                   ;add carry to page location for
00B39F  1  69 00                adc #$00                  ;next enemy
00B3A1  1  85 02                sta $02
00B3A3  1  A5 00                lda $00                   ;store y coordinate for enemy object
00B3A5  1  95 CF                sta Enemy_Y_Position,x
00B3A7  1  A9 01                lda #$01                  ;activate flag for buffer, and
00B3A9  1  95 B6                sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
00B3AB  1  95 0F                sta Enemy_Flag,x
00B3AD  1  20 70 AE             jsr CheckpointEnemyID     ;process each enemy object separately
00B3B0  1  CE D3 06             dec NumberofGroupEnemies  ;do this until we run out of enemy objects
00B3B3  1  D0 CC                bne GrLoop
00B3B5  1  4C 62 AE     NextED: jmp Inc2B                 ;jump to increment data offset and leave
00B3B8  1               
00B3B8  1               ;--------------------------------
00B3B8  1               ;$00 - used to store piranha plant attribute data
00B3B8  1               ;$01 - used to store piranha plant range data for player
00B3B8  1               
00B3B8  1               InitPiranhaPlant:
00B3B8  1  A9 01                 lda #$01                     ;set initial speed
00B3BA  1  95 58                 sta PiranhaPlant_Y_Speed,x
00B3BC  1  4A                    lsr
00B3BD  1  95 1E                 sta Enemy_State,x            ;initialize enemy state and what would normally
00B3BF  1  95 A0                 sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
00B3C1  1  B5 CF                 lda Enemy_Y_Position,x
00B3C3  1  9D 34 04              sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
00B3C6  1  38                    sec
00B3C7  1  E9 18                 sbc #$18
00B3C9  1  9D 17 04              sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
00B3CC  1  A9 09                 lda #$09
00B3CE  1  4C 0C B4              jmp SetBBox2                 ;set specific value for bounding box control
00B3D1  1               
00B3D1  1               ;--------------------------------
00B3D1  1               
00B3D1  1               InitEnemyFrenzy:
00B3D1  1  B5 16              lda Enemy_ID,x        ;load enemy identifier
00B3D3  1  8D CB 06           sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
00B3D6  1  38                 sec
00B3D7  1  E9 12              sbc #$12              ;subtract 12 and use as offset for jump engine
00B3D9  1  20 69 8C           jsr JumpEngine
00B3DC  1               
00B3DC  1               ;frenzy object jump table
00B3DC  1  AF AF              .word LakituAndSpinyHandler
00B3DE  1  E8 B3              .word NoFrenzyCode
00B3E0  1  C1 B0              .word InitFlyingCheepCheep
00B3E2  1  D4 B1              .word InitBowserFlame
00B3E4  1  6E B2              .word InitFireworks
00B3E6  1  CD B2              .word BulletBillCheepCheep
00B3E8  1               
00B3E8  1               NoFrenzyCode:
00B3E8  1  60                 rts
00B3E9  1               
00B3E9  1               EndFrenzy:
00B3E9  1  A0 05                   ldy #$05               ;start at last slot
00B3EB  1  B9 16 00     LakituChk: lda Enemy_ID,y         ;check enemy identifiers
00B3EE  1  C9 11                   cmp #Lakitu            ;for lakitu
00B3F0  1  D0 05                   bne NextFSlot
00B3F2  1  A9 01                   lda #$01               ;if found, set state
00B3F4  1  99 1E 00                sta Enemy_State,y
00B3F7  1  88           NextFSlot: dey                    ;move onto the next slot
00B3F8  1  10 F1                   bpl LakituChk          ;do this until all slots are checked
00B3FA  1  A9 00                   lda #$00
00B3FC  1  8D CB 06                sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
00B3FF  1  95 0F                   sta Enemy_Flag,x       ;disable enemy buffer flag for this object
00B401  1  60                      rts
00B402  1               
00B402  1               ;--------------------------------
00B402  1               
00B402  1               InitJumpGPTroopa:
00B402  1  A9 02                   lda #$02                  ;set for movement to the left
00B404  1  95 46                   sta Enemy_MovingDir,x
00B406  1  A9 F4                   lda #$f4                  ;set horizontal speed
00B408  1  95 58                   sta Enemy_X_Speed,x
00B40A  1  A9 03        TallBBox2: lda #$03                  ;set specific value for bounding box control
00B40C  1  9D 9A 04     SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
00B40F  1  60                      rts
00B410  1               
00B410  1               ;--------------------------------
00B410  1               
00B410  1               InitBalPlatform:
00B410  1  D6 CF                dec Enemy_Y_Position,x    ;raise vertical position by two pixels
00B412  1  D6 CF                dec Enemy_Y_Position,x
00B414  1  AC CC 06             ldy SecondaryHardMode     ;if secondary hard mode flag not set,
00B417  1  D0 05                bne AlignP                ;branch ahead
00B419  1  A0 02                ldy #$02                  ;otherwise set value here
00B41B  1  20 A2 B4             jsr PosPlatform           ;do a sub to add or subtract pixels
00B41E  1  A0 FF        AlignP: ldy #$ff                  ;set default value here for now
00B420  1  AD A0 03             lda BalPlatformAlignment  ;get current balance platform alignment
00B423  1  95 1E                sta Enemy_State,x         ;set platform alignment to object state here
00B425  1  10 02                bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
00B427  1  8A                   txa                       ;if old contents already $ff, put
00B428  1  A8                   tay                       ;object offset as alignment to make next positive
00B429  1  8C A0 03     SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
00B42C  1  A9 00                lda #$00
00B42E  1  95 46                sta Enemy_MovingDir,x     ;init moving direction
00B430  1  A8                   tay                       ;init Y
00B431  1  20 A2 B4             jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
00B434  1               
00B434  1               ;--------------------------------
00B434  1               
00B434  1               InitDropPlatform:
00B434  1  A9 FF              lda #$ff
00B436  1  9D A2 03           sta PlatformCollisionFlag,x  ;set some value here
00B439  1  4C 59 B4           jmp CommonPlatCode           ;then jump ahead to execute more code
00B43C  1               
00B43C  1               ;--------------------------------
00B43C  1               
00B43C  1               InitHoriPlatform:
00B43C  1  A9 00              lda #$00
00B43E  1  95 58              sta XMoveSecondaryCounter,x  ;init one of the moving counters
00B440  1  4C 59 B4           jmp CommonPlatCode           ;jump ahead to execute more code
00B443  1               
00B443  1               ;--------------------------------
00B443  1               
00B443  1               InitVertPlatform:
00B443  1  A0 40               ldy #$40                    ;set default value here
00B445  1  B5 CF               lda Enemy_Y_Position,x      ;check vertical position
00B447  1  10 07               bpl SetYO                   ;if above a certain point, skip this part
00B449  1  49 FF               eor #$ff
00B44B  1  18                  clc                         ;otherwise get two's compliment
00B44C  1  69 01               adc #$01
00B44E  1  A0 C0               ldy #$c0                    ;get alternate value to add to vertical position
00B450  1  9D 01 04     SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
00B453  1  98                  tya
00B454  1  18                  clc                         ;load value from earlier, add number of pixels
00B455  1  75 CF               adc Enemy_Y_Position,x      ;to vertical position
00B457  1  95 58               sta YPlatformCenterYPos,x   ;save result as central vertical position
00B459  1               
00B459  1               ;--------------------------------
00B459  1               
00B459  1               CommonPlatCode:
00B459  1  20 6E AF             jsr InitVStf              ;do a sub to init certain other values
00B45C  1  A9 05        SPBBox: lda #$05                  ;set default bounding box size control
00B45E  1  AC 4E 07             ldy AreaType
00B461  1  C0 03                cpy #$03                  ;check for castle-type level
00B463  1  F0 07                beq CasPBB                ;use default value if found
00B465  1  AC CC 06             ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
00B468  1  D0 02                bne CasPBB                ;if set, use default value
00B46A  1  A9 06                lda #$06                  ;use alternate value if not castle or secondary not set
00B46C  1  9D 9A 04     CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
00B46F  1  60                   rts
00B470  1               
00B470  1               ;--------------------------------
00B470  1               
00B470  1               LargeLiftUp:
00B470  1  20 7C B4           jsr PlatLiftUp       ;execute code for platforms going up
00B473  1  4C 79 B4           jmp LargeLiftBBox    ;overwrite bounding box for large platforms
00B476  1               
00B476  1               LargeLiftDown:
00B476  1  20 88 B4           jsr PlatLiftDown     ;execute code for platforms going down
00B479  1               
00B479  1               LargeLiftBBox:
00B479  1  4C 5C B4           jmp SPBBox           ;jump to overwrite bounding box size control
00B47C  1               
00B47C  1               ;--------------------------------
00B47C  1               
00B47C  1               PlatLiftUp:
00B47C  1  A9 10              lda #$10                 ;set movement amount here
00B47E  1  9D 34 04           sta Enemy_Y_MoveForce,x
00B481  1  A9 FF              lda #$ff                 ;set moving speed for platforms going up
00B483  1  95 A0              sta Enemy_Y_Speed,x
00B485  1  4C 91 B4           jmp CommonSmallLift      ;skip ahead to part we should be executing
00B488  1               
00B488  1               ;--------------------------------
00B488  1               
00B488  1               PlatLiftDown:
00B488  1  A9 F0              lda #$f0                 ;set movement amount here
00B48A  1  9D 34 04           sta Enemy_Y_MoveForce,x
00B48D  1  A9 00              lda #$00                 ;set moving speed for platforms going down
00B48F  1  95 A0              sta Enemy_Y_Speed,x
00B491  1               
00B491  1               ;--------------------------------
00B491  1               
00B491  1               CommonSmallLift:
00B491  1  A0 01              ldy #$01
00B493  1  20 A2 B4           jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
00B496  1  A9 04              lda #$04
00B498  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
00B49B  1  60                 rts
00B49C  1               
00B49C  1               ;--------------------------------
00B49C  1               
00B49C  1               PlatPosDataLow:
00B49C  1  08 0C F8           .byte $08,$0c,$f8
00B49F  1               
00B49F  1               PlatPosDataHigh:
00B49F  1  00 00 FF           .byte $00,$00,$ff
00B4A2  1               
00B4A2  1               PosPlatform:
00B4A2  1  B5 87              lda Enemy_X_Position,x  ;get horizontal coordinate
00B4A4  1  18                 clc
00B4A5  1  79 9C B4           adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
00B4A8  1  95 87              sta Enemy_X_Position,x  ;store as new horizontal coordinate
00B4AA  1  B5 6E              lda Enemy_PageLoc,x
00B4AC  1  79 9F B4           adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
00B4AF  1  95 6E              sta Enemy_PageLoc,x     ;store as new page location
00B4B1  1  60                 rts                     ;and go back
00B4B2  1               
00B4B2  1               ;--------------------------------
00B4B2  1               
00B4B2  1               EndOfEnemyInitCode:
00B4B2  1  60                 rts
00B4B3  1               
00B4B3  1               ;-------------------------------------------------------------------------------------
00B4B3  1               
00B4B3  1               RunEnemyObjectsCore:
00B4B3  1  A6 08               ldx ObjectOffset  ;get offset for enemy object buffer
00B4B5  1  A9 00               lda #$00          ;load value 0 for jump engine by default
00B4B7  1  B4 16               ldy Enemy_ID,x
00B4B9  1  C0 15               cpy #$15          ;if enemy object < $15, use default value
00B4BB  1  90 03               bcc JmpEO
00B4BD  1  98                  tya               ;otherwise subtract $14 from the value and use
00B4BE  1  E9 14               sbc #$14          ;as value for jump engine
00B4C0  1  20 69 8C     JmpEO: jsr JumpEngine
00B4C3  1               
00B4C3  1  11 B5              .word RunNormalEnemies  ;for objects $00-$14
00B4C5  1               
00B4C5  1  66 B5              .word RunBowserFlame    ;for objects $15-$1f
00B4C7  1  C6 BE              .word RunFireworks
00B4C9  1  07 B5              .word NoRunCode
00B4CB  1  07 B5              .word NoRunCode
00B4CD  1  07 B5              .word NoRunCode
00B4CF  1  07 B5              .word NoRunCode
00B4D1  1  78 B5              .word RunFirebarObj
00B4D3  1  78 B5              .word RunFirebarObj
00B4D5  1  78 B5              .word RunFirebarObj
00B4D7  1  78 B5              .word RunFirebarObj
00B4D9  1  78 B5              .word RunFirebarObj
00B4DB  1               
00B4DB  1  78 B5              .word RunFirebarObj     ;for objects $20-$2f
00B4DD  1  78 B5              .word RunFirebarObj
00B4DF  1  78 B5              .word RunFirebarObj
00B4E1  1  07 B5              .word NoRunCode
00B4E3  1  96 B5              .word RunLargePlatform
00B4E5  1  96 B5              .word RunLargePlatform
00B4E7  1  96 B5              .word RunLargePlatform
00B4E9  1  96 B5              .word RunLargePlatform
00B4EB  1  96 B5              .word RunLargePlatform
00B4ED  1  96 B5              .word RunLargePlatform
00B4EF  1  96 B5              .word RunLargePlatform
00B4F1  1  7E B5              .word RunSmallPlatform
00B4F3  1  7E B5              .word RunSmallPlatform
00B4F5  1  96 BC              .word RunBowser
00B4F7  1  69 A8              .word PowerUpObjHandler
00B4F9  1  02 A5              .word VineObjectHandler
00B4FB  1               
00B4FB  1  07 B5              .word NoRunCode         ;for objects $30-$35
00B4FD  1  0A BF              .word RunStarFlagObj
00B4FF  1  5C A4              .word JumpspringHandler
00B501  1  07 B5              .word NoRunCode
00B503  1  49 A3              .word WarpZoneObject
00B505  1  08 B5              .word RunRetainerObj
00B507  1               
00B507  1               ;--------------------------------
00B507  1               
00B507  1               NoRunCode:
00B507  1  60                 rts
00B508  1               
00B508  1               ;--------------------------------
00B508  1               
00B508  1               RunRetainerObj:
00B508  1  20 79 DE           jsr GetEnemyOffscreenBits
00B50B  1  20 1C DE           jsr RelativeEnemyPosition
00B50E  1  4C 08 D5           jmp EnemyGfxHandler
00B511  1               
00B511  1               ;--------------------------------
00B511  1               
00B511  1               RunNormalEnemies:
00B511  1  A9 00                  lda #$00                  ;init sprite attributes
00B513  1  9D C5 03               sta Enemy_SprAttrib,x
00B516  1  20 79 DE               jsr GetEnemyOffscreenBits
00B519  1  20 1C DE               jsr RelativeEnemyPosition
00B51C  1  20 08 D5               jsr EnemyGfxHandler
00B51F  1  20 C4 CE               jsr GetEnemyBoundBox
00B522  1  20 2D CC               jsr EnemyToBGCollisionDet
00B525  1  20 94 C6               jsr EnemiesCollision
00B528  1  20 A3 C4               jsr PlayerEnemyCollision
00B52B  1  AC 47 07               ldy TimerControl          ;if master timer control set, skip to last routine
00B52E  1  D0 03                  bne SkipMove
00B530  1  20 36 B5               jsr EnemyMovementSubs
00B533  1  4C AD C2     SkipMove: jmp OffscreenBoundsCheck
00B536  1               
00B536  1               EnemyMovementSubs:
00B536  1  B5 16              lda Enemy_ID,x
00B538  1  20 69 8C           jsr JumpEngine
00B53B  1               
00B53B  1  A8 B6              .word MoveNormalEnemy      ;only objects $00-$14 use this table
00B53D  1  A8 B6              .word MoveNormalEnemy
00B53F  1  A8 B6              .word MoveNormalEnemy
00B541  1  A8 B6              .word MoveNormalEnemy
00B543  1  44 E4              .word MoveUpsideDownPiranhaP
00B545  1  09 B6              .word ProcHammerBro
00B547  1  A8 B6              .word MoveNormalEnemy
00B549  1  BA B7              .word MoveBloober
00B54B  1  67 B8              .word MoveBulletBill
00B54D  1  65 B5              .word NoMoveCode
00B54F  1  7B B8              .word MoveSwimmingCheepCheep
00B551  1  7B B8              .word MoveSwimmingCheepCheep
00B553  1  E1 B5              .word MovePodoboo
00B555  1  C0 BF              .word MovePiranhaPlant
00B557  1  2A B7              .word MoveJumpingEnemy
00B559  1  30 B7              .word ProcMoveRedPTroopa
00B55B  1  56 B7              .word MoveFlyGreenPTroopa
00B55D  1  59 BB              .word MoveLakitu
00B55F  1  A8 B6              .word MoveNormalEnemy
00B561  1  65 B5              .word NoMoveCode            ;dummy
00B563  1  10 BB              .word MoveFlyingCheepCheep
00B565  1               
00B565  1               ;--------------------------------
00B565  1               
00B565  1               NoMoveCode:
00B565  1  60                 rts
00B566  1               
00B566  1               ;--------------------------------
00B566  1               
00B566  1               RunBowserFlame:
00B566  1  20 1C BE           jsr ProcBowserFlame
00B569  1  20 79 DE           jsr GetEnemyOffscreenBits
00B56C  1  20 1C DE           jsr RelativeEnemyPosition
00B56F  1  20 C4 CE           jsr GetEnemyBoundBox
00B572  1  20 A3 C4           jsr PlayerEnemyCollision
00B575  1  4C AD C2           jmp OffscreenBoundsCheck
00B578  1               
00B578  1               ;--------------------------------
00B578  1               
00B578  1               RunFirebarObj:
00B578  1  20 6D B9           jsr ProcFirebar
00B57B  1  4C AD C2           jmp OffscreenBoundsCheck
00B57E  1               
00B57E  1               ;--------------------------------
00B57E  1               
00B57E  1               RunSmallPlatform:
00B57E  1  20 79 DE           jsr GetEnemyOffscreenBits
00B581  1  20 1C DE           jsr RelativeEnemyPosition
00B584  1  20 CD CE           jsr SmallPlatformBoundBox
00B587  1  20 E8 C7           jsr SmallPlatformCollision
00B58A  1  20 1C DE           jsr RelativeEnemyPosition
00B58D  1  20 26 DA           jsr DrawSmallPlatform
00B590  1  20 88 C2           jsr MoveSmallPlatform
00B593  1  4C AD C2           jmp OffscreenBoundsCheck
00B596  1               
00B596  1               ;--------------------------------
00B596  1               
00B596  1               RunLargePlatform:
00B596  1  20 79 DE             jsr GetEnemyOffscreenBits
00B599  1  20 1C DE             jsr RelativeEnemyPosition
00B59C  1  20 F4 CE             jsr LargePlatformBoundBox
00B59F  1  20 B2 C7             jsr LargePlatformCollision
00B5A2  1  AD 47 07             lda TimerControl             ;if master timer control set,
00B5A5  1  D0 03                bne SkipPT                   ;skip subroutine tree
00B5A7  1  20 B3 B5             jsr LargePlatformSubroutines
00B5AA  1  20 1C DE     SkipPT: jsr RelativeEnemyPosition
00B5AD  1  20 4A D2             jsr DrawLargePlatform
00B5B0  1  4C AD C2             jmp OffscreenBoundsCheck
00B5B3  1               
00B5B3  1               ;--------------------------------
00B5B3  1               
00B5B3  1               LargePlatformSubroutines:
00B5B3  1  B5 16              lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
00B5B5  1  38                 sec
00B5B6  1  E9 24              sbc #$24
00B5B8  1  20 69 8C           jsr JumpEngine
00B5BB  1               
00B5BB  1  5E C0              .word BalancePlatform   ;table used by objects $24-$2a
00B5BD  1  06 C2              .word YMovingPlatform
00B5BF  1  82 C2              .word MoveLargeLiftPlat
00B5C1  1  82 C2              .word MoveLargeLiftPlat
00B5C3  1  3A C2              .word XMovingPlatform
00B5C5  1  64 C2              .word DropPlatform
00B5C7  1  70 C2              .word RightPlatform
00B5C9  1               
00B5C9  1               ;-------------------------------------------------------------------------------------
00B5C9  1               
00B5C9  1               EraseEnemyObject:
00B5C9  1  A9 00              lda #$00                 ;clear all enemy object variables
00B5CB  1  95 0F              sta Enemy_Flag,x
00B5CD  1  95 16              sta Enemy_ID,x
00B5CF  1  95 1E              sta Enemy_State,x
00B5D1  1  9D 10 01           sta FloateyNum_Control,x
00B5D4  1  9D 96 07           sta EnemyIntervalTimer,x
00B5D7  1  9D 25 01           sta ShellChainCounter,x
00B5DA  1  9D C5 03           sta Enemy_SprAttrib,x
00B5DD  1  9D 8A 07           sta EnemyFrameTimer,x
00B5E0  1  60                 rts
00B5E1  1               
00B5E1  1               ;-------------------------------------------------------------------------------------
00B5E1  1               
00B5E1  1               MovePodoboo:
00B5E1  1  BD 96 07           lda EnemyIntervalTimer,x   ;check enemy timer
00B5E4  1  D0 16              bne PdbM                   ;branch to move enemy if not expired
00B5E6  1  20 FB AE           jsr InitPodoboo            ;otherwise set up podoboo again
00B5E9  1  BD A8 07           lda PseudoRandomBitReg+1,x ;get part of LSFR
00B5EC  1  09 80              ora #%10000000             ;set d7
00B5EE  1  9D 34 04           sta Enemy_Y_MoveForce,x    ;store as movement force
00B5F1  1  29 0F              and #%00001111             ;mask out high nybble
00B5F3  1  09 06              ora #$06                   ;set for at least six intervals
00B5F5  1  9D 96 07           sta EnemyIntervalTimer,x   ;store as new enemy timer
00B5F8  1  A9 F9              lda #$f9
00B5FA  1  95 A0              sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
00B5FC  1  4C 8E AB     PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
00B5FF  1               
00B5FF  1               ;--------------------------------
00B5FF  1               ;$00 - used in HammerBroJumpCode as bitmask
00B5FF  1               
00B5FF  1               HammerThrowTmrData:
00B5FF  1  30 1C              .byte $30, $1c
00B601  1               
00B601  1               XSpeedAdderData:
00B601  1  00 E8 00 18        .byte $00, $e8, $00, $18
00B605  1               
00B605  1               RevivedXSpeed:
00B605  1  08 F8 0C F4        .byte $08, $f8, $0c, $f4
00B609  1               
00B609  1               ProcHammerBro:
00B609  1  B5 1E               lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
00B60B  1  29 20               and #%00100000
00B60D  1  F0 03               beq ChkJH                  ;if not set, go ahead with code
00B60F  1  4C 16 B7            jmp MoveDefeatedEnemy      ;otherwise jump to something else
00B612  1  B5 3C        ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
00B614  1  F0 2D               beq HammerBroJumpCode      ;if expired, branch to jump
00B616  1  D6 3C               dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
00B618  1  AD D1 03            lda Enemy_OffscreenBits
00B61B  1  29 0C               and #%00001100             ;check offscreen bits
00B61D  1  D0 6A               bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
00B61F  1  BD A2 03            lda HammerThrowingTimer,x  ;check hammer throwing timer
00B622  1  D0 17               bne DecHT                  ;if not expired, skip ahead, do not throw hammer
00B624  1  AC CC 06            ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
00B627  1  B9 FF B5            lda HammerThrowTmrData,y   ;get timer data using flag as offset
00B62A  1  9D A2 03            sta HammerThrowingTimer,x  ;set as new timer
00B62D  1  20 8A A6            jsr SpawnHammerObj         ;do a sub here to spawn hammer object
00B630  1  90 09               bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
00B632  1  B5 1E               lda Enemy_State,x
00B634  1  09 08               ora #%00001000             ;set d3 in enemy state for hammer throw
00B636  1  95 1E               sta Enemy_State,x
00B638  1  4C 89 B6            jmp MoveHammerBroXDir      ;jump to move hammer bro
00B63B  1  DE A2 03     DecHT: dec HammerThrowingTimer,x  ;decrement timer
00B63E  1  4C 89 B6            jmp MoveHammerBroXDir      ;jump to move hammer bro
00B641  1               
00B641  1               HammerBroJumpLData:
00B641  1  20 37              .byte $20, $37
00B643  1               
00B643  1               HammerBroJumpCode:
00B643  1  B5 1E               lda Enemy_State,x           ;get hammer bro's enemy state
00B645  1  29 07               and #%00000111              ;mask out all but 3 LSB
00B647  1  C9 01               cmp #$01                    ;check for d0 set (for jumping)
00B649  1  F0 3E               beq MoveHammerBroXDir       ;if set, branch ahead to moving code
00B64B  1  A9 00               lda #$00                    ;load default value here
00B64D  1  85 00               sta $00                     ;save into temp variable for now
00B64F  1  A0 FA               ldy #$fa                    ;set default vertical speed
00B651  1  B5 CF               lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
00B653  1  30 13               bmi SetHJ                   ;if on the bottom half of the screen, use current speed
00B655  1  A0 FD               ldy #$fd                    ;otherwise set alternate vertical speed
00B657  1  C9 70               cmp #$70                    ;check to see if hammer bro is above the middle of screen
00B659  1  E6 00               inc $00                     ;increment preset value to $01
00B65B  1  90 0B               bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
00B65D  1  C6 00               dec $00                     ;otherwise return value to $00
00B65F  1  BD A8 07            lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
00B662  1  29 01               and #$01
00B664  1  D0 02               bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
00B666  1  A0 FA               ldy #$fa                    ;otherwise reset to default vertical speed
00B668  1  94 A0        SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
00B66A  1  B5 1E               lda Enemy_State,x           ;set d0 in enemy state for jumping
00B66C  1  09 01               ora #$01
00B66E  1  95 1E               sta Enemy_State,x
00B670  1  A5 00               lda $00                     ;load preset value here to use as bitmask
00B672  1  3D A9 07            and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
00B675  1  A8                  tay                         ;then use as offset
00B676  1  AD CC 06            lda SecondaryHardMode       ;check secondary hard mode flag
00B679  1  D0 01               bne HJump
00B67B  1  A8                  tay                         ;if secondary hard mode flag clear, set offset to 0
00B67C  1  B9 41 B6     HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
00B67F  1  9D 8A 07            sta EnemyFrameTimer,x       ;save in enemy timer
00B682  1  BD A8 07            lda PseudoRandomBitReg+1,x
00B685  1  09 C0               ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
00B687  1  95 3C               sta HammerBroJumpTimer,x    ;store in jump timer
00B689  1               
00B689  1               MoveHammerBroXDir:
00B689  1  A0 FC                 ldy #$fc                  ;move hammer bro a little to the left
00B68B  1  A5 09                 lda FrameCounter
00B68D  1  29 40                 and #%01000000            ;change hammer bro's direction every 64 frames
00B68F  1  D0 02                 bne Shimmy
00B691  1  A0 04                 ldy #$04                  ;if d6 set in counter, move him a little to the right
00B693  1  94 58        Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
00B695  1  A0 01                 ldy #$01                  ;set to face right by default
00B697  1  20 BC CD              jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
00B69A  1  30 0A                 bmi SetShim               ;if enemy to the left of player, skip this part
00B69C  1  C8                    iny                       ;set to face left
00B69D  1  BD 96 07              lda EnemyIntervalTimer,x  ;check walking timer
00B6A0  1  D0 04                 bne SetShim               ;if not yet expired, skip to set moving direction
00B6A2  1  A9 F8                 lda #$f8
00B6A4  1  95 58                 sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
00B6A6  1  94 46        SetShim: sty Enemy_MovingDir,x     ;set moving direction
00B6A8  1               
00B6A8  1               MoveNormalEnemy:
00B6A8  1  A0 00               ldy #$00                   ;init Y to leave horizontal movement as-is
00B6AA  1  B5 1E               lda Enemy_State,x
00B6AC  1  29 40               and #%01000000             ;check enemy state for d6 set, if set skip
00B6AE  1  D0 19               bne FallE                  ;to move enemy vertically, then horizontally if necessary
00B6B0  1  B5 1E               lda Enemy_State,x
00B6B2  1  0A                  asl                        ;check enemy state for d7 set
00B6B3  1  B0 30               bcs SteadM                 ;if set, branch to move enemy horizontally
00B6B5  1  B5 1E               lda Enemy_State,x
00B6B7  1  29 20               and #%00100000             ;check enemy state for d5 set
00B6B9  1  D0 5B               bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
00B6BB  1  B5 1E               lda Enemy_State,x
00B6BD  1  29 07               and #%00000111             ;check d2-d0 of enemy state for any set bits
00B6BF  1  F0 24               beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
00B6C1  1  C9 05               cmp #$05
00B6C3  1  F0 04               beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
00B6C5  1  C9 03               cmp #$03
00B6C7  1  B0 30               bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
00B6C9  1  20 5F AB     FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
00B6CC  1  A0 00               ldy #$00
00B6CE  1  B5 1E               lda Enemy_State,x          ;check for enemy state $02
00B6D0  1  C9 02               cmp #$02
00B6D2  1  F0 0C               beq MEHor                  ;if found, branch to move enemy horizontally
00B6D4  1  29 40               and #%01000000             ;check for d6 set
00B6D6  1  F0 0D               beq SteadM                 ;if not set, branch to something else
00B6D8  1  B5 16               lda Enemy_ID,x
00B6DA  1  C9 2E               cmp #PowerUpObject         ;check for power-up object
00B6DC  1  F0 07               beq SteadM
00B6DE  1  D0 03               bne SlowM                  ;if any other object where d6 set, jump to set Y
00B6E0  1  4C FE AA     MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
00B6E3  1               
00B6E3  1  A0 01        SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
00B6E5  1  B5 58        SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
00B6E7  1  48                   pha                       ;save to stack
00B6E8  1  10 02                bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
00B6EA  1  C8                   iny
00B6EB  1  C8                   iny                       ;otherwise increment Y to next data
00B6EC  1  18           AddHS:  clc
00B6ED  1  79 01 B6             adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
00B6F0  1  95 58                sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
00B6F2  1  20 FE AA             jsr MoveEnemyHorizontally ;then do a sub to move horizontally
00B6F5  1  68                   pla
00B6F6  1  95 58                sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
00B6F8  1  60                   rts                       ;original memory location, then leave
00B6F9  1               
00B6F9  1               ReviveStunned:
00B6F9  1  BD 96 07              lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
00B6FC  1  D0 1E                 bne ChkKillGoomba         ;skip ahead to something else
00B6FE  1  95 1E                 sta Enemy_State,x         ;otherwise initialize enemy state to normal
00B700  1  A5 09                 lda FrameCounter
00B702  1  29 01                 and #$01                  ;get d0 of frame counter
00B704  1  A8                    tay                       ;use as Y and increment for movement direction
00B705  1  C8                    iny
00B706  1  94 46                 sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
00B708  1  88                    dey                       ;decrement for use as pointer
00B709  1  AD 6A 07              lda PrimaryHardMode       ;check primary hard mode flag
00B70C  1  F0 02                 beq SetRSpd               ;if not set, use pointer as-is
00B70E  1  C8                    iny
00B70F  1  C8                    iny                       ;otherwise increment 2 bytes to next data
00B710  1  B9 05 B6     SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
00B713  1  95 58                 sta Enemy_X_Speed,x       ;and leave
00B715  1  60                    rts
00B716  1               
00B716  1               MoveDefeatedEnemy:
00B716  1  20 5F AB           jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
00B719  1  4C FE AA           jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
00B71C  1               
00B71C  1               ChkKillGoomba:
00B71C  1  C9 0E                cmp #$0e              ;check to see if enemy timer has reached
00B71E  1  D0 09                bne NKGmba            ;a certain point, and branch to leave if not
00B720  1  B5 16                lda Enemy_ID,x
00B722  1  C9 06                cmp #Goomba           ;check for goomba object
00B724  1  D0 03                bne NKGmba            ;branch if not found
00B726  1  20 C9 B5             jsr EraseEnemyObject  ;otherwise, kill this goomba object
00B729  1  60           NKGmba: rts                   ;leave!
00B72A  1               
00B72A  1               ;--------------------------------
00B72A  1               
00B72A  1               MoveJumpingEnemy:
00B72A  1  20 8E AB           jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
00B72D  1  4C FE AA           jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
00B730  1               
00B730  1               ;--------------------------------
00B730  1               
00B730  1               ProcMoveRedPTroopa:
00B730  1  B5 A0                  lda Enemy_Y_Speed,x
00B732  1  1D 34 04               ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
00B735  1  D0 13                  bne MoveRedPTUpOrDown       ;branch if any found
00B737  1  9D 17 04               sta Enemy_YMF_Dummy,x       ;initialize something here
00B73A  1  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
00B73C  1  DD 01 04               cmp RedPTroopaOrigXPos,x
00B73F  1  B0 09                  bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
00B741  1  A5 09                  lda FrameCounter            ;get frame counter
00B743  1  29 07                  and #%00000111              ;mask out all but 3 LSB
00B745  1  D0 02                  bne NoIncPT                 ;if any bits set, branch to leave
00B747  1  F6 CF                  inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
00B749  1  60           NoIncPT:  rts                         ;leave
00B74A  1               
00B74A  1               MoveRedPTUpOrDown:
00B74A  1  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
00B74C  1  D5 58                  cmp RedPTroopaCenterYPos,x
00B74E  1  90 03                  bcc MovPTDwn                ;if current < central, jump to move downwards
00B750  1  4C 71 AB               jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
00B753  1  4C 6C AB     MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
00B756  1               
00B756  1               ;--------------------------------
00B756  1               ;$00 - used to store adder for movement, also used as adder for platform
00B756  1               ;$01 - used to store maximum value for secondary counter
00B756  1               
00B756  1               MoveFlyGreenPTroopa:
00B756  1  20 76 B7             jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
00B759  1  20 97 B7             jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
00B75C  1  A0 01                ldy #$01                   ;set Y to move green paratroopa down
00B75E  1  A5 09                lda FrameCounter
00B760  1  29 03                and #%00000011             ;check frame counter 2 LSB for any bits set
00B762  1  D0 11                bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
00B764  1  A5 09                lda FrameCounter
00B766  1  29 40                and #%01000000             ;check frame counter for d6 set
00B768  1  D0 02                bne YSway                  ;branch to move green paratroopa down if set
00B76A  1  A0 FF                ldy #$ff                   ;otherwise set Y to move green paratroopa up
00B76C  1  84 00        YSway:  sty $00                    ;store adder here
00B76E  1  B5 CF                lda Enemy_Y_Position,x
00B770  1  18                   clc                        ;add or subtract from vertical position
00B771  1  65 00                adc $00                    ;to give green paratroopa a wavy flight
00B773  1  95 CF                sta Enemy_Y_Position,x
00B775  1  60           NoMGPT: rts                        ;leave!
00B776  1               
00B776  1               XMoveCntr_GreenPTroopa:
00B776  1  A9 13                 lda #$13                    ;load preset maximum value for secondary counter
00B778  1               
00B778  1               XMoveCntr_Platform:
00B778  1  85 01                 sta $01                     ;store value here
00B77A  1  A5 09                 lda FrameCounter
00B77C  1  29 03                 and #%00000011              ;branch to leave if not on
00B77E  1  D0 0D                 bne NoIncXM                 ;every fourth frame
00B780  1  B4 58                 ldy XMoveSecondaryCounter,x ;get secondary counter
00B782  1  B5 A0                 lda XMovePrimaryCounter,x   ;get primary counter
00B784  1  4A                    lsr
00B785  1  B0 0A                 bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
00B787  1  C4 01                 cpy $01                     ;compare secondary counter to preset maximum value
00B789  1  F0 03                 beq IncPXM                  ;if equal, branch ahead of this part
00B78B  1  F6 58                 inc XMoveSecondaryCounter,x ;increment secondary counter and leave
00B78D  1  60           NoIncXM: rts
00B78E  1  F6 A0        IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
00B790  1  60                    rts
00B791  1  98           DecSeXM: tya                         ;put secondary counter in A
00B792  1  F0 FA                 beq IncPXM                  ;if secondary counter at zero, branch back
00B794  1  D6 58                 dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
00B796  1  60                    rts
00B797  1               
00B797  1               MoveWithXMCntrs:
00B797  1  B5 58                 lda XMoveSecondaryCounter,x  ;save secondary counter to stack
00B799  1  48                    pha
00B79A  1  A0 01                 ldy #$01                     ;set value here by default
00B79C  1  B5 A0                 lda XMovePrimaryCounter,x
00B79E  1  29 02                 and #%00000010               ;if d1 of primary counter is
00B7A0  1  D0 0B                 bne XMRight                  ;set, branch ahead of this part here
00B7A2  1  B5 58                 lda XMoveSecondaryCounter,x
00B7A4  1  49 FF                 eor #$ff                     ;otherwise change secondary
00B7A6  1  18                    clc                          ;counter to two's compliment
00B7A7  1  69 01                 adc #$01
00B7A9  1  95 58                 sta XMoveSecondaryCounter,x
00B7AB  1  A0 02                 ldy #$02                     ;load alternate value here
00B7AD  1  94 46        XMRight: sty Enemy_MovingDir,x        ;store as moving direction
00B7AF  1  20 FE AA              jsr MoveEnemyHorizontally
00B7B2  1  85 00                 sta $00                      ;save value obtained from sub here
00B7B4  1  68                    pla                          ;get secondary counter from stack
00B7B5  1  95 58                 sta XMoveSecondaryCounter,x  ;and return to original place
00B7B7  1  60                    rts
00B7B8  1               
00B7B8  1               ;--------------------------------
00B7B8  1               
00B7B8  1               
00B7B8  1               BlooberBitmasks:
00B7B8  1  3F 03              .byte %00111111, %00000011
00B7BA  1               
00B7BA  1               MoveBloober:
00B7BA  1  B5 1E                lda Enemy_State,x
00B7BC  1  29 20                and #%00100000             ;check enemy state for d5 set
00B7BE  1  D0 4D                bne MoveDefeatedBloober    ;branch if set to move defeated bloober
00B7C0  1  AC CC 06             ldy SecondaryHardMode      ;use secondary hard mode flag as offset
00B7C3  1  BD A8 07             lda PseudoRandomBitReg+1,x ;get LSFR
00B7C6  1  39 B8 B7             and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
00B7C9  1  D0 12                bne BlooberSwim            ;if any bits set, skip ahead to make swim
00B7CB  1  8A                   txa
00B7CC  1  4A                   lsr                        ;check to see if on second or fourth slot (1 or 3)
00B7CD  1  90 04                bcc FBLeft                 ;if not, branch to figure out moving direction
00B7CF  1  A4 45                ldy Player_MovingDir       ;otherwise, load player's moving direction and
00B7D1  1  B0 08                bcs SBMDir                 ;do an unconditional branch to set
00B7D3  1  A0 02        FBLeft: ldy #$02                   ;set left moving direction by default
00B7D5  1  20 BC CD             jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
00B7D8  1  10 01                bpl SBMDir                 ;if enemy to the right of player, keep left
00B7DA  1  88                   dey                        ;otherwise decrement to set right moving direction
00B7DB  1  94 46        SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
00B7DD  1               
00B7DD  1               BlooberSwim:
00B7DD  1  20 10 B8            jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
00B7E0  1  B5 CF               lda Enemy_Y_Position,x   ;get vertical coordinate
00B7E2  1  38                  sec
00B7E3  1  FD 34 04            sbc Enemy_Y_MoveForce,x  ;subtract movement force
00B7E6  1  C9 20               cmp #$20                 ;check to see if position is above edge of status bar
00B7E8  1  90 02               bcc SwimX                ;if so, don't do it
00B7EA  1  95 CF               sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
00B7EC  1  B4 46        SwimX: ldy Enemy_MovingDir,x    ;check moving direction
00B7EE  1  88                  dey
00B7EF  1  D0 0E               bne LeftSwim             ;if moving to the left, branch to second part
00B7F1  1  B5 87               lda Enemy_X_Position,x
00B7F3  1  18                  clc                      ;add movement speed to horizontal coordinate
00B7F4  1  75 58               adc BlooperMoveSpeed,x
00B7F6  1  95 87               sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00B7F8  1  B5 6E               lda Enemy_PageLoc,x
00B7FA  1  69 00               adc #$00                 ;add carry to page location
00B7FC  1  95 6E               sta Enemy_PageLoc,x      ;store as new page location and leave
00B7FE  1  60                  rts
00B7FF  1               
00B7FF  1               LeftSwim:
00B7FF  1  B5 87              lda Enemy_X_Position,x
00B801  1  38                 sec                      ;subtract movement speed from horizontal coordinate
00B802  1  F5 58              sbc BlooperMoveSpeed,x
00B804  1  95 87              sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00B806  1  B5 6E              lda Enemy_PageLoc,x
00B808  1  E9 00              sbc #$00                 ;subtract borrow from page location
00B80A  1  95 6E              sta Enemy_PageLoc,x      ;store as new page location and leave
00B80C  1  60                 rts
00B80D  1               
00B80D  1               MoveDefeatedBloober:
00B80D  1  4C 88 AB           jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
00B810  1               
00B810  1               ProcSwimmingB:
00B810  1  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00B812  1  29 02                and #%00000010            ;check for d1 set
00B814  1  D0 37                bne ChkForFloatdown       ;branch if set
00B816  1  A5 09                lda FrameCounter
00B818  1  29 07                and #%00000111            ;get 3 LSB of frame counter
00B81A  1  48                   pha                       ;and save it to the stack
00B81B  1  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00B81D  1  4A                   lsr                       ;check for d0 set
00B81E  1  B0 15                bcs SlowSwim              ;branch if set
00B820  1  68                   pla                       ;pull 3 LSB of frame counter from the stack
00B821  1  D0 11                bne BSwimE                ;branch to leave, execute code only every eighth frame
00B823  1  BD 34 04             lda Enemy_Y_MoveForce,x
00B826  1  18                   clc                       ;add to movement force to speed up swim
00B827  1  69 01                adc #$01
00B829  1  9D 34 04             sta Enemy_Y_MoveForce,x   ;set movement force
00B82C  1  95 58                sta BlooperMoveSpeed,x    ;set as movement speed
00B82E  1  C9 02                cmp #$02
00B830  1  D0 02                bne BSwimE                ;if certain horizontal speed, branch to leave
00B832  1  F6 A0                inc BlooperMoveCounter,x  ;otherwise increment movement counter
00B834  1  60           BSwimE: rts
00B835  1               
00B835  1               SlowSwim:
00B835  1  68                  pla                      ;pull 3 LSB of frame counter from the stack
00B836  1  D0 14               bne NoSSw                ;branch to leave, execute code only every eighth frame
00B838  1  BD 34 04            lda Enemy_Y_MoveForce,x
00B83B  1  38                  sec                      ;subtract from movement force to slow swim
00B83C  1  E9 01               sbc #$01
00B83E  1  9D 34 04            sta Enemy_Y_MoveForce,x  ;set movement force
00B841  1  95 58               sta BlooperMoveSpeed,x   ;set as movement speed
00B843  1  D0 07               bne NoSSw                ;if any speed, branch to leave
00B845  1  F6 A0               inc BlooperMoveCounter,x ;otherwise increment movement counter
00B847  1  A9 02               lda #$02
00B849  1  9D 96 07            sta EnemyIntervalTimer,x ;set enemy's timer
00B84C  1  60           NoSSw: rts                      ;leave
00B84D  1               
00B84D  1               ChkForFloatdown:
00B84D  1  BD 96 07           lda EnemyIntervalTimer,x ;get enemy timer
00B850  1  F0 08              beq ChkNearPlayer        ;branch if expired
00B852  1               
00B852  1               Floatdown:
00B852  1  A5 09              lda FrameCounter        ;get frame counter
00B854  1  4A                 lsr                     ;check for d0 set
00B855  1  B0 02              bcs NoFD                ;branch to leave on every other frame
00B857  1  F6 CF              inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
00B859  1  60           NoFD: rts                     ;leave
00B85A  1               
00B85A  1               ChkNearPlayer:
00B85A  1  B5 CF              lda Enemy_Y_Position,x    ;get vertical coordinate
00B85C  1  69 10              adc #$10                  ;add sixteen pixels
00B85E  1  C5 CE              cmp Player_Y_Position     ;compare result with player's vertical coordinate
00B860  1  90 F0              bcc Floatdown             ;if modified vertical less than player's, branch
00B862  1  A9 00              lda #$00
00B864  1  95 A0              sta BlooperMoveCounter,x  ;otherwise nullify movement counter
00B866  1  60                 rts
00B867  1               
00B867  1               ;--------------------------------
00B867  1               
00B867  1               MoveBulletBill:
00B867  1  B5 1E                 lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
00B869  1  29 20                 and #%00100000
00B86B  1  F0 03                 beq NotDefB                ;if not set, continue with movement code
00B86D  1  4C 8E AB              jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
00B870  1  A9 E8        NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
00B872  1  95 58                 sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
00B874  1  4C FE AA              jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
00B877  1               
00B877  1               ;--------------------------------
00B877  1               ;$02 - used to hold preset values
00B877  1               ;$03 - used to hold enemy state
00B877  1               
00B877  1               SwimCCXMoveData:
00B877  1  40 80              .byte $40, $80
00B879  1  04 04              .byte $04, $04 ;residual data, not used
00B87B  1               
00B87B  1               MoveSwimmingCheepCheep:
00B87B  1  B5 1E                lda Enemy_State,x         ;check cheep-cheep's enemy object state
00B87D  1  29 20                and #%00100000            ;for d5 set
00B87F  1  F0 03                beq CCSwim                ;if not set, continue with movement code
00B881  1  4C 88 AB             jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
00B884  1  85 03        CCSwim: sta $03                   ;save enemy state in $03
00B886  1  B5 16                lda Enemy_ID,x            ;get enemy identifier
00B888  1  38                   sec
00B889  1  E9 0A                sbc #$0a                  ;subtract ten for cheep-cheep identifiers
00B88B  1  A8                   tay                       ;use as offset
00B88C  1  B9 77 B8             lda SwimCCXMoveData,y     ;load value here
00B88F  1  85 02                sta $02
00B891  1  BD 01 04             lda Enemy_X_MoveForce,x   ;load horizontal force
00B894  1  38                   sec
00B895  1  E5 02                sbc $02                   ;subtract preset value from horizontal force
00B897  1  9D 01 04             sta Enemy_X_MoveForce,x   ;store as new horizontal force
00B89A  1  B5 87                lda Enemy_X_Position,x    ;get horizontal coordinate
00B89C  1  E9 00                sbc #$00                  ;subtract borrow (thus moving it slowly)
00B89E  1  95 87                sta Enemy_X_Position,x    ;and save as new horizontal coordinate
00B8A0  1  B5 6E                lda Enemy_PageLoc,x
00B8A2  1  E9 00                sbc #$00                  ;subtract borrow again, this time from the
00B8A4  1  95 6E                sta Enemy_PageLoc,x       ;page location, then save
00B8A6  1  A9 40                lda #$40
00B8A8  1  85 02                sta $02                   ;save new value here
00B8AA  1  E0 02                cpx #$02                  ;check enemy object offset
00B8AC  1  90 49                bcc ExSwCC                ;if in first or second slot, branch to leave
00B8AE  1  B5 58                lda CheepCheepMoveMFlag,x ;check movement flag
00B8B0  1  C9 10                cmp #$10                  ;if movement speed set to $00,
00B8B2  1  90 16                bcc CCSwimUpwards         ;branch to move upwards
00B8B4  1  BD 17 04             lda Enemy_YMF_Dummy,x
00B8B7  1  18                   clc
00B8B8  1  65 02                adc $02                   ;add preset value to dummy variable to get carry
00B8BA  1  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00B8BD  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00B8BF  1  65 03                adc $03                   ;add carry to it plus enemy state to slowly move it downwards
00B8C1  1  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00B8C3  1  B5 B6                lda Enemy_Y_HighPos,x
00B8C5  1  69 00                adc #$00                  ;add carry to page location and
00B8C7  1  4C DD B8             jmp ChkSwimYPos           ;jump to end of movement code
00B8CA  1               
00B8CA  1               CCSwimUpwards:
00B8CA  1  BD 17 04             lda Enemy_YMF_Dummy,x
00B8CD  1  38                   sec
00B8CE  1  E5 02                sbc $02                   ;subtract preset value to dummy variable to get borrow
00B8D0  1  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00B8D3  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00B8D5  1  E5 03                sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
00B8D7  1  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00B8D9  1  B5 B6                lda Enemy_Y_HighPos,x
00B8DB  1  E9 00                sbc #$00                  ;subtract borrow from page location
00B8DD  1               
00B8DD  1               ChkSwimYPos:
00B8DD  1  95 B6                sta Enemy_Y_HighPos,x     ;save new page location here
00B8DF  1  A0 00                ldy #$00                  ;load movement speed to upwards by default
00B8E1  1  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00B8E3  1  38                   sec
00B8E4  1  FD 34 04             sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
00B8E7  1  10 07                bpl YPDiff                ;if result positive, skip to next part
00B8E9  1  A0 10                ldy #$10                  ;otherwise load movement speed to downwards
00B8EB  1  49 FF                eor #$ff
00B8ED  1  18                   clc                       ;get two's compliment of result
00B8EE  1  69 01                adc #$01                  ;to obtain total difference of original vs. current
00B8F0  1  C9 0F        YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
00B8F2  1  90 03                bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
00B8F4  1  98                   tya
00B8F5  1  95 58                sta CheepCheepMoveMFlag,x ;otherwise change movement speed
00B8F7  1  60           ExSwCC: rts                       ;leave
00B8F8  1               
00B8F8  1               ;--------------------------------
00B8F8  1               ;$00 - used as counter for firebar parts
00B8F8  1               ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
00B8F8  1               ;$02 - used for oscillated high byte of spin state or to hold vertical adder
00B8F8  1               ;$03 - used for mirror data
00B8F8  1               ;$04 - used to store player's sprite 1 X coordinate
00B8F8  1               ;$05 - used to evaluate mirror data
00B8F8  1               ;$06 - used to store either screen X coordinate or sprite data offset
00B8F8  1               ;$07 - used to store screen Y coordinate
00B8F8  1               ;$ed - used to hold maximum length of firebar
00B8F8  1               ;$ef - used to hold high byte of spinstate
00B8F8  1               
00B8F8  1               ;horizontal adder is at first byte + high byte of spinstate,
00B8F8  1               ;vertical adder is same + 8 bytes, two's compliment
00B8F8  1               ;if greater than $08 for proper oscillation
00B8F8  1               FirebarPosLookupTbl:
00B8F8  1  00 01 03 04        .byte $00, $01, $03, $04, $05, $06, $07, $07, $08
00B8FC  1  05 06 07 07  
00B900  1  08           
00B901  1  00 03 06 09        .byte $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
00B905  1  0B 0D 0E 0F  
00B909  1  10           
00B90A  1  00 04 09 0D        .byte $00, $04, $09, $0d, $10, $13, $16, $17, $18
00B90E  1  10 13 16 17  
00B912  1  18           
00B913  1  00 06 0C 12        .byte $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
00B917  1  16 1A 1D 1F  
00B91B  1  20           
00B91C  1  00 07 0F 16        .byte $00, $07, $0f, $16, $1c, $21, $25, $27, $28
00B920  1  1C 21 25 27  
00B924  1  28           
00B925  1  00 09 12 1B        .byte $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
00B929  1  21 27 2C 2F  
00B92D  1  30           
00B92E  1  00 0B 15 1F        .byte $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
00B932  1  27 2E 33 37  
00B936  1  38           
00B937  1  00 0C 18 24        .byte $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
00B93B  1  2D 35 3B 3E  
00B93F  1  40           
00B940  1  00 0E 1B 28        .byte $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
00B944  1  32 3B 42 46  
00B948  1  48           
00B949  1  00 0F 1F 2D        .byte $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
00B94D  1  38 42 4A 4E  
00B951  1  50           
00B952  1  00 11 22 31        .byte $00, $11, $22, $31, $3e, $49, $51, $56, $58
00B956  1  3E 49 51 56  
00B95A  1  58           
00B95B  1               
00B95B  1               FirebarMirrorData:
00B95B  1  01 03 02 00        .byte $01, $03, $02, $00
00B95F  1               
00B95F  1               FirebarTblOffsets:
00B95F  1  00 09 12 1B        .byte $00, $09, $12, $1b, $24, $2d
00B963  1  24 2D        
00B965  1  36 3F 48 51        .byte $36, $3f, $48, $51, $5a, $63
00B969  1  5A 63        
00B96B  1               
00B96B  1               FirebarYPos:
00B96B  1  0C 18              .byte $0c, $18
00B96D  1               
00B96D  1               ProcFirebar:
00B96D  1  20 79 DE               jsr GetEnemyOffscreenBits   ;get offscreen information
00B970  1  AD D1 03               lda Enemy_OffscreenBits     ;check for d3 set
00B973  1  29 08                  and #%00001000              ;if so, branch to leave
00B975  1  D0 74                  bne SkipFBar
00B977  1  AD 47 07               lda TimerControl            ;if master timer control set, branch
00B97A  1  D0 0A                  bne SusFbar                 ;ahead of this part
00B97C  1  BD 88 03               lda FirebarSpinSpeed,x      ;load spinning speed of firebar
00B97F  1  20 3C C0               jsr FirebarSpin             ;modify current spinstate
00B982  1  29 1F                  and #%00011111              ;mask out all but 5 LSB
00B984  1  95 A0                  sta FirebarSpinState_High,x ;and store as new high byte of spinstate
00B986  1  B5 A0        SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
00B988  1  B4 16                  ldy Enemy_ID,x              ;check enemy identifier
00B98A  1  C0 1F                  cpy #$1f
00B98C  1  90 0D                  bcc SetupGFB                ;if < $1f (long firebar), branch
00B98E  1  C9 08                  cmp #$08                    ;check high byte of spinstate
00B990  1  F0 04                  beq SkpFSte                 ;if eight, branch to change
00B992  1  C9 18                  cmp #$18
00B994  1  D0 05                  bne SetupGFB                ;if not at twenty-four branch to not change
00B996  1  18           SkpFSte:  clc
00B997  1  69 01                  adc #$01                    ;add one to spinning thing to avoid horizontal state
00B999  1  95 A0                  sta FirebarSpinState_High,x
00B99B  1  85 EF        SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
00B99D  1  20 1C DE               jsr RelativeEnemyPosition   ;get relative coordinates to screen
00B9A0  1  20 BF BA               jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
00B9A3  1  BC E5 06               ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B9A6  1  AD B9 03               lda Enemy_Rel_YPos          ;get relative vertical coordinate
00B9A9  1  99 00 02               sta Sprite_Y_Position,y     ;store as Y in OAM data
00B9AC  1  85 07                  sta $07                     ;also save here
00B9AE  1  AD AE 03               lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00B9B1  1  99 03 02               sta Sprite_X_Position,y     ;store as X in OAM data
00B9B4  1  85 06                  sta $06                     ;also save here
00B9B6  1  A9 01                  lda #$01
00B9B8  1  85 00                  sta $00                     ;set $01 value here (not necessary)
00B9BA  1  20 39 BA               jsr FirebarCollision        ;draw fireball part and do collision detection
00B9BD  1  A0 05                  ldy #$05                    ;load value for short firebars by default
00B9BF  1  B5 16                  lda Enemy_ID,x
00B9C1  1  C9 1F                  cmp #$1f                    ;are we doing a long firebar?
00B9C3  1  90 02                  bcc SetMFbar                ;no, branch then
00B9C5  1  A0 0B                  ldy #$0b                    ;otherwise load value for long firebars
00B9C7  1  84 ED        SetMFbar: sty $ed                     ;store maximum value for length of firebars
00B9C9  1  A9 00                  lda #$00
00B9CB  1  85 00                  sta $00                     ;initialize counter here
00B9CD  1  A5 EF        DrawFbar: lda $ef                     ;load high byte of spinstate
00B9CF  1  20 BF BA               jsr GetFirebarPosition      ;get fireball position data depending on firebar part
00B9D2  1  20 EC B9               jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
00B9D5  1  A5 00                  lda $00                     ;check which firebar part
00B9D7  1  C9 04                  cmp #$04
00B9D9  1  D0 08                  bne NextFbar
00B9DB  1  AC CF 06               ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
00B9DE  1  B9 E5 06               lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
00B9E1  1  85 06                  sta $06                     ;using long firebar offset, then store as new one here
00B9E3  1  E6 00        NextFbar: inc $00                     ;move onto the next firebar part
00B9E5  1  A5 00                  lda $00
00B9E7  1  C5 ED                  cmp $ed                     ;if we end up at the maximum part, go on and leave
00B9E9  1  90 E2                  bcc DrawFbar                ;otherwise go back and do another
00B9EB  1  60           SkipFBar: rts
00B9EC  1               
00B9EC  1               DrawFirebar_Collision:
00B9EC  1  A5 03                 lda $03                  ;store mirror data elsewhere
00B9EE  1  85 05                 sta $05
00B9F0  1  A4 06                 ldy $06                  ;load OAM data offset for firebar
00B9F2  1  A5 01                 lda $01                  ;load horizontal adder we got from position loader
00B9F4  1  46 05                 lsr $05                  ;shift LSB of mirror data
00B9F6  1  B0 04                 bcs AddHA                ;if carry was set, skip this part
00B9F8  1  49 FF                 eor #$ff
00B9FA  1  69 01                 adc #$01                 ;otherwise get two's compliment of horizontal adder
00B9FC  1  18           AddHA:   clc                      ;add horizontal coordinate relative to screen to
00B9FD  1  6D AE 03              adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
00BA00  1  99 03 02              sta Sprite_X_Position,y  ;store as X coordinate here
00BA03  1  85 06                 sta $06                  ;store here for now, note offset is saved in Y still
00BA05  1  CD AE 03              cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
00BA08  1  B0 09                 bcs SubtR1               ;if sprite coordinate => original coordinate, branch
00BA0A  1  AD AE 03              lda Enemy_Rel_XPos
00BA0D  1  38                    sec                      ;otherwise subtract sprite X from the
00BA0E  1  E5 06                 sbc $06                  ;original one and skip this part
00BA10  1  4C 17 BA              jmp ChkFOfs
00BA13  1  38           SubtR1:  sec                      ;subtract original X from the
00BA14  1  ED AE 03              sbc Enemy_Rel_XPos       ;current sprite X
00BA17  1  C9 59        ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
00BA19  1  90 04                 bcc VAHandl              ;continue by handling vertical adder
00BA1B  1  A9 F8                 lda #$f8                 ;otherwise, load offscreen Y coordinate
00BA1D  1  D0 15                 bne SetVFbr              ;and unconditionally branch to move sprite offscreen
00BA1F  1  AD B9 03     VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
00BA22  1  C9 F8                 cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
00BA24  1  F0 0E                 beq SetVFbr
00BA26  1  A5 02                 lda $02                  ;load vertical adder we got from position loader
00BA28  1  46 05                 lsr $05                  ;shift LSB of mirror data one more time
00BA2A  1  B0 04                 bcs AddVA                ;if carry was set, skip this part
00BA2C  1  49 FF                 eor #$ff
00BA2E  1  69 01                 adc #$01                 ;otherwise get two's compliment of second part
00BA30  1  18           AddVA:   clc                      ;add vertical coordinate relative to screen to
00BA31  1  6D B9 03              adc Enemy_Rel_YPos       ;the second data, modified or otherwise
00BA34  1  99 00 02     SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
00BA37  1  85 07                 sta $07                  ;also store here for now
00BA39  1               
00BA39  1               FirebarCollision:
00BA39  1  20 AD D9              jsr DrawFirebar          ;run sub here to draw current tile of firebar
00BA3C  1  98                    tya                      ;return OAM data offset and save
00BA3D  1  48                    pha                      ;to the stack for now
00BA3E  1  AD 9F 07              lda StarInvincibleTimer  ;if star mario invincibility timer
00BA41  1  0D 47 07              ora TimerControl         ;or master timer controls set
00BA44  1  D0 70                 bne NoColFB              ;then skip all of this
00BA46  1  85 05                 sta $05                  ;otherwise initialize counter
00BA48  1  A4 B5                 ldy Player_Y_HighPos
00BA4A  1  88                    dey                      ;if player's vertical high byte offscreen,
00BA4B  1  D0 69                 bne NoColFB              ;skip all of this
00BA4D  1  A4 CE                 ldy Player_Y_Position    ;get player's vertical position
00BA4F  1  AD 54 07              lda PlayerSize           ;get player's size
00BA52  1  D0 05                 bne AdjSm                ;if player small, branch to alter variables
00BA54  1  AD 14 07              lda CrouchingFlag
00BA57  1  F0 09                 beq BigJp                ;if player big and not crouching, jump ahead
00BA59  1  E6 05        AdjSm:   inc $05                  ;if small or big but crouching, execute this part
00BA5B  1  E6 05                 inc $05                  ;first increment our counter twice (setting $02 as flag)
00BA5D  1  98                    tya
00BA5E  1  18                    clc                      ;then add 24 pixels to the player's
00BA5F  1  69 18                 adc #$18                 ;vertical coordinate
00BA61  1  A8                    tay
00BA62  1  98           BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
00BA63  1  38           FBCLoop: sec                      ;subtract vertical position of firebar
00BA64  1  E5 07                 sbc $07                  ;from the vertical coordinate of the player
00BA66  1  10 05                 bpl ChkVFBD              ;if player lower on the screen than firebar,
00BA68  1  49 FF                 eor #$ff                 ;skip two's compliment part
00BA6A  1  18                    clc                      ;otherwise get two's compliment
00BA6B  1  69 01                 adc #$01
00BA6D  1  C9 08        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
00BA6F  1  B0 1C                 bcs Chk2Ofs
00BA71  1  A5 06                 lda $06                  ;if firebar on far right on the screen, skip this,
00BA73  1  C9 F0                 cmp #$f0                 ;because, really, what's the point?
00BA75  1  B0 16                 bcs Chk2Ofs
00BA77  1  AD 07 02              lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
00BA7A  1  18                    clc
00BA7B  1  69 04                 adc #$04                 ;add four pixels
00BA7D  1  85 04                 sta $04                  ;store here
00BA7F  1  38                    sec                      ;subtract horizontal coordinate of firebar
00BA80  1  E5 06                 sbc $06                  ;from the X coordinate of player's sprite 1
00BA82  1  10 05                 bpl ChkFBCl              ;if modded X coordinate to the right of firebar
00BA84  1  49 FF                 eor #$ff                 ;skip two's compliment part
00BA86  1  18                    clc                      ;otherwise get two's compliment
00BA87  1  69 01                 adc #$01
00BA89  1  C9 08        ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
00BA8B  1  90 13                 bcc ChgSDir              ;to process
00BA8D  1  A5 05        Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
00BA8F  1  C9 02                 cmp #$02                 ;branch to increment OAM offset and leave, no collision
00BA91  1  F0 23                 beq NoColFB
00BA93  1  A4 05                 ldy $05                  ;otherwise get temp here and use as offset
00BA95  1  A5 CE                 lda Player_Y_Position
00BA97  1  18                    clc
00BA98  1  79 6B B9              adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
00BA9B  1  E6 05                 inc $05                  ;then increment temp and jump back
00BA9D  1  4C 63 BA              jmp FBCLoop
00BAA0  1  A2 01        ChgSDir: ldx #$01                 ;set movement direction by default
00BAA2  1  A5 04                 lda $04                  ;if OAM X coordinate of player's sprite 1
00BAA4  1  C5 06                 cmp $06                  ;is greater than horizontal coordinate of firebar
00BAA6  1  B0 01                 bcs SetSDir              ;then do not alter movement direction
00BAA8  1  E8                    inx                      ;otherwise increment it
00BAA9  1  86 46        SetSDir: stx Enemy_MovingDir      ;store movement direction here
00BAAB  1  A2 00                 ldx #$00
00BAAD  1  A5 00                 lda $00                  ;save value written to $00 to stack
00BAAF  1  48                    pha
00BAB0  1  20 7F C5              jsr InjurePlayer         ;perform sub to hurt or kill player
00BAB3  1  68                    pla
00BAB4  1  85 00                 sta $00                  ;get value of $00 from stack
00BAB6  1  68           NoColFB: pla                      ;get OAM data offset
00BAB7  1  18                    clc                      ;add four to it and save
00BAB8  1  69 04                 adc #$04
00BABA  1  85 06                 sta $06
00BABC  1  A6 08                 ldx ObjectOffset         ;get enemy object buffer offset and leave
00BABE  1  60                    rts
00BABF  1               
00BABF  1               GetFirebarPosition:
00BABF  1  48                      pha                        ;save high byte of spinstate to the stack
00BAC0  1  29 0F                   and #%00001111             ;mask out low nybble
00BAC2  1  C9 09                   cmp #$09
00BAC4  1  90 05                   bcc GetHAdder              ;if lower than $09, branch ahead
00BAC6  1  49 0F                   eor #%00001111             ;otherwise get two's compliment to oscillate
00BAC8  1  18                      clc
00BAC9  1  69 01                   adc #$01
00BACB  1  85 01        GetHAdder: sta $01                    ;store result, modified or not, here
00BACD  1  A4 00                   ldy $00                    ;load number of firebar ball where we're at
00BACF  1  B9 5F B9                lda FirebarTblOffsets,y    ;load offset to firebar position data
00BAD2  1  18                      clc
00BAD3  1  65 01                   adc $01                    ;add oscillated high byte of spinstate
00BAD5  1  A8                      tay                        ;to offset here and use as new offset
00BAD6  1  B9 F8 B8                lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
00BAD9  1  85 01                   sta $01
00BADB  1  68                      pla                        ;pull whatever was in A from the stack
00BADC  1  48                      pha                        ;save it again because we still need it
00BADD  1  18                      clc
00BADE  1  69 08                   adc #$08                   ;add eight this time, to get vertical adder
00BAE0  1  29 0F                   and #%00001111             ;mask out high nybble
00BAE2  1  C9 09                   cmp #$09                   ;if lower than $09, branch ahead
00BAE4  1  90 05                   bcc GetVAdder
00BAE6  1  49 0F                   eor #%00001111             ;otherwise get two's compliment
00BAE8  1  18                      clc
00BAE9  1  69 01                   adc #$01
00BAEB  1  85 02        GetVAdder: sta $02                    ;store result here
00BAED  1  A4 00                   ldy $00
00BAEF  1  B9 5F B9                lda FirebarTblOffsets,y    ;load offset to firebar position data again
00BAF2  1  18                      clc
00BAF3  1  65 02                   adc $02                    ;this time add value in $02 to offset here and use as offset
00BAF5  1  A8                      tay
00BAF6  1  B9 F8 B8                lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
00BAF9  1  85 02                   sta $02
00BAFB  1  68                      pla                        ;pull out whatever was in A one last time
00BAFC  1  4A                      lsr                        ;divide by eight or shift three to the right
00BAFD  1  4A                      lsr
00BAFE  1  4A                      lsr
00BAFF  1  A8                      tay                        ;use as offset
00BB00  1  B9 5B B9                lda FirebarMirrorData,y    ;load mirroring data here
00BB03  1  85 03                   sta $03                    ;store
00BB05  1  60                      rts
00BB06  1               
00BB06  1               ;--------------------------------
00BB06  1               
00BB06  1               PRandomSubtracter:
00BB06  1  F8 A0 70 BD        .byte $f8, $a0, $70, $bd, $00
00BB0A  1  00           
00BB0B  1               
00BB0B  1               FlyCCBPriority:
00BB0B  1  20 20 20 00        .byte $20, $20, $20, $00, $00
00BB0F  1  00           
00BB10  1               
00BB10  1               MoveFlyingCheepCheep:
00BB10  1  B5 1E                lda Enemy_State,x          ;check cheep-cheep's enemy state
00BB12  1  29 20                and #%00100000             ;for d5 set
00BB14  1  F0 08                beq FlyCC                  ;branch to continue code if not set
00BB16  1  A9 00                lda #$00
00BB18  1  9D C5 03             sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
00BB1B  1  4C 8E AB             jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
00BB1E  1  20 FE AA     FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
00BB21  1  A0 0D                ldy #$0d                   ;set vertical movement amount
00BB23  1  A9 05                lda #$05                   ;set maximum speed
00BB25  1  20 92 AB             jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
00BB28  1  BD 34 04             lda Enemy_Y_MoveForce,x
00BB2B  1  4A                   lsr                        ;get vertical movement force and
00BB2C  1  4A                   lsr                        ;move high nybble to low
00BB2D  1  4A                   lsr
00BB2E  1  4A                   lsr
00BB2F  1  A8                   tay                        ;save as offset (note this tends to go into reach of code)
00BB30  1  B5 CF                lda Enemy_Y_Position,x     ;get vertical position
00BB32  1  38                   sec                        ;subtract pseudorandom value based on offset from position
00BB33  1  F9 06 BB             sbc PRandomSubtracter,y
00BB36  1  10 05                bpl AddCCF                  ;if result within top half of screen, skip this part
00BB38  1  49 FF                eor #$ff
00BB3A  1  18                   clc                        ;otherwise get two's compliment
00BB3B  1  69 01                adc #$01
00BB3D  1  C9 08        AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
00BB3F  1  B0 0E                bcs BPGet                  ;skip to the end without changing movement force
00BB41  1  BD 34 04             lda Enemy_Y_MoveForce,x
00BB44  1  18                   clc
00BB45  1  69 10                adc #$10                   ;otherwise add to it
00BB47  1  9D 34 04             sta Enemy_Y_MoveForce,x
00BB4A  1  4A                   lsr                        ;move high nybble to low again
00BB4B  1  4A                   lsr
00BB4C  1  4A                   lsr
00BB4D  1  4A                   lsr
00BB4E  1  A8                   tay
00BB4F  1  B9 0B BB     BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
00BB52  1  9D C5 03             sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
00BB55  1  60                   rts                        ;drawing it next frame), then leave
00BB56  1               
00BB56  1               ;--------------------------------
00BB56  1               ;$00 - used to hold horizontal difference
00BB56  1               ;$01-$03 - used to hold difference adjusters
00BB56  1               
00BB56  1               LakituDiffAdj:
00BB56  1  15 30 40           .byte $15, $30, $40
00BB59  1               
00BB59  1               MoveLakitu:
00BB59  1  B5 1E                 lda Enemy_State,x          ;check lakitu's enemy state
00BB5B  1  29 20                 and #%00100000             ;for d5 set
00BB5D  1  F0 03                 beq ChkLS                  ;if not set, continue with code
00BB5F  1  4C 5F AB              jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
00BB62  1  B5 1E        ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
00BB64  1  F0 0B                 beq Fr12S                  ;go ahead and continue with code
00BB66  1  A9 00                 lda #$00
00BB68  1  95 A0                 sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
00BB6A  1  8D CB 06              sta EnemyFrenzyBuffer      ;initialize frenzy buffer
00BB6D  1  A9 10                 lda #$10
00BB6F  1  D0 13                 bne SetLSpd                ;load horizontal speed and do unconditional branch
00BB71  1  A9 12        Fr12S:   lda #Spiny
00BB73  1  8D CB 06              sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
00BB76  1  A0 02                 ldy #$02
00BB78  1  B9 56 BB     LdLDa:   lda LakituDiffAdj,y        ;load values
00BB7B  1  99 01 00              sta $0001,y                ;store in zero page
00BB7E  1  88                    dey
00BB7F  1  10 F7                 bpl LdLDa                  ;do this until all values are stired
00BB81  1  20 9D BB              jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
00BB84  1  95 58        SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
00BB86  1  A0 01                 ldy #$01                   ;set moving direction to right by default
00BB88  1  B5 A0                 lda LakituMoveDirection,x
00BB8A  1  29 01                 and #$01                   ;get LSB of moving direction
00BB8C  1  D0 0A                 bne SetLMov                ;if set, branch to the end to use moving direction
00BB8E  1  B5 58                 lda LakituMoveSpeed,x
00BB90  1  49 FF                 eor #$ff                   ;get two's compliment of moving speed
00BB92  1  18                    clc
00BB93  1  69 01                 adc #$01
00BB95  1  95 58                 sta LakituMoveSpeed,x      ;store as new moving speed
00BB97  1  C8                    iny                        ;increment moving direction to left
00BB98  1  94 46        SetLMov: sty Enemy_MovingDir,x      ;store moving direction
00BB9A  1  4C FE AA              jmp MoveEnemyHorizontally  ;move lakitu horizontally
00BB9D  1               
00BB9D  1               PlayerLakituDiff:
00BB9D  1  A0 00                   ldy #$00                   ;set Y for default value
00BB9F  1  20 BC CD                jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
00BBA2  1  10 0A                   bpl ChkLakDif              ;branch if enemy is to the right of the player
00BBA4  1  C8                      iny                        ;increment Y for left of player
00BBA5  1  A5 00                   lda $00
00BBA7  1  49 FF                   eor #$ff                   ;get two's compliment of low byte of horizontal difference
00BBA9  1  18                      clc
00BBAA  1  69 01                   adc #$01                   ;store two's compliment as horizontal difference
00BBAC  1  85 00                   sta $00
00BBAE  1  A5 00        ChkLakDif: lda $00                    ;get low byte of horizontal difference
00BBB0  1  C9 3C                   cmp #$3c                   ;if within a certain distance of player, branch
00BBB2  1  90 1C                   bcc ChkPSpeed
00BBB4  1  A9 3C                   lda #$3c                   ;otherwise set maximum distance
00BBB6  1  85 00                   sta $00
00BBB8  1  B5 16                   lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
00BBBA  1  C9 11                   cmp #Lakitu
00BBBC  1  D0 12                   bne ChkPSpeed              ;if not, branch elsewhere
00BBBE  1  98                      tya                        ;compare contents of Y, now in A
00BBBF  1  D5 A0                   cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
00BBC1  1  F0 0D                   beq ChkPSpeed              ;if moving toward the player, branch, do not alter
00BBC3  1  B5 A0                   lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
00BBC5  1  F0 06                   beq SetLMovD               ;branch and alter without delay
00BBC7  1  D6 58                   dec LakituMoveSpeed,x      ;decrement horizontal speed
00BBC9  1  B5 58                   lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
00BBCB  1  D0 40                   bne ExMoveLak
00BBCD  1  98           SetLMovD:  tya                        ;set horizontal direction depending on horizontal
00BBCE  1  95 A0                   sta LakituMoveDirection,x  ;difference between enemy and player if necessary
00BBD0  1  A5 00        ChkPSpeed: lda $00
00BBD2  1  29 3C                   and #%00111100             ;mask out all but four bits in the middle
00BBD4  1  4A                      lsr                        ;divide masked difference by four
00BBD5  1  4A                      lsr
00BBD6  1  85 00                   sta $00                    ;store as new value
00BBD8  1  A0 00                   ldy #$00                   ;init offset
00BBDA  1  A5 57                   lda Player_X_Speed
00BBDC  1  F0 24                   beq SubDifAdj              ;if player not moving horizontally, branch
00BBDE  1  AD 75 07                lda ScrollAmount
00BBE1  1  F0 1F                   beq SubDifAdj              ;if scroll speed not set, branch to same place
00BBE3  1  C8                      iny                        ;otherwise increment offset
00BBE4  1  A5 57                   lda Player_X_Speed
00BBE6  1  C9 19                   cmp #$19                   ;if player not running, branch
00BBE8  1  90 08                   bcc ChkSpinyO
00BBEA  1  AD 75 07                lda ScrollAmount
00BBED  1  C9 02                   cmp #$02                   ;if scroll speed below a certain amount, branch
00BBEF  1  90 01                   bcc ChkSpinyO              ;to same place
00BBF1  1  C8                      iny                        ;otherwise increment once more
00BBF2  1  B5 16        ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
00BBF4  1  C9 12                   cmp #Spiny
00BBF6  1  D0 04                   bne ChkEmySpd              ;branch if not found
00BBF8  1  A5 57                   lda Player_X_Speed         ;if player not moving, skip this part
00BBFA  1  D0 06                   bne SubDifAdj
00BBFC  1  B5 A0        ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
00BBFE  1  D0 02                   bne SubDifAdj              ;branch if nonzero
00BC00  1  A0 00                   ldy #$00                   ;otherwise reinit offset
00BC02  1  B9 01 00     SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
00BC05  1  A4 00                   ldy $00                    ;get saved horizontal difference
00BC07  1  38           SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
00BC08  1  E9 01                   sbc #$01                   ;from one of three saved values
00BC0A  1  88                      dey
00BC0B  1  10 FA                   bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
00BC0D  1  60           ExMoveLak: rts                        ;leave!!!
00BC0E  1               
00BC0E  1               ;-------------------------------------------------------------------------------------
00BC0E  1               ;$04-$05 - used to store name table address in little endian order
00BC0E  1               
00BC0E  1               BridgeCollapseData:
00BC0E  1  1A                 .byte $1a ;axe
00BC0F  1  58                 .byte $58 ;chain
00BC10  1  98 96 94 92        .byte $98, $96, $94, $92, $90, $8e, $8c ;bridge
00BC14  1  90 8E 8C     
00BC17  1  8A 88 86 84        .byte $8a, $88, $86, $84, $82, $80
00BC1B  1  82 80        
00BC1D  1               
00BC1D  1               BridgeCollapse:
00BC1D  1  AE 68 03            ldx BowserFront_Offset    ;get enemy offset for bowser
00BC20  1  B5 16               lda Enemy_ID,x            ;check enemy object identifier for bowser
00BC22  1  C9 2D               cmp #Bowser               ;if not found, branch ahead,
00BC24  1  D0 10               bne SetM2                 ;metatile removal not necessary
00BC26  1  86 08               stx ObjectOffset          ;store as enemy offset here
00BC28  1  B5 1E               lda Enemy_State,x         ;if bowser in normal state, skip all of this
00BC2A  1  F0 1A               beq RemoveBridge
00BC2C  1  29 40               and #%01000000            ;if bowser's state has d6 clear, skip to silence music
00BC2E  1  F0 06               beq SetM2
00BC30  1  B5 CF               lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
00BC32  1  C9 E0               cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
00BC34  1  90 0A               bcc MoveD_Bowser
00BC36  1  A9 80        SetM2: lda #Silence              ;silence music
00BC38  1  85 FC               sta EventMusicQueue
00BC3A  1  EE 72 07            inc OperMode_Task         ;move onto next secondary mode in victory mode
00BC3D  1  4C A2 BC            jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
00BC40  1               
00BC40  1               MoveD_Bowser:
00BC40  1  20 88 AB            jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
00BC43  1  4C AC BD            jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
00BC46  1               
00BC46  1               RemoveBridge:
00BC46  1  CE 64 03              dec BowserFeetCounter     ;decrement timer to control bowser's feet
00BC49  1  D0 44                 bne NoBFall               ;if not expired, skip all of this
00BC4B  1  A9 04                 lda #$04
00BC4D  1  8D 64 03              sta BowserFeetCounter     ;otherwise, set timer now
00BC50  1  AD 63 03              lda BowserBodyControls
00BC53  1  49 01                 eor #$01                  ;invert bit to control bowser's feet
00BC55  1  8D 63 03              sta BowserBodyControls
00BC58  1  A9 22                 lda #$22                  ;put high byte of name table address here for now
00BC5A  1  85 05                 sta $05
00BC5C  1  AC 69 03              ldy BridgeCollapseOffset  ;get bridge collapse offset here
00BC5F  1  B9 0E BC              lda BridgeCollapseData,y  ;load low byte of name table address and store here
00BC62  1  85 04                 sta $04
00BC64  1  AC 00 03              ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
00BC67  1  C8                    iny
00BC68  1  A2 0C                 ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
00BC6A  1  20 82 89              jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
00BC6D  1  A6 08                 ldx ObjectOffset          ;get enemy offset
00BC6F  1  20 44 89              jsr MoveVOffset           ;set new vram buffer offset
00BC72  1  A9 08                 lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
00BC74  1  85 FE                 sta Square2SoundQueue     ;queue while at the same time loading the brick
00BC76  1  A9 01                 lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
00BC78  1  85 FD                 sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
00BC7A  1  EE 69 03              inc BridgeCollapseOffset  ;increment bridge collapse offset
00BC7D  1  AD 69 03              lda BridgeCollapseOffset
00BC80  1  C9 0F                 cmp #$0f                  ;if bridge collapse offset has not yet reached
00BC82  1  D0 0B                 bne NoBFall               ;the end, go ahead and skip this part
00BC84  1  20 6E AF              jsr InitVStf              ;initialize whatever vertical speed bowser has
00BC87  1  A9 40                 lda #%01000000
00BC89  1  95 1E                 sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
00BC8B  1  A9 80                 lda #Sfx_BowserFall
00BC8D  1  85 FE                 sta Square2SoundQueue     ;play bowser defeat sound
00BC8F  1  4C AC BD     NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
00BC92  1               
00BC92  1               ;--------------------------------
00BC92  1               
00BC92  1               PRandomRange:
00BC92  1  21 41 11 31        .byte $21, $41, $11, $31
00BC96  1               
00BC96  1               RunBowser:
00BC96  1  B5 1E              lda Enemy_State,x       ;if d5 in enemy state is not set
00BC98  1  29 20              and #%00100000          ;then branch elsewhere to run bowser
00BC9A  1  F0 14              beq BowserControl
00BC9C  1  B5 CF              lda Enemy_Y_Position,x  ;otherwise check vertical position
00BC9E  1  C9 E0              cmp #$e0                ;if above a certain point, branch to move defeated bowser
00BCA0  1  90 9E              bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
00BCA2  1               
00BCA2  1               KillAllEnemies:
00BCA2  1  A2 04                  ldx #$04              ;start with last enemy slot
00BCA4  1  20 C9 B5     KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
00BCA7  1  CA                     dex                   ;move onto next enemy slot
00BCA8  1  10 FA                  bpl KillLoop          ;do this until all slots are emptied
00BCAA  1  8D CB 06               sta EnemyFrenzyBuffer ;empty frenzy buffer
00BCAD  1  A6 08                  ldx ObjectOffset      ;get enemy object offset and leave
00BCAF  1  60                     rts
00BCB0  1               
00BCB0  1               BowserControl:
00BCB0  1  A9 00                   lda #$00
00BCB2  1  8D CB 06                sta EnemyFrenzyBuffer      ;empty frenzy buffer
00BCB5  1  AD 47 07                lda TimerControl           ;if master timer control not set,
00BCB8  1  F0 03                   beq ChkMouth               ;skip jump and execute code here
00BCBA  1  4C 6A BD                jmp SkipToFB               ;otherwise, jump over a bunch of code
00BCBD  1  AD 63 03     ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
00BCC0  1  10 03                   bpl FeetTmr                ;if bit clear, go ahead with code here
00BCC2  1  4C 40 BD                jmp HammerChk              ;otherwise skip a whole section starting here
00BCC5  1  CE 64 03     FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
00BCC8  1  D0 0D                   bne ResetMDr               ;if not expired, skip this part
00BCCA  1  A9 20                   lda #$20                   ;otherwise, reset timer
00BCCC  1  8D 64 03                sta BowserFeetCounter
00BCCF  1  AD 63 03                lda BowserBodyControls     ;and invert bit used
00BCD2  1  49 01                   eor #%00000001             ;to control bowser's feet
00BCD4  1  8D 63 03                sta BowserBodyControls
00BCD7  1  A5 09        ResetMDr:  lda FrameCounter           ;check frame counter
00BCD9  1  29 0F                   and #%00001111             ;if not on every sixteenth frame, skip
00BCDB  1  D0 04                   bne B_FaceP                ;ahead to continue code
00BCDD  1  A9 02                   lda #$02                   ;otherwise reset moving/facing direction every
00BCDF  1  95 46                   sta Enemy_MovingDir,x      ;sixteen frames
00BCE1  1  BD 8A 07     B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
00BCE4  1  F0 1C                   beq GetPRCmp               ;branch to next section
00BCE6  1  20 BC CD                jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
00BCE9  1  10 17                   bpl GetPRCmp               ;and branch if bowser to the right of the player
00BCEB  1  A9 01                   lda #$01
00BCED  1  95 46                   sta Enemy_MovingDir,x      ;set bowser to move and face to the right
00BCEF  1  A9 02                   lda #$02
00BCF1  1  8D 65 03                sta BowserMovementSpeed    ;set movement speed
00BCF4  1  A9 20                   lda #$20
00BCF6  1  9D 8A 07                sta EnemyFrameTimer,x      ;set timer here
00BCF9  1  8D 90 07                sta BowserFireBreathTimer  ;set timer used for bowser's flame
00BCFC  1  B5 87                   lda Enemy_X_Position,x
00BCFE  1  C9 C8                   cmp #$c8                   ;if bowser to the right past a certain point,
00BD00  1  B0 3E                   bcs HammerChk              ;skip ahead to some other section
00BD02  1  A5 09        GetPRCmp:  lda FrameCounter           ;get frame counter
00BD04  1  29 03                   and #%00000011
00BD06  1  D0 38                   bne HammerChk              ;execute this code every fourth frame, otherwise branch
00BD08  1  B5 87                   lda Enemy_X_Position,x
00BD0A  1  CD 66 03                cmp BowserOrigXPos         ;if bowser not at original horizontal position,
00BD0D  1  D0 0C                   bne GetDToO                ;branch to skip this part
00BD0F  1  BD A7 07                lda PseudoRandomBitReg,x
00BD12  1  29 03                   and #%00000011             ;get pseudorandom offset
00BD14  1  A8                      tay
00BD15  1  B9 92 BC                lda PRandomRange,y         ;load value using pseudorandom offset
00BD18  1  8D DC 06                sta MaxRangeFromOrigin     ;and store here
00BD1B  1  B5 87        GetDToO:   lda Enemy_X_Position,x
00BD1D  1  18                      clc                        ;add movement speed to bowser's horizontal
00BD1E  1  6D 65 03                adc BowserMovementSpeed    ;coordinate and save as new horizontal position
00BD21  1  95 87                   sta Enemy_X_Position,x
00BD23  1  B4 46                   ldy Enemy_MovingDir,x
00BD25  1  C0 01                   cpy #$01                   ;if bowser moving and facing to the right, skip ahead
00BD27  1  F0 17                   beq HammerChk
00BD29  1  A0 FF                   ldy #$ff                   ;set default movement speed here (move left)
00BD2B  1  38                      sec                        ;get difference of current vs. original
00BD2C  1  ED 66 03                sbc BowserOrigXPos         ;horizontal position
00BD2F  1  10 07                   bpl CompDToO               ;if current position to the right of original, skip ahead
00BD31  1  49 FF                   eor #$ff
00BD33  1  18                      clc                        ;get two's compliment
00BD34  1  69 01                   adc #$01
00BD36  1  A0 01                   ldy #$01                   ;set alternate movement speed here (move right)
00BD38  1  CD DC 06     CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
00BD3B  1  90 03                   bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
00BD3D  1  8C 65 03                sty BowserMovementSpeed    ;otherwise change bowser's movement speed
00BD40  1  BD 8A 07     HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
00BD43  1  D0 28                   bne MakeBJump              ;some other section of code
00BD45  1  20 88 AB                jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
00BD48  1  AD 5F 07                lda WorldNumber            ;check world number
00BD4B  1  C9 05                   cmp #World6
00BD4D  1  90 09                   bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
00BD4F  1  A5 09                   lda FrameCounter
00BD51  1  29 03                   and #%00000011             ;check to see if it's time to execute sub
00BD53  1  D0 03                   bne SetHmrTmr              ;if not, skip sub, otherwise
00BD55  1  20 8A A6                jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn hammer
00BD58  1  B5 CF        SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
00BD5A  1  C9 80                   cmp #$80                   ;if still above a certain point
00BD5C  1  90 1C                   bcc ChkFireB               ;then skip to world number check for flames
00BD5E  1  BD A7 07                lda PseudoRandomBitReg,x
00BD61  1  29 03                   and #%00000011             ;get pseudorandom offset
00BD63  1  A8                      tay
00BD64  1  B9 92 BC                lda PRandomRange,y         ;get value using pseudorandom offset
00BD67  1  9D 8A 07                sta EnemyFrameTimer,x      ;set for timer here
00BD6A  1  4C 7A BD     SkipToFB:  jmp ChkFireB               ;jump to execute flames code
00BD6D  1  C9 01        MakeBJump: cmp #$01                   ;if timer not yet about to expire,
00BD6F  1  D0 09                   bne ChkFireB               ;skip ahead to next part
00BD71  1  D6 CF                   dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
00BD73  1  20 6E AF                jsr InitVStf               ;initialize movement amount
00BD76  1  A9 FE                   lda #$fe
00BD78  1  95 A0                   sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
00BD7A  1  AD 5F 07     ChkFireB:  lda WorldNumber            ;check world number here
00BD7D  1  C9 07                   cmp #World8                ;world 8?
00BD7F  1  F0 04                   beq SpawnFBr               ;if so, execute this part here
00BD81  1  C9 05                   cmp #World6                ;world 6-7?
00BD83  1  B0 27                   bcs BowserGfxHandler       ;if so, skip this part here
00BD85  1  AD 90 07     SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
00BD88  1  D0 22                   bne BowserGfxHandler       ;if not expired yet, skip all of this
00BD8A  1  A9 20                   lda #$20
00BD8C  1  8D 90 07                sta BowserFireBreathTimer  ;set timer here
00BD8F  1  AD 63 03                lda BowserBodyControls
00BD92  1  49 80                   eor #%10000000             ;invert bowser's mouth bit to open
00BD94  1  8D 63 03                sta BowserBodyControls     ;and close bowser's mouth
00BD97  1  30 E1                   bmi ChkFireB               ;if bowser's mouth open, loop back
00BD99  1  20 0A BE                jsr SetFlameTimer          ;get timing for bowser's flame
00BD9C  1  AC CC 06                ldy SecondaryHardMode
00BD9F  1  F0 03                   beq SetFBTmr               ;if secondary hard mode flag not set, skip this
00BDA1  1  38                      sec
00BDA2  1  E9 10                   sbc #$10                   ;otherwise subtract from value in A
00BDA4  1  8D 90 07     SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
00BDA7  1  A9 15                   lda #BowserFlame           ;put bowser's flame identifier
00BDA9  1  8D CB 06                sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
00BDAC  1               
00BDAC  1               ;--------------------------------
00BDAC  1               
00BDAC  1               BowserGfxHandler:
00BDAC  1  20 ED BD               jsr ProcessBowserHalf    ;do a sub here to process bowser's front
00BDAF  1  A0 10                  ldy #$10                 ;load default value here to position bowser's rear
00BDB1  1  B5 46                  lda Enemy_MovingDir,x    ;check moving direction
00BDB3  1  4A                     lsr
00BDB4  1  90 02                  bcc CopyFToR             ;if moving left, use default
00BDB6  1  A0 F0                  ldy #$f0                 ;otherwise load alternate positioning value here
00BDB8  1  98           CopyFToR: tya                      ;move bowser's rear object position value to A
00BDB9  1  18                     clc
00BDBA  1  75 87                  adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
00BDBC  1  AC CF 06               ldy DuplicateObj_Offset  ;get bowser's rear object offset
00BDBF  1  99 87 00               sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
00BDC2  1  B5 CF                  lda Enemy_Y_Position,x
00BDC4  1  18                     clc                      ;add eight pixels to bowser's front object
00BDC5  1  69 08                  adc #$08                 ;vertical coordinate and store as vertical coordinate
00BDC7  1  99 CF 00               sta Enemy_Y_Position,y   ;for bowser's rear
00BDCA  1  B5 1E                  lda Enemy_State,x
00BDCC  1  99 1E 00               sta Enemy_State,y        ;copy enemy state directly from front to rear
00BDCF  1  B5 46                  lda Enemy_MovingDir,x
00BDD1  1  99 46 00               sta Enemy_MovingDir,y    ;copy moving direction also
00BDD4  1  A5 08                  lda ObjectOffset         ;save enemy object offset of front to stack
00BDD6  1  48                     pha
00BDD7  1  AE CF 06               ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
00BDDA  1  86 08                  stx ObjectOffset
00BDDC  1  A9 2D                  lda #Bowser              ;set bowser's enemy identifier
00BDDE  1  95 16                  sta Enemy_ID,x           ;store in bowser's rear object
00BDE0  1  20 ED BD               jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
00BDE3  1  68                     pla
00BDE4  1  85 08                  sta ObjectOffset         ;get original enemy object offset
00BDE6  1  AA                     tax
00BDE7  1  A9 00                  lda #$00                 ;nullify bowser's front/rear graphics flag
00BDE9  1  8D 6A 03               sta BowserGfxFlag
00BDEC  1  60           ExBGfxH:  rts                      ;leave!
00BDED  1               
00BDED  1               ProcessBowserHalf:
00BDED  1  EE 6A 03           inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
00BDF0  1  20 08 B5           jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
00BDF3  1  B5 1E              lda Enemy_State,x
00BDF5  1  D0 F5              bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
00BDF7  1  A9 0A              lda #$0a
00BDF9  1  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
00BDFC  1  20 C4 CE           jsr GetEnemyBoundBox      ;get bounding box coordinates
00BDFF  1  4C A3 C4           jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
00BE02  1               
00BE02  1               ;-------------------------------------------------------------------------------------
00BE02  1               ;$00 - used to hold movement force and tile number
00BE02  1               ;$01 - used to hold sprite attribute data
00BE02  1               
00BE02  1               FlameTimerData:
00BE02  1  BF 40 BF BF        .byte $bf, $40, $bf, $bf, $bf, $40, $40, $bf
00BE06  1  BF 40 40 BF  
00BE0A  1               
00BE0A  1               SetFlameTimer:
00BE0A  1  AC 67 03           ldy BowserFlameTimerCtrl  ;load counter as offset
00BE0D  1  EE 67 03           inc BowserFlameTimerCtrl  ;increment
00BE10  1  AD 67 03           lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
00BE13  1  29 07              and #%00000111            ;to keep in range of 0-7
00BE15  1  8D 67 03           sta BowserFlameTimerCtrl
00BE18  1  B9 02 BE           lda FlameTimerData,y      ;load value to be used then leave
00BE1B  1  60           ExFl: rts
00BE1C  1               
00BE1C  1               ProcBowserFlame:
00BE1C  1  AD 47 07              lda TimerControl            ;if master timer control flag set,
00BE1F  1  D0 30                 bne SetGfxF                 ;skip all of this
00BE21  1  A9 40                 lda #$40                    ;load default movement force
00BE23  1  AC CC 06              ldy SecondaryHardMode
00BE26  1  F0 02                 beq SFlmX                   ;if secondary hard mode flag not set, use default
00BE28  1  A9 60                 lda #$60                    ;otherwise load alternate movement force to go faster
00BE2A  1  85 00        SFlmX:   sta $00                     ;store value here
00BE2C  1  BD 01 04              lda Enemy_X_MoveForce,x
00BE2F  1  38                    sec                         ;subtract value from movement force
00BE30  1  E5 00                 sbc $00
00BE32  1  9D 01 04              sta Enemy_X_MoveForce,x     ;save new value
00BE35  1  B5 87                 lda Enemy_X_Position,x
00BE37  1  E9 01                 sbc #$01                    ;subtract one from horizontal position to move
00BE39  1  95 87                 sta Enemy_X_Position,x      ;to the left
00BE3B  1  B5 6E                 lda Enemy_PageLoc,x
00BE3D  1  E9 00                 sbc #$00                    ;subtract borrow from page location
00BE3F  1  95 6E                 sta Enemy_PageLoc,x
00BE41  1  BC 17 04              ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
00BE44  1  B5 CF                 lda Enemy_Y_Position,x      ;load vertical coordinate
00BE46  1  D9 CE B1              cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
00BE49  1  F0 06                 beq SetGfxF                 ;if equal, branch and do not modify coordinate
00BE4B  1  18                    clc
00BE4C  1  7D 34 04              adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
00BE4F  1  95 CF                 sta Enemy_Y_Position,x      ;as new vertical coordinate
00BE51  1  20 1C DE     SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
00BE54  1  B5 1E                 lda Enemy_State,x           ;if bowser's flame not in normal state,
00BE56  1  D0 C3                 bne ExFl                    ;branch to leave
00BE58  1  A9 51                 lda #$51                    ;otherwise, continue
00BE5A  1  85 00                 sta $00                     ;write first tile number
00BE5C  1  A0 02                 ldy #$02                    ;load attributes without vertical flip by default
00BE5E  1  A5 09                 lda FrameCounter
00BE60  1  29 02                 and #%00000010              ;invert vertical flip bit every 2 frames
00BE62  1  F0 02                 beq FlmeAt                  ;if d1 not set, write default value
00BE64  1  A0 82                 ldy #$82                    ;otherwise write value with vertical flip bit set
00BE66  1  84 01        FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
00BE68  1  BC E5 06              ldy Enemy_SprDataOffset,x   ;get OAM data offset
00BE6B  1  A2 00                 ldx #$00
00BE6D  1               
00BE6D  1               DrawFlameLoop:
00BE6D  1  AD B9 03              lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
00BE70  1  99 00 02              sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
00BE73  1  A5 00                 lda $00
00BE75  1  99 01 02              sta Sprite_Tilenumber,y    ;write current tile number into OAM data
00BE78  1  E6 00                 inc $00                    ;increment tile number to draw more bowser's flame
00BE7A  1  A5 01                 lda $01
00BE7C  1  99 02 02              sta Sprite_Attributes,y    ;write saved attributes into OAM data
00BE7F  1  AD AE 03              lda Enemy_Rel_XPos
00BE82  1  99 03 02              sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
00BE85  1  18                    clc
00BE86  1  69 08                 adc #$08
00BE88  1  8D AE 03              sta Enemy_Rel_XPos         ;then add eight to it and store
00BE8B  1  C8                    iny
00BE8C  1  C8                    iny
00BE8D  1  C8                    iny
00BE8E  1  C8                    iny                        ;increment Y four times to move onto the next OAM
00BE8F  1  E8                    inx                        ;move onto the next OAM, and branch if three
00BE90  1  E0 03                 cpx #$03                   ;have not yet been done
00BE92  1  90 D9                 bcc DrawFlameLoop
00BE94  1  A6 08                 ldx ObjectOffset           ;reload original enemy offset
00BE96  1  20 79 DE              jsr GetEnemyOffscreenBits  ;get offscreen information
00BE99  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00BE9C  1  AD D1 03              lda Enemy_OffscreenBits    ;get enemy object offscreen bits
00BE9F  1  4A                    lsr                        ;move d0 to carry and result to stack
00BEA0  1  48                    pha
00BEA1  1  90 05                 bcc M3FOfs                 ;branch if carry not set
00BEA3  1  A9 F8                 lda #$f8                   ;otherwise move sprite offscreen, this part likely
00BEA5  1  99 0C 02              sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
00BEA8  1  68           M3FOfs:  pla                        ;get bits from stack
00BEA9  1  4A                    lsr                        ;move d1 to carry and move bits back to stack
00BEAA  1  48                    pha
00BEAB  1  90 05                 bcc M2FOfs                 ;branch if carry not set again
00BEAD  1  A9 F8                 lda #$f8                   ;otherwise move third sprite offscreen
00BEAF  1  99 08 02              sta Sprite_Y_Position+8,y
00BEB2  1  68           M2FOfs:  pla                        ;get bits from stack again
00BEB3  1  4A                    lsr                        ;move d2 to carry and move bits back to stack again
00BEB4  1  48                    pha
00BEB5  1  90 05                 bcc M1FOfs                 ;branch if carry not set yet again
00BEB7  1  A9 F8                 lda #$f8                   ;otherwise move second sprite offscreen
00BEB9  1  99 04 02              sta Sprite_Y_Position+4,y
00BEBC  1  68           M1FOfs:  pla                        ;get bits from stack one last time
00BEBD  1  4A                    lsr                        ;move d3 to carry
00BEBE  1  90 05                 bcc ExFlmeD                ;branch if carry not set one last time
00BEC0  1  A9 F8                 lda #$f8
00BEC2  1  99 00 02              sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
00BEC5  1  60           ExFlmeD: rts                        ;leave
00BEC6  1               
00BEC6  1               ;--------------------------------
00BEC6  1               
00BEC6  1               RunFireworks:
00BEC6  1  D6 A0                   dec ExplosionTimerCounter,x ;decrement explosion timing counter here
00BEC8  1  D0 0C                   bne SetupExpl               ;if not expired, skip this part
00BECA  1  A9 08                   lda #$08
00BECC  1  95 A0                   sta ExplosionTimerCounter,x ;reset counter
00BECE  1  F6 58                   inc ExplosionGfxCounter,x   ;increment explosion graphics counter
00BED0  1  B5 58                   lda ExplosionGfxCounter,x
00BED2  1  C9 03                   cmp #$03                    ;check explosion graphics counter
00BED4  1  B0 18                   bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
00BED6  1  20 1C DE     SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
00BED9  1  AD B9 03                lda Enemy_Rel_YPos          ;copy relative coordinates
00BEDC  1  8D BA 03                sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
00BEDF  1  AD AE 03                lda Enemy_Rel_XPos          ;first vertical, then horizontal
00BEE2  1  8D AF 03                sta Fireball_Rel_XPos
00BEE5  1  BC E5 06                ldy Enemy_SprDataOffset,x   ;get OAM data offset
00BEE8  1  B5 58                   lda ExplosionGfxCounter,x   ;get explosion graphics counter
00BEEA  1  20 D7 D9                jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
00BEED  1  60                      rts
00BEEE  1               
00BEEE  1               FireworksSoundScore:
00BEEE  1  A9 00              lda #$00               ;disable enemy buffer flag
00BEF0  1  95 0F              sta Enemy_Flag,x
00BEF2  1  A9 08              lda #Sfx_Blast         ;play fireworks/gunfire sound
00BEF4  1  85 FE              sta Square2SoundQueue
00BEF6  1  A9 05              lda #$05               ;set part of score modifier for 500 points
00BEF8  1  8D 38 01           sta DigitModifier+4
00BEFB  1  4C 54 BF           jmp EndAreaPoints     ;jump to award points accordingly then leave
00BEFE  1               
00BEFE  1               ;--------------------------------
00BEFE  1               
00BEFE  1               StarFlagYPosAdder:
00BEFE  1  00 00 08 08        .byte $00, $00, $08, $08
00BF02  1               
00BF02  1               StarFlagXPosAdder:
00BF02  1  00 08 00 08        .byte $00, $08, $00, $08
00BF06  1               
00BF06  1               StarFlagTileData:
00BF06  1  54 55 56 57        .byte $54, $55, $56, $57
00BF0A  1               
00BF0A  1               RunStarFlagObj:
00BF0A  1  A9 00              lda #$00                 ;initialize enemy frenzy buffer
00BF0C  1  8D CB 06           sta EnemyFrenzyBuffer
00BF0F  1  AD 46 07           lda StarFlagTaskControl  ;check star flag object task number here
00BF12  1  C9 05              cmp #$05                 ;if greater than 5, branch to exit
00BF14  1  B0 19              bcs StarFlagExit
00BF16  1  20 69 8C           jsr JumpEngine           ;otherwise jump to appropriate sub
00BF19  1               
00BF19  1  2F BF              .word StarFlagExit
00BF1B  1  23 BF              .word GameTimerFireworks
00BF1D  1  30 BF              .word AwardGameTimerPoints
00BF1F  1  5E BF              .word RaiseFlagSetoffFWorks
00BF21  1  B2 BF              .word DelayToAreaEnd
00BF23  1               
00BF23  1               GameTimerFireworks:
00BF23  1                        ;lda GameTimerDisplay+2 ;check to see if last digit of timer matches
00BF23  1                        ;cmp CoinDisplay+1      ;the last digit in the coin tally
00BF23  1                        ;bne NoFWks             ;if not, skip the fireworks
00BF23  1                        ;and #$01
00BF23  1                        ;beq EvenDgs            ;if so, check to see if they are both odd or even
00BF23  1                        ;ldy #$03
00BF23  1                        ;lda #$03               ;if they are both odd, set state and counter
00BF23  1                        ;bne SetFWC             ;for 3 fireworks to go off
00BF23  1               EvenDgs: ;ldy #$00               ;if they are both even, set state and counter
00BF23  1                        ;lda #$06               ;for 6 fireworks to go off
00BF23  1                        ;bne SetFWC
00BF23  1  A0 00        NoFWks:  ldy #$00
00BF25  1  A9 FF                 lda #$ff               ;otherwise set value for no fireworks
00BF27  1  8D D7 06     SetFWC:  sta FireworksCounter   ;set fireworks counter here
00BF2A  1  94 1E                 sty Enemy_State,x      ;set whatever state we have in star flag object
00BF2C  1               
00BF2C  1               IncrementSFTask1:
00BF2C  1  EE 46 07           inc StarFlagTaskControl  ;increment star flag object task number
00BF2F  1               
00BF2F  1               StarFlagExit:
00BF2F  1  60                 rts                      ;leave
00BF30  1               
00BF30  1               AwardGameTimerPoints:
00BF30  1  AD EC 07              lda GameTimerDisplay   ;check all game timer digits for any intervals left
00BF33  1  0D ED 07              ora GameTimerDisplay+1
00BF36  1  0D EE 07              ora GameTimerDisplay+2
00BF39  1  F0 F1                 beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
00BF3B  1               AwardTimerCastle:
00BF3B  1  A5 09                 lda FrameCounter
00BF3D  1  29 04                 and #%00000100         ;check frame counter for d2 set (skip ahead
00BF3F  1  F0 04                 beq NoTTick            ;for four frames every four frames) branch if not set
00BF41  1  A9 10                 lda #Sfx_TimerTick
00BF43  1  85 FE                 sta Square2SoundQueue  ;load timer tick sound
00BF45  1  A0 17        NoTTick: ldy #$17               ;set offset here to subtract from game timer's last digit
00BF47  1  A9 FF                 lda #$ff               ;set adder here to $ff, or -1, to subtract one
00BF49  1  8D 39 01              sta DigitModifier+5    ;from the last digit of the game timer
00BF4C  1  20 BE 8D              jsr DigitsMathRoutine  ;subtract digit
00BF4F  1  A9 05                 lda #$05               ;set now to add 50 points
00BF51  1  8D 39 01              sta DigitModifier+5    ;per game timer interval subtracted
00BF54  1               
00BF54  1               EndAreaPoints:
00BF54  1  A0 0B                 ldy #$0b               ;load offset for score, then jump to handle the awarding
00BF56  1  20 BE 8D              jsr DigitsMathRoutine
00BF59  1  A9 02                 lda #$02               ;now update the score on the screen
00BF5B  1  4C 1A A8              jmp WriteDigits
00BF5E  1               
00BF5E  1               RaiseFlagSetoffFWorks:
00BF5E  1  B5 CF                 lda Enemy_Y_Position,x  ;check star flag's vertical position
00BF60  1  C9 72                 cmp #$72                ;against preset value
00BF62  1  90 05                 bcc SetoffF             ;if star flag higher vertically, branch to other code
00BF64  1  D6 CF                 dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
00BF66  1  4C 75 BF              jmp DrawStarFlag        ;and skip this part here
00BF69  1  AD D7 06     SetoffF: lda FireworksCounter    ;check fireworks counter
00BF6C  1  F0 38                 beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
00BF6E  1  30 36                 bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
00BF70  1  A9 16                 lda #Fireworks
00BF72  1  8D CB 06              sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
00BF75  1               
00BF75  1               DrawStarFlag:
00BF75  1  20 1C DE              jsr RelativeEnemyPosition  ;get relative coordinates of star flag
00BF78  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00BF7B  1  A2 03                 ldx #$03                   ;do four sprites
00BF7D  1  AD B9 03     DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
00BF80  1  18                    clc
00BF81  1  7D FE BE              adc StarFlagYPosAdder,x    ;add Y coordinate adder data
00BF84  1  99 00 02              sta Sprite_Y_Position,y    ;store as Y coordinate
00BF87  1  BD 06 BF              lda StarFlagTileData,x     ;get tile number
00BF8A  1  99 01 02              sta Sprite_Tilenumber,y    ;store as tile number
00BF8D  1  A9 22                 lda #$22                   ;set palette and background priority bits
00BF8F  1  99 02 02              sta Sprite_Attributes,y    ;store as attributes
00BF92  1  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00BF95  1  18                    clc
00BF96  1  7D 02 BF              adc StarFlagXPosAdder,x    ;add X coordinate adder data
00BF99  1  99 03 02              sta Sprite_X_Position,y    ;store as X coordinate
00BF9C  1  C8                    iny
00BF9D  1  C8                    iny                        ;increment OAM data offset four bytes
00BF9E  1  C8                    iny                        ;for next sprite
00BF9F  1  C8                    iny
00BFA0  1  CA                    dex                        ;move onto next sprite
00BFA1  1  10 DA                 bpl DSFLoop                ;do this until all sprites are done
00BFA3  1  A6 08                 ldx ObjectOffset           ;get enemy object offset and leave
00BFA5  1  60                    rts
00BFA6  1               
00BFA6  1               DrawFlagSetTimer:
00BFA6  1  20 75 BF           jsr DrawStarFlag          ;do sub to draw star flag
00BFA9  1  A9 06              lda #$06
00BFAB  1  9D 96 07           sta EnemyIntervalTimer,x  ;set interval timer here
00BFAE  1               
00BFAE  1               IncrementSFTask2:
00BFAE  1  EE 46 07           inc StarFlagTaskControl   ;move onto next task
00BFB1  1  60                 rts
00BFB2  1               
00BFB2  1               DelayToAreaEnd:
00BFB2  1  20 75 BF           jsr DrawStarFlag          ;do sub to draw star flag
00BFB5  1  BD 96 07           lda EnemyIntervalTimer,x  ;if interval timer set in previous task
00BFB8  1  D0 05              bne StarFlagExit2         ;not yet expired, branch to leave
00BFBA  1  AD B1 07           lda EventMusicBuffer      ;if event music buffer empty,
00BFBD  1  F0 EF              beq IncrementSFTask2      ;branch to increment task
00BFBF  1               
00BFBF  1               StarFlagExit2:
00BFBF  1  60                 rts                       ;otherwise leave
00BFC0  1               
00BFC0  1               ;--------------------------------
00BFC0  1               ;$00 - used to store horizontal difference between player and piranha plant
00BFC0  1               
00BFC0  1               MovePiranhaPlant:
00BFC0  1  B5 1E              lda Enemy_State,x           ;check enemy state
00BFC2  1  D0 72              bne PutinPipe               ;if set at all, branch to leave
00BFC4  1  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00BFC7  1  D0 6D              bne PutinPipe               ;branch to end if not yet expired
00BFC9  1  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00BFCB  1  D0 33              bne SetupToMovePPlant       ;if moving, skip to part ahead
00BFCD  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
00BFCF  1  30 24              bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
00BFD1  1  20 BC CD           jsr PlayerEnemyDiff         ;get horizontal difference between player and
00BFD4  1  10 09              bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
00BFD6  1  A5 00              lda $00                     ;otherwise get saved horizontal difference
00BFD8  1  49 FF              eor #$ff
00BFDA  1  18                 clc                         ;and change to two's compliment
00BFDB  1  69 01              adc #$01
00BFDD  1  85 00              sta $00                     ;save as new horizontal difference
00BFDF  1               
00BFDF  1               ChkPlayerNearPipe:
00BFDF  1  A5 00              lda $00                     ;get saved horizontal difference
00BFE1  1  C9 13              cmp #$13
00BFE3  1  90 51              bcc PutinPipe               ;if player within a certain distance, branch to leave
00BFE5  1  AC FB 07           ldy HardWorldFlag           ;are we dealing with red piranha plants?
00BFE8  1  D0 0B              bne ReversePlantSpeed
00BFEA  1  AC 5F 07           ldy WorldNumber
00BFED  1  C0 03              cpy #$03
00BFEF  1  B0 04              bcs ReversePlantSpeed       ;if found, we're done here
00BFF1  1  C9 21              cmp #$21                    ;otherwise, extend distance for green piranha plants
00BFF3  1  90 41              bcc PutinPipe
00BFF5  1               
00BFF5  1               ReversePlantSpeed:
00BFF5  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00BFF7  1  49 FF              eor #$ff
00BFF9  1  18                 clc                         ;change to two's compliment
00BFFA  1  69 01              adc #$01
00BFFC  1  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00BFFE  1  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00C000  1               
00C000  1               SetupToMovePPlant:
00C000  1  BD 34 04           lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
00C003  1  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00C005  1  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00C007  1  BD 17 04           lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
00C00A  1               
00C00A  1               RiseFallPiranhaPlant:
00C00A  1  85 00               sta $00                     ;save vertical coordinate here
00C00C  1  AD FB 07            lda HardWorldFlag           ;check for red piranha plants
00C00F  1  D0 0C               bne RedPP
00C011  1  AD 5F 07            lda WorldNumber
00C014  1  C9 03               cmp #$03
00C016  1  B0 05               bcs RedPP                   ;if found, skip to next part to execute code on every frame
00C018  1  A5 09               lda FrameCounter            ;get frame counter
00C01A  1  4A                  lsr
00C01B  1  90 19               bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
00C01D  1  AD 47 07     RedPP: lda TimerControl            ;get master timer control
00C020  1  D0 14               bne PutinPipe               ;branch to leave if set (likely not necessary)
00C022  1  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00C024  1  18                  clc
00C025  1  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00C027  1  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00C029  1  C5 00               cmp $00                     ;compare against low or high coordinate
00C02B  1  D0 09               bne PutinPipe               ;branch to leave if not yet reached
00C02D  1  A9 00               lda #$00
00C02F  1  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00C031  1  A9 40               lda #$40
00C033  1  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00C036  1               
00C036  1               PutinPipe:
00C036  1  A9 20              lda #%00100000              ;set background priority bit in sprite
00C038  1  9D C5 03           sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
00C03B  1  60                 rts                         ;then leave
00C03C  1               
00C03C  1               ;-------------------------------------------------------------------------------------
00C03C  1               ;$07 - spinning speed
00C03C  1               
00C03C  1               FirebarSpin:
00C03C  1  85 07              sta $07                     ;save spinning speed here
00C03E  1  B5 34              lda FirebarSpinDirection,x  ;check spinning direction
00C040  1  D0 0E              bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
00C042  1  A0 18              ldy #$18                    ;possibly residual ldy
00C044  1  B5 58              lda FirebarSpinState_Low,x
00C046  1  18                 clc                         ;add spinning speed to what would normally be
00C047  1  65 07              adc $07                     ;the horizontal speed
00C049  1  95 58              sta FirebarSpinState_Low,x
00C04B  1  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00C04D  1  69 00              adc #$00
00C04F  1  60                 rts
00C050  1               
00C050  1               SpinCounterClockwise:
00C050  1  A0 08              ldy #$08                    ;possibly residual ldy
00C052  1  B5 58              lda FirebarSpinState_Low,x
00C054  1  38                 sec                         ;subtract spinning speed to what would normally be
00C055  1  E5 07              sbc $07                     ;the horizontal speed
00C057  1  95 58              sta FirebarSpinState_Low,x
00C059  1  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00C05B  1  E9 00              sbc #$00
00C05D  1  60                 rts
00C05E  1               
00C05E  1               
00C05E  1               ;-------------------------------------------------------------------------------------
00C05E  1               ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
00C05E  1               ;$01 - used to hold high byte of name table for rope
00C05E  1               ;$02 - used to hold page location of rope
00C05E  1               
00C05E  1               BalancePlatform:
00C05E  1  B5 B6                lda Enemy_Y_HighPos,x       ;check high byte of vertical position
00C060  1  C9 03                cmp #$03
00C062  1  D0 03                bne DoBPl
00C064  1  4C C9 B5             jmp EraseEnemyObject        ;if far below screen, kill the object
00C067  1  B5 1E        DoBPl:  lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
00C069  1  10 01                bpl CheckBalPlatform        ;if doing other balance platform, branch to handle it
00C06B  1  60           ExBalP: rts
00C06C  1               
00C06C  1               
00C06C  1               CheckBalPlatform:
00C06C  1  A8                  tay                         ;save offset from state as Y
00C06D  1  B9 16 00            lda Enemy_ID,y
00C070  1  C9 24               cmp #$24                    ;check to see if other object is balance platform
00C072  1  D0 F7               bne ExBalP                  ;if not, branch to leave
00C074  1  BD A2 03            lda PlatformCollisionFlag,x ;get collision flag of platform
00C077  1  85 00               sta $00                     ;store here
00C079  1  B5 46               lda Enemy_MovingDir,x       ;get moving direction
00C07B  1  F0 03               beq ChkForFall
00C07D  1  4C EE C1            jmp PlatformFall            ;if set, jump here
00C080  1               
00C080  1               ChkForFall:
00C080  1  A9 2D               lda #$2d                    ;check if platform is above a certain point
00C082  1  D5 CF               cmp Enemy_Y_Position,x
00C084  1  90 0F               bcc ChkOtherForFall         ;if not, branch elsewhere
00C086  1  C4 00               cpy $00                     ;if collision flag is set to same value as
00C088  1  F0 08               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00C08A  1  18                  clc
00C08B  1  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00C08D  1  95 CF               sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
00C08F  1  4C E4 C1            jmp StopPlatforms           ;to make platforms stop
00C092  1               
00C092  1               MakePlatformFall:
00C092  1  4C CB C1            jmp InitPlatformFall        ;make platforms fall
00C095  1               
00C095  1               ChkOtherForFall:
00C095  1  D9 CF 00            cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
00C098  1  90 0D               bcc ChkToMoveBalPlat        ;if not, branch elsewhere
00C09A  1  E4 00               cpx $00                     ;if collision flag is set to same value as
00C09C  1  F0 F4               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00C09E  1  18                  clc
00C09F  1  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00C0A1  1  99 CF 00            sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
00C0A4  1  4C E4 C1            jmp StopPlatforms           ;jump to stop movement and do not return
00C0A7  1               
00C0A7  1               ChkToMoveBalPlat:
00C0A7  1  B5 CF                lda Enemy_Y_Position,x      ;save vertical position to stack
00C0A9  1  48                   pha
00C0AA  1  BD A2 03             lda PlatformCollisionFlag,x ;get collision flag
00C0AD  1  10 18                bpl ColFlg                  ;branch if collision
00C0AF  1  BD 34 04             lda Enemy_Y_MoveForce,x
00C0B2  1  18                   clc                         ;add $05 to contents of moveforce, whatever they be
00C0B3  1  69 05                adc #$05
00C0B5  1  85 00                sta $00                     ;store here
00C0B7  1  B5 A0                lda Enemy_Y_Speed,x
00C0B9  1  69 00                adc #$00                    ;add carry to vertical speed
00C0BB  1  30 1A                bmi PlatDn                  ;branch if moving downwards
00C0BD  1  D0 0C                bne PlatUp                  ;branch elsewhere if moving upwards
00C0BF  1  A5 00                lda $00
00C0C1  1  C9 0B                cmp #$0b                    ;check if there's still a little force left
00C0C3  1  90 0C                bcc PlatSt                  ;if not enough, branch to stop movement
00C0C5  1  B0 04                bcs PlatUp                  ;otherwise keep branch to move upwards
00C0C7  1  C5 08        ColFlg: cmp ObjectOffset            ;if collision flag matches
00C0C9  1  F0 0C                beq PlatDn                  ;current enemy object offset, branch
00C0CB  1  20 B3 AB     PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
00C0CE  1  4C DA C0             jmp DoOtherPlatform         ;jump ahead to remaining code
00C0D1  1  20 E4 C1     PlatSt: jsr StopPlatforms           ;do a sub to stop movement
00C0D4  1  4C DA C0             jmp DoOtherPlatform         ;jump ahead to remaining code
00C0D7  1  20 B0 AB     PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
00C0DA  1               
00C0DA  1               DoOtherPlatform:
00C0DA  1  B4 1E               ldy Enemy_State,x           ;get offset of other platform
00C0DC  1  68                  pla                         ;get old vertical coordinate from stack
00C0DD  1  38                  sec
00C0DE  1  F5 CF               sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
00C0E0  1  18                  clc
00C0E1  1  79 CF 00            adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
00C0E4  1  99 CF 00            sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
00C0E7  1  BD A2 03            lda PlatformCollisionFlag,x ;if no collision, skip this part here
00C0EA  1  30 04               bmi DrawEraseRope
00C0EC  1  AA                  tax                         ;put offset which collision occurred here
00C0ED  1  20 8E C8            jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
00C0F0  1               
00C0F0  1               DrawEraseRope:
00C0F0  1  A4 08                 ldy ObjectOffset            ;get enemy object offset
00C0F2  1  B9 A0 00              lda Enemy_Y_Speed,y         ;check to see if current platform is
00C0F5  1  19 34 04              ora Enemy_Y_MoveForce,y     ;moving at all
00C0F8  1  F0 77                 beq ExitRp                  ;if not, skip all of this and branch to leave
00C0FA  1  AE 00 03              ldx VRAM_Buffer1_Offset     ;get vram buffer offset
00C0FD  1  E0 20                 cpx #$20                    ;if offset beyond a certain point, go ahead
00C0FF  1  B0 70                 bcs ExitRp                  ;and skip this, branch to leave
00C101  1  B9 A0 00              lda Enemy_Y_Speed,y
00C104  1  48                    pha                         ;save two copies of vertical speed to stack
00C105  1  48                    pha
00C106  1  20 74 C1              jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
00C109  1  A5 01                 lda $01                     ;write name table address to vram buffer
00C10B  1  9D 01 03              sta VRAM_Buffer1,x          ;first the high byte, then the low
00C10E  1  A5 00                 lda $00
00C110  1  9D 02 03              sta VRAM_Buffer1+1,x
00C113  1  A9 02                 lda #$02                    ;set length for 2 bytes
00C115  1  9D 03 03              sta VRAM_Buffer1+2,x
00C118  1  B9 A0 00              lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
00C11B  1  30 0D                 bmi EraseR1                 ;to do something else
00C11D  1  A9 A2                 lda #$a2
00C11F  1  9D 04 03              sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
00C122  1  A9 A3                 lda #$a3                    ;and right sides of rope in vram buffer
00C124  1  9D 05 03              sta VRAM_Buffer1+4,x
00C127  1  4C 32 C1              jmp OtherRope               ;jump to skip this part
00C12A  1  A9 24        EraseR1: lda #$24                    ;put blank tiles in vram buffer
00C12C  1  9D 04 03              sta VRAM_Buffer1+3,x        ;to erase rope
00C12F  1  9D 05 03              sta VRAM_Buffer1+4,x
00C132  1               
00C132  1               OtherRope:
00C132  1  B9 1E 00              lda Enemy_State,y           ;get offset of other platform from state
00C135  1  A8                    tay                         ;use as Y here
00C136  1  68                    pla                         ;pull second copy of vertical speed from stack
00C137  1  49 FF                 eor #$ff                    ;invert bits to reverse speed
00C139  1  20 74 C1              jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
00C13C  1  A5 01                 lda $01                     ;write name table address to vram buffer
00C13E  1  9D 06 03              sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
00C141  1  A5 00                 lda $00                     ;the other platform
00C143  1  9D 07 03              sta VRAM_Buffer1+6,x
00C146  1  A9 02                 lda #$02
00C148  1  9D 08 03              sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
00C14B  1  68                    pla                         ;pull first copy of vertical speed from stack
00C14C  1  10 0D                 bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
00C14E  1  A9 A2                 lda #$a2
00C150  1  9D 09 03              sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
00C153  1  A9 A3                 lda #$a3                    ;and right sides of rope in vram
00C155  1  9D 0A 03              sta VRAM_Buffer1+9,x        ;transfer buffer
00C158  1  4C 63 C1              jmp EndRp                   ;jump to skip this part
00C15B  1  A9 24        EraseR2: lda #$24                    ;put blank tiles in vram buffer
00C15D  1  9D 09 03              sta VRAM_Buffer1+8,x        ;to erase rope
00C160  1  9D 0A 03              sta VRAM_Buffer1+9,x
00C163  1  A9 00        EndRp:   lda #$00                    ;put null terminator at the end
00C165  1  9D 0B 03              sta VRAM_Buffer1+10,x
00C168  1  AD 00 03              lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
00C16B  1  18                    clc                         ;and store
00C16C  1  69 0A                 adc #10
00C16E  1  8D 00 03              sta VRAM_Buffer1_Offset
00C171  1  A6 08        ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
00C173  1  60                    rts
00C174  1               
00C174  1               SetupPlatformRope:
00C174  1  48                   pha                     ;save second/third copy to stack
00C175  1  B9 87 00             lda Enemy_X_Position,y  ;get horizontal coordinate
00C178  1  18                   clc
00C179  1  69 08                adc #$08                ;add eight pixels
00C17B  1  AE CC 06             ldx SecondaryHardMode   ;if secondary hard mode flag set,
00C17E  1  D0 03                bne GetLRp              ;use coordinate as-is
00C180  1  18                   clc
00C181  1  69 10                adc #$10                ;otherwise add sixteen more pixels
00C183  1  48           GetLRp: pha                     ;save modified horizontal coordinate to stack
00C184  1  B9 6E 00             lda Enemy_PageLoc,y
00C187  1  69 00                adc #$00                ;add carry to page location
00C189  1  85 02                sta $02                 ;and save here
00C18B  1  68                   pla                     ;pull modified horizontal coordinate
00C18C  1  29 F0                and #%11110000          ;from the stack, mask out low nybble
00C18E  1  4A                   lsr                     ;and shift three bits to the right
00C18F  1  4A                   lsr
00C190  1  4A                   lsr
00C191  1  85 00                sta $00                 ;store result here as part of name table low byte
00C193  1  B6 CF                ldx Enemy_Y_Position,y  ;get vertical coordinate
00C195  1  68                   pla                     ;get second/third copy of vertical speed from stack
00C196  1  10 05                bpl GetHRp              ;skip this part if moving downwards or not at all
00C198  1  8A                   txa
00C199  1  18                   clc
00C19A  1  69 08                adc #$08                ;add eight to vertical coordinate and
00C19C  1  AA                   tax                     ;save as X
00C19D  1  8A           GetHRp: txa                     ;move vertical coordinate to A
00C19E  1  AE 00 03             ldx VRAM_Buffer1_Offset ;get vram buffer offset
00C1A1  1  0A                   asl
00C1A2  1  2A                   rol                     ;rotate d7 to d0 and d6 into carry
00C1A3  1  48                   pha                     ;save modified vertical coordinate to stack
00C1A4  1  2A                   rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
00C1A5  1  29 03                and #%00000011          ;mask out all bits but d7 and d6, then set
00C1A7  1  09 20                ora #%00100000          ;d5 to get appropriate high byte of name table
00C1A9  1  85 01                sta $01                 ;address, then store
00C1AB  1  A5 02                lda $02                 ;get saved page location from earlier
00C1AD  1  29 01                and #$01                ;mask out all but LSB
00C1AF  1  0A                   asl
00C1B0  1  0A                   asl                     ;shift twice to the left and save with the
00C1B1  1  05 01                ora $01                 ;rest of the bits of the high byte, to get
00C1B3  1  85 01                sta $01                 ;the proper name table and the right place on it
00C1B5  1  68                   pla                     ;get modified vertical coordinate from stack
00C1B6  1  29 E0                and #%11100000          ;mask out low nybble and LSB of high nybble
00C1B8  1  18                   clc
00C1B9  1  65 00                adc $00                 ;add to horizontal part saved here
00C1BB  1  85 00                sta $00                 ;save as name table low byte
00C1BD  1  B9 CF 00             lda Enemy_Y_Position,y
00C1C0  1  C9 E8                cmp #$e8                ;if vertical position not below the
00C1C2  1  90 06                bcc ExPRp               ;bottom of the screen, we're done, branch to leave
00C1C4  1  A5 00                lda $00
00C1C6  1  29 BF                and #%10111111          ;mask out d6 of low byte of name table address
00C1C8  1  85 00                sta $00
00C1CA  1  60           ExPRp:  rts                     ;leave!
00C1CB  1               
00C1CB  1               InitPlatformFall:
00C1CB  1  98                 tya                        ;move offset of other platform from Y to X
00C1CC  1  AA                 tax
00C1CD  1  20 79 DE           jsr GetEnemyOffscreenBits  ;get offscreen bits
00C1D0  1  A9 06              lda #$06
00C1D2  1  20 72 C6           jsr SetupFloateyNumber     ;award 1000 points to player
00C1D5  1  AD AD 03           lda Player_Rel_XPos
00C1D8  1  9D 17 01           sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
00C1DB  1  A5 CE              lda Player_Y_Position
00C1DD  1  9D 1E 01           sta FloateyNum_Y_Pos,x
00C1E0  1  A9 01              lda #$01                   ;set moving direction as flag for
00C1E2  1  95 46              sta Enemy_MovingDir,x      ;falling platforms
00C1E4  1               
00C1E4  1               StopPlatforms:
00C1E4  1  20 6E AF           jsr InitVStf             ;initialize vertical speed and low byte
00C1E7  1  99 A0 00           sta Enemy_Y_Speed,y      ;for both platforms and leave
00C1EA  1  99 34 04           sta Enemy_Y_MoveForce,y
00C1ED  1  60                 rts
00C1EE  1               
00C1EE  1               PlatformFall:
00C1EE  1  98                 tya                         ;save offset for other platform to stack
00C1EF  1  48                 pha
00C1F0  1  20 67 AB           jsr MoveFallingPlatform     ;make current platform fall
00C1F3  1  68                 pla
00C1F4  1  AA                 tax                         ;pull offset from stack and save to X
00C1F5  1  20 67 AB           jsr MoveFallingPlatform     ;make other platform fall
00C1F8  1  A6 08              ldx ObjectOffset
00C1FA  1  BD A2 03           lda PlatformCollisionFlag,x ;if player not standing on either platform,
00C1FD  1  30 04              bmi ExPF                    ;skip this part
00C1FF  1  AA                 tax                         ;transfer collision flag offset as offset to X
00C200  1  20 8E C8           jsr PositionPlayerOnVPlat   ;and position player appropriately
00C203  1  A6 08        ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
00C205  1  60                 rts
00C206  1               
00C206  1               ;--------------------------------
00C206  1               
00C206  1               YMovingPlatform:
00C206  1  B5 A0                lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
00C208  1  1D 34 04             ora Enemy_Y_MoveForce,x      ;check on other position
00C20B  1  D0 15                bne ChkYCenterPos
00C20D  1  9D 17 04             sta Enemy_YMF_Dummy,x        ;initialize dummy variable
00C210  1  B5 CF                lda Enemy_Y_Position,x
00C212  1  DD 01 04             cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
00C215  1  B0 0B                bcs ChkYCenterPos            ;ahead of all this
00C217  1  A5 09                lda FrameCounter
00C219  1  29 07                and #%00000111               ;check for every eighth frame
00C21B  1  D0 02                bne SkipIY
00C21D  1  F6 CF                inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
00C21F  1  4C 31 C2     SkipIY: jmp ChkYPCollision           ;skip ahead to last part
00C222  1               
00C222  1               ChkYCenterPos:
00C222  1  B5 CF                lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
00C224  1  D5 58                cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
00C226  1  90 06                bcc YMDown
00C228  1  20 B3 AB             jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
00C22B  1  4C 31 C2             jmp ChkYPCollision
00C22E  1  20 B0 AB     YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
00C231  1               
00C231  1               ChkYPCollision:
00C231  1  BD A2 03            lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
00C234  1  30 03               bmi ExYPl                    ;to leave
00C236  1  20 8E C8            jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
00C239  1  60           ExYPl: rts                          ;leave
00C23A  1               
00C23A  1               ;--------------------------------
00C23A  1               ;$00 - used as adder to position player hotizontally
00C23A  1               
00C23A  1               XMovingPlatform:
00C23A  1  A9 0E              lda #$0e                     ;load preset maximum value for secondary counter
00C23C  1  20 78 B7           jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
00C23F  1  20 97 B7           jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
00C242  1  BD A2 03           lda PlatformCollisionFlag,x  ;if no collision with player,
00C245  1  30 1C              bmi ExXMP                    ;branch ahead to leave
00C247  1               
00C247  1               PositionPlayerOnHPlat:
00C247  1  A5 86                 lda Player_X_Position
00C249  1  18                    clc                       ;add saved value from second subroutine to
00C24A  1  65 00                 adc $00                   ;current player's position to position
00C24C  1  85 86                 sta Player_X_Position     ;player accordingly in horizontal position
00C24E  1  A5 6D                 lda Player_PageLoc        ;get player's page location
00C250  1  A4 00                 ldy $00                   ;check to see if saved value here is positive or negative
00C252  1  30 05                 bmi PPHSubt               ;if negative, branch to subtract
00C254  1  69 00                 adc #$00                  ;otherwise add carry to page location
00C256  1  4C 5B C2              jmp SetPVar               ;jump to skip subtraction
00C259  1  E9 00        PPHSubt: sbc #$00                  ;subtract borrow from page location
00C25B  1  85 6D        SetPVar: sta Player_PageLoc        ;save result to player's page location
00C25D  1  8C A1 03              sty Platform_X_Scroll     ;put saved value from second sub here to be used later
00C260  1  20 8E C8              jsr PositionPlayerOnVPlat ;position player vertically and appropriately
00C263  1  60           ExXMP:   rts                       ;and we are done here
00C264  1               
00C264  1               ;--------------------------------
00C264  1               
00C264  1               DropPlatform:
00C264  1  BD A2 03            lda PlatformCollisionFlag,x  ;if no collision between platform and player
00C267  1  30 06               bmi ExDPl                    ;occurred, just leave without moving anything
00C269  1  20 84 AB            jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
00C26C  1  20 8E C8            jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
00C26F  1  60           ExDPl: rts                          ;leave
00C270  1               
00C270  1               ;--------------------------------
00C270  1               ;$00 - residual value from sub
00C270  1               
00C270  1               RightPlatform:
00C270  1  20 FE AA            jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
00C273  1  85 00               sta $00                       ;store saved value here (residual code)
00C275  1  BD A2 03            lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
00C278  1  30 07               bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
00C27A  1  A9 10               lda #$10
00C27C  1  95 58               sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
00C27E  1  20 47 C2            jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
00C281  1  60           ExRPl: rts                           ;then leave
00C282  1               
00C282  1               ;--------------------------------
00C282  1               
00C282  1               MoveLargeLiftPlat:
00C282  1  20 8E C2           jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
00C285  1  4C 31 C2           jmp ChkYPCollision     ;branch to position player correctly
00C288  1               
00C288  1               MoveSmallPlatform:
00C288  1  20 8E C2           jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
00C28B  1  4C A4 C2           jmp ChkSmallPlatCollision  ;branch to position player correctly
00C28E  1               
00C28E  1               MoveLiftPlatforms:
00C28E  1  AD 47 07           lda TimerControl         ;if master timer control set, skip all of this
00C291  1  D0 19              bne ExLiftP              ;and branch to leave
00C293  1  BD 17 04           lda Enemy_YMF_Dummy,x
00C296  1  18                 clc                      ;add contents of movement amount to whatever's here
00C297  1  7D 34 04           adc Enemy_Y_MoveForce,x
00C29A  1  9D 17 04           sta Enemy_YMF_Dummy,x
00C29D  1  B5 CF              lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
00C29F  1  75 A0              adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
00C2A1  1  95 CF              sta Enemy_Y_Position,x   ;and then leave
00C2A3  1  60                 rts
00C2A4  1               
00C2A4  1               ChkSmallPlatCollision:
00C2A4  1  BD A2 03              lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
00C2A7  1  F0 03                 beq ExLiftP                 ;if none found, leave player position alone
00C2A9  1  20 86 C8              jsr PositionPlayerOnS_Plat  ;use to position player correctly
00C2AC  1  60           ExLiftP: rts                         ;then leave
00C2AD  1               
00C2AD  1               ;-------------------------------------------------------------------------------------
00C2AD  1               ;$00 - page location of extended left boundary
00C2AD  1               ;$01 - extended left boundary position
00C2AD  1               ;$02 - page location of extended right boundary
00C2AD  1               ;$03 - extended right boundary position
00C2AD  1               
00C2AD  1               OffscreenBoundsCheck:
00C2AD  1  B5 16                  lda Enemy_ID,x          ;check for cheep-cheep object
00C2AF  1  C9 14                  cmp #FlyingCheepCheep   ;branch to leave if found
00C2B1  1  F0 5D                  beq ExScrnBd
00C2B3  1  AD 1C 07               lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
00C2B6  1  B4 16                  ldy Enemy_ID,x
00C2B8  1  C0 05                  cpy #HammerBro          ;check for hammer bro object
00C2BA  1  F0 08                  beq LimitB
00C2BC  1  C0 04                  cpy #UpsideDownPiranhaP ;check for upside-down piranha plant object
00C2BE  1  F0 04                  beq LimitB
00C2C0  1  C0 0D                  cpy #PiranhaPlant       ;check for piranha plant object
00C2C2  1  D0 02                  bne ExtendLB            ;these three will be erased sooner than others if too far left
00C2C4  1  69 38        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
00C2C6  1  E9 48        ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
00C2C8  1  85 01                  sta $01                 ;store result here
00C2CA  1  AD 1A 07               lda ScreenLeft_PageLoc
00C2CD  1  E9 00                  sbc #$00                ;subtract borrow from page location of left side
00C2CF  1  85 00                  sta $00                 ;store result here
00C2D1  1  AD 1D 07               lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
00C2D4  1  69 48                  adc #$48
00C2D6  1  85 03                  sta $03                 ;store result here
00C2D8  1  AD 1B 07               lda ScreenRight_PageLoc
00C2DB  1  69 00                  adc #$00                ;then add the carry to the page location
00C2DD  1  85 02                  sta $02                 ;and store result here
00C2DF  1  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00C2E1  1  C5 01                  cmp $01                 ;to modified horizontal left edge coordinate to get carry
00C2E3  1  B5 6E                  lda Enemy_PageLoc,x
00C2E5  1  E5 00                  sbc $00                 ;then subtract it from the page coordinate of the enemy object
00C2E7  1  30 24                  bmi TooFar              ;if enemy object is too far left, branch to erase it
00C2E9  1  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00C2EB  1  C5 03                  cmp $03                 ;to modified horizontal right edge coordinate to get carry
00C2ED  1  B5 6E                  lda Enemy_PageLoc,x
00C2EF  1  E5 02                  sbc $02                 ;then subtract it from the page coordinate of the enemy object
00C2F1  1  30 1D                  bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
00C2F3  1  B5 1E                  lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
00C2F5  1  C9 05                  cmp #HammerBro          ;if in state used by spiny's egg, do not erase
00C2F7  1  F0 17                  beq ExScrnBd
00C2F9  1  C0 0D                  cpy #PiranhaPlant       ;if piranha plant, do not erase
00C2FB  1  F0 13                  beq ExScrnBd
00C2FD  1  C0 04                  cpy #UpsideDownPiranhaP ;if upside-down piranha plant, do not erase
00C2FF  1  F0 0F                  beq ExScrnBd
00C301  1  C0 30                  cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
00C303  1  F0 0B                  beq ExScrnBd
00C305  1  C0 31                  cpy #StarFlagObject     ;if star flag, do not erase
00C307  1  F0 07                  beq ExScrnBd
00C309  1  C0 32                  cpy #JumpspringObject   ;if jumpspring, do not erase
00C30B  1  F0 03                  beq ExScrnBd            ;erase all others too far to the right
00C30D  1  20 C9 B5     TooFar:   jsr EraseEnemyObject    ;erase object if necessary
00C310  1  60           ExScrnBd: rts                     ;leave
00C311  1               
00C311  1               ;-------------------------------------------------------------------------------------
00C311  1               ;$01 - enemy buffer offset
00C311  1               
00C311  1               FireballEnemyCollision:
00C311  1  B5 24              lda Fireball_State,x  ;check to see if fireball state is set at all
00C313  1  F0 56              beq ExitFBallEnemy    ;branch to leave if not
00C315  1  0A                 asl
00C316  1  B0 53              bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
00C318  1  A5 09              lda FrameCounter
00C31A  1  4A                 lsr                   ;get LSB of frame counter
00C31B  1  B0 4E              bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
00C31D  1  8A                 txa
00C31E  1  0A                 asl                   ;multiply fireball offset by four
00C31F  1  0A                 asl
00C320  1  18                 clc
00C321  1  69 1C              adc #$1c              ;then add $1c or 28 bytes to it
00C323  1  A8                 tay                   ;to use fireball's bounding box coordinates
00C324  1  A2 04              ldx #$04
00C326  1               
00C326  1               FireballEnemyCDLoop:
00C326  1  86 01                   stx $01                     ;store enemy object offset here
00C328  1  98                      tya
00C329  1  48                      pha                         ;push fireball offset to the stack
00C32A  1  B5 1E                   lda Enemy_State,x
00C32C  1  29 20                   and #%00100000              ;check to see if d5 is set in enemy state
00C32E  1  D0 34                   bne NoFToECol               ;if so, skip to next enemy slot
00C330  1  B5 0F                   lda Enemy_Flag,x            ;check to see if buffer flag is set
00C332  1  F0 30                   beq NoFToECol               ;if not, skip to next enemy slot
00C334  1  B5 16                   lda Enemy_ID,x              ;check enemy identifier
00C336  1  C9 24                   cmp #$24
00C338  1  90 04                   bcc GoombaDie               ;if < $24, branch to check further
00C33A  1  C9 2B                   cmp #$2b
00C33C  1  90 26                   bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
00C33E  1  C9 06        GoombaDie: cmp #Goomba                 ;check for goomba identifier
00C340  1  D0 06                   bne NotGoomba               ;if not found, continue with code
00C342  1  B5 1E                   lda Enemy_State,x           ;otherwise check for defeated state
00C344  1  C9 02                   cmp #$02                    ;if stomped or otherwise defeated,
00C346  1  B0 1C                   bcs NoFToECol               ;skip to next enemy slot
00C348  1  BD D8 03     NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
00C34B  1  D0 17                   bne NoFToECol               ;skip to next enemy slot
00C34D  1  8A                      txa
00C34E  1  0A                      asl                         ;otherwise multiply enemy offset by four
00C34F  1  0A                      asl
00C350  1  18                      clc
00C351  1  69 04                   adc #$04                    ;add 4 bytes to it
00C353  1  AA                      tax                         ;to use enemy's bounding box coordinates
00C354  1  20 A8 CF                jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
00C357  1  A6 08                   ldx ObjectOffset            ;return fireball's original offset
00C359  1  90 09                   bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
00C35B  1  A9 80                   lda #%10000000
00C35D  1  95 24                   sta Fireball_State,x        ;set d7 in enemy state
00C35F  1  A6 01                   ldx $01                     ;get enemy offset
00C361  1  20 77 C3                jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
00C364  1  68           NoFToECol: pla                         ;pull fireball offset from stack
00C365  1  A8                      tay                         ;put it in Y
00C366  1  A6 01                   ldx $01                     ;get enemy object offset
00C368  1  CA                      dex                         ;decrement it
00C369  1  10 BB                   bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
00C36B  1               
00C36B  1               ExitFBallEnemy:
00C36B  1  A6 08              ldx ObjectOffset                 ;get original fireball offset and leave
00C36D  1  60                 rts
00C36E  1               
00C36E  1               BowserIdentities:
00C36E  1  06 00 02 12        .byte Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser, Bowser
00C372  1  11 07 05 2D  
00C376  1  2D           
00C377  1               
00C377  1               HandleEnemyFBallCol:
00C377  1  20 1C DE           jsr RelativeEnemyPosition  ;get relative coordinate of enemy
00C37A  1  A6 01              ldx $01                    ;get current enemy object offset
00C37C  1  B5 0F              lda Enemy_Flag,x           ;check buffer flag for d7 set
00C37E  1  10 0B              bpl ChkBuzzyBeetle         ;branch if not set to continue
00C380  1  29 0F              and #%00001111             ;otherwise mask out high nybble and
00C382  1  AA                 tax                        ;use low nybble as enemy offset
00C383  1  B5 16              lda Enemy_ID,x
00C385  1  C9 2D              cmp #Bowser                ;check enemy identifier for bowser
00C387  1  F0 0C              beq HurtBowser             ;branch if found
00C389  1  A6 01              ldx $01                    ;otherwise retrieve current enemy offset
00C38B  1               
00C38B  1               ChkBuzzyBeetle:
00C38B  1  B5 16              lda Enemy_ID,x
00C38D  1  C9 02              cmp #BuzzyBeetle           ;check for buzzy beetle
00C38F  1  F0 76              beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
00C391  1  C9 2D              cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
00C393  1  D0 2D              bne ChkOtherEnemies        ;if not found, branch to check other enemies
00C395  1               
00C395  1               HurtBowser:
00C395  1  CE 83 04               dec BowserHitPoints        ;decrement bowser's hit points
00C398  1  D0 6D                  bne ExHCF                  ;if bowser still has hit points, branch to leave
00C39A  1  20 6E AF               jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
00C39D  1  95 58                  sta Enemy_X_Speed,x        ;initialize horizontal speed
00C39F  1  8D CB 06               sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
00C3A2  1  A9 FE                  lda #$fe
00C3A4  1  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
00C3A6  1  AC 5F 07               ldy WorldNumber            ;use world number as offset
00C3A9  1  B9 6E C3               lda BowserIdentities,y     ;get enemy identifier to replace bowser with
00C3AC  1  95 16                  sta Enemy_ID,x             ;set as new enemy identifier
00C3AE  1  A9 20                  lda #$20                   ;set A to use starting value for state
00C3B0  1  C0 03                  cpy #$03                   ;check to see if using offset of 3 or more
00C3B2  1  B0 02                  bcs SetDBSte               ;branch if so
00C3B4  1  09 03                  ora #$03                   ;otherwise add 3 to enemy state
00C3B6  1  95 1E        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
00C3B8  1  A9 80                  lda #Sfx_BowserFall
00C3BA  1  85 FE                  sta Square2SoundQueue      ;load bowser defeat sound
00C3BC  1  A6 01                  ldx $01                    ;get enemy offset
00C3BE  1  A9 09                  lda #$09                   ;award 5000 points to player for defeating bowser
00C3C0  1  D0 3E                  bne EnemySmackScore        ;unconditional branch to award points
00C3C2  1               
00C3C2  1               ChkOtherEnemies:
00C3C2  1  C9 08              cmp #BulletBill_FrenzyVar
00C3C4  1  F0 41              beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
00C3C6  1  C9 0C              cmp #Podoboo
00C3C8  1  F0 3D              beq ExHCF                 ;branch to leave if podoboo
00C3CA  1  C9 15              cmp #$15
00C3CC  1  B0 39              bcs ExHCF                 ;branch to leave if identifier => $15
00C3CE  1               
00C3CE  1               ShellOrBlockDefeat:
00C3CE  1  B5 16               lda Enemy_ID,x            ;check for both kinds of piranha plant
00C3D0  1  C9 04               cmp #UpsideDownPiranhaP
00C3D2  1  F0 04               beq DinP
00C3D4  1  C9 0D               cmp #PiranhaPlant
00C3D6  1  D0 0D               bne StnE                  ;branch if not found
00C3D8  1  A8           DinP:  tay
00C3D9  1  B5 CF               lda Enemy_Y_Position,x
00C3DB  1  69 18               adc #$18                  ;add 24 pixels to enemy object's vertical position
00C3DD  1  C0 04               cpy #UpsideDownPiranhaP   ;to put defeated piranha plant back in pipe
00C3DF  1  D0 02               bne SetDY
00C3E1  1  E9 31               sbc #$31                  ;subtract 49 pixels to vertical position to put
00C3E3  1  95 CF        SetDY: sta Enemy_Y_Position,x    ;defeated upside down piranha plant back in pipe
00C3E5  1  20 86 CC     StnE:  jsr ChkToStunEnemies      ;do yet another sub
00C3E8  1  B5 1E               lda Enemy_State,x
00C3EA  1  29 1F               and #%00011111            ;mask out 2 MSB of enemy object's state
00C3EC  1  09 20               ora #%00100000            ;set d5 to defeat enemy and save as new state
00C3EE  1  95 1E               sta Enemy_State,x
00C3F0  1  A9 02               lda #$02                  ;award 200 points by default
00C3F2  1  B4 16               ldy Enemy_ID,x            ;check for hammer bro
00C3F4  1  C0 05               cpy #HammerBro
00C3F6  1  D0 02               bne GoombaPoints          ;branch if not found
00C3F8  1  A9 06               lda #$06                  ;award 1000 points for hammer bro
00C3FA  1               
00C3FA  1               GoombaPoints:
00C3FA  1  C0 06              cpy #Goomba               ;check for goomba
00C3FC  1  D0 02              bne EnemySmackScore       ;branch if not found
00C3FE  1  A9 01              lda #$01                  ;award 100 points for goomba
00C400  1               
00C400  1               EnemySmackScore:
00C400  1  20 72 C6            jsr SetupFloateyNumber   ;update necessary score variables
00C403  1  A9 08               lda #Sfx_EnemySmack      ;play smack enemy sound
00C405  1  85 FF               sta Square1SoundQueue
00C407  1  60           ExHCF: rts                      ;and now let's leave
00C408  1               
00C408  1               ;-------------------------------------------------------------------------------------
00C408  1               
00C408  1               PlayerHammerCollision:
00C408  1  A5 09                lda FrameCounter          ;get frame counter
00C40A  1  4A                   lsr                       ;shift d0 into carry
00C40B  1  90 39                bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
00C40D  1  AD D0 03             lda Player_OffscreenBits  ;if player offscreen bits, master timer control
00C410  1  0D 47 07             ora TimerControl          ;or any offscreen bits for hammer are set
00C413  1  0D D6 03             ora Misc_OffscreenBits    ;then branch to leave
00C416  1  D0 2E                bne ExPHC
00C418  1  8A                   txa
00C419  1  0A                   asl                       ;multiply misc object offset by four
00C41A  1  0A                   asl
00C41B  1  18                   clc
00C41C  1  69 24                adc #$24                  ;add 36 or $24 bytes to get proper offset
00C41E  1  A8                   tay                       ;for misc object bounding box coordinates
00C41F  1  20 A6 CF             jsr PlayerCollisionCore   ;do player-to-hammer collision detection
00C422  1  A6 08                ldx ObjectOffset          ;get misc object offset
00C424  1  90 1B                bcc ClHCol                ;if no collision, then branch
00C426  1  BD BE 06             lda Misc_Collision_Flag,x ;otherwise read collision flag
00C429  1  D0 1B                bne ExPHC                 ;if collision flag already set, branch to leave
00C42B  1  A9 01                lda #$01
00C42D  1  9D BE 06             sta Misc_Collision_Flag,x ;otherwise set collision flag now
00C430  1  B5 64                lda Misc_X_Speed,x
00C432  1  49 FF                eor #$ff                  ;get two's compliment of
00C434  1  18                   clc                       ;hammer's horizontal speed
00C435  1  69 01                adc #$01
00C437  1  95 64                sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
00C439  1  AD 9F 07             lda StarInvincibleTimer   ;if star mario invincibility timer set,
00C43C  1  D0 08                bne ExPHC                 ;branch to leave
00C43E  1  4C 7F C5             jmp InjurePlayer          ;otherwise jump to hurt player, do not return
00C441  1  A9 00        ClHCol: lda #$00                  ;clear collision flag
00C443  1  9D BE 06             sta Misc_Collision_Flag,x
00C446  1  60           ExPHC:  rts
00C447  1               
00C447  1               ;-------------------------------------------------------------------------------------
00C447  1               
00C447  1               HandlePowerUpCollision:
00C447  1  20 C9 B5           jsr EraseEnemyObject    ;erase the power-up object
00C44A  1  A5 39              lda PowerUpType
00C44C  1  C9 04              cmp #$04                ;check power-up type
00C44E  1  D0 03              bne Safe                ;if not a poison shroom, branch
00C450  1  4C 7F C5           jmp InjurePlayer        ;otherwise injure the player properly
00C453  1  A9 06        Safe: lda #$06
00C455  1  20 72 C6           jsr SetupFloateyNumber  ;award 1000 points to player by default
00C458  1  A9 20              lda #Sfx_PowerUpGrab
00C45A  1  85 FE              sta Square2SoundQueue   ;play the power-up sound
00C45C  1  A5 39              lda PowerUpType         ;check power-up type
00C45E  1  C9 02              cmp #$02
00C460  1  90 0E              bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
00C462  1  C9 03              cmp #$03
00C464  1  F0 24              beq SetFor1Up           ;if 1-up mushroom, branch
00C466  1  A9 23              lda #$23                ;otherwise set star mario invincibility
00C468  1  8D 9F 07           sta StarInvincibleTimer ;timer, and load the star mario music
00C46B  1  A9 40              lda #StarPowerMusic     ;into the area music queue, then leave
00C46D  1  85 FB              sta AreaMusicQueue
00C46F  1  60                 rts
00C470  1               
00C470  1               Shroom_Flower_PUp:
00C470  1  AD 56 07           lda PlayerStatus    ;if player status = small, branch
00C473  1  F0 1B              beq UpToSuper
00C475  1  C9 01              cmp #$01            ;if player status not super, leave
00C477  1  D0 23              bne NoPUp
00C479  1  A6 08              ldx ObjectOffset    ;get enemy offset, not necessary
00C47B  1  A9 02              lda #$02            ;set player status to fiery
00C47D  1  8D 56 07           sta PlayerStatus
00C480  1  20 03 85           jsr GetPlayerColors ;run sub to change colors of player
00C483  1  A6 08              ldx ObjectOffset    ;get enemy offset again, and again not necessary
00C485  1  A9 0C              lda #$0c            ;set value to be used by subroutine tree (fiery)
00C487  1  4C 97 C4           jmp UpToFiery       ;jump to set values accordingly
00C48A  1               
00C48A  1               SetFor1Up:
00C48A  1  A9 0B              lda #$0b                 ;change 1000 points into 1-up instead
00C48C  1  9D 10 01           sta FloateyNum_Control,x ;and then leave
00C48F  1  60                 rts
00C490  1               
00C490  1               UpToSuper:
00C490  1  A9 01               lda #$01         ;set player status to super
00C492  1  8D 56 07            sta PlayerStatus
00C495  1  A9 09               lda #$09         ;set value to be used by subroutine tree (super)
00C497  1               
00C497  1               UpToFiery:
00C497  1  A0 00               ldy #$00         ;set value to be used as new player state
00C499  1  20 9E C5            jsr SetPRout     ;set values to stop certain things in motion
00C49C  1  60           NoPUp: rts
00C49D  1               
00C49D  1               ;--------------------------------
00C49D  1               
00C49D  1               ResidualXSpdData:
00C49D  1  18 E8              .byte $18, $e8
00C49F  1               
00C49F  1               KickedShellXSpdData:
00C49F  1  30 D0              .byte $30, $d0
00C4A1  1               
00C4A1  1               DemotedKoopaXSpdData:
00C4A1  1  08 F8              .byte $08, $f8
00C4A3  1               
00C4A3  1               PlayerEnemyCollision:
00C4A3  1  A5 09                 lda FrameCounter            ;check counter for d0 set
00C4A5  1  4A                    lsr
00C4A6  1  B0 F4                 bcs NoPUp                   ;if set, branch to leave
00C4A8  1  20 AE C8              jsr CheckPlayerVertical     ;if player object is completely offscreen or
00C4AB  1  B0 23                 bcs NoPECol                 ;if down past 224th pixel row, branch to leave
00C4AD  1  BD D8 03              lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
00C4B0  1  D0 1E                 bne NoPECol                 ;go ahead and branch to leave
00C4B2  1  A5 0E                 lda GameEngineSubroutine
00C4B4  1  C9 08                 cmp #$08                    ;if not set to run player control routine
00C4B6  1  D0 18                 bne NoPECol                 ;on next frame, branch to leave
00C4B8  1  B5 1E                 lda Enemy_State,x
00C4BA  1  29 20                 and #%00100000              ;if enemy state has d5 set, branch to leave
00C4BC  1  D0 12                 bne NoPECol
00C4BE  1  20 B8 C8              jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
00C4C1  1  20 A6 CF              jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
00C4C4  1  A6 08                 ldx ObjectOffset            ;get enemy object buffer offset
00C4C6  1  B0 09                 bcs CheckForPUpCollision    ;if collision, branch past this part here
00C4C8  1  BD 91 04              lda Enemy_CollisionBits,x
00C4CB  1  29 FE                 and #%11111110              ;otherwise, clear d0 of current enemy object's
00C4CD  1  9D 91 04              sta Enemy_CollisionBits,x   ;collision bit
00C4D0  1  60           NoPECol: rts
00C4D1  1               
00C4D1  1               CheckForPUpCollision:
00C4D1  1  B4 16               ldy Enemy_ID,x
00C4D3  1  C0 2E               cpy #PowerUpObject            ;check for power-up object
00C4D5  1  D0 03               bne EColl                     ;if not found, branch to next part
00C4D7  1  4C 47 C4            jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
00C4DA  1  AD 9F 07     EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
00C4DD  1  F0 06               beq HandlePECollisions        ;perform task here, otherwise kill enemy like
00C4DF  1  4C CE C3            jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
00C4E2  1               
00C4E2  1               KickedShellPtsData:
00C4E2  1  0A 06 04           .byte $0a, $06, $04
00C4E5  1               
00C4E5  1               HandlePECollisions:
00C4E5  1  BD 91 04            lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
00C4E8  1  29 01               and #%00000001               ;or for being offscreen at all
00C4EA  1  1D D8 03            ora EnemyOffscrBitsMasked,x
00C4ED  1  D0 5D               bne ExPEC                    ;branch to leave if either is true
00C4EF  1  A9 01               lda #$01
00C4F1  1  1D 91 04            ora Enemy_CollisionBits,x    ;otherwise set d0 now
00C4F4  1  9D 91 04            sta Enemy_CollisionBits,x
00C4F7  1  C0 12               cpy #Spiny                   ;branch if spiny
00C4F9  1  F0 52               beq ChkForPlayerInjury
00C4FB  1  C0 33               cpy #BulletBill_CannonVar    ;branch if bullet bill
00C4FD  1  F0 4E               beq ChkForPlayerInjury
00C4FF  1  C0 0D               cpy #PiranhaPlant            ;branch if piranha plant
00C501  1  F0 7C               beq InjurePlayer
00C503  1  C0 04               cpy #UpsideDownPiranhaP      ;branch if upside-down piranha plant
00C505  1  F0 78               beq InjurePlayer
00C507  1  C0 0C               cpy #Podoboo                 ;branch if podoboo
00C509  1  F0 74               beq InjurePlayer
00C50B  1  C0 15               cpy #$15                     ;branch if object => $15
00C50D  1  B0 70               bcs InjurePlayer
00C50F  1  AD 4E 07            lda AreaType                 ;branch if water type level
00C512  1  F0 6B               beq InjurePlayer
00C514  1  B5 1E               lda Enemy_State,x            ;branch if d7 of enemy state was set
00C516  1  0A                  asl
00C517  1  B0 34               bcs ChkForPlayerInjury
00C519  1  B5 1E               lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
00C51B  1  29 07               and #%00000111
00C51D  1  C9 02               cmp #$02                     ;branch if enemy is in normal or falling state
00C51F  1  90 2C               bcc ChkForPlayerInjury
00C521  1  B5 16               lda Enemy_ID,x               ;branch to leave if goomba in defeated state
00C523  1  C9 06               cmp #Goomba
00C525  1  F0 25               beq ExPEC
00C527  1  A9 08               lda #Sfx_EnemySmack          ;play smack enemy sound
00C529  1  85 FF               sta Square1SoundQueue
00C52B  1  B5 1E               lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
00C52D  1  09 80               ora #%10000000
00C52F  1  95 1E               sta Enemy_State,x
00C531  1  20 66 C6            jsr EnemyFacePlayer          ;set moving direction and get offset
00C534  1  B9 9F C4            lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
00C537  1  95 58               sta Enemy_X_Speed,x
00C539  1  A9 03               lda #$03                     ;add three to whatever the stomp counter contains
00C53B  1  18                  clc                          ;to give points for kicking the shell
00C53C  1  6D 84 04            adc StompChainCounter
00C53F  1  BC 96 07            ldy EnemyIntervalTimer,x     ;check shell enemy's timer
00C542  1  C0 03               cpy #$03                     ;if above a certain point, branch using the points
00C544  1  B0 03               bcs KSPts                    ;data obtained from the stomp counter + 3
00C546  1  B9 E2 C4            lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
00C549  1  20 72 C6     KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
00C54C  1  60           ExPEC: rts                          ;leave!!!
00C54D  1               
00C54D  1               ChkForPlayerInjury:
00C54D  1  A4 9F                  ldy Player_Y_Speed     ;check player's vertical speed
00C54F  1  88                     dey                    ;branch elsewhere if player is not moving downwards
00C550  1  10 6D                  bpl EnemyStomped
00C552  1  B5 16        ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
00C554  1  C9 07                  cmp #Bloober
00C556  1  90 09                  bcc ChkETmrs
00C558  1  A5 CE                  lda Player_Y_Position  ;add 12 pixels to player's vertical position
00C55A  1  18                     clc
00C55B  1  69 0C                  adc #$0c
00C55D  1  D5 CF                  cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
00C55F  1  90 5E                  bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
00C561  1  AD 91 07     ChkETmrs: lda StompTimer         ;check stomp timer
00C564  1  D0 59                  bne EnemyStomped       ;branch if set
00C566  1  AD 9E 07               lda InjuryTimer        ;check to see if injured invincibility timer still
00C569  1  D0 40                  bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
00C56B  1  AD AD 03               lda Player_Rel_XPos
00C56E  1  CD AE 03               cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
00C571  1  90 03                  bcc TInjE              ;relative position, branch here
00C573  1  4C 57 C6               jmp ChkEnemyFaceRight  ;otherwise do a jump here
00C576  1  B5 46        TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
00C578  1  C9 01                  cmp #$01               ;branch, otherwise do a jump here
00C57A  1  D0 03                  bne InjurePlayer       ;to turn the enemy around
00C57C  1  4C 60 C6               jmp LInj
00C57F  1               
00C57F  1               InjurePlayer:
00C57F  1  AD 9E 07           lda InjuryTimer          ;check again to see if either of the two
00C582  1  0D 9F 07           ora StarInvincibleTimer  ;invincibility timers have expired, branch if not
00C585  1  D0 24              bne ExInjColRoutines
00C587  1               
00C587  1               ForceInjury:
00C587  1  AE 56 07               ldx PlayerStatus          ;check player's status
00C58A  1  F0 22                  beq KillPlayer            ;branch if small
00C58C  1  8D 56 07               sta PlayerStatus          ;otherwise set player's status to small
00C58F  1  A9 08                  lda #$08
00C591  1  8D 9E 07               sta InjuryTimer           ;set injured invincibility timer
00C594  1  0A                     asl
00C595  1  85 FF                  sta Square1SoundQueue     ;play pipedown/injury sound
00C597  1  20 03 85               jsr GetPlayerColors       ;change player's palette if necessary
00C59A  1  A9 0A                  lda #$0a                  ;set subroutine to run on next frame
00C59C  1  A0 01        SetKRout: ldy #$01                  ;set new player state
00C59E  1  85 0E        SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
00C5A0  1  84 1D                  sty Player_State          ;store new player state
00C5A2  1  A0 FF                  ldy #$ff
00C5A4  1  8C 47 07               sty TimerControl          ;set master timer control flag to halt timers
00C5A7  1  C8                     iny
00C5A8  1  8C 75 07               sty ScrollAmount          ;initialize scroll speed
00C5AB  1               
00C5AB  1               ExInjColRoutines:
00C5AB  1  A6 08              ldx ObjectOffset              ;get enemy offset and leave
00C5AD  1  60                 rts
00C5AE  1               
00C5AE  1               KillPlayer:
00C5AE  1  86 57              stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
00C5B0  1  E8                 inx
00C5B1  1  86 FC              stx EventMusicQueue  ;set event music queue to death music
00C5B3  1  A9 FC              lda #$fc
00C5B5  1  85 9F              sta Player_Y_Speed   ;set new vertical speed
00C5B7  1  A9 0B              lda #$0b             ;set subroutine to run on next frame
00C5B9  1  D0 E1              bne SetKRout         ;branch to set player's state and other things
00C5BB  1               
00C5BB  1               StompedEnemyPtsData:
00C5BB  1  02 06 05 06        .byte $02, $06, $05, $06
00C5BF  1               
00C5BF  1               EnemyStomped:
00C5BF  1  B5 16              lda Enemy_ID,x             ;check for spiny, branch to hurt player
00C5C1  1  C9 12              cmp #Spiny                 ;if found
00C5C3  1  F0 BA              beq InjurePlayer
00C5C5  1  A9 04              lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
00C5C7  1  85 FF              sta Square1SoundQueue
00C5C9  1  B5 16              lda Enemy_ID,x
00C5CB  1  A0 00              ldy #$00                   ;initialize points data offset for stomped enemies
00C5CD  1  C9 14              cmp #FlyingCheepCheep      ;branch for cheep-cheep
00C5CF  1  F0 1B              beq EnemyStompedPts
00C5D1  1  C9 08              cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
00C5D3  1  F0 17              beq EnemyStompedPts
00C5D5  1  C9 33              cmp #BulletBill_CannonVar
00C5D7  1  F0 13              beq EnemyStompedPts
00C5D9  1  C9 0C              cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
00C5DB  1  F0 0F              beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
00C5DD  1  C8                 iny                        ;increment points data offset
00C5DE  1  C9 05              cmp #HammerBro             ;branch for hammer bro
00C5E0  1  F0 0A              beq EnemyStompedPts
00C5E2  1  C8                 iny                        ;increment points data offset
00C5E3  1  C9 11              cmp #Lakitu                ;branch for lakitu
00C5E5  1  F0 05              beq EnemyStompedPts
00C5E7  1  C8                 iny                        ;increment points data offset
00C5E8  1  C9 07              cmp #Bloober               ;branch if NOT bloober
00C5EA  1  D0 1B              bne ChkForDemoteKoopa
00C5EC  1               
00C5EC  1               EnemyStompedPts:
00C5EC  1  B9 BB C5           lda StompedEnemyPtsData,y  ;load points data using offset in Y
00C5EF  1  20 72 C6           jsr SetupFloateyNumber     ;run sub to set floatey number controls
00C5F2  1  B5 46              lda Enemy_MovingDir,x
00C5F4  1  48                 pha                        ;save enemy movement direction to stack
00C5F5  1  20 A4 CC           jsr NoDemote               ;run sub to kill enemy
00C5F8  1  68                 pla
00C5F9  1  95 46              sta Enemy_MovingDir,x      ;return enemy movement direction from stack
00C5FB  1  A9 20              lda #%00100000
00C5FD  1  95 1E              sta Enemy_State,x          ;set d5 in enemy state
00C5FF  1  20 6E AF           jsr InitVStf               ;nullify vertical speed, physics-related thing,
00C602  1  95 58              sta Enemy_X_Speed,x        ;and horizontal speed
00C604  1  4C 46 C6           jmp SetBounce
00C607  1               
00C607  1               ChkForDemoteKoopa:
00C607  1  C9 09              cmp #$09                   ;branch elsewhere if enemy object < $09
00C609  1  90 1E              bcc HandleStompedShellE
00C60B  1  20 46 C6           jsr SetBounce
00C60E  1  29 01              and #%00000001             ;demote koopa paratroopas to ordinary troopas
00C610  1  95 16              sta Enemy_ID,x
00C612  1  A9 00              lda #$00                   ;return enemy to normal state
00C614  1  95 1E              sta Enemy_State,x
00C616  1  A9 03              lda #$03                   ;award 400 points to the player
00C618  1  20 72 C6           jsr SetupFloateyNumber
00C61B  1  20 6E AF           jsr InitVStf               ;nullify physics-related thing and vertical speed
00C61E  1  20 66 C6           jsr EnemyFacePlayer        ;turn enemy around if necessary
00C621  1  B9 A1 C4           lda DemotedKoopaXSpdData,y
00C624  1  95 58              sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
00C626  1  60                 rts
00C627  1               
00C627  1               RevivalRateData:
00C627  1  10 0B              .byte $10, $0b
00C629  1               
00C629  1               HandleStompedShellE:
00C629  1  A9 04               lda #$04                   ;set defeated state for enemy
00C62B  1  95 1E               sta Enemy_State,x
00C62D  1  EE 84 04            inc StompChainCounter      ;increment the stomp counter
00C630  1  AD 84 04            lda StompChainCounter      ;add whatever is in the stomp counter
00C633  1  18                  clc                        ;to whatever is in the stomp timer
00C634  1  6D 91 07            adc StompTimer
00C637  1  20 72 C6            jsr SetupFloateyNumber     ;award points accordingly
00C63A  1  EE 91 07            inc StompTimer             ;increment stomp timer of some sort
00C63D  1  AC 6A 07            ldy PrimaryHardMode        ;check primary hard mode flag
00C640  1  B9 27 C6            lda RevivalRateData,y      ;load timer setting according to flag
00C643  1  9D 96 07            sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
00C646  1               SetBounce:
00C646  1  A0 FA               ldy #$fa                   ;set a regular bounce rate for all other enemies
00C648  1  B5 16               lda Enemy_ID,x
00C64A  1  C9 0F               cmp #RedParatroopa         ;set a higher bounce rate for red paratroopas
00C64C  1  F0 04               beq BnceH                  ;and green paratroopas that fly
00C64E  1  C9 10               cmp #GreenParatroopaFly
00C650  1  D0 02               bne BnceL
00C652  1  A0 F8        BnceH: ldy #$f8                   ;set player's vertical speed for bounce
00C654  1  84 9F        BnceL: sty Player_Y_Speed         ;and then leave!!!
00C656  1  60                  rts
00C657  1               
00C657  1               ChkEnemyFaceRight:
00C657  1  B5 46               lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
00C659  1  C9 01               cmp #$01
00C65B  1  D0 03               bne LInj              ;if not, branch
00C65D  1  4C 7F C5            jmp InjurePlayer      ;otherwise go back to hurt player
00C660  1  20 85 C7     LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
00C663  1  4C 7F C5            jmp InjurePlayer      ;go back to hurt player
00C666  1               
00C666  1               EnemyFacePlayer:
00C666  1  A0 01               ldy #$01               ;set to move right by default
00C668  1  20 BC CD            jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
00C66B  1  10 01               bpl SFcRt              ;if enemy is to the right of player, do not increment
00C66D  1  C8                  iny                    ;otherwise, increment to set to move to the left
00C66E  1  94 46        SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
00C670  1  88                  dey                    ;then decrement to use as a proper offset
00C671  1  60                  rts
00C672  1               
00C672  1               SetupFloateyNumber:
00C672  1  9D 10 01            sta FloateyNum_Control,x ;set number of points control for floatey numbers
00C675  1  A9 30               lda #$30
00C677  1  9D 2C 01            sta FloateyNum_Timer,x   ;set timer for floatey numbers
00C67A  1  B5 CF               lda Enemy_Y_Position,x
00C67C  1  9D 1E 01            sta FloateyNum_Y_Pos,x   ;set vertical coordinate
00C67F  1  AD AE 03            lda Enemy_Rel_XPos
00C682  1  9D 17 01            sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
00C685  1  60           ExSFN: rts
00C686  1               
00C686  1               ;-------------------------------------------------------------------------------------
00C686  1               ;$01 - used to hold enemy offset for second enemy
00C686  1               
00C686  1               SetBitsMask:
00C686  1  80 40 20 10        .byte %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
00C68A  1  08 04 02     
00C68D  1               
00C68D  1               ClearBitsMask:
00C68D  1  7F BF DF EF        .byte %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
00C691  1  F7 FB FD     
00C694  1               
00C694  1               EnemiesCollision:
00C694  1  A5 09                lda FrameCounter            ;check counter for d0 set
00C696  1  4A                   lsr
00C697  1  90 EC                bcc ExSFN                   ;if d0 not set, leave
00C699  1  AD 4E 07             lda AreaType
00C69C  1  F0 E7                beq ExSFN                   ;if water area type, leave
00C69E  1  B5 16                lda Enemy_ID,x
00C6A0  1  C9 15                cmp #$15                    ;if enemy object => $15, branch to leave
00C6A2  1  B0 76                bcs ExitECRoutine
00C6A4  1  C9 11                cmp #Lakitu                 ;if lakitu, branch to leave
00C6A6  1  F0 72                beq ExitECRoutine
00C6A8  1  C9 0D                cmp #PiranhaPlant           ;if piranha plant, branch to leave
00C6AA  1  F0 6E                beq ExitECRoutine
00C6AC  1  C9 04                cmp #UpsideDownPiranhaP     ;if upside-down piranha plant, branch to leave
00C6AE  1  F0 6A                beq ExitECRoutine
00C6B0  1  BD D8 03             lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
00C6B3  1  D0 65                bne ExitECRoutine
00C6B5  1  20 B8 C8             jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
00C6B8  1  CA                   dex                         ;first enemy we're going to compare, then decrement for second
00C6B9  1  30 5F                bmi ExitECRoutine           ;branch to leave if there are no other enemies
00C6BB  1  86 01        ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
00C6BD  1  98                   tya                         ;save first enemy's bounding box offset to stack
00C6BE  1  48                   pha
00C6BF  1  B5 0F                lda Enemy_Flag,x            ;check enemy object enable flag
00C6C1  1  F0 50                beq ReadyNextEnemy          ;branch if flag not set
00C6C3  1  B5 16                lda Enemy_ID,x
00C6C5  1  C9 15                cmp #$15                    ;check for enemy object => $15
00C6C7  1  B0 4A                bcs ReadyNextEnemy          ;branch if true
00C6C9  1  C9 11                cmp #Lakitu
00C6CB  1  F0 46                beq ReadyNextEnemy          ;branch if enemy object is lakitu
00C6CD  1  C9 0D                cmp #PiranhaPlant
00C6CF  1  F0 42                beq ReadyNextEnemy          ;branch if enemy object is piranha plant
00C6D1  1  C9 04                cmp #UpsideDownPiranhaP
00C6D3  1  F0 3E                beq ReadyNextEnemy          ;branch if enemy object is upside-down piranha plant
00C6D5  1  BD D8 03             lda EnemyOffscrBitsMasked,x
00C6D8  1  D0 39                bne ReadyNextEnemy          ;branch if masked offscreen bits set
00C6DA  1  8A                   txa                         ;get second enemy object's bounding box offset
00C6DB  1  0A                   asl                         ;multiply by four, then add four
00C6DC  1  0A                   asl
00C6DD  1  18                   clc
00C6DE  1  69 04                adc #$04
00C6E0  1  AA                   tax                         ;use as new contents of X
00C6E1  1  20 A8 CF             jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
00C6E4  1  A6 08                ldx ObjectOffset            ;use first enemy offset for X
00C6E6  1  A4 01                ldy $01                     ;use second enemy offset for Y
00C6E8  1  90 20                bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
00C6EA  1  B5 1E                lda Enemy_State,x
00C6EC  1  19 1E 00             ora Enemy_State,y           ;check both enemy states for d7 set
00C6EF  1  29 80                and #%10000000
00C6F1  1  D0 11                bne YesEC                   ;branch if at least one of them is set
00C6F3  1  B9 91 04             lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
00C6F6  1  3D 86 C6             and SetBitsMask,x           ;check to see if bit connected to second enemy is
00C6F9  1  D0 18                bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
00C6FB  1  B9 91 04             lda Enemy_CollisionBits,y
00C6FE  1  1D 86 C6             ora SetBitsMask,x           ;if the bit is not set, set it now
00C701  1  99 91 04             sta Enemy_CollisionBits,y
00C704  1  20 1D C7     YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
00C707  1  4C 13 C7             jmp ReadyNextEnemy          ;move onto next enemy slot
00C70A  1               
00C70A  1               NoEnemyCollision:
00C70A  1  B9 91 04           lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
00C70D  1  3D 8D C6           and ClearBitsMask,x           ;clear bit connected to second enemy
00C710  1  99 91 04           sta Enemy_CollisionBits,y     ;then move onto next enemy slot
00C713  1               
00C713  1               ReadyNextEnemy:
00C713  1  68                 pla              ;get first enemy's bounding box offset from the stack
00C714  1  A8                 tay              ;use as Y again
00C715  1  A6 01              ldx $01          ;get and decrement second enemy's object buffer offset
00C717  1  CA                 dex
00C718  1  10 A1              bpl ECLoop       ;loop until all enemy slots have been checked
00C71A  1               
00C71A  1               ExitECRoutine:
00C71A  1  A6 08              ldx ObjectOffset ;get enemy object buffer offset
00C71C  1  60                 rts              ;leave
00C71D  1               
00C71D  1               ProcEnemyCollisions:
00C71D  1  B9 1E 00           lda Enemy_State,y        ;check both enemy states for d5 set
00C720  1  15 1E              ora Enemy_State,x
00C722  1  29 20              and #%00100000           ;if d5 is set in either state, or both, branch
00C724  1  D0 33              bne ExitProcessEColl     ;to leave and do nothing else at this point
00C726  1  B5 1E              lda Enemy_State,x
00C728  1  C9 06              cmp #$06                 ;if second enemy state < $06, branch elsewhere
00C72A  1  90 2E              bcc ProcSecondEnemyColl
00C72C  1  B5 16              lda Enemy_ID,x           ;check second enemy identifier for hammer bro
00C72E  1  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00C730  1  F0 27              beq ExitProcessEColl
00C732  1  B9 1E 00           lda Enemy_State,y        ;check first enemy state for d7 set
00C735  1  0A                 asl
00C736  1  90 0A              bcc ShellCollisions      ;branch if d7 is clear
00C738  1  A9 06              lda #$06
00C73A  1  20 72 C6           jsr SetupFloateyNumber   ;award 1000 points for killing enemy
00C73D  1  20 CE C3           jsr ShellOrBlockDefeat   ;then kill enemy, then load
00C740  1  A4 01              ldy $01                  ;original offset of second enemy
00C742  1               
00C742  1               ShellCollisions:
00C742  1  98                 tya                      ;move Y to X
00C743  1  AA                 tax
00C744  1  20 CE C3           jsr ShellOrBlockDefeat   ;kill second enemy
00C747  1  A6 08              ldx ObjectOffset
00C749  1  BD 25 01           lda ShellChainCounter,x  ;get chain counter for shell
00C74C  1  18                 clc
00C74D  1  69 04              adc #$04                 ;add four to get appropriate point offset
00C74F  1  A6 01              ldx $01
00C751  1  20 72 C6           jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
00C754  1  A6 08              ldx ObjectOffset         ;load original offset of first enemy
00C756  1  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00C759  1               
00C759  1               ExitProcessEColl:
00C759  1  60                 rts                      ;leave!!!
00C75A  1               
00C75A  1               ProcSecondEnemyColl:
00C75A  1  B9 1E 00           lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
00C75D  1  C9 06              cmp #$06
00C75F  1  90 1D              bcc MoveEOfs
00C761  1  B9 16 00           lda Enemy_ID,y           ;check first enemy identifier for hammer bro
00C764  1  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00C766  1  F0 F1              beq ExitProcessEColl
00C768  1  20 CE C3           jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
00C76B  1  A4 01              ldy $01
00C76D  1  B9 25 01           lda ShellChainCounter,y  ;get chain counter for shell
00C770  1  18                 clc
00C771  1  69 04              adc #$04                 ;add four to get appropriate point offset
00C773  1  A6 08              ldx ObjectOffset
00C775  1  20 72 C6           jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
00C778  1  A6 01              ldx $01                  ;load original offset of second enemy
00C77A  1  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00C77D  1  60                 rts                      ;leave!!!
00C77E  1               
00C77E  1               MoveEOfs:
00C77E  1  98                 tya                      ;move Y ($01) to X
00C77F  1  AA                 tax
00C780  1  20 85 C7           jsr EnemyTurnAround      ;do the sub here using value from $01
00C783  1  A6 08              ldx ObjectOffset         ;then do it again using value from $08
00C785  1               
00C785  1               EnemyTurnAround:
00C785  1  B5 16               lda Enemy_ID,x           ;check for specific enemies
00C787  1  C9 0D               cmp #PiranhaPlant
00C789  1  F0 26               beq ExTA                 ;if piranha plant, leave
00C78B  1  C9 04               cmp #UpsideDownPiranhaP
00C78D  1  F0 22               beq ExTA                 ;if upside-down piranha plant, leave
00C78F  1  C9 11               cmp #Lakitu
00C791  1  F0 1E               beq ExTA                 ;if lakitu, leave
00C793  1  C9 05               cmp #HammerBro
00C795  1  F0 1A               beq ExTA                 ;if hammer bro, leave
00C797  1  C9 12               cmp #Spiny
00C799  1  F0 08               beq RXSpd                ;if spiny, turn it around
00C79B  1  C9 0E               cmp #GreenParatroopaJump
00C79D  1  F0 04               beq RXSpd                ;if green paratroopa, turn it around
00C79F  1  C9 07               cmp #$07
00C7A1  1  B0 0E               bcs ExTA                 ;if any OTHER enemy object => $07, leave
00C7A3  1  B5 58        RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
00C7A5  1  49 FF               eor #$ff                 ;get two's compliment for horizontal speed
00C7A7  1  A8                  tay
00C7A8  1  C8                  iny
00C7A9  1  94 58               sty Enemy_X_Speed,x      ;store as new horizontal speed
00C7AB  1  B5 46               lda Enemy_MovingDir,x
00C7AD  1  49 03               eor #%00000011           ;invert moving direction and store, then leave
00C7AF  1  95 46               sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
00C7B1  1  60           ExTA:  rts                      ;leave!!!
00C7B2  1               
00C7B2  1               ;-------------------------------------------------------------------------------------
00C7B2  1               ;$00 - vertical position of platform
00C7B2  1               
00C7B2  1               LargePlatformCollision:
00C7B2  1  A9 FF               lda #$ff                     ;save value here
00C7B4  1  9D A2 03            sta PlatformCollisionFlag,x
00C7B7  1  AD 47 07            lda TimerControl             ;check master timer control
00C7BA  1  D0 29               bne ExLPC                    ;if set, branch to leave
00C7BC  1  B5 1E               lda Enemy_State,x            ;if d7 set in object state,
00C7BE  1  30 25               bmi ExLPC                    ;branch to leave
00C7C0  1  B5 16               lda Enemy_ID,x
00C7C2  1  C9 24               cmp #$24                     ;check enemy object identifier for
00C7C4  1  D0 06               bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
00C7C6  1  B5 1E               lda Enemy_State,x
00C7C8  1  AA                  tax                          ;set state as enemy offset here
00C7C9  1  20 CC C7            jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
00C7CC  1               
00C7CC  1               ChkForPlayerC_LargeP:
00C7CC  1  20 AE C8            jsr CheckPlayerVertical      ;figure out if player is below a certain point
00C7CF  1  B0 14               bcs ExLPC                    ;or offscreen, branch to leave if true
00C7D1  1  8A                  txa
00C7D2  1  20 BA C8            jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
00C7D5  1  B5 CF               lda Enemy_Y_Position,x       ;store vertical coordinate in
00C7D7  1  85 00               sta $00                      ;temp variable for now
00C7D9  1  8A                  txa                          ;send offset we're on to the stack
00C7DA  1  48                  pha
00C7DB  1  20 A6 CF            jsr PlayerCollisionCore      ;do player-to-platform collision detection
00C7DE  1  68                  pla                          ;retrieve offset from the stack
00C7DF  1  AA                  tax
00C7E0  1  90 03               bcc ExLPC                    ;if no collision, branch to leave
00C7E2  1  20 29 C8            jsr ProcLPlatCollisions      ;otherwise collision, perform sub
00C7E5  1  A6 08        ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
00C7E7  1  60                  rts
00C7E8  1               
00C7E8  1               ;--------------------------------
00C7E8  1               ;$00 - counter for bounding boxes
00C7E8  1               
00C7E8  1               SmallPlatformCollision:
00C7E8  1  AD 47 07           lda TimerControl             ;if master timer control set,
00C7EB  1  D0 37              bne ExSPC                    ;branch to leave
00C7ED  1  9D A2 03           sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
00C7F0  1  20 AE C8           jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
00C7F3  1  B0 2F              bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
00C7F5  1  A9 02              lda #$02
00C7F7  1  85 00              sta $00                      ;load counter here for 2 bounding boxes
00C7F9  1               
00C7F9  1               ChkSmallPlatLoop:
00C7F9  1  A6 08              ldx ObjectOffset           ;get enemy object offset
00C7FB  1  20 B8 C8           jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
00C7FE  1  29 02              and #%00000010             ;if d1 of offscreen lower nybble bits was set
00C800  1  D0 22              bne ExSPC                  ;then branch to leave
00C802  1  B9 AD 04           lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
00C805  1  C9 20              cmp #$20                   ;above a specific point
00C807  1  90 05              bcc MoveBoundBox           ;if so, branch, don't do collision detection
00C809  1  20 A6 CF           jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
00C80C  1  B0 19              bcs ProcSPlatCollisions    ;skip ahead if collision
00C80E  1               
00C80E  1               MoveBoundBox:
00C80E  1  B9 AD 04            lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
00C811  1  18                  clc                        ;128 pixels downwards
00C812  1  69 80               adc #$80
00C814  1  99 AD 04            sta BoundingBox_UL_YPos,y
00C817  1  B9 AF 04            lda BoundingBox_DR_YPos,y
00C81A  1  18                  clc
00C81B  1  69 80               adc #$80
00C81D  1  99 AF 04            sta BoundingBox_DR_YPos,y
00C820  1  C6 00               dec $00                    ;decrement counter we set earlier
00C822  1  D0 D5               bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
00C824  1  A6 08        ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
00C826  1  60                  rts
00C827  1               
00C827  1               ;--------------------------------
00C827  1               
00C827  1               ProcSPlatCollisions:
00C827  1  A6 08              ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
00C829  1               
00C829  1               ProcLPlatCollisions:
00C829  1  B9 AF 04           lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
00C82C  1  38                 sec                          ;of the player's bounding box from the bottom
00C82D  1  ED AD 04           sbc BoundingBox_UL_YPos      ;of the platform's bounding box
00C830  1  C9 04              cmp #$04                     ;if difference too large or negative,
00C832  1  B0 08              bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
00C834  1  A5 9F              lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
00C836  1  10 04              bpl ChkForTopCollision       ;if so, don't mess with it
00C838  1  A9 01              lda #$01                     ;otherwise, set vertical
00C83A  1  85 9F              sta Player_Y_Speed           ;speed of player to kill jump
00C83C  1               
00C83C  1               ChkForTopCollision:
00C83C  1  AD AF 04           lda BoundingBox_DR_YPos      ;get difference by subtracting the top
00C83F  1  38                 sec                          ;of the platform's bounding box from the bottom
00C840  1  F9 AD 04           sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
00C843  1  C9 06              cmp #$06
00C845  1  B0 1B              bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
00C847  1  A5 9F              lda Player_Y_Speed
00C849  1  30 17              bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
00C84B  1  A5 00              lda $00                      ;get saved bounding box counter from earlier
00C84D  1  B4 16              ldy Enemy_ID,x
00C84F  1  C0 2B              cpy #$2b                     ;if either of the two small platform objects are found,
00C851  1  F0 05              beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
00C853  1  C0 2C              cpy #$2c                     ;as contents of collision flag
00C855  1  F0 01              beq SetCollisionFlag
00C857  1  8A                 txa                          ;otherwise use enemy object buffer offset
00C858  1               
00C858  1               SetCollisionFlag:
00C858  1  A6 08              ldx ObjectOffset             ;get enemy object buffer offset
00C85A  1  9D A2 03           sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
00C85D  1  A9 00              lda #$00
00C85F  1  85 1D              sta Player_State             ;set player state to normal then leave
00C861  1  60                 rts
00C862  1               
00C862  1               PlatformSideCollisions:
00C862  1  A9 01                 lda #$01                   ;set value here to indicate possible horizontal
00C864  1  85 00                 sta $00                    ;collision on left side of platform
00C866  1  AD AE 04              lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
00C869  1  38                    sec                        ;from player's right edge
00C86A  1  F9 AC 04              sbc BoundingBox_UL_XPos,y
00C86D  1  C9 08                 cmp #$08                   ;if difference close enough, skip all of this
00C86F  1  90 0D                 bcc SideC
00C871  1  E6 00                 inc $00                    ;otherwise increment value set here for right side collision
00C873  1  B9 AE 04              lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
00C876  1  18                    clc                        ;from platform's right edge
00C877  1  ED AC 04              sbc BoundingBox_UL_XPos
00C87A  1  C9 09                 cmp #$09                   ;if difference not close enough, skip subroutine
00C87C  1  B0 03                 bcs NoSideC                ;and instead branch to leave (no collision)
00C87E  1  20 B7 CB     SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
00C881  1  A6 08        NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
00C883  1  60                    rts
00C884  1               
00C884  1               ;-------------------------------------------------------------------------------------
00C884  1               
00C884  1               PlayerPosSPlatData:
00C884  1  80 00              .byte $80, $00
00C886  1               
00C886  1               PositionPlayerOnS_Plat:
00C886  1  A8                 tay                        ;use bounding box counter saved in collision flag
00C887  1  B5 CF              lda Enemy_Y_Position,x     ;for offset
00C889  1  18                 clc                        ;add positioning data using offset to the vertical
00C88A  1  79 83 C8           adc PlayerPosSPlatData-1,y ;coordinate
00C88D  1  2C                 .byte $2c                    ;BIT instruction opcode
00C88E  1               
00C88E  1               PositionPlayerOnVPlat:
00C88E  1  B5 CF                 lda Enemy_Y_Position,x    ;get vertical coordinate
00C890  1  A4 0E                 ldy GameEngineSubroutine
00C892  1  C0 0B                 cpy #$0b                  ;if certain routine being executed on this frame,
00C894  1  F0 17                 beq ExPlPos               ;skip all of this
00C896  1  B4 B6                 ldy Enemy_Y_HighPos,x
00C898  1  C0 01                 cpy #$01                  ;if vertical high byte offscreen, skip this
00C89A  1  D0 11                 bne ExPlPos
00C89C  1  38                    sec                       ;subtract 32 pixels from vertical coordinate
00C89D  1  E9 20                 sbc #$20                  ;for the player object's height
00C89F  1  85 CE                 sta Player_Y_Position     ;save as player's new vertical coordinate
00C8A1  1  98                    tya
00C8A2  1  E9 00                 sbc #$00                  ;subtract borrow and store as player's
00C8A4  1  85 B5                 sta Player_Y_HighPos      ;new vertical high byte
00C8A6  1  A9 00                 lda #$00
00C8A8  1  85 9F                 sta Player_Y_Speed        ;initialize vertical speed and low byte of force
00C8AA  1  8D 33 04              sta Player_Y_MoveForce    ;and then leave
00C8AD  1  60           ExPlPos: rts
00C8AE  1               
00C8AE  1               ;-------------------------------------------------------------------------------------
00C8AE  1               
00C8AE  1               CheckPlayerVertical:
00C8AE  1  AD D0 03            lda Player_OffscreenBits  ;if player object is not offscreen
00C8B1  1  29 F0               and #$f0                  ;then branch with clear carry flag
00C8B3  1  18                  clc
00C8B4  1  F0 01               beq ExCPV                 ;otherwise fall through and set carry flag
00C8B6  1  38                  sec                       ;to symbolize that player is offscreen
00C8B7  1  60           ExCPV: rts
00C8B8  1               
00C8B8  1               ;-------------------------------------------------------------------------------------
00C8B8  1               
00C8B8  1               GetEnemyBoundBoxOfs:
00C8B8  1  A5 08              lda ObjectOffset         ;get enemy object buffer offset
00C8BA  1               
00C8BA  1               GetEnemyBoundBoxOfsArg:
00C8BA  1  0A                 asl                      ;multiply A by four, then add four
00C8BB  1  0A                 asl                      ;to skip player's bounding box
00C8BC  1  18                 clc
00C8BD  1  69 04              adc #$04
00C8BF  1  A8                 tay                      ;send to Y
00C8C0  1  AD D1 03           lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
00C8C3  1  29 0F              and #%00001111           ;save low nybble
00C8C5  1  C9 0F              cmp #%00001111           ;check for all bits set
00C8C7  1  60                 rts
00C8C8  1               
00C8C8  1               ;-------------------------------------------------------------------------------------
00C8C8  1               ;$00-$01 - used to hold many values, essentially temp variables
00C8C8  1               ;$04 - holds lower nybble of vertical coordinate from block buffer routine
00C8C8  1               ;$eb - used to hold block buffer adder
00C8C8  1               
00C8C8  1               PlayerBGUpperExtent:
00C8C8  1  20 10              .byte $20, $10
00C8CA  1               
00C8CA  1               PlayerBGCollision:
00C8CA  1  AD 16 07               lda DisableCollisionDet   ;if collision detection disabled flag set,
00C8CD  1  D0 2E                  bne ExPBGCol              ;branch to leave
00C8CF  1  A5 0E                  lda GameEngineSubroutine
00C8D1  1  C9 0B                  cmp #$0b                  ;if running routine #11 or $0b
00C8D3  1  F0 28                  beq ExPBGCol              ;branch to leave
00C8D5  1  C9 04                  cmp #$04
00C8D7  1  90 24                  bcc ExPBGCol              ;if running routines $00-$03 branch to leave
00C8D9  1  A9 01                  lda #$01                  ;load default player state for swimming
00C8DB  1  AC 04 07               ldy SwimmingFlag          ;if swimming flag set,
00C8DE  1  D0 0A                  bne SetPSte               ;branch ahead to set default state
00C8E0  1  A5 1D                  lda Player_State          ;if player in normal state,
00C8E2  1  F0 04                  beq SetFallS              ;branch to set default state for falling
00C8E4  1  C9 03                  cmp #$03
00C8E6  1  D0 04                  bne ChkOnScr              ;if in any other state besides climbing, skip to next part
00C8E8  1  A9 02        SetFallS: lda #$02                  ;load default player state for falling
00C8EA  1  85 1D        SetPSte:  sta Player_State          ;set whatever player state is appropriate
00C8EC  1  A5 B5        ChkOnScr: lda Player_Y_HighPos
00C8EE  1  C9 01                  cmp #$01                  ;check player's vertical high byte for still on the screen
00C8F0  1  D0 0B                  bne ExPBGCol              ;branch to leave if not
00C8F2  1  A9 FF                  lda #$ff
00C8F4  1  8D 90 04               sta Player_CollisionBits  ;initialize player's collision flag
00C8F7  1  A5 CE                  lda Player_Y_Position
00C8F9  1  C9 CF                  cmp #$cf                  ;check player's vertical coordinate
00C8FB  1  90 01                  bcc ChkCollSize           ;if not too close to the bottom of screen, continue
00C8FD  1  60           ExPBGCol: rts                       ;otherwise leave
00C8FE  1               
00C8FE  1               ChkCollSize:
00C8FE  1  A0 02                 ldy #$02                    ;load default offset
00C900  1  AD 14 07              lda CrouchingFlag
00C903  1  D0 0C                 bne GBBAdr                  ;if player crouching, skip ahead
00C905  1  AD 54 07              lda PlayerSize
00C908  1  D0 07                 bne GBBAdr                  ;if player small, skip ahead
00C90A  1  88                    dey                         ;otherwise decrement offset for big player not crouching
00C90B  1  AD 04 07              lda SwimmingFlag
00C90E  1  D0 01                 bne GBBAdr                  ;if swimming flag set, skip ahead
00C910  1  88                    dey                         ;otherwise decrement offset
00C911  1  B9 2E D0     GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
00C914  1  85 EB                 sta $eb                     ;store value here
00C916  1  A8                    tay                         ;put value into Y, as offset for block buffer routine
00C917  1  AE 54 07              ldx PlayerSize              ;get player's size as offset
00C91A  1  AD 14 07              lda CrouchingFlag
00C91D  1  F0 01                 beq HeadChk                 ;if player not crouching, branch ahead
00C91F  1  E8                    inx                         ;otherwise increment size as offset
00C920  1  A5 CE        HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
00C922  1  DD C8 C8              cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
00C925  1  90 35                 bcc DoFootCheck             ;if player is too high, skip this part
00C927  1  20 6A D0              jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
00C92A  1  F0 30                 beq DoFootCheck             ;player, and branch if nothing above player's head
00C92C  1  20 0D CC              jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
00C92F  1  B0 4F                 bcs AwardTouchedCoin        ;if so, branch to some other part of code
00C931  1  A4 9F                 ldy Player_Y_Speed          ;check player's vertical speed
00C933  1  10 27                 bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
00C935  1  A4 04                 ldy $04                     ;check lower nybble of vertical coordinate returned
00C937  1  C0 04                 cpy #$04                    ;from collision detection routine
00C939  1  90 21                 bcc DoFootCheck             ;if low nybble < 4, branch
00C93B  1  20 FB CB              jsr CheckForSolidMTiles     ;check to see what player's head bumped on
00C93E  1  B0 10                 bcs SolidOrClimb            ;if player collided with solid metatile, branch
00C940  1  AC 4E 07              ldy AreaType                ;otherwise check area type
00C943  1  F0 13                 beq NYSpd                   ;if water level, branch ahead
00C945  1  AC 84 07              ldy BlockBounceTimer        ;if block bounce timer not expired,
00C948  1  D0 0E                 bne NYSpd                   ;branch ahead, do not process collision
00C94A  1  20 D9 A8              jsr PlayerHeadCollision     ;otherwise do a sub to process collision
00C94D  1  4C 5C C9              jmp DoFootCheck             ;jump ahead to skip these other parts here
00C950  1               
00C950  1               SolidOrClimb:
00C950  1  C9 23               cmp #$23               ;if climbing metatile,
00C952  1  F0 04               beq NYSpd              ;branch ahead and do not play sound
00C954  1  A9 02               lda #Sfx_Bump
00C956  1  85 FF               sta Square1SoundQueue  ;otherwise load bump sound
00C958  1  A9 01        NYSpd: lda #$01               ;set player's vertical speed to nullify
00C95A  1  85 9F               sta Player_Y_Speed     ;jump or swim
00C95C  1               
00C95C  1               DoFootCheck:
00C95C  1  A4 EB              ldy $eb                    ;get block buffer adder offset
00C95E  1  A5 CE              lda Player_Y_Position
00C960  1  C9 CF              cmp #$cf                   ;check to see how low player is
00C962  1  B0 60              bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
00C964  1  20 69 D0           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
00C967  1  20 0D CC           jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
00C96A  1  B0 14              bcs AwardTouchedCoin       ;if so, branch to some other part of code
00C96C  1  48                 pha                        ;save bottom left metatile to stack
00C96D  1  20 69 D0           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
00C970  1  85 00              sta $00                    ;save bottom right metatile here
00C972  1  68                 pla
00C973  1  85 01              sta $01                    ;pull bottom left metatile and save here
00C975  1  D0 0C              bne ChkFootMTile           ;if anything here, skip this part
00C977  1  A5 00              lda $00                    ;otherwise check for anything in bottom right metatile
00C979  1  F0 49              beq DoPlayerSideCheck      ;and skip ahead if not
00C97B  1  20 0D CC           jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
00C97E  1  90 03              bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
00C980  1               
00C980  1               AwardTouchedCoin:
00C980  1  4C 6B CA           jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
00C983  1               
00C983  1               ChkFootMTile:
00C983  1  20 06 CC               jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
00C986  1  B0 3C                  bcs DoPlayerSideCheck      ;if so, branch
00C988  1  A4 9F                  ldy Player_Y_Speed         ;check player's vertical speed
00C98A  1  30 38                  bmi DoPlayerSideCheck      ;if player moving upwards, branch
00C98C  1  C9 C6                  cmp #$c6
00C98E  1  D0 03                  bne ContChk                ;if player did not touch axe, skip ahead
00C990  1  4C 74 CA               jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
00C993  1  20 26 CB     ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
00C996  1  F0 2C                  beq DoPlayerSideCheck      ;if either found, branch
00C998  1  AC 0E 07               ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
00C99B  1  D0 23                  bne InitSteP               ;branch ahead
00C99D  1  A4 04                  ldy $04                    ;check lower nybble of vertical coordinate returned
00C99F  1  C0 05                  cpy #$05                   ;from collision detection routine
00C9A1  1  90 07                  bcc LandPlyr               ;if lower nybble < 5, branch
00C9A3  1  A5 45                  lda Player_MovingDir
00C9A5  1  85 00                  sta $00                    ;use player's moving direction as temp variable
00C9A7  1  4C B7 CB               jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
00C9AA  1  20 35 CB     LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
00C9AD  1  A9 F0                  lda #$f0
00C9AF  1  25 CE                  and Player_Y_Position      ;mask out lower nybble of player's vertical position
00C9B1  1  85 CE                  sta Player_Y_Position      ;and store as new vertical position to land player properly
00C9B3  1  20 5C CB               jsr HandlePipeEntry        ;do sub to process potential pipe entry
00C9B6  1  A9 00                  lda #$00
00C9B8  1  85 9F                  sta Player_Y_Speed         ;initialize vertical speed and fractional
00C9BA  1  8D 33 04               sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
00C9BD  1  8D 84 04               sta StompChainCounter      ;initialize enemy stomp counter
00C9C0  1  A9 00        InitSteP: lda #$00
00C9C2  1  85 1D                  sta Player_State           ;set player's state to normal
00C9C4  1               
00C9C4  1               DoPlayerSideCheck:
00C9C4  1  A4 EB              ldy $eb       ;get block buffer adder offset
00C9C6  1  C8                 iny
00C9C7  1  C8                 iny           ;increment offset 2 bytes to use adders for side collisions
00C9C8  1  A9 02              lda #$02      ;set value here to be used as counter
00C9CA  1  85 00              sta $00
00C9CC  1               
00C9CC  1               SideCheckLoop:
00C9CC  1  C8                  iny                       ;move onto the next one
00C9CD  1  84 EB               sty $eb                   ;store it
00C9CF  1  A5 CE               lda Player_Y_Position
00C9D1  1  C9 20               cmp #$20                  ;check player's vertical position
00C9D3  1  90 16               bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
00C9D5  1  C9 E4               cmp #$e4
00C9D7  1  B0 28               bcs ExSCH                 ;branch to leave if player is too far down
00C9D9  1  20 6D D0            jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
00C9DC  1  F0 0D               beq BHalf                 ;branch ahead if nothing found
00C9DE  1  C9 19               cmp #$19                  ;otherwise check for pipe metatiles
00C9E0  1  F0 09               beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00C9E2  1  C9 6D               cmp #$6d
00C9E4  1  F0 05               beq BHalf                 ;if collided with water pipe (top), branch ahead
00C9E6  1  20 06 CC            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
00C9E9  1  90 17               bcc CheckSideMTiles       ;if not, branch to alternate section of code
00C9EB  1  A4 EB        BHalf: ldy $eb                   ;load block adder offset
00C9ED  1  C8                  iny                       ;increment it
00C9EE  1  A5 CE               lda Player_Y_Position     ;get player's vertical position
00C9F0  1  C9 08               cmp #$08
00C9F2  1  90 0D               bcc ExSCH                 ;if too high, branch to leave
00C9F4  1  C9 D0               cmp #$d0
00C9F6  1  B0 09               bcs ExSCH                 ;if too low, branch to leave
00C9F8  1  20 6D D0            jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
00C9FB  1  D0 05               bne CheckSideMTiles       ;if something found, branch
00C9FD  1  C6 00               dec $00                   ;otherwise decrement counter
00C9FF  1  D0 CB               bne SideCheckLoop         ;run code until both sides of player are checked
00CA01  1  60           ExSCH: rts                       ;leave
00CA02  1               
00CA02  1               CheckSideMTiles:
00CA02  1  20 26 CB               jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
00CA05  1  F0 61                  beq ExCSM                  ;branch to leave if either found
00CA07  1  20 06 CC               jsr CheckForClimbMTiles    ;check for climbable metatiles
00CA0A  1  90 03                  bcc ContSChk               ;if not found, skip and continue with code
00CA0C  1  4C 97 CA               jmp HandleClimbing         ;otherwise jump to handle climbing
00CA0F  1  20 0D CC     ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
00CA12  1  B0 57                  bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
00CA14  1  20 51 CB               jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
00CA17  1  90 08                  bcc ChkPBtm                ;if not found, branch ahead to continue cude
00CA19  1  AD 0E 07               lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
00CA1C  1  D0 4A                  bne ExCSM                  ;branch to leave if set
00CA1E  1  4C 65 CA               jmp StopPlayerMove         ;otherwise jump to impede player's movement
00CA21  1  A4 1D        ChkPBtm:  ldy Player_State           ;get player's state
00CA23  1  C0 00                  cpy #$00                   ;check for player's state set to normal
00CA25  1  D0 3E                  bne StopPlayerMove         ;if not, branch to impede player's movement
00CA27  1  A4 33                  ldy PlayerFacingDir        ;get player's facing direction
00CA29  1  88                     dey
00CA2A  1  D0 39                  bne StopPlayerMove         ;if facing left, branch to impede movement
00CA2C  1  C9 6E                  cmp #$6e                   ;otherwise check for pipe metatiles
00CA2E  1  F0 04                  beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00CA30  1  C9 1C                  cmp #$1c                   ;if collided with water pipe (bottom), continue
00CA32  1  D0 31                  bne StopPlayerMove         ;otherwise branch to impede player's movement
00CA34  1  AD C4 03     PipeDwnS: lda Player_SprAttrib       ;check player's attributes
00CA37  1  D0 04                  bne PlyrPipe               ;if already set, branch, do not play sound again
00CA39  1  A0 10                  ldy #Sfx_PipeDown_Injury
00CA3B  1  84 FF                  sty Square1SoundQueue      ;otherwise load pipedown/injury sound
00CA3D  1  09 20        PlyrPipe: ora #%00100000
00CA3F  1  8D C4 03               sta Player_SprAttrib       ;set background priority bit in player attributes
00CA42  1  A5 86                  lda Player_X_Position
00CA44  1  29 0F                  and #%00001111             ;get lower nybble of player's horizontal coordinate
00CA46  1  F0 0E                  beq ChkGERtn               ;if at zero, branch ahead to skip this part
00CA48  1  A0 00                  ldy #$00                   ;set default offset for timer setting data
00CA4A  1  AD 1A 07               lda ScreenLeft_PageLoc     ;load page location for left side of screen
00CA4D  1  F0 01                  beq SetCATmr               ;if at page zero, use default offset
00CA4F  1  C8                     iny                        ;otherwise increment offset
00CA50  1  B9 69 CA     SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
00CA53  1  8D DE 06               sta ChangeAreaTimer
00CA56  1  A5 0E        ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
00CA58  1  C9 07                  cmp #$07
00CA5A  1  F0 0C                  beq ExCSM                  ;if running player entrance routine or
00CA5C  1  C9 08                  cmp #$08                   ;player control routine, go ahead and branch to leave
00CA5E  1  D0 08                  bne ExCSM
00CA60  1  A9 02                  lda #$02
00CA62  1  85 0E                  sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
00CA64  1  60                     rts                        ;and leave
00CA65  1               
00CA65  1               ;--------------------------------
00CA65  1               ;$02 - high nybble of vertical coordinate from block buffer
00CA65  1               ;$04 - low nybble of horizontal coordinate from block buffer
00CA65  1               ;$06-$07 - block buffer address
00CA65  1               
00CA65  1               StopPlayerMove:
00CA65  1  20 B7 CB            jsr ImpedePlayerMove      ;stop player's movement
00CA68  1  60           ExCSM: rts                       ;leave
00CA69  1               
00CA69  1               AreaChangeTimerData:
00CA69  1  A0 34              .byte $a0, $34
00CA6B  1               
00CA6B  1               HandleCoinMetatile:
00CA6B  1  20 85 CA           jsr ErACM             ;do sub to erase coin metatile from block buffer
00CA6E  1  EE 48 07           inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
00CA71  1  4C EE A7           jmp GiveOneCoin       ;update coin amount and tally on the screen
00CA74  1               
00CA74  1               HandleAxeMetatile:
00CA74  1  A9 00               lda #$00
00CA76  1  8D 72 07            sta OperMode_Task   ;reset secondary mode
00CA79  1  A9 02               lda #$02
00CA7B  1  8D 70 07            sta OperMode        ;set primary mode to victory mode
00CA7E  1  A9 18               lda #$18
00CA80  1  85 57               sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
00CA82  1  20 rr rr            jsr BANK_PractisePrintScore
00CA85  1  A4 02        ErACM: ldy $02             ;load vertical high nybble offset for block buffer
00CA87  1  A9 00               lda #$00            ;load blank metatile
00CA89  1  91 06               sta ($06),y         ;store to remove old contents from block buffer
00CA8B  1  4C 02 89            jmp RemoveCoin_Axe  ;update the screen accordingly
00CA8E  1               
00CA8E  1               ;--------------------------------
00CA8E  1               ;$02 - high nybble of vertical coordinate from block buffer
00CA8E  1               ;$04 - low nybble of horizontal coordinate from block buffer
00CA8E  1               ;$06-$07 - block buffer address
00CA8E  1               
00CA8E  1               ClimbXPosAdder:
00CA8E  1  F9 07              .byte $f9, $07
00CA90  1               
00CA90  1               ClimbPLocAdder:
00CA90  1  FF 00              .byte $ff, $00
00CA92  1               
00CA92  1               FlagpoleYPosData:
00CA92  1  18 22 50 68        .byte $18, $22, $50, $68, $90
00CA96  1  90           
00CA97  1               
00CA97  1               HandleClimbing:
00CA97  1  A4 04              ldy $04            ;check low nybble of horizontal coordinate returned from
00CA99  1  C0 06              cpy #$06           ;collision detection routine against certain values, this
00CA9B  1  90 04              bcc ExHC           ;makes actual physical part of vine or flagpole thinner
00CA9D  1  C0 0A              cpy #$0a           ;than 16 pixels
00CA9F  1  90 01              bcc ChkForFlagpole
00CAA1  1  60           ExHC: rts                ;leave if too far left or too far right
00CAA2  1               
00CAA2  1               ChkForFlagpole:
00CAA2  1  C9 21              cmp #$21               ;check climbing metatiles
00CAA4  1  F0 04              beq FlagpoleCollision  ;branch if flagpole ball found
00CAA6  1  C9 22              cmp #$22
00CAA8  1  D0 39              bne VineCollision      ;branch to alternate code if flagpole shaft not found
00CAAA  1               
00CAAA  1               FlagpoleCollision:
00CAAA  1  A5 0E              lda GameEngineSubroutine
00CAAC  1  C9 05              cmp #$05                  ;check for end-of-level routine running
00CAAE  1  F0 41              beq PutPlayerOnVine       ;if running, branch to end of climbing code
00CAB0  1  A9 01              lda #$01
00CAB2  1  85 33              sta PlayerFacingDir       ;set player's facing direction to right
00CAB4  1  EE 23 07           inc ScrollLock            ;set scroll lock flag
00CAB7  1  A5 0E              lda GameEngineSubroutine
00CAB9  1  C9 04              cmp #$04                  ;check for flagpole slide routine running
00CABB  1  F0 1F              beq RunFR                 ;if running, branch to end of flagpole code here
00CABD  1  A9 33              lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
00CABF  1  20 68 95           jsr KillEnemies           ;get rid of them
00CAC2  1  A9 80              lda #Silence
00CAC4  1  85 FC              sta EventMusicQueue       ;silence music
00CAC6  1  4A                 lsr
00CAC7  1  8D 13 07           sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
00CACA  1  A2 04              ldx #$04                  ;start at end of vertical coordinate data
00CACC  1  A5 CE              lda Player_Y_Position
00CACE  1  8D 0F 07           sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
00CAD1  1               
00CAD1  1               ChkFlagpoleYPosLoop:
00CAD1  1  DD 92 CA            cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
00CAD4  1  B0 03               bcs MtchF                 ;if player's => current, branch to use current offset
00CAD6  1  CA                  dex                       ;otherwise decrement offset to use
00CAD7  1  D0 F8               bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
00CAD9  1  8E 0F 01     MtchF: stx FlagpoleScore         ;store offset here to be used later
00CADC  1                      ;lda CoinDisplay
00CADC  1                      ;cmp CoinDisplay+1         ;check to see if coin tally digits are the same
00CADC  1                      ;bne RunFR                 ;if not, branch to use flagpole score data as-is
00CADC  1                      ;cmp GameTimerDisplay+2    ;check to see if the last digit of game timer matches
00CADC  1                      ;bne RunFR                 ;the two digits, if not, branch to use data as-is
00CADC  1                      ;lda #$05
00CADC  1                      ;sta FlagpoleScore         ;otherwise, set to give player an extra life
00CADC  1  A9 04        RunFR: lda #$04
00CADE  1  85 0E               sta GameEngineSubroutine  ;set value to run flagpole slide routine
00CAE0  1  4C F1 CA            jmp PutPlayerOnVine       ;jump to end of climbing code
00CAE3  1               
00CAE3  1               VineCollision:
00CAE3  1  C9 23              cmp #$23                  ;check for climbing metatile used on vines
00CAE5  1  D0 0A              bne PutPlayerOnVine
00CAE7  1  A5 CE              lda Player_Y_Position     ;check player's vertical coordinate
00CAE9  1  C9 20              cmp #$20                  ;for being in status bar area
00CAEB  1  B0 04              bcs PutPlayerOnVine       ;branch if not that far up
00CAED  1  A9 01              lda #$01
00CAEF  1  85 0E              sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
00CAF1  1               
00CAF1  1               PutPlayerOnVine:
00CAF1  1  A9 03                 lda #$03                ;set player state to climbing
00CAF3  1  85 1D                 sta Player_State
00CAF5  1  A9 00                 lda #$00                ;nullify player's horizontal speed
00CAF7  1  85 57                 sta Player_X_Speed      ;and fractional horizontal movement force
00CAF9  1  8D 05 07              sta Player_X_MoveForce
00CAFC  1  A5 86                 lda Player_X_Position   ;get player's horizontal coordinate
00CAFE  1  38                    sec
00CAFF  1  ED 1C 07              sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
00CB02  1  C9 10                 cmp #$10
00CB04  1  B0 04                 bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
00CB06  1  A9 02                 lda #$02
00CB08  1  85 33                 sta PlayerFacingDir     ;otherwise force player to face left
00CB0A  1  A4 33        SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
00CB0C  1  A5 06                 lda $06                 ;get low byte of block buffer address
00CB0E  1  0A                    asl
00CB0F  1  0A                    asl                     ;move low nybble to high
00CB10  1  0A                    asl
00CB11  1  0A                    asl
00CB12  1  18                    clc
00CB13  1  79 8D CA              adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
00CB16  1  85 86                 sta Player_X_Position   ;store as player's horizontal coordinate
00CB18  1  A5 06                 lda $06                 ;get low byte of block buffer address again
00CB1A  1  D0 09                 bne ExPVne              ;if not zero, branch
00CB1C  1  AD 1B 07              lda ScreenRight_PageLoc ;load page location of right side of screen
00CB1F  1  18                    clc
00CB20  1  79 8F CA              adc ClimbPLocAdder-1,y  ;add depending on facing location
00CB23  1  85 6D                 sta Player_PageLoc      ;store as player's page location
00CB25  1  60           ExPVne:  rts                     ;finally, we're done!
00CB26  1               
00CB26  1               ;--------------------------------
00CB26  1               
00CB26  1               ChkInvisibleMTiles:
00CB26  1  C9 5E                 cmp #$5e       ;check for hidden coin block
00CB28  1  F0 0A                 beq ExCInvT
00CB2A  1  C9 5F                 cmp #$5f       ;check for hidden 1-up block
00CB2C  1  F0 06                 beq ExCInvT
00CB2E  1  C9 60                 cmp #$60       ;check for hidden poison shroom block
00CB30  1  F0 02                 beq ExCInvT
00CB32  1  C9 61                 cmp #$61       ;check for hidden power-up block
00CB34  1  60           ExCInvT: rts            ;leave with zero flag set if any of these found
00CB35  1               
00CB35  1               ;--------------------------------
00CB35  1               ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
00CB35  1               ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
00CB35  1               
00CB35  1               ChkForLandJumpSpring:
00CB35  1  20 51 CB             jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
00CB38  1  90 16                bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
00CB3A  1  A9 70                lda #$70
00CB3C  1  8D 09 07             sta VerticalForce           ;otherwise set vertical movement force for player
00CB3F  1  8D 0A 07             sta VerticalForceDown
00CB42  1  A9 F9                lda #$f9
00CB44  1  8D DB 06             sta JumpspringForce         ;set default jumpspring force
00CB47  1  A9 03                lda #$03
00CB49  1  8D 86 07             sta JumpspringTimer         ;set jumpspring timer to be used later
00CB4C  1  4A                   lsr
00CB4D  1  8D 0E 07             sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
00CB50  1  60           ExCJSp: rts                         ;and leave
00CB51  1               
00CB51  1               ChkJumpspringMetatiles:
00CB51  1  C9 68                 cmp #$68      ;check for top jumpspring metatile
00CB53  1  F0 05                 beq JSFnd     ;branch to set carry if found
00CB55  1  C9 69                 cmp #$69      ;check for bottom jumpspring metatile
00CB57  1  18                    clc           ;clear carry flag
00CB58  1  D0 01                 bne NoJSFnd   ;branch to use cleared carry if not found
00CB5A  1  38           JSFnd:   sec           ;set carry if found
00CB5B  1  60           NoJSFnd: rts           ;leave
00CB5C  1               
00CB5C  1               HandlePipeEntry:
00CB5C  1  A5 0B                  lda Up_Down_Buttons       ;check saved controller bits from earlier
00CB5E  1  29 04                  and #%00000100            ;for pressing down
00CB60  1  F0 54                  beq ExPipeE               ;if not pressing down, branch to leave
00CB62  1  A5 00                  lda $00
00CB64  1  C9 11                  cmp #$11                  ;check right foot metatile for warp pipe right metatile
00CB66  1  D0 4E                  bne ExPipeE               ;branch to leave if not found
00CB68  1  A5 01                  lda $01
00CB6A  1  C9 10                  cmp #$10                  ;check left foot metatile for warp pipe left metatile
00CB6C  1  D0 48                  bne ExPipeE               ;branch to leave if not found
00CB6E  1  A9 30                  lda #$30
00CB70  1  8D DE 06               sta ChangeAreaTimer       ;set timer for change of area
00CB73  1  A9 03                  lda #$03
00CB75  1  85 0E                  sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
00CB77  1  A9 10                  lda #Sfx_PipeDown_Injury
00CB79  1  85 FF                  sta Square1SoundQueue     ;load pipedown/injury sound
00CB7B  1  A9 20                  lda #%00100000
00CB7D  1  8D C4 03               sta Player_SprAttrib      ;set background priority bit in player's attributes
00CB80  1  AD D6 06               lda WarpZoneControl       ;check warp zone control
00CB83  1  F0 31                  beq ExPipeE               ;branch to leave if none found
00CB85  1  29 0F                  and #%00001111            ;mask out all but lower nybble
00CB87  1  AA                     tax                       ;save as offset, then use to load warp zone destination
00CB88  1  BD D3 86               lda WarpZoneNumbers,x
00CB8B  1  AC FB 07               ldy HardWorldFlag         ;if playing worlds A-D, branch to skip this part
00CB8E  1  F0 03                  beq SetWDest
00CB90  1  38                     sec
00CB91  1  E9 09                  sbc #$09                  ;otherwise subtract 9 to get correct world number
00CB93  1  A8           SetWDest: tay
00CB94  1  88                     dey                       ;decrement for use as world number
00CB95  1  8C 5F 07               sty WorldNumber           ;store as world number and offset
00CB98  1  20 49 FF               jsr RunGetAreaPointer
00CB9B  1  8C 50 07               sty AreaPointer           ;store area offset here to be used to change areas
00CB9E  1  A9 80                  lda #Silence
00CBA0  1  85 FC                  sta EventMusicQueue       ;silence music
00CBA2  1  A9 00                  lda #$00
00CBA4  1  8D 51 07               sta EntrancePage          ;initialize starting page number
00CBA7  1  8D 60 07               sta AreaNumber            ;initialize area number used for area address offset
00CBAA  1  8D 5C 07               sta LevelNumber           ;initialize level number used for world display
00CBAD  1  8D 52 07               sta AltEntranceControl    ;initialize mode of entry
00CBB0  1  EE 5D 07               inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
00CBB3  1  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
00CBB6  1  60           ExPipeE:  rts                       ;leave!!!
00CBB7  1               
00CBB7  1               ImpedePlayerMove:
00CBB7  1  A9 00               lda #$00                  ;initialize value here
00CBB9  1  A4 57               ldy Player_X_Speed        ;get player's horizontal speed
00CBBB  1  A6 00               ldx $00                   ;check value set earlier for
00CBBD  1  CA                  dex                       ;left side collision
00CBBE  1  D0 0A               bne RImpd                 ;if right side collision, skip this part
00CBC0  1  E8                  inx                       ;return value to X
00CBC1  1  C0 00               cpy #$00                  ;if player moving to the left,
00CBC3  1  30 28               bmi ExIPM                 ;branch to invert bit and leave
00CBC5  1  A9 FF               lda #$ff                  ;otherwise load A with value to be used later
00CBC7  1  4C D2 CB            jmp NXSpd                 ;and jump to affect movement
00CBCA  1  A2 02        RImpd: ldx #$02                  ;return $02 to X
00CBCC  1  C0 01               cpy #$01                  ;if player moving to the right,
00CBCE  1  10 1D               bpl ExIPM                 ;branch to invert bit and leave
00CBD0  1  A9 01               lda #$01                  ;otherwise load A with value to be used here
00CBD2  1  A0 10        NXSpd: ldy #$10
00CBD4  1  8C 85 07            sty SideCollisionTimer    ;set timer of some sort
00CBD7  1  A0 00               ldy #$00
00CBD9  1  84 57               sty Player_X_Speed        ;nullify player's horizontal speed
00CBDB  1  C9 00               cmp #$00                  ;if value set in A not set to $ff,
00CBDD  1  10 01               bpl PlatF                 ;branch ahead, do not decrement Y
00CBDF  1  88                  dey                       ;otherwise decrement Y now
00CBE0  1  84 00        PlatF: sty $00                   ;store Y as high bits of horizontal adder
00CBE2  1  18                  clc
00CBE3  1  65 86               adc Player_X_Position     ;add contents of A to player's horizontal
00CBE5  1  85 86               sta Player_X_Position     ;position to move player left or right
00CBE7  1  A5 6D               lda Player_PageLoc
00CBE9  1  65 00               adc $00                   ;add high bits and carry to
00CBEB  1  85 6D               sta Player_PageLoc        ;page location if necessary
00CBED  1  8A           ExIPM: txa                       ;invert contents of X
00CBEE  1  49 FF               eor #$ff
00CBF0  1  2D 90 04            and Player_CollisionBits  ;mask out bit that was set here
00CBF3  1  8D 90 04            sta Player_CollisionBits  ;store to clear bit
00CBF6  1  60                  rts
00CBF7  1               
00CBF7  1               ;--------------------------------
00CBF7  1               
00CBF7  1               SolidMTileUpperExt:
00CBF7  1  10 62 88 C5        .byte $10, $62, $88, $c5
00CBFB  1               
00CBFB  1               CheckForSolidMTiles:
00CBFB  1  20 1C CC           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00CBFE  1  DD F7 CB           cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
00CC01  1  60                 rts
00CC02  1               
00CC02  1               ClimbMTileUpperExt:
00CC02  1  21 6F 8D C7        .byte $21, $6f, $8d, $c7
00CC06  1               
00CC06  1               CheckForClimbMTiles:
00CC06  1  20 1C CC           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00CC09  1  DD 02 CC           cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
00CC0C  1  60                 rts
00CC0D  1               
00CC0D  1               CheckForCoinMTiles:
00CC0D  1  C9 C3                 cmp #$c3              ;check for regular coin
00CC0F  1  F0 06                 beq CoinSd            ;branch if found
00CC11  1  C9 C4                 cmp #$c4              ;check for underwater coin
00CC13  1  F0 02                 beq CoinSd            ;branch if found
00CC15  1  18                    clc                   ;otherwise clear carry and leave
00CC16  1  60                    rts
00CC17  1  A9 01        CoinSd:  lda #Sfx_CoinGrab
00CC19  1  85 FE                 sta Square2SoundQueue ;load coin grab sound and leave
00CC1B  1  60                    rts
00CC1C  1               
00CC1C  1               GetMTileAttrib:
00CC1C  1  A8                  tay            ;save metatile value into Y
00CC1D  1  29 C0               and #%11000000 ;mask out all but 2 MSB
00CC1F  1  0A                  asl
00CC20  1  2A                  rol            ;shift and rotate d7-d6 to d1-d0
00CC21  1  2A                  rol
00CC22  1  AA                  tax            ;use as offset for metatile data
00CC23  1  98                  tya            ;get original metatile value back
00CC24  1  60           ExEBG: rts            ;leave
00CC25  1               
00CC25  1               ;-------------------------------------------------------------------------------------
00CC25  1               ;$06-$07 - address from block buffer routine
00CC25  1               
00CC25  1               EnemyBGCStateData:
00CC25  1  01 01 02 02        .byte $01, $01, $02, $02, $02, $05
00CC29  1  02 05        
00CC2B  1               
00CC2B  1               EnemyBGCXSpdData:
00CC2B  1  10 F0              .byte $10, $f0
00CC2D  1               
00CC2D  1               EnemyToBGCollisionDet:
00CC2D  1  B5 1E              lda Enemy_State,x        ;check enemy state for d6 set
00CC2F  1  29 20              and #%00100000
00CC31  1  D0 F1              bne ExEBG                ;if set, branch to leave
00CC33  1  20 D4 CD           jsr SubtEnemyYPos        ;otherwise, do a subroutine here
00CC36  1  90 EC              bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
00CC38  1  B4 16              ldy Enemy_ID,x
00CC3A  1  C0 12              cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
00CC3C  1  D0 06              bne DoIDCheckBGColl
00CC3E  1  B5 CF              lda Enemy_Y_Position,x
00CC40  1  C9 25              cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
00CC42  1  90 E0              bcc ExEBG
00CC44  1               
00CC44  1               DoIDCheckBGColl:
00CC44  1  C0 0E                  cpy #GreenParatroopaJump ;check for some other enemy object
00CC46  1  D0 03                  bne HBChk                ;branch if not found
00CC48  1  4C DC CD               jmp EnemyJump            ;otherwise jump elsewhere
00CC4B  1  C0 05        HBChk:    cpy #HammerBro           ;check for hammer bro
00CC4D  1  D0 04                  bne CInvu                ;branch if not found
00CC4F  1  4C FE CD               jmp HammerBroBGColl      ;otherwise jump elsewhere
00CC52  1  60           ExIDBChk: rts
00CC53  1  C0 12        CInvu:    cpy #Spiny               ;if enemy object is spiny, branch
00CC55  1  F0 0C                  beq YesIn
00CC57  1  C0 2E                  cpy #PowerUpObject       ;if special power-up object, branch
00CC59  1  F0 08                  beq YesIn
00CC5B  1  C0 04                  cpy #UpsideDownPiranhaP  ;if enemy object is upside-down piranha plant
00CC5D  1  F0 F3                  beq ExIDBChk             ;then branch to leave
00CC5F  1  C0 07                  cpy #$07                 ;if enemy object =>$07, branch to leave
00CC61  1  B0 EF                  bcs ExIDBChk
00CC63  1  20 27 CE     YesIn:    jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
00CC66  1  D0 03                  bne HandleEToBGCollision ;if block underneath enemy, branch
00CC68  1               
00CC68  1               NoEToBGCollision:
00CC68  1  4C 5B CD            jmp ChkForRedKoopa       ;otherwise skip and do something else
00CC6B  1               
00CC6B  1               ;--------------------------------
00CC6B  1               ;$02 - vertical coordinate from block buffer routine
00CC6B  1               
00CC6B  1               HandleEToBGCollision:
00CC6B  1  20 2E CE           jsr ChkForNonSolids       ;if something is underneath enemy, find out what
00CC6E  1  F0 F8              beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
00CC70  1  C9 20              cmp #$20
00CC72  1  D0 6C              bne LandEnemyProperly     ;check for blank metatile $20 and branch if not found
00CC74  1  B5 16              lda Enemy_ID,x
00CC76  1  C9 15              cmp #$15                  ;if enemy object => $15, branch ahead
00CC78  1  B0 0C              bcs ChkToStunEnemies
00CC7A  1  C9 06              cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
00CC7C  1  D0 03              bne GiveOEPoints
00CC7E  1  20 07 CE           jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
00CC81  1               
00CC81  1               GiveOEPoints:
00CC81  1  A9 01              lda #$01                  ;award 100 points for hitting block beneath enemy
00CC83  1  20 72 C6           jsr SetupFloateyNumber
00CC86  1               
00CC86  1               ChkToStunEnemies:
00CC86  1  B5 16                   lda Enemy_ID,x
00CC88  1  C9 09                   cmp #$09                   ;perform many comparisons on enemy object identifier
00CC8A  1  90 18                   bcc NoDemote               ;if the enemy object identifier is equal to the values
00CC8C  1  C9 11                   cmp #$11                   ;$0e-$10 it will be demoted, in practice $0e and $10
00CC8E  1  B0 14                   bcs NoDemote               ;are values used by green paratroopas
00CC90  1  C9 0D                   cmp #PiranhaPlant
00CC92  1  F0 10                   beq NoDemote               ;enemy objects $0a-$0d will not be demoted
00CC94  1  C9 04                   cmp #UpsideDownPiranhaP
00CC96  1  F0 0C                   beq NoDemote
00CC98  1  C9 0A                   cmp #$0a                   ;demote enemy object $09 even though it is not used
00CC9A  1  90 04                   bcc Demote
00CC9C  1  C9 0D                   cmp #PiranhaPlant
00CC9E  1  90 04                   bcc NoDemote
00CCA0  1  29 01        Demote:    and #%00000001             ;erase all but LSB, essentially turning enemy object
00CCA2  1  95 16                   sta Enemy_ID,x             ;into green or red koopa troopa to demote them
00CCA4  1  C9 2E        NoDemote:  cmp #PowerUpObject
00CCA6  1  F0 08                   beq BounceOff              ;if power-up object, branch to bounce it
00CCA8  1  C9 06                   cmp #Goomba
00CCAA  1  F0 04                   beq BounceOff              ;redundant, already checked for goomba
00CCAC  1  A9 02                   lda #$02
00CCAE  1  95 1E                   sta Enemy_State,x          ;set enemy state to 2 (stunned)
00CCB0  1  D6 CF        BounceOff: dec Enemy_Y_Position,x
00CCB2  1  D6 CF                   dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
00CCB4  1  B5 16                   lda Enemy_ID,x
00CCB6  1  C9 07                   cmp #Bloober               ;check for bloober object
00CCB8  1  F0 07                   beq SetWYSpd
00CCBA  1  A9 FD                   lda #$fd                   ;set default vertical speed
00CCBC  1  AC 4E 07                ldy AreaType
00CCBF  1  D0 02                   bne SetNotW                ;if area type not water, set as speed, otherwise
00CCC1  1  A9 FF        SetWYSpd:  lda #$ff                   ;change the vertical speed
00CCC3  1  95 A0        SetNotW:   sta Enemy_Y_Speed,x        ;set vertical speed now
00CCC5  1  A0 01                   ldy #$01
00CCC7  1  20 BC CD                jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
00CCCA  1  10 01                   bpl ChkBBill               ;branch if enemy is to the right of player
00CCCC  1  C8                      iny                        ;increment Y if not
00CCCD  1  B5 16        ChkBBill:  lda Enemy_ID,x
00CCCF  1  C9 33                   cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
00CCD1  1  F0 06                   beq NoCDirF
00CCD3  1  C9 08                   cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
00CCD5  1  F0 02                   beq NoCDirF                ;branch if either found, direction does not change
00CCD7  1  94 46                   sty Enemy_MovingDir,x      ;store as moving direction
00CCD9  1  88           NoCDirF:   dey                        ;decrement and use as offset
00CCDA  1  B9 2B CC                lda EnemyBGCXSpdData,y     ;get proper horizontal speed
00CCDD  1  95 58                   sta Enemy_X_Speed,x        ;and store, then leave
00CCDF  1  60           ExEBGChk:  rts
00CCE0  1               
00CCE0  1               ;--------------------------------
00CCE0  1               ;$04 - low nybble of vertical coordinate from block buffer routine
00CCE0  1               
00CCE0  1               LandEnemyProperly:
00CCE0  1  A5 04               lda $04                 ;check lower nybble of vertical coordinate saved earlier
00CCE2  1  38                  sec
00CCE3  1  E9 08               sbc #$08                ;subtract eight pixels
00CCE5  1  C9 05               cmp #$05                ;used to determine whether enemy landed from falling
00CCE7  1  B0 72               bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
00CCE9  1  B5 1E               lda Enemy_State,x
00CCEB  1  29 40               and #%01000000          ;branch if d6 in enemy state is set
00CCED  1  D0 57               bne LandEnemyInitState
00CCEF  1  B5 1E               lda Enemy_State,x
00CCF1  1  0A                  asl                     ;branch if d7 in enemy state is not set
00CCF2  1  90 03               bcc ChkLandedEnemyState
00CCF4  1  4C 77 CD     SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
00CCF7  1               
00CCF7  1               ChkLandedEnemyState:
00CCF7  1  B5 1E                   lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
00CCF9  1  F0 F9                   beq SChkA
00CCFB  1  C9 05                   cmp #$05                  ;if in state used by spiny's egg
00CCFD  1  F0 1F                   beq ProcEnemyDirection    ;then branch elsewhere
00CCFF  1  C9 03                   cmp #$03                  ;if already in state used by koopas and buzzy beetles
00CD01  1  B0 1A                   bcs ExSteChk              ;or in higher numbered state, branch to leave
00CD03  1  B5 1E                   lda Enemy_State,x         ;load enemy state again (why?)
00CD05  1  C9 02                   cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
00CD07  1  D0 15                   bne ProcEnemyDirection    ;then branch elsewhere
00CD09  1  A9 10                   lda #$10                  ;load default timer here
00CD0B  1  B4 16                   ldy Enemy_ID,x            ;check enemy identifier for spiny
00CD0D  1  C0 12                   cpy #Spiny
00CD0F  1  D0 02                   bne SetForStn             ;branch if not found
00CD11  1  A9 00                   lda #$00                  ;set timer for $00 if spiny
00CD13  1  9D 96 07     SetForStn: sta EnemyIntervalTimer,x  ;set timer here
00CD16  1  A9 03                   lda #$03                  ;set state here, apparently used to render
00CD18  1  95 1E                   sta Enemy_State,x         ;upside-down koopas and buzzy beetles
00CD1A  1  20 C8 CD                jsr EnemyLanding          ;then land it properly
00CD1D  1  60           ExSteChk:  rts                       ;then leave
00CD1E  1               
00CD1E  1               ProcEnemyDirection:
00CD1E  1  B5 16                 lda Enemy_ID,x            ;check enemy identifier for goomba
00CD20  1  C9 06                 cmp #Goomba               ;branch if found
00CD22  1  F0 22                 beq LandEnemyInitState
00CD24  1  C9 12                 cmp #Spiny                ;check for spiny
00CD26  1  D0 0E                 bne InvtD                 ;branch if not found
00CD28  1  A9 01                 lda #$01
00CD2A  1  95 46                 sta Enemy_MovingDir,x     ;send enemy moving to the right by default
00CD2C  1  A9 08                 lda #$08
00CD2E  1  95 58                 sta Enemy_X_Speed,x       ;set horizontal speed accordingly
00CD30  1  A5 09                 lda FrameCounter
00CD32  1  29 07                 and #%00000111            ;if timed appropriately, spiny will skip over
00CD34  1  F0 10                 beq LandEnemyInitState    ;trying to face the player
00CD36  1  A0 01        InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
00CD38  1  20 BC CD              jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
00CD3B  1  10 01                 bpl CNwCDir               ;if enemy to the right of player, branch
00CD3D  1  C8                    iny                       ;if to the left, increment by one for enemy to face right (inverted)
00CD3E  1  98           CNwCDir: tya
00CD3F  1  D5 46                 cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
00CD41  1  D0 03                 bne LandEnemyInitState
00CD43  1  20 9D CD              jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
00CD46  1               
00CD46  1               LandEnemyInitState:
00CD46  1  20 C8 CD           jsr EnemyLanding       ;land enemy properly
00CD49  1  B5 1E              lda Enemy_State,x
00CD4B  1  29 80              and #%10000000         ;if d7 of enemy state is set, branch
00CD4D  1  D0 05              bne NMovShellFallBit
00CD4F  1  A9 00              lda #$00               ;otherwise initialize enemy state and leave
00CD51  1  95 1E              sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
00CD53  1  60                 rts
00CD54  1               
00CD54  1               NMovShellFallBit:
00CD54  1  B5 1E              lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
00CD56  1  29 BF              and #%10111111      ;and store, then leave
00CD58  1  95 1E              sta Enemy_State,x
00CD5A  1  60                 rts
00CD5B  1               
00CD5B  1               ;--------------------------------
00CD5B  1               
00CD5B  1               ChkForRedKoopa:
00CD5B  1  B5 16                     lda Enemy_ID,x            ;check for red koopa troopa $03
00CD5D  1  C9 03                     cmp #RedKoopa
00CD5F  1  D0 04                     bne Chk2MSBSt             ;branch if not found
00CD61  1  B5 1E                     lda Enemy_State,x
00CD63  1  F0 38                     beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
00CD65  1  B5 1E        Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
00CD67  1  A8                        tay
00CD68  1  0A                        asl                       ;check for d7 set
00CD69  1  90 07                     bcc GetSteFromD           ;branch if not set
00CD6B  1  B5 1E                     lda Enemy_State,x
00CD6D  1  09 40                     ora #%01000000            ;set d6
00CD6F  1  4C 75 CD                  jmp SetD6Ste              ;jump ahead of this part
00CD72  1  B9 25 CC     GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
00CD75  1  95 1E        SetD6Ste:    sta Enemy_State,x         ;set as new state
00CD77  1               
00CD77  1               ;--------------------------------
00CD77  1               ;$00 - used to store bitmask (not used but initialized here)
00CD77  1               ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
00CD77  1               
00CD77  1               DoEnemySideCheck:
00CD77  1  B5 CF                  lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
00CD79  1  C9 20                  cmp #$20                   ;because there's nothing there that impedes movement
00CD7B  1  90 1F                  bcc ExESdeC
00CD7D  1  A0 16                  ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
00CD7F  1  A9 02                  lda #$02                   ;set value here in what is also used as
00CD81  1  85 EB                  sta $eb                    ;OAM data offset
00CD83  1  A5 EB        SdeCLoop: lda $eb                    ;check value
00CD85  1  D5 46                  cmp Enemy_MovingDir,x      ;compare value against moving direction
00CD87  1  D0 0C                  bne NextSdeC               ;branch if different and do not seek block there
00CD89  1  A9 01                  lda #$01                   ;set flag in A for save horizontal coordinate
00CD8B  1  20 09 D0               jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
00CD8E  1  F0 05                  beq NextSdeC               ;if nothing found, branch
00CD90  1  20 2E CE               jsr ChkForNonSolids        ;check for non-solid blocks
00CD93  1  D0 08                  bne ChkForBump_HammerBroJ  ;branch if not found
00CD95  1  C6 EB        NextSdeC: dec $eb                    ;move to the next direction
00CD97  1  C8                     iny
00CD98  1  C0 18                  cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
00CD9A  1  90 E7                  bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
00CD9C  1  60           ExESdeC:  rts
00CD9D  1               
00CD9D  1               ChkForBump_HammerBroJ:
00CD9D  1  E0 05                cpx #$05               ;check if we're on the special use slot
00CD9F  1  F0 09                beq NoBump             ;and if so, branch ahead and do not play sound
00CDA1  1  B5 1E                lda Enemy_State,x      ;if enemy state d7 not set, branch
00CDA3  1  0A                   asl                    ;ahead and do not play sound
00CDA4  1  90 04                bcc NoBump
00CDA6  1  A9 02                lda #Sfx_Bump          ;otherwise, play bump sound
00CDA8  1  85 FF                sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
00CDAA  1  B5 16        NoBump: lda Enemy_ID,x         ;check for hammer bro
00CDAC  1  C9 05                cmp #$05
00CDAE  1  D0 09                bne InvEnemyDir        ;branch if not found
00CDB0  1  A9 00                lda #$00
00CDB2  1  85 00                sta $00                ;initialize value here for bitmask
00CDB4  1  A0 FA                ldy #$fa               ;load default vertical speed for jumping
00CDB6  1  4C 68 B6             jmp SetHJ              ;jump to code that makes hammer bro jump
00CDB9  1               
00CDB9  1               InvEnemyDir:
00CDB9  1  4C A3 C7           jmp RXSpd     ;jump to turn the enemy around
00CDBC  1               
00CDBC  1               ;--------------------------------
00CDBC  1               ;$00 - used to hold horizontal difference between player and enemy
00CDBC  1               
00CDBC  1               PlayerEnemyDiff:
00CDBC  1  B5 87              lda Enemy_X_Position,x  ;get distance between enemy object's
00CDBE  1  38                 sec                     ;horizontal coordinate and the player's
00CDBF  1  E5 86              sbc Player_X_Position   ;horizontal coordinate
00CDC1  1  85 00              sta $00                 ;and store here
00CDC3  1  B5 6E              lda Enemy_PageLoc,x
00CDC5  1  E5 6D              sbc Player_PageLoc      ;subtract borrow, then leave
00CDC7  1  60                 rts
00CDC8  1               
00CDC8  1               ;--------------------------------
00CDC8  1               
00CDC8  1               EnemyLanding:
00CDC8  1  20 6E AF           jsr InitVStf            ;do something here to vertical speed and something else
00CDCB  1  B5 CF              lda Enemy_Y_Position,x
00CDCD  1  29 F0              and #%11110000          ;save high nybble of vertical coordinate, and
00CDCF  1  09 08              ora #%00001000          ;set d3, then store, probably used to set enemy object
00CDD1  1  95 CF              sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
00CDD3  1  60                 rts
00CDD4  1               
00CDD4  1               SubtEnemyYPos:
00CDD4  1  B5 CF              lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
00CDD6  1  18                 clc                     ;vertical coordinate
00CDD7  1  69 3E              adc #$3e
00CDD9  1  C9 44              cmp #$44                ;compare against a certain range
00CDDB  1  60                 rts                     ;and leave with flags set for conditional branch
00CDDC  1               
00CDDC  1               EnemyJump:
00CDDC  1  20 D4 CD             jsr SubtEnemyYPos     ;do a sub here
00CDDF  1  90 1A                bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
00CDE1  1  B5 A0                lda Enemy_Y_Speed,x
00CDE3  1  18                   clc                   ;add two to vertical speed
00CDE4  1  69 02                adc #$02
00CDE6  1  C9 03                cmp #$03              ;if green paratroopa not falling, branch ahead
00CDE8  1  90 11                bcc DoSide
00CDEA  1  20 27 CE             jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
00CDED  1  F0 0C                beq DoSide            ;standing on anything, then branch to same place if not
00CDEF  1  20 2E CE             jsr ChkForNonSolids   ;check for non-solid blocks
00CDF2  1  F0 07                beq DoSide            ;branch if found
00CDF4  1  20 C8 CD             jsr EnemyLanding      ;change vertical coordinate and speed
00CDF7  1  A9 FD                lda #$fd
00CDF9  1  95 A0                sta Enemy_Y_Speed,x   ;make the paratroopa jump again
00CDFB  1  4C 77 CD     DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
00CDFE  1               
00CDFE  1               ;--------------------------------
00CDFE  1               
00CDFE  1               HammerBroBGColl:
00CDFE  1  20 27 CE           jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
00CE01  1  F0 1D              beq NoUnderHammerBro
00CE03  1  C9 20              cmp #$20             ;check for blank metatile $20 and branch if not found
00CE05  1  D0 08              bne UnderHammerBro
00CE07  1               
00CE07  1               KillEnemyAboveBlock:
00CE07  1  20 CE C3           jsr ShellOrBlockDefeat  ;do this sub to kill enemy
00CE0A  1  A9 FC              lda #$fc                ;alter vertical speed of enemy and leave
00CE0C  1  95 A0              sta Enemy_Y_Speed,x
00CE0E  1  60                 rts
00CE0F  1               
00CE0F  1               UnderHammerBro:
00CE0F  1  BD 8A 07           lda EnemyFrameTimer,x ;check timer used by hammer bro
00CE12  1  D0 0C              bne NoUnderHammerBro  ;branch if not expired
00CE14  1  B5 1E              lda Enemy_State,x
00CE16  1  29 88              and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
00CE18  1  95 1E              sta Enemy_State,x     ;and store
00CE1A  1  20 C8 CD           jsr EnemyLanding      ;modify vertical coordinate, speed and something else
00CE1D  1  4C 77 CD           jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
00CE20  1               
00CE20  1               NoUnderHammerBro:
00CE20  1  B5 1E              lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
00CE22  1  09 01              ora #$01           ;in the enemy state to indicate jumping or falling, then leave
00CE24  1  95 1E              sta Enemy_State,x
00CE26  1  60                 rts
00CE27  1               
00CE27  1               ChkUnderEnemy:
00CE27  1  A9 00              lda #$00                  ;set flag in A for save vertical coordinate
00CE29  1  A0 15              ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
00CE2B  1  4C 09 D0           jmp BlockBufferChk_Enemy  ;hop to it!
00CE2E  1               
00CE2E  1               ChkForNonSolids:
00CE2E  1  C9 23               cmp #$23       ;blank metatile used for vines?
00CE30  1  F0 16               beq NSFnd
00CE32  1  C9 C3               cmp #$c3       ;regular coin?
00CE34  1  F0 12               beq NSFnd
00CE36  1  C9 C4               cmp #$c4       ;underwater coin?
00CE38  1  F0 0E               beq NSFnd
00CE3A  1  C9 5E               cmp #$5e       ;hidden coin block?
00CE3C  1  F0 0A               beq NSFnd
00CE3E  1  C9 5F               cmp #$5f       ;hidden 1-up block?
00CE40  1  F0 06               beq NSFnd
00CE42  1  C9 60               cmp #$60       ;hidden poison shroom block?
00CE44  1  F0 02               beq NSFnd
00CE46  1  C9 61               cmp #$61       ;hidden power-up block?
00CE48  1  60           NSFnd: rts
00CE49  1               
00CE49  1               ;-------------------------------------------------------------------------------------
00CE49  1               
00CE49  1               FireballBGCollision:
00CE49  1  B5 D5              lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
00CE4B  1  C9 18              cmp #$18
00CE4D  1  90 21              bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
00CE4F  1  20 1D D0           jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
00CE52  1  F0 1C              beq ClearBounceFlag         ;if nothing underneath fireball, branch
00CE54  1  20 2E CE           jsr ChkForNonSolids         ;check for non-solid metatiles
00CE57  1  F0 17              beq ClearBounceFlag         ;branch if any found
00CE59  1  B5 A6              lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
00CE5B  1  30 18              bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
00CE5D  1  B5 3A              lda FireballBouncingFlag,x  ;if bouncing flag already set,
00CE5F  1  D0 14              bne InitFireballExplode     ;branch to set exploding bit in fireball's state
00CE61  1  A9 FD              lda #$fd
00CE63  1  95 A6              sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
00CE65  1  A9 01              lda #$01
00CE67  1  95 3A              sta FireballBouncingFlag,x  ;set bouncing flag
00CE69  1  B5 D5              lda Fireball_Y_Position,x
00CE6B  1  29 F8              and #$f8                    ;modify vertical coordinate to land it properly
00CE6D  1  95 D5              sta Fireball_Y_Position,x   ;store as new vertical coordinate
00CE6F  1  60                 rts                         ;leave
00CE70  1               
00CE70  1               ClearBounceFlag:
00CE70  1  A9 00              lda #$00
00CE72  1  95 3A              sta FireballBouncingFlag,x  ;clear bouncing flag by default
00CE74  1  60                 rts                         ;leave
00CE75  1               
00CE75  1               InitFireballExplode:
00CE75  1  A9 80              lda #$80
00CE77  1  95 24              sta Fireball_State,x        ;set exploding flag in fireball's state
00CE79  1  A9 02              lda #Sfx_Bump
00CE7B  1  85 FF              sta Square1SoundQueue       ;load bump sound
00CE7D  1  60                 rts                         ;leave
00CE7E  1               
00CE7E  1               ;-------------------------------------------------------------------------------------
00CE7E  1               ;$00 - used to hold one of bitmasks, or offset
00CE7E  1               ;$01 - used for relative X coordinate, also used to store middle screen page location
00CE7E  1               ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
00CE7E  1               
00CE7E  1               ;this data added to relative coordinates of sprite objects
00CE7E  1               ;stored in order: left edge, top edge, right edge, bottom edge
00CE7E  1               BoundBoxCtrlData:
00CE7E  1  02 08 0E 20        .byte $02, $08, $0e, $20
00CE82  1  03 14 0D 20        .byte $03, $14, $0d, $20
00CE86  1  02 14 0E 20        .byte $02, $14, $0e, $20
00CE8A  1  02 09 0E 15        .byte $02, $09, $0e, $15
00CE8E  1  00 00 18 06        .byte $00, $00, $18, $06
00CE92  1  00 00 20 0D        .byte $00, $00, $20, $0d
00CE96  1  00 00 30 0D        .byte $00, $00, $30, $0d
00CE9A  1  00 00 08 08        .byte $00, $00, $08, $08
00CE9E  1  06 04 0A 08        .byte $06, $04, $0a, $08
00CEA2  1  03 0E 0D 16        .byte $03, $0e, $0d, $16
00CEA6  1  00 02 10 15        .byte $00, $02, $10, $15
00CEAA  1  04 04 0C 1C        .byte $04, $04, $0c, $1c
00CEAE  1               
00CEAE  1               GetFireballBoundBox:
00CEAE  1  8A                 txa         ;add seven bytes to offset
00CEAF  1  18                 clc         ;to use in routines as offset for fireball
00CEB0  1  69 07              adc #$07
00CEB2  1  AA                 tax
00CEB3  1  A0 02              ldy #$02    ;set offset for relative coordinates
00CEB5  1  D0 07              bne FBallB  ;unconditional branch
00CEB7  1               
00CEB7  1               GetMiscBoundBox:
00CEB7  1  8A                   txa                       ;add nine bytes to offset
00CEB8  1  18                   clc                       ;to use in routines as offset for misc object
00CEB9  1  69 09                adc #$09
00CEBB  1  AA                   tax
00CEBC  1  A0 06                ldy #$06                  ;set offset for relative coordinates
00CEBE  1  20 1D CF     FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
00CEC1  1  4C 5F CF             jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
00CEC4  1               
00CEC4  1               GetEnemyBoundBox:
00CEC4  1  A0 48              ldy #$48                 ;store bitmask here for now
00CEC6  1  84 00              sty $00
00CEC8  1  A0 44              ldy #$44                 ;store another bitmask here for now and jump
00CECA  1  4C D3 CE           jmp GetMaskedOffScrBits
00CECD  1               
00CECD  1               SmallPlatformBoundBox:
00CECD  1  A0 08              ldy #$08                 ;store bitmask here for now
00CECF  1  84 00              sty $00
00CED1  1  A0 04              ldy #$04                 ;store another bitmask here for now
00CED3  1               
00CED3  1               GetMaskedOffScrBits:
00CED3  1  B5 87                lda Enemy_X_Position,x      ;get enemy object position relative
00CED5  1  38                   sec                         ;to the left side of the screen
00CED6  1  ED 1C 07             sbc ScreenLeft_X_Pos
00CED9  1  85 01                sta $01                     ;store here
00CEDB  1  B5 6E                lda Enemy_PageLoc,x         ;subtract borrow from current page location
00CEDD  1  ED 1A 07             sbc ScreenLeft_PageLoc      ;of left side
00CEE0  1  30 06                bmi CMBits                  ;if enemy object is beyond left edge, branch
00CEE2  1  05 01                ora $01
00CEE4  1  F0 02                beq CMBits                  ;if precisely at the left edge, branch
00CEE6  1  A4 00                ldy $00                     ;if to the right of left edge, use value in $00 for A
00CEE8  1  98           CMBits: tya                         ;otherwise use contents of Y
00CEE9  1  2D D1 03             and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
00CEEC  1  9D D8 03             sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
00CEEF  1  D0 19                bne MoveBoundBoxOffscreen   ;if anything set here, branch
00CEF1  1  4C FD CE             jmp SetupEOffsetFBBox       ;otherwise, do something else
00CEF4  1               
00CEF4  1               LargePlatformBoundBox:
00CEF4  1  E8                 inx                        ;increment X to get the proper offset
00CEF5  1  20 C0 DE           jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
00CEF8  1  CA                 dex                        ;decrement to return to original offset
00CEF9  1  C9 FE              cmp #$fe                   ;if completely offscreen, branch to put entire bounding
00CEFB  1  B0 0D              bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
00CEFD  1               
00CEFD  1               SetupEOffsetFBBox:
00CEFD  1  8A                 txa                        ;add 1 to offset to properly address
00CEFE  1  18                 clc                        ;the enemy object memory locations
00CEFF  1  69 01              adc #$01
00CF01  1  AA                 tax
00CF02  1  A0 01              ldy #$01                   ;load 1 as offset here, same reason
00CF04  1  20 1D CF           jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
00CF07  1  4C 5F CF           jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
00CF0A  1               
00CF0A  1               MoveBoundBoxOffscreen:
00CF0A  1  8A                 txa                            ;multiply offset by 4
00CF0B  1  0A                 asl
00CF0C  1  0A                 asl
00CF0D  1  A8                 tay                            ;use as offset here
00CF0E  1  A9 FF              lda #$ff
00CF10  1  99 B0 04           sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
00CF13  1  99 B1 04           sta EnemyBoundingBoxCoord+1,y
00CF16  1  99 B2 04           sta EnemyBoundingBoxCoord+2,y
00CF19  1  99 B3 04           sta EnemyBoundingBoxCoord+3,y
00CF1C  1  60                 rts
00CF1D  1               
00CF1D  1               BoundingBoxCore:
00CF1D  1  86 00              stx $00                     ;save offset here
00CF1F  1  B9 B8 03           lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
00CF22  1  85 02              sta $02                     ;vertically and horizontally, respectively
00CF24  1  B9 AD 03           lda SprObject_Rel_XPos,y
00CF27  1  85 01              sta $01
00CF29  1  8A                 txa                         ;multiply offset by four and save to stack
00CF2A  1  0A                 asl
00CF2B  1  0A                 asl
00CF2C  1  48                 pha
00CF2D  1  A8                 tay                         ;use as offset for Y, X is left alone
00CF2E  1  BD 99 04           lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
00CF31  1  0A                 asl                         ;multiply that by four and use as X
00CF32  1  0A                 asl
00CF33  1  AA                 tax
00CF34  1  A5 01              lda $01                     ;add the first number in the bounding box data to the
00CF36  1  18                 clc                         ;relative horizontal coordinate using enemy object offset
00CF37  1  7D 7E CE           adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
00CF3A  1  99 AC 04           sta BoundingBox_UL_Corner,y ;store here
00CF3D  1  A5 01              lda $01
00CF3F  1  18                 clc
00CF40  1  7D 80 CE           adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
00CF43  1  99 AE 04           sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
00CF46  1  E8                 inx                         ;increment both offsets
00CF47  1  C8                 iny
00CF48  1  A5 02              lda $02                     ;add the second number to the relative vertical coordinate
00CF4A  1  18                 clc                         ;using incremented offset and store using the other
00CF4B  1  7D 7E CE           adc BoundBoxCtrlData,x      ;incremented offset
00CF4E  1  99 AC 04           sta BoundingBox_UL_Corner,y
00CF51  1  A5 02              lda $02
00CF53  1  18                 clc
00CF54  1  7D 80 CE           adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
00CF57  1  99 AE 04           sta BoundingBox_LR_Corner,y ;and store
00CF5A  1  68                 pla                         ;get original offset loaded into $00 * y from stack
00CF5B  1  A8                 tay                         ;use as Y
00CF5C  1  A6 00              ldx $00                     ;get original offset and use as X again
00CF5E  1  60                 rts
00CF5F  1               
00CF5F  1               CheckRightScreenBBox:
00CF5F  1  AD 1C 07            lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
00CF62  1  18                  clc                        ;and store as horizontal coordinate of middle
00CF63  1  69 80               adc #$80
00CF65  1  85 02               sta $02
00CF67  1  AD 1A 07            lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
00CF6A  1  69 00               adc #$00                   ;and store as page location of middle
00CF6C  1  85 01               sta $01
00CF6E  1  B5 86               lda SprObject_X_Position,x ;get horizontal coordinate
00CF70  1  C5 02               cmp $02                    ;compare against middle horizontal coordinate
00CF72  1  B5 6D               lda SprObject_PageLoc,x    ;get page location
00CF74  1  E5 01               sbc $01                    ;subtract from middle page location
00CF76  1  90 15               bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
00CF78  1  B9 AE 04            lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00CF7B  1  30 0D               bmi NoOfs                  ;coordinates, branch if still on the screen
00CF7D  1  A9 FF               lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
00CF7F  1  BE AC 04            ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00CF82  1  30 03               bmi SORte                  ;coordinates, and branch if still on the screen
00CF84  1  99 AC 04            sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00CF87  1  99 AE 04     SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00CF8A  1  A6 08        NoOfs: ldx ObjectOffset           ;get object offset and leave
00CF8C  1  60                  rts
00CF8D  1               
00CF8D  1               CheckLeftScreenBBox:
00CF8D  1  B9 AC 04             lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00CF90  1  10 11                bpl NoOfs2                 ;coordinates, and branch if still on the screen
00CF92  1  C9 A0                cmp #$a0                   ;check to see if left-side edge is in the middle of the
00CF94  1  90 0D                bcc NoOfs2                 ;screen or really offscreen, and branch if still on
00CF96  1  A9 00                lda #$00
00CF98  1  BE AE 04             ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00CF9B  1  10 03                bpl SOLft                  ;coordinates, branch if still onscreen
00CF9D  1  99 AE 04             sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00CFA0  1  99 AC 04     SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00CFA3  1  A6 08        NoOfs2: ldx ObjectOffset           ;get object offset and leave
00CFA5  1  60                   rts
00CFA6  1               
00CFA6  1               ;-------------------------------------------------------------------------------------
00CFA6  1               ;$06 - second object's offset
00CFA6  1               ;$07 - counter
00CFA6  1               
00CFA6  1               PlayerCollisionCore:
00CFA6  1  A2 00              ldx #$00     ;initialize X to use player's bounding box for comparison
00CFA8  1               
00CFA8  1               SprObjectCollisionCore:
00CFA8  1  84 06              sty $06      ;save contents of Y here
00CFAA  1  A9 01              lda #$01
00CFAC  1  85 07              sta $07      ;save value 1 here as counter, compare horizontal coordinates first
00CFAE  1               
00CFAE  1               CollisionCoreLoop:
00CFAE  1  B9 AC 04           lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
00CFB1  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
00CFB4  1  B0 2A              bcs FirstBoxGreater          ;if first left/top => second, branch
00CFB6  1  DD AE 04           cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
00CFB9  1  90 12              bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
00CFBB  1  F0 42              beq CollisionFound           ;if somehow equal, collision, thus branch
00CFBD  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
00CFC0  1  D9 AC 04           cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
00CFC3  1  90 3A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00CFC5  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
00CFC8  1  B0 35              bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
00CFCA  1  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00CFCC  1  60                 rts                          ;note horizontal wrapping never occurs
00CFCD  1               
00CFCD  1               SecondBoxVerticalChk:
00CFCD  1  BD AE 04           lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
00CFD0  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
00CFD3  1  90 2A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00CFD5  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
00CFD8  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
00CFDB  1  B0 22              bcs CollisionFound           ;if equal or greater, collision, thus branch
00CFDD  1  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00CFDF  1  60                 rts
00CFE0  1               
00CFE0  1               FirstBoxGreater:
00CFE0  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
00CFE3  1  F0 1A              beq CollisionFound           ;if first coordinate = second, collision, thus branch
00CFE5  1  DD AE 04           cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
00CFE8  1  90 15              bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
00CFEA  1  F0 13              beq CollisionFound           ;then collision, thus branch
00CFEC  1  D9 AE 04           cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
00CFEF  1  90 0A              bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
00CFF1  1  F0 08              beq NoCollisionFound
00CFF3  1  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
00CFF6  1  DD AC 04           cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
00CFF9  1  B0 04              bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
00CFFB  1               
00CFFB  1               NoCollisionFound:
00CFFB  1  18                 clc          ;clear carry, then load value set earlier, then leave
00CFFC  1  A4 06              ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
00CFFE  1  60                 rts          ;not bother checking vertical ones, because what's the point?
00CFFF  1               
00CFFF  1               CollisionFound:
00CFFF  1  E8                 inx                    ;increment offsets on both objects to check
00D000  1  C8                 iny                    ;the vertical coordinates
00D001  1  C6 07              dec $07                ;decrement counter to reflect this
00D003  1  10 A9              bpl CollisionCoreLoop  ;if counter not expired, branch to loop
00D005  1  38                 sec                    ;otherwise we already did both sets, therefore collision, so set carry
00D006  1  A4 06              ldy $06                ;load original value set here earlier, then leave
00D008  1  60                 rts
00D009  1               
00D009  1               ;-------------------------------------------------------------------------------------
00D009  1               ;$02 - modified y coordinate
00D009  1               ;$03 - stores metatile involved in block buffer collisions
00D009  1               ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
00D009  1               ;$05 - modified x coordinate
00D009  1               ;$06-$07 - block buffer address
00D009  1               
00D009  1               BlockBufferChk_Enemy:
00D009  1  48                 pha        ;save contents of A to stack
00D00A  1  8A                 txa
00D00B  1  18                 clc        ;add 1 to X to run sub with enemy offset in mind
00D00C  1  69 01              adc #$01
00D00E  1  AA                 tax
00D00F  1  68                 pla        ;pull A from stack and jump elsewhere
00D010  1  4C 26 D0           jmp BBChk_E
00D013  1               
00D013  1               ResidualMiscObjectCode:
00D013  1  8A                 txa
00D014  1  18                 clc           ;supposedly used once to set offset for
00D015  1  69 0D              adc #$0d      ;miscellaneous objects
00D017  1  AA                 tax
00D018  1  A0 1B              ldy #$1b      ;supposedly used once to set offset for block buffer data
00D01A  1  4C 24 D0           jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
00D01D  1               
00D01D  1               BlockBufferChk_FBall:
00D01D  1  A0 1A                 ldy #$1a                  ;set offset for block buffer adder data
00D01F  1  8A                    txa
00D020  1  18                    clc
00D021  1  69 07                 adc #$07                  ;add seven bytes to use
00D023  1  AA                    tax
00D024  1  A9 00        ResJmpM: lda #$00                  ;set A to return vertical coordinate
00D026  1  20 71 D0     BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
00D029  1  A6 08                 ldx ObjectOffset          ;get object offset
00D02B  1  C9 00                 cmp #$00                  ;check to see if object bumped into anything
00D02D  1  60                    rts
00D02E  1               
00D02E  1               BlockBufferAdderData:
00D02E  1  00 07 0E           .byte $00, $07, $0e
00D031  1               
00D031  1               BlockBuffer_X_Adder:
00D031  1  08 03 0C 02        .byte $08, $03, $0c, $02, $02, $0d, $0d, $08
00D035  1  02 0D 0D 08  
00D039  1  03 0C 02 02        .byte $03, $0c, $02, $02, $0d, $0d, $08, $03
00D03D  1  0D 0D 08 03  
00D041  1  0C 02 02 0D        .byte $0c, $02, $02, $0d, $0d, $08, $00, $10
00D045  1  0D 08 00 10  
00D049  1  04 14 04 04        .byte $04, $14, $04, $04
00D04D  1               
00D04D  1               BlockBuffer_Y_Adder:
00D04D  1  04 20 20 08        .byte $04, $20, $20, $08, $18, $08, $18, $02
00D051  1  18 08 18 02  
00D055  1  20 20 08 18        .byte $20, $20, $08, $18, $08, $18, $12, $20
00D059  1  08 18 12 20  
00D05D  1  20 18 18 18        .byte $20, $18, $18, $18, $18, $18, $14, $14
00D061  1  18 18 14 14  
00D065  1  06 06 08 10        .byte $06, $06, $08, $10
00D069  1               
00D069  1               BlockBufferColli_Feet:
00D069  1  C8                  iny            ;if branched here, increment to next set of adders
00D06A  1               
00D06A  1               BlockBufferColli_Head:
00D06A  1  A9 00               lda #$00       ;set flag to return vertical coordinate
00D06C  1  2C                  .byte $2c        ;BIT instruction opcode
00D06D  1               
00D06D  1               BlockBufferColli_Side:
00D06D  1  A9 01               lda #$01       ;set flag to return horizontal coordinate
00D06F  1  A2 00               ldx #$00       ;set offset for player object
00D071  1               
00D071  1               BlockBufferCollision:
00D071  1  48                  pha                         ;save contents of A to stack
00D072  1  84 04               sty $04                     ;save contents of Y here
00D074  1  B9 31 D0            lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
00D077  1  18                  clc                         ;of object to value obtained using Y as offset
00D078  1  75 86               adc SprObject_X_Position,x
00D07A  1  85 05               sta $05                     ;store here
00D07C  1  B5 6D               lda SprObject_PageLoc,x
00D07E  1  69 00               adc #$00                    ;add carry to page location
00D080  1  29 01               and #$01                    ;get LSB, mask out all other bits
00D082  1  4A                  lsr                         ;move to carry
00D083  1  05 05               ora $05                     ;get stored value
00D085  1  6A                  ror                         ;rotate carry to MSB of A
00D086  1  4A                  lsr                         ;and effectively move high nybble to
00D087  1  4A                  lsr                         ;lower, LSB which became MSB will be
00D088  1  4A                  lsr                         ;d4 at this point
00D089  1  20 1D 9A            jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
00D08C  1  A4 04               ldy $04                     ;get old contents of Y
00D08E  1  B5 CE               lda SprObject_Y_Position,x  ;get vertical coordinate of object
00D090  1  18                  clc
00D091  1  79 4D D0            adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
00D094  1  29 F0               and #%11110000              ;mask out low nybble
00D096  1  38                  sec
00D097  1  E9 20               sbc #$20                    ;subtract 32 pixels for the status bar
00D099  1  85 02               sta $02                     ;store result here
00D09B  1  A8                  tay                         ;use as offset for block buffer
00D09C  1  B1 06               lda ($06),y                 ;check current content of block buffer
00D09E  1  85 03               sta $03                     ;and store here
00D0A0  1  A4 04               ldy $04                     ;get old contents of Y again
00D0A2  1  68                  pla                         ;pull A from stack
00D0A3  1  D0 05               bne RetXC                   ;if A = 1, branch
00D0A5  1  B5 CE               lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
00D0A7  1  4C AC D0            jmp RetYC                   ;and jump
00D0AA  1  B5 86        RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
00D0AC  1  29 0F        RetYC: and #%00001111              ;and mask out high nybble
00D0AE  1  85 04               sta $04                     ;store masked out result here
00D0B0  1  A5 03               lda $03                     ;get saved content of block buffer
00D0B2  1  60                  rts                         ;and leave
00D0B3  1               
00D0B3  1               ;-------------------------------------------------------------------------------------
00D0B3  1               
00D0B3  1               ;$00 - offset to vine Y coordinate adder
00D0B3  1               ;$02 - offset to sprite data
00D0B3  1               
00D0B3  1               VineYPosAdder:
00D0B3  1  00 30              .byte $00, $30
00D0B5  1               
00D0B5  1               DrawVine:
00D0B5  1  84 00                 sty $00                    ;save offset here
00D0B7  1  AD B9 03              lda Enemy_Rel_YPos         ;get relative vertical coordinate
00D0BA  1  18                    clc
00D0BB  1  79 B3 D0              adc VineYPosAdder,y        ;add value using offset in Y to get value
00D0BE  1  BE 9A 03              ldx VineObjOffset,y        ;get offset to vine
00D0C1  1  BC E5 06              ldy Enemy_SprDataOffset,x  ;get sprite data offset
00D0C4  1  84 02                 sty $02                    ;store sprite data offset here
00D0C6  1  20 2E D1              jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
00D0C9  1  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00D0CC  1  99 03 02              sta Sprite_X_Position,y    ;store in first, third and fifth sprites
00D0CF  1  99 0B 02              sta Sprite_X_Position+8,y
00D0D2  1  99 13 02              sta Sprite_X_Position+16,y
00D0D5  1  18                    clc
00D0D6  1  69 06                 adc #$06                   ;add six pixels to second, fourth and sixth sprites
00D0D8  1  99 07 02              sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
00D0DB  1  99 0F 02              sta Sprite_X_Position+12,y ;our vertical stack of sprites
00D0DE  1  99 17 02              sta Sprite_X_Position+20,y
00D0E1  1  A9 21                 lda #%00100001             ;set bg priority and palette attribute bits
00D0E3  1  99 02 02              sta Sprite_Attributes,y    ;set in first, third and fifth sprites
00D0E6  1  99 0A 02              sta Sprite_Attributes+8,y
00D0E9  1  99 12 02              sta Sprite_Attributes+16,y
00D0EC  1  09 40                 ora #%01000000             ;additionally, set horizontal flip bit
00D0EE  1  99 06 02              sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
00D0F1  1  99 0E 02              sta Sprite_Attributes+12,y
00D0F4  1  99 16 02              sta Sprite_Attributes+20,y
00D0F7  1  A2 05                 ldx #$05                   ;set tiles for six sprites
00D0F9  1  A9 E1        VineTL:  lda #$e1                   ;set tile number for sprite
00D0FB  1  99 01 02              sta Sprite_Tilenumber,y
00D0FE  1  C8                    iny                        ;move offset to next sprite data
00D0FF  1  C8                    iny
00D100  1  C8                    iny
00D101  1  C8                    iny
00D102  1  CA                    dex                        ;move onto next sprite
00D103  1  10 F4                 bpl VineTL                 ;loop until all sprites are done
00D105  1  A4 02                 ldy $02                    ;get original offset
00D107  1  A5 00                 lda $00                    ;get offset to vine adding data
00D109  1  D0 05                 bne SkpVTop                ;if offset not zero, skip this part
00D10B  1  A9 E0                 lda #$e0
00D10D  1  99 01 02              sta Sprite_Tilenumber,y    ;set other tile number for top of vine
00D110  1  A2 00        SkpVTop: ldx #$00                   ;start with the first sprite again
00D112  1  AD 9D 03     ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
00D115  1  38                    sec
00D116  1  F9 00 02              sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
00D119  1  C9 64                 cmp #$64                   ;if two coordinates are less than 100/$64 pixels
00D11B  1  90 05                 bcc NextVSp                ;apart, skip this to leave sprite alone
00D11D  1  A9 F8                 lda #$f8
00D11F  1  99 00 02              sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
00D122  1  C8           NextVSp: iny                        ;move offset to next OAM data
00D123  1  C8                    iny
00D124  1  C8                    iny
00D125  1  C8                    iny
00D126  1  E8                    inx                        ;move onto next sprite
00D127  1  E0 06                 cpx #$06                   ;do this until all sprites are checked
00D129  1  D0 E7                 bne ChkFTop
00D12B  1  A4 00                 ldy $00                    ;return offset set earlier
00D12D  1  60                    rts
00D12E  1               
00D12E  1               SixSpriteStacker:
00D12E  1  A2 06               ldx #$06           ;do six sprites
00D130  1  99 00 02     StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
00D133  1  18                  clc
00D134  1  69 08               adc #$08           ;add eight pixels
00D136  1  C8                  iny
00D137  1  C8                  iny                ;move offset four bytes forward
00D138  1  C8                  iny
00D139  1  C8                  iny
00D13A  1  CA                  dex                ;do another sprite
00D13B  1  D0 F3               bne StkLp          ;do this until all sprites are done
00D13D  1  A4 02               ldy $02            ;get saved OAM data offset and leave
00D13F  1  60                  rts
00D140  1               
00D140  1               ;-------------------------------------------------------------------------------------
00D140  1               
00D140  1               FirstSprXPos:
00D140  1  04 00 04 00        .byte $04, $00, $04, $00
00D144  1               
00D144  1               FirstSprYPos:
00D144  1  00 04 00 04        .byte $00, $04, $00, $04
00D148  1               
00D148  1               SecondSprXPos:
00D148  1  00 08 00 08        .byte $00, $08, $00, $08
00D14C  1               
00D14C  1               SecondSprYPos:
00D14C  1  08 00 08 00        .byte $08, $00, $08, $00
00D150  1               
00D150  1               FirstSprTilenum:
00D150  1  80 82 81 83        .byte $80, $82, $81, $83
00D154  1               
00D154  1               SecondSprTilenum:
00D154  1  81 83 80 82        .byte $81, $83, $80, $82
00D158  1               
00D158  1               HammerSprAttrib:
00D158  1  03 03 C3 C3        .byte $03, $03, $c3, $c3
00D15C  1               
00D15C  1               DrawHammer:
00D15C  1  BC F3 06                 ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
00D15F  1  AD 47 07                 lda TimerControl
00D162  1  D0 08                    bne ForceHPose              ;if master timer control set, skip this part
00D164  1  B5 2A                    lda Misc_State,x            ;otherwise get hammer's state
00D166  1  29 7F                    and #%01111111              ;mask out d7
00D168  1  C9 01                    cmp #$01                    ;check to see if set to 1 yet
00D16A  1  F0 04                    beq GetHPose                ;if so, branch
00D16C  1  A2 00        ForceHPose: ldx #$00                    ;reset offset here
00D16E  1  F0 07                    beq RenderH                 ;do unconditional branch to rendering part
00D170  1  A5 09        GetHPose:   lda FrameCounter            ;get frame counter
00D172  1  4A                       lsr                         ;move d3-d2 to d1-d0
00D173  1  4A                       lsr
00D174  1  29 03                    and #%00000011              ;mask out all but d1-d0 (changes every four frames)
00D176  1  AA                       tax                         ;use as timing offset
00D177  1  AD BE 03     RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
00D17A  1  18                       clc
00D17B  1  7D 44 D1                 adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
00D17E  1  99 00 02                 sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
00D181  1  18                       clc
00D182  1  7D 4C D1                 adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
00D185  1  99 04 02                 sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
00D188  1  AD B3 03                 lda Misc_Rel_XPos           ;get relative horizontal coordinate
00D18B  1  18                       clc
00D18C  1  7D 40 D1                 adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
00D18F  1  99 03 02                 sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
00D192  1  18                       clc
00D193  1  7D 48 D1                 adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
00D196  1  99 07 02                 sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
00D199  1  BD 50 D1                 lda FirstSprTilenum,x
00D19C  1  99 01 02                 sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
00D19F  1  BD 54 D1                 lda SecondSprTilenum,x
00D1A2  1  99 05 02                 sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
00D1A5  1  BD 58 D1                 lda HammerSprAttrib,x
00D1A8  1  99 02 02                 sta Sprite_Attributes,y     ;get and store attribute bytes for both
00D1AB  1  99 06 02                 sta Sprite_Attributes+4,y   ;note in this case they use the same data
00D1AE  1  A6 08                    ldx ObjectOffset            ;get misc object offset
00D1B0  1  AD D6 03                 lda Misc_OffscreenBits
00D1B3  1  29 FC                    and #%11111100              ;check offscreen bits
00D1B5  1  F0 09                    beq NoHOffscr               ;if all bits clear, leave object alone
00D1B7  1  A9 00                    lda #$00
00D1B9  1  95 2A                    sta Misc_State,x            ;otherwise nullify misc object state
00D1BB  1  A9 F8                    lda #$f8
00D1BD  1  20 43 D2                 jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
00D1C0  1  60           NoHOffscr:  rts                         ;leave
00D1C1  1               
00D1C1  1               ;-------------------------------------------------------------------------------------
00D1C1  1               ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
00D1C1  1               ;$02 - used to hold Y coordinate for floatey number
00D1C1  1               ;$03 - residual byte used for flip (but value set here affects nothing)
00D1C1  1               ;$04 - attribute byte for floatey number
00D1C1  1               ;$05 - used as X coordinate for floatey number
00D1C1  1               
00D1C1  1               FlagpoleScoreNumTiles:
00D1C1  1  F9 50              .byte $f9, $50
00D1C3  1  F7 50              .byte $f7, $50
00D1C5  1  FA FB              .byte $fa, $fb
00D1C7  1  F8 FB              .byte $f8, $fb
00D1C9  1  F6 FB              .byte $f6, $fb
00D1CB  1  FD FE              .byte $fd, $fe
00D1CD  1               
00D1CD  1               FlagpoleGfxHandler:
00D1CD  1  BC E5 06           ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
00D1D0  1  AD AE 03           lda Enemy_Rel_XPos             ;get relative horizontal coordinate
00D1D3  1  99 03 02           sta Sprite_X_Position,y        ;store as X coordinate for first sprite
00D1D6  1  18                 clc
00D1D7  1  69 08              adc #$08                       ;add eight pixels and store
00D1D9  1  99 07 02           sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
00D1DC  1  99 0B 02           sta Sprite_X_Position+8,y
00D1DF  1  18                 clc
00D1E0  1  69 0C              adc #$0c                       ;add twelve more pixels and
00D1E2  1  85 05              sta $05                        ;store here to be used later by floatey number
00D1E4  1  B5 CF              lda Enemy_Y_Position,x         ;get vertical coordinate
00D1E6  1  20 43 D2           jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
00D1E9  1  69 08              adc #$08                       ;add eight pixels
00D1EB  1  99 08 02           sta Sprite_Y_Position+8,y      ;and store into third sprite
00D1EE  1  AD 0D 01           lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
00D1F1  1  85 02              sta $02                        ;store it here
00D1F3  1  A9 01              lda #$01
00D1F5  1  85 03              sta $03                        ;set value for flip which will not be used, and
00D1F7  1  85 04              sta $04                        ;attribute byte for floatey number
00D1F9  1  99 02 02           sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
00D1FC  1  99 06 02           sta Sprite_Attributes+4,y
00D1FF  1  99 0A 02           sta Sprite_Attributes+8,y
00D202  1  A9 7E              lda #$7e
00D204  1  99 01 02           sta Sprite_Tilenumber,y        ;put triangle shaped tile
00D207  1  99 09 02           sta Sprite_Tilenumber+8,y      ;into first and third sprites
00D20A  1  A9 7F              lda #$7f
00D20C  1  99 05 02           sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
00D20F  1  AD 0F 07           lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
00D212  1  F0 15              beq ChkFlagOffscreen           ;if zero, branch ahead
00D214  1  98                 tya
00D215  1  18                 clc                            ;add 12 bytes to sprite data offset
00D216  1  69 0C              adc #$0c
00D218  1  A8                 tay                            ;put back in Y
00D219  1  AD 0F 01           lda FlagpoleScore              ;get offset used to award points for touching flagpole
00D21C  1  0A                 asl                            ;multiply by 2 to get proper offset here
00D21D  1  AA                 tax
00D21E  1  BD C1 D1           lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
00D221  1  85 00              sta $00
00D223  1  BD C2 D1           lda FlagpoleScoreNumTiles+1,x
00D226  1  20 72 D8           jsr DrawOneSpriteRow           ;use it to render floatey number
00D229  1               
00D229  1               ChkFlagOffscreen:
00D229  1  A6 08              ldx ObjectOffset               ;get object offset for flag
00D22B  1  BC E5 06           ldy Enemy_SprDataOffset,x      ;get OAM data offset
00D22E  1  AD D1 03           lda Enemy_OffscreenBits        ;get offscreen bits
00D231  1  29 0E              and #%00001110                 ;mask out all but d3-d1
00D233  1  F0 14              beq ExitDumpSpr                ;if none of these bits set, branch to leave
00D235  1               
00D235  1               ;-------------------------------------------------------------------------------------
00D235  1               
00D235  1               MoveSixSpritesOffscreen:
00D235  1  A9 F8              lda #$f8                  ;set offscreen coordinate if jumping here
00D237  1               
00D237  1               DumpSixSpr:
00D237  1  99 14 02           sta Sprite_Data+20,y      ;dump A contents
00D23A  1  99 10 02           sta Sprite_Data+16,y      ;into third row sprites
00D23D  1               
00D23D  1               DumpFourSpr:
00D23D  1  99 0C 02           sta Sprite_Data+12,y      ;into second row sprites
00D240  1               
00D240  1               DumpThreeSpr:
00D240  1  99 08 02           sta Sprite_Data+8,y
00D243  1               
00D243  1               DumpTwoSpr:
00D243  1  99 04 02           sta Sprite_Data+4,y       ;and into first row sprites
00D246  1  99 00 02           sta Sprite_Data,y
00D249  1               
00D249  1               ExitDumpSpr:
00D249  1  60                 rts
00D24A  1               
00D24A  1               ;-------------------------------------------------------------------------------------
00D24A  1               
00D24A  1               DrawLargePlatform:
00D24A  1  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00D24D  1  84 02              sty $02                     ;store here
00D24F  1  C8                 iny                         ;add 3 to it for offset
00D250  1  C8                 iny                         ;to X coordinate
00D251  1  C8                 iny
00D252  1  AD AE 03           lda Enemy_Rel_XPos          ;get horizontal relative coordinate
00D255  1  20 2E D1           jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
00D258  1  A6 08              ldx ObjectOffset
00D25A  1  B5 CF              lda Enemy_Y_Position,x      ;get vertical coordinate
00D25C  1  20 3D D2           jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
00D25F  1  AC 4E 07           ldy AreaType
00D262  1  C0 03              cpy #$03                    ;check for castle-type level
00D264  1  F0 05              beq ShrinkPlatform
00D266  1  AC CC 06           ldy SecondaryHardMode       ;check for secondary hard mode flag set
00D269  1  F0 02              beq SetLast2Platform        ;branch if not set elsewhere
00D26B  1               
00D26B  1               ShrinkPlatform:
00D26B  1  A9 F8              lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
00D26D  1               
00D26D  1               SetLast2Platform:
00D26D  1  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00D270  1  99 10 02           sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
00D273  1  99 14 02           sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
00D276  1  A9 5B              lda #$5b                    ;load default tile for platform (mushroom)
00D278  1  AE 43 07           ldx CloudTypeOverride
00D27B  1  F0 02              beq SetPlatformTilenum      ;if cloud level override flag not set, use
00D27D  1  A9 75              lda #$75                    ;otherwise load other tile for platform (puff)
00D27F  1               
00D27F  1               SetPlatformTilenum:
00D27F  1  A6 08                ldx ObjectOffset            ;get enemy object buffer offset
00D281  1  C8                   iny                         ;increment Y for tile offset
00D282  1  20 37 D2             jsr DumpSixSpr              ;dump tile number into all six sprites
00D285  1  A9 02                lda #$02                    ;set palette controls
00D287  1  C8                   iny                         ;increment Y for sprite attributes
00D288  1  20 37 D2             jsr DumpSixSpr              ;dump attributes into all six sprites
00D28B  1  E8                   inx                         ;increment X for enemy objects
00D28C  1  20 C0 DE             jsr GetXOffscreenBits       ;get offscreen bits again
00D28F  1  CA                   dex
00D290  1  BC E5 06             ldy Enemy_SprDataOffset,x   ;get OAM data offset
00D293  1  0A                   asl                         ;rotate d7 into carry, save remaining
00D294  1  48                   pha                         ;bits to the stack
00D295  1  90 05                bcc SChk2
00D297  1  A9 F8                lda #$f8                    ;if d7 was set, move first sprite offscreen
00D299  1  99 00 02             sta Sprite_Y_Position,y
00D29C  1  68           SChk2:  pla                         ;get bits from stack
00D29D  1  0A                   asl                         ;rotate d6 into carry
00D29E  1  48                   pha                         ;save to stack
00D29F  1  90 05                bcc SChk3
00D2A1  1  A9 F8                lda #$f8                    ;if d6 was set, move second sprite offscreen
00D2A3  1  99 04 02             sta Sprite_Y_Position+4,y
00D2A6  1  68           SChk3:  pla                         ;get bits from stack
00D2A7  1  0A                   asl                         ;rotate d5 into carry
00D2A8  1  48                   pha                         ;save to stack
00D2A9  1  90 05                bcc SChk4
00D2AB  1  A9 F8                lda #$f8                    ;if d5 was set, move third sprite offscreen
00D2AD  1  99 08 02             sta Sprite_Y_Position+8,y
00D2B0  1  68           SChk4:  pla                         ;get bits from stack
00D2B1  1  0A                   asl                         ;rotate d4 into carry
00D2B2  1  48                   pha                         ;save to stack
00D2B3  1  90 05                bcc SChk5
00D2B5  1  A9 F8                lda #$f8                    ;if d4 was set, move fourth sprite offscreen
00D2B7  1  99 0C 02             sta Sprite_Y_Position+12,y
00D2BA  1  68           SChk5:  pla                         ;get bits from stack
00D2BB  1  0A                   asl                         ;rotate d3 into carry
00D2BC  1  48                   pha                         ;save to stack
00D2BD  1  90 05                bcc SChk6
00D2BF  1  A9 F8                lda #$f8                    ;if d3 was set, move fifth sprite offscreen
00D2C1  1  99 10 02             sta Sprite_Y_Position+16,y
00D2C4  1  68           SChk6:  pla                         ;get bits from stack
00D2C5  1  0A                   asl                         ;rotate d2 into carry
00D2C6  1  90 05                bcc SLChk                   ;save to stack
00D2C8  1  A9 F8                lda #$f8
00D2CA  1  99 14 02             sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
00D2CD  1  AD D1 03     SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
00D2D0  1  0A                   asl                         ;and if d7 is not set, skip sub
00D2D1  1  90 03                bcc ExDLPl
00D2D3  1  20 35 D2             jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
00D2D6  1  60           ExDLPl: rts
00D2D7  1               
00D2D7  1               ;-------------------------------------------------------------------------------------
00D2D7  1               
00D2D7  1               DrawFloateyNumber_Coin:
00D2D7  1  A5 09                  lda FrameCounter          ;get frame counter
00D2D9  1  4A                     lsr                       ;divide by 2
00D2DA  1  B0 02                  bcs NotRsNum              ;branch if d0 not set to raise number every other frame
00D2DC  1  D6 DB                  dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
00D2DE  1  B5 DB        NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
00D2E0  1  20 43 D2               jsr DumpTwoSpr            ;dump into both sprites
00D2E3  1  AD B3 03               lda Misc_Rel_XPos         ;get relative horizontal coordinate
00D2E6  1  99 03 02               sta Sprite_X_Position,y   ;store as X coordinate for first sprite
00D2E9  1  18                     clc
00D2EA  1  69 08                  adc #$08                  ;add eight pixels
00D2EC  1  99 07 02               sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
00D2EF  1  A9 02                  lda #$02
00D2F1  1  99 02 02               sta Sprite_Attributes,y   ;store attribute byte in both sprites
00D2F4  1  99 06 02               sta Sprite_Attributes+4,y
00D2F7  1  A9 F7                  lda #$f7
00D2F9  1  99 01 02               sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
00D2FC  1  A9 FB                  lda #$fb                  ;that resemble "200"
00D2FE  1  99 05 02               sta Sprite_Tilenumber+4,y
00D301  1  4C 3F D3               jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
00D304  1               
00D304  1               JumpingCoinTiles:
00D304  1  60 61 62 63        .byte $60, $61, $62, $63
00D308  1               
00D308  1               JCoinGfxHandler:
00D308  1  BC F3 06              ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
00D30B  1  B5 2A                 lda Misc_State,x            ;get state of misc object
00D30D  1  C9 02                 cmp #$02                    ;if 2 or greater,
00D30F  1  B0 C6                 bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
00D311  1  B5 DB                 lda Misc_Y_Position,x       ;store vertical coordinate as
00D313  1  99 00 02              sta Sprite_Y_Position,y     ;Y coordinate for first sprite
00D316  1  18                    clc
00D317  1  69 08                 adc #$08                    ;add eight pixels
00D319  1  99 04 02              sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
00D31C  1  AD B3 03              lda Misc_Rel_XPos           ;get relative horizontal coordinate
00D31F  1  99 03 02              sta Sprite_X_Position,y
00D322  1  99 07 02              sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
00D325  1  A5 09                 lda FrameCounter            ;get frame counter
00D327  1  4A                    lsr                         ;divide by 2 to alter every other frame
00D328  1  29 03                 and #%00000011              ;mask out d2-d1
00D32A  1  AA                    tax                         ;use as graphical offset
00D32B  1  BD 04 D3              lda JumpingCoinTiles,x      ;load tile number
00D32E  1  C8                    iny                         ;increment OAM data offset to write tile numbers
00D32F  1  20 43 D2              jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
00D332  1  88                    dey                         ;decrement to get old offset
00D333  1  A9 02                 lda #$02
00D335  1  99 02 02              sta Sprite_Attributes,y     ;set attribute byte in first sprite
00D338  1  A9 82                 lda #$82
00D33A  1  99 06 02              sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
00D33D  1  A6 08                 ldx ObjectOffset            ;get misc object offset
00D33F  1  60           ExJCGfx: rts                         ;leave
00D340  1               
00D340  1               ;-------------------------------------------------------------------------------------
00D340  1               ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
00D340  1               ;$02 - used to hold bottom row Y position
00D340  1               ;$03 - used to hold flip control (not used here)
00D340  1               ;$04 - used to hold sprite attributes
00D340  1               ;$05 - used to hold X position
00D340  1               ;$07 - counter
00D340  1               
00D340  1               ;tiles arranged in top left, right, bottom left, right order
00D340  1               PowerUpGfxTable:
00D340  1  D8 DA DB FF        .byte $d8, $da, $db, $ff ;regular mushroom
00D344  1  D6 D6 D9 D9        .byte $d6, $d6, $d9, $d9 ;fire flower
00D348  1  8D 8D E4 E4        .byte $8d, $8d, $e4, $e4 ;star
00D34C  1  D8 DA DB FF        .byte $d8, $da, $db, $ff ;1-up mushroom
00D350  1  D8 DA DB FF        .byte $d8, $da, $db, $ff ;poison mushroom
00D354  1               
00D354  1               PowerUpAttributes:
00D354  1  02 01 02 01        .byte $02, $01, $02, $01, $03
00D358  1  03           
00D359  1               
00D359  1               DrawPowerUp:
00D359  1  AC EA 06           ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
00D35C  1  AD B9 03           lda Enemy_Rel_YPos         ;get relative vertical coordinate
00D35F  1  18                 clc
00D360  1  69 08              adc #$08                   ;add eight pixels
00D362  1  85 02              sta $02                    ;store result here
00D364  1  AD AE 03           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00D367  1  85 05              sta $05                    ;store here
00D369  1  A6 39              ldx PowerUpType            ;get power-up type
00D36B  1  BD 54 D3           lda PowerUpAttributes,x    ;get attribute data for power-up type
00D36E  1  0D CA 03           ora Enemy_SprAttrib+5      ;add background priority bit if set
00D371  1  85 04              sta $04                    ;store attributes here
00D373  1  8A                 txa
00D374  1  48                 pha                        ;save power-up type to the stack
00D375  1  0A                 asl
00D376  1  0A                 asl                        ;multiply by four to get proper offset
00D377  1  AA                 tax                        ;use as X
00D378  1  A9 01              lda #$01
00D37A  1  85 07              sta $07                    ;set counter here to draw two rows of sprite object
00D37C  1  85 03              sta $03                    ;init d1 of flip control
00D37E  1               
00D37E  1               PUpDrawLoop:
00D37E  1  BD 40 D3             lda PowerUpGfxTable,x      ;load left tile of power-up object
00D381  1  85 00                sta $00
00D383  1  BD 41 D3             lda PowerUpGfxTable+1,x    ;load right tile
00D386  1  20 72 D8             jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
00D389  1  C6 07                dec $07                    ;decrement counter
00D38B  1  10 F1                bpl PUpDrawLoop            ;branch until two rows are drawn
00D38D  1  AC EA 06             ldy Enemy_SprDataOffset+5  ;get sprite data offset again
00D390  1  68                   pla                        ;pull saved power-up type from the stack
00D391  1  F0 33                beq PUpOfs                 ;if regular mushroom, 1-up mushroom
00D393  1  C9 03                cmp #$03                   ;or poison mushroom, branch
00D395  1  F0 2F                beq PUpOfs                 ;do not change colors or flip them
00D397  1  C9 04                cmp #$04
00D399  1  F0 2B                beq PUpOfs
00D39B  1  85 00                sta $00                    ;store power-up type here now
00D39D  1  A5 09                lda FrameCounter           ;get frame counter
00D39F  1  4A                   lsr                        ;divide by 2 to change colors every two frames
00D3A0  1  29 03                and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
00D3A2  1  0D CA 03             ora Enemy_SprAttrib+5      ;add background priority bit if any set
00D3A5  1  99 02 02             sta Sprite_Attributes,y    ;set as new palette bits for top left and
00D3A8  1  99 06 02             sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
00D3AB  1  A6 00                ldx $00
00D3AD  1  CA                   dex                        ;check power-up type for fire flower
00D3AE  1  F0 06                beq FlipPUpRightSide       ;if found, skip this part
00D3B0  1  99 0A 02             sta Sprite_Attributes+8,y  ;otherwise set new palette bits for bottom left
00D3B3  1  99 0E 02             sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
00D3B6  1               
00D3B6  1               FlipPUpRightSide:
00D3B6  1  B9 06 02             lda Sprite_Attributes+4,y
00D3B9  1  09 40                ora #%01000000             ;set horizontal flip bit for top right sprite
00D3BB  1  99 06 02             sta Sprite_Attributes+4,y
00D3BE  1  B9 0E 02             lda Sprite_Attributes+12,y
00D3C1  1  09 40                ora #%01000000             ;set horizontal flip bit for bottom right sprite
00D3C3  1  99 0E 02             sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
00D3C6  1  4C 24 D8     PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
00D3C9  1               
00D3C9  1               
00D3C9  1               ;-------------------------------------------------------------------------------------
00D3C9  1               ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
00D3C9  1               ;$02 - used to store Y position
00D3C9  1               ;$03 - used to store moving direction, used to flip enemies horizontally
00D3C9  1               ;$04 - used to store enemy's sprite attributes
00D3C9  1               ;$05 - used to store X position
00D3C9  1               ;$eb - used to hold sprite data offset
00D3C9  1               ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
00D3C9  1               ;$ed - used to hold enemy state from buffer
00D3C9  1               ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
00D3C9  1               
00D3C9  1               ;tiles arranged in top left, right, middle left, right, bottom left, right order
00D3C9  1               ;most enemies use more than one frame, thus have more than 6 tiles
00D3C9  1               EnemyGraphicsTable:
00D3C9  1  FC FC AA AB        .byte $fc, $fc, $aa, $ab, $ac, $ad ;buzzy beetle
00D3CD  1  AC AD        
00D3CF  1  FC FC AE AF        .byte $fc, $fc, $ae, $af, $b0, $b1
00D3D3  1  B0 B1        
00D3D5  1  FC A5 A6 A7        .byte $fc, $a5, $a6, $a7, $a8, $a9 ;koopa troopa
00D3D9  1  A8 A9        
00D3DB  1  FC A0 A1 A2        .byte $fc, $a0, $a1, $a2, $a3, $a4
00D3DF  1  A3 A4        
00D3E1  1  69 A5 6A A7        .byte $69, $a5, $6a, $a7, $a8, $a9 ;koopa paratroopa
00D3E5  1  A8 A9        
00D3E7  1  6B A0 6C A2        .byte $6b, $a0, $6c, $a2, $a3, $a4
00D3EB  1  A3 A4        
00D3ED  1  FC FC 96 97        .byte $fc, $fc, $96, $97, $98, $99 ;spiny
00D3F1  1  98 99        
00D3F3  1  FC FC 9A 9B        .byte $fc, $fc, $9a, $9b, $9c, $9d
00D3F7  1  9C 9D        
00D3F9  1  FC FC 8F 8E        .byte $fc, $fc, $8f, $8e, $8e, $8f ;spiny egg
00D3FD  1  8E 8F        
00D3FF  1  FC FC 95 94        .byte $fc, $fc, $95, $94, $94, $95
00D403  1  94 95        
00D405  1  FC FC DC DC        .byte $fc, $fc, $dc, $dc, $df, $df ;bloober
00D409  1  DF DF        
00D40B  1  DC DC DD DD        .byte $dc, $dc, $dd, $dd, $de, $de
00D40F  1  DE DE        
00D411  1  FC FC B2 B3        .byte $fc, $fc, $b2, $b3, $b4, $b5 ;cheep-cheep
00D415  1  B4 B5        
00D417  1  FC FC B6 B3        .byte $fc, $fc, $b6, $b3, $b7, $b5
00D41B  1  B7 B5        
00D41D  1  FC FC 70 71        .byte $fc, $fc, $70, $71, $72, $73 ;goomba
00D421  1  72 73        
00D423  1  FC FC 6E 6E        .byte $fc, $fc, $6e, $6e, $6f, $6f ;koopa shell (upside-down)
00D427  1  6F 6F        
00D429  1  FC FC 6D 6D        .byte $fc, $fc, $6d, $6d, $6f, $6f
00D42D  1  6F 6F        
00D42F  1  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6e, $6e ;koopa shell
00D433  1  6E 6E        
00D435  1  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6d, $6d
00D439  1  6D 6D        
00D43B  1  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5 ;buzzy beetle shell (upside-down)
00D43F  1  F5 F5        
00D441  1  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5
00D445  1  F5 F5        
00D447  1  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4 ;buzzy beetle
00D44B  1  F4 F4        
00D44D  1  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4
00D451  1  F4 F4        
00D453  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $ef, $ef ;defeated goomba
00D457  1  EF EF        
00D459  1  B9 B8 BB BA        .byte $b9, $b8, $bb, $ba, $bc, $bc ;lakitu
00D45D  1  BC BC        
00D45F  1  FC FC BD BD        .byte $fc, $fc, $bd, $bd, $bc, $bc
00D463  1  BC BC        
00D465  1  76 79 77 77        .byte $76, $79, $77, $77, $78, $78 ;princess/door to princess's room
00D469  1  78 78        
00D46B  1  CD CD CE CE        .byte $cd, $cd, $ce, $ce, $cf, $cf ;mushroom retainer
00D46F  1  CF CF        
00D471  1  7D 7C D1 8C        .byte $7d, $7c, $d1, $8c, $d3, $d2 ;hammer bro
00D475  1  D3 D2        
00D477  1  7D 7C 89 88        .byte $7d, $7c, $89, $88, $8b, $8a
00D47B  1  8B 8A        
00D47D  1  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $d3, $d2
00D481  1  D3 D2        
00D483  1  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $8b, $8a
00D487  1  8B 8A        
00D489  1  E5 E5 E6 E6        .byte $e5, $e5, $e6, $e6, $eb, $eb ;piranha plant
00D48D  1  EB EB        
00D48F  1  EC EC ED ED        .byte $ec, $ec, $ed, $ed, $eb, $eb
00D493  1  EB EB        
00D495  1  FC FC D0 D0        .byte $fc, $fc, $d0, $d0, $d7, $d7 ;podoboo
00D499  1  D7 D7        
00D49B  1  BF BE C1 C0        .byte $bf, $be, $c1, $c0, $c2, $fc ;bowser front
00D49F  1  C2 FC        
00D4A1  1  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $c8, $c7 ;bowser rear
00D4A5  1  C8 C7        
00D4A7  1  BF BE CA C9        .byte $bf, $be, $ca, $c9, $c2, $fc ;front frame 2
00D4AB  1  C2 FC        
00D4AD  1  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $cc, $cb ;rear frame 2
00D4B1  1  CC CB        
00D4B3  1  FC FC E8 E7        .byte $fc, $fc, $e8, $e7, $ea, $e9 ;bullet bill
00D4B7  1  EA E9        
00D4B9  1  F2 F2 F3 F3        .byte $f2, $f2, $f3, $f3, $f2, $f2 ;jumpspring
00D4BD  1  F2 F2        
00D4BF  1  F1 F1 F1 F1        .byte $f1, $f1, $f1, $f1, $fc, $fc
00D4C3  1  FC FC        
00D4C5  1  F0 F0 FC FC        .byte $f0, $f0, $fc, $fc, $fc, $fc
00D4C9  1  FC FC        
00D4CB  1               
00D4CB  1               EnemyGfxTableOffsets:
00D4CB  1  0C 0C 00 0C        .byte $0c, $0c, $00, $0c, $c0, $a8, $54, $3c
00D4CF  1  C0 A8 54 3C  
00D4D3  1  EA 18 48 48        .byte $ea, $18, $48, $48, $cc, $c0, $18, $18
00D4D7  1  CC C0 18 18  
00D4DB  1  18 90 24 FF        .byte $18, $90, $24, $ff, $48, $9c, $d2, $d8
00D4DF  1  48 9C D2 D8  
00D4E3  1  F0 F6 FC           .byte $f0, $f6, $fc
00D4E6  1               
00D4E6  1               EnemyAttributeData:
00D4E6  1  01 02 03 02        .byte $01, $02, $03, $02, $22, $01, $03, $03
00D4EA  1  22 01 03 03  
00D4EE  1  03 01 01 02        .byte $03, $01, $01, $02, $02, $20, $01, $02
00D4F2  1  02 20 01 02  
00D4F6  1  01 01 02 FF        .byte $01, $01, $02, $ff, $02, $02, $01, $01
00D4FA  1  02 02 01 01  
00D4FE  1  00 00 00           .byte $00, $00, $00
00D501  1               
00D501  1               EnemyAnimTimingBMask:
00D501  1  08 18              .byte $08, $18
00D503  1               
00D503  1               JumpspringFrameOffsets:
00D503  1  18 19 1A 19        .byte $18, $19, $1a, $19, $18
00D507  1  18           
00D508  1               
00D508  1               EnemyGfxHandler:
00D508  1  B5 CF               lda Enemy_Y_Position,x      ;get enemy object vertical position
00D50A  1  85 02               sta $02
00D50C  1  AD AE 03            lda Enemy_Rel_XPos          ;get enemy object horizontal position
00D50F  1  85 05               sta $05                     ;relative to screen
00D511  1  BC E5 06            ldy Enemy_SprDataOffset,x
00D514  1  84 EB               sty $eb                     ;get sprite data offset
00D516  1  A9 00               lda #$00
00D518  1  8D 09 01            sta VerticalFlipFlag        ;initialize vertical flip flag by default
00D51B  1  B5 46               lda Enemy_MovingDir,x
00D51D  1  85 03               sta $03                     ;get enemy object moving direction
00D51F  1  BD C5 03            lda Enemy_SprAttrib,x
00D522  1  85 04               sta $04                     ;get enemy object sprite attributes
00D524  1  B5 16               lda Enemy_ID,x
00D526  1  C9 0D               cmp #PiranhaPlant           ;is enemy object piranha plant?
00D528  1  D0 1B               bne CheckForRetainerObj     ;if not, branch
00D52A  1  A0 02               ldy #$02                    ;default data makes red piranha plants
00D52C  1  AD FB 07            lda HardWorldFlag
00D52F  1  D0 08               bne RPlnt                   ;use default data if in worlds A-D
00D531  1  AD 5F 07            lda WorldNumber
00D534  1  C9 03               cmp #$03
00D536  1  B0 01               bcs RPlnt                   ;use default data if in worlds 4-8
00D538  1  88                  dey                         ;otherwise make green piranha plant
00D539  1  84 04        RPlnt: sty $04
00D53B  1  B4 58               ldy PiranhaPlant_Y_Speed,x
00D53D  1  30 06               bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
00D53F  1  BC 8A 07            ldy EnemyFrameTimer,x
00D542  1  F0 01               beq CheckForRetainerObj     ;if timer for movement expired, branch
00D544  1  60                  rts                         ;if all conditions fail, leave
00D545  1               
00D545  1               CheckForRetainerObj:
00D545  1  B5 1E              lda Enemy_State,x           ;store enemy state
00D547  1  85 ED              sta $ed
00D549  1  29 1F              and #%00011111              ;nullify all but 5 LSB and use as Y
00D54B  1  A8                 tay
00D54C  1  B5 16              lda Enemy_ID,x              ;check for mushroom retainer/princess object
00D54E  1  C9 35              cmp #RetainerObject
00D550  1  D0 08              bne CheckForBulletBillCV    ;if not found, branch
00D552  1  A0 00              ldy #$00                    ;if found, nullify saved state in Y
00D554  1  A9 01              lda #$01                    ;set value that will not be used
00D556  1  85 03              sta $03
00D558  1  A9 15              lda #$15                    ;set value $15 as code for mushroom retainer/princess object
00D55A  1               
00D55A  1               CheckForBulletBillCV:
00D55A  1  C9 33               cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
00D55C  1  D0 13               bne CheckForJumpspring      ;if not found, branch again
00D55E  1  C6 02               dec $02                     ;decrement saved vertical position
00D560  1  A9 03               lda #$03
00D562  1  BC 8A 07            ldy EnemyFrameTimer,x       ;get timer for enemy object
00D565  1  F0 02               beq SBBAt                   ;if expired, do not set priority bit
00D567  1  09 20               ora #%00100000              ;otherwise do so
00D569  1  85 04        SBBAt: sta $04                     ;set new sprite attributes
00D56B  1  A0 00               ldy #$00                    ;nullify saved enemy state both in Y and in
00D56D  1  84 ED               sty $ed                     ;memory location here
00D56F  1  A9 08               lda #$08                    ;set specific value to unconditionally branch once
00D571  1               
00D571  1               CheckForJumpspring:
00D571  1  C9 32               cmp #JumpspringObject        ;check for jumpspring object
00D573  1  D0 1C               bne CheckForPodoboo
00D575  1  A9 02               lda #$02
00D577  1  AC 5F 07            ldy WorldNumber              ;if the world number is not 2, 3 or 7
00D57A  1  C0 01               cpy #$01                     ;then use regular attributes for jumpsprings
00D57C  1  F0 08               beq GrnJS                    ;which will paint them red
00D57E  1  C0 02               cpy #$02
00D580  1  F0 04               beq GrnJS                    ;otherwise use alternate attributes
00D582  1  C0 06               cpy #$06                     ;to get the green superhigh jumpsprings
00D584  1  D0 01               bne RedJS
00D586  1  4A           GrnJS: lsr
00D587  1  85 04        RedJS: sta $04
00D589  1  A0 03               ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
00D58B  1  AE 0E 07            ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
00D58E  1  BD 03 D5            lda JumpspringFrameOffsets,x ;load data using frame number as offset
00D591  1               
00D591  1               CheckForPodoboo:
00D591  1  85 EF              sta $ef                 ;store saved enemy object value here
00D593  1  84 EC              sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
00D595  1  A6 08              ldx ObjectOffset        ;get enemy object offset
00D597  1  C9 0C              cmp #$0c                ;check for podoboo object
00D599  1  D0 07              bne CheckBowserGfxFlag  ;branch if not found
00D59B  1  B5 A0              lda Enemy_Y_Speed,x     ;if moving upwards, branch
00D59D  1  30 03              bmi CheckBowserGfxFlag
00D59F  1  EE 09 01           inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
00D5A2  1               
00D5A2  1               CheckBowserGfxFlag:
00D5A2  1  AD 6A 03                  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
00D5A5  1  F0 09                     beq CheckForGoomba
00D5A7  1  A0 16                     ldy #$16            ;if set to 1, draw bowser's front
00D5A9  1  C9 01                     cmp #$01
00D5AB  1  F0 01                     beq SBwsrGfxOfs
00D5AD  1  C8                        iny                 ;otherwise draw bowser's rear
00D5AE  1  84 EF        SBwsrGfxOfs: sty $ef
00D5B0  1               
00D5B0  1               CheckForGoomba:
00D5B0  1  A4 EF                  ldy $ef               ;check value for goomba object
00D5B2  1  C0 06                  cpy #Goomba
00D5B4  1  D0 1D                  bne CheckBowserFront  ;branch if not found
00D5B6  1  B5 1E                  lda Enemy_State,x
00D5B8  1  C9 02                  cmp #$02              ;check for defeated state
00D5BA  1  90 04                  bcc GmbaAnim          ;if not defeated, go ahead and animate
00D5BC  1  A2 04                  ldx #$04              ;if defeated, write new value here
00D5BE  1  86 EC                  stx $ec
00D5C0  1  29 20        GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
00D5C2  1  0D 47 07               ora TimerControl      ;or timer disable flag set
00D5C5  1  D0 0C                  bne CheckBowserFront  ;if either condition true, do not animate goomba
00D5C7  1  A5 09                  lda FrameCounter
00D5C9  1  29 08                  and #%00001000        ;check for every eighth frame
00D5CB  1  D0 06                  bne CheckBowserFront
00D5CD  1  A5 03                  lda $03
00D5CF  1  49 03                  eor #%00000011        ;invert bits to flip horizontally every eight frames
00D5D1  1  85 03                  sta $03               ;leave alone otherwise
00D5D3  1               
00D5D3  1               CheckBowserFront:
00D5D3  1  B9 E6 D4                  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
00D5D6  1  05 04                     ora $04                     ;as offset, and add to bits already loaded
00D5D8  1  85 04                     sta $04
00D5DA  1  B9 CB D4                  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
00D5DD  1  AA                        tax                         ;save as X
00D5DE  1  A4 EC                     ldy $ec                     ;get previously saved value
00D5E0  1  AD 6A 03                  lda BowserGfxFlag
00D5E3  1  F0 30                     beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
00D5E5  1  C9 01                     cmp #$01
00D5E7  1  D0 13                     bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
00D5E9  1  AD 63 03                  lda BowserBodyControls      ;check bowser's body control bits
00D5EC  1  10 02                     bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
00D5EE  1  A2 DE                     ldx #$de                    ;otherwise load offset for second frame
00D5F0  1  A5 ED        ChkFrontSte: lda $ed                     ;check saved enemy state
00D5F2  1  29 20                     and #%00100000              ;if bowser not defeated, do not set flag
00D5F4  1  F0 03                     beq DrawBowser
00D5F6  1               
00D5F6  1               FlipBowserOver:
00D5F6  1  8E 09 01           stx VerticalFlipFlag  ;set vertical flip flag to nonzero
00D5F9  1               
00D5F9  1               DrawBowser:
00D5F9  1  4C 01 D7           jmp DrawEnemyObject   ;draw bowser's graphics now
00D5FC  1               
00D5FC  1               
00D5FC  1               CheckBowserRear:
00D5FC  1  AD 63 03                 lda BowserBodyControls  ;check bowser's body control bits
00D5FF  1  29 01                    and #$01
00D601  1  F0 02                    beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
00D603  1  A2 E4                    ldx #$e4                ;otherwise load offset for second frame
00D605  1  A5 ED        ChkRearSte: lda $ed                 ;check saved enemy state
00D607  1  29 20                    and #%00100000          ;if bowser not defeated, do not set flag
00D609  1  F0 EE                    beq DrawBowser
00D60B  1  A5 02                    lda $02                 ;subtract 16 pixels from
00D60D  1  38                       sec                     ;saved vertical coordinate
00D60E  1  E9 10                    sbc #$10
00D610  1  85 02                    sta $02
00D612  1  4C F6 D5                 jmp FlipBowserOver      ;jump to set vertical flip flag
00D615  1               
00D615  1               CheckForSpiny:
00D615  1  E0 24                cpx #$24               ;check if value loaded is for spiny
00D617  1  D0 11                bne CheckForLakitu     ;if not found, branch
00D619  1  C0 05                cpy #$05               ;if enemy state set to $05, do this,
00D61B  1  D0 0A                bne NotEgg             ;otherwise branch
00D61D  1  A2 30                ldx #$30               ;set to spiny egg offset
00D61F  1  A9 02                lda #$02
00D621  1  85 03                sta $03                ;set enemy direction to reverse sprites horizontally
00D623  1  A9 05                lda #$05
00D625  1  85 EC                sta $ec                ;set enemy state
00D627  1  4C 7A D6     NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
00D62A  1               
00D62A  1               CheckForLakitu:
00D62A  1  E0 90                cpx #$90                  ;check value for lakitu's offset loaded
00D62C  1  D0 12                bne CheckUpsideDownShell  ;branch if not loaded
00D62E  1  A5 ED                lda $ed
00D630  1  29 20                and #%00100000            ;check for d5 set in enemy state
00D632  1  D0 09                bne NoLAFr                ;branch if set
00D634  1  AD 8F 07             lda FrenzyEnemyTimer
00D637  1  C9 10                cmp #$10                  ;check timer to see if we've reached a certain range
00D639  1  B0 02                bcs NoLAFr                ;branch if not
00D63B  1  A2 96                ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
00D63D  1  4C E7 D6     NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
00D640  1               
00D640  1               CheckUpsideDownShell:
00D640  1  A5 EF              lda $ef                    ;check for enemy object => $04
00D642  1  C9 04              cmp #$04
00D644  1  B0 10              bcs CheckRightSideUpShell  ;branch if true
00D646  1  C0 02              cpy #$02
00D648  1  90 0C              bcc CheckRightSideUpShell  ;branch if enemy state < $02
00D64A  1  A2 5A              ldx #$5a                   ;set for upside-down koopa shell by default
00D64C  1  A4 EF              ldy $ef
00D64E  1  C0 02              cpy #BuzzyBeetle           ;check for buzzy beetle object
00D650  1  D0 04              bne CheckRightSideUpShell
00D652  1  A2 7E              ldx #$7e                   ;set for upside-down buzzy beetle shell if found
00D654  1  E6 02              inc $02                    ;increment vertical position by one pixel
00D656  1               
00D656  1               CheckRightSideUpShell:
00D656  1  A5 EC              lda $ec                ;check for value set here
00D658  1  C9 04              cmp #$04               ;if enemy state < $02, do not change to shell, if
00D65A  1  D0 1E              bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
00D65C  1  A2 72              ldx #$72               ;set right-side up buzzy beetle shell by default
00D65E  1  E6 02              inc $02                ;increment saved vertical position by one pixel
00D660  1  A4 EF              ldy $ef
00D662  1  C0 02              cpy #BuzzyBeetle       ;check for buzzy beetle object
00D664  1  F0 04              beq CheckForDefdGoomba ;branch if found
00D666  1  A2 66              ldx #$66               ;change to right-side up koopa shell if not found
00D668  1  E6 02              inc $02                ;and increment saved vertical position again
00D66A  1               
00D66A  1               CheckForDefdGoomba:
00D66A  1  C0 06              cpy #Goomba            ;check for goomba object (necessary if previously
00D66C  1  D0 0C              bne CheckForHammerBro  ;failed buzzy beetle object test)
00D66E  1  A2 54              ldx #$54               ;load for regular goomba
00D670  1  A5 ED              lda $ed                ;note that this only gets performed if enemy state => $02
00D672  1  29 20              and #%00100000         ;check saved enemy state for d5 set
00D674  1  D0 04              bne CheckForHammerBro  ;branch if set
00D676  1  A2 8A              ldx #$8a               ;load offset for defeated goomba
00D678  1  C6 02              dec $02                ;set different value and decrement saved vertical position
00D67A  1               
00D67A  1               CheckForHammerBro:
00D67A  1  A4 08              ldy ObjectOffset
00D67C  1  A5 EF              lda $ef                  ;check for hammer bro object
00D67E  1  C9 05              cmp #HammerBro
00D680  1  D0 0C              bne CheckForBloober      ;branch if not found
00D682  1  A5 ED              lda $ed
00D684  1  F0 24              beq CheckToAnimateEnemy  ;branch if not in normal enemy state
00D686  1  29 08              and #%00001000
00D688  1  F0 5D              beq CheckDefeatedState   ;if d3 not set, branch further away
00D68A  1  A2 B4              ldx #$b4                 ;otherwise load offset for different frame
00D68C  1  D0 1C              bne CheckToAnimateEnemy  ;unconditional branch
00D68E  1               
00D68E  1               CheckForBloober:
00D68E  1  E0 48              cpx #$48                 ;check for cheep-cheep offset loaded
00D690  1  F0 18              beq CheckToAnimateEnemy  ;branch if found
00D692  1  B9 96 07           lda EnemyIntervalTimer,y
00D695  1  C9 05              cmp #$05
00D697  1  B0 4E              bcs CheckDefeatedState   ;branch if some timer is above a certain point
00D699  1  E0 3C              cpx #$3c                 ;check for bloober offset loaded
00D69B  1  D0 0D              bne CheckToAnimateEnemy  ;branch if not found this time
00D69D  1  C9 01              cmp #$01
00D69F  1  F0 46              beq CheckDefeatedState   ;branch if timer is set to certain point
00D6A1  1  E6 02              inc $02                  ;increment saved vertical coordinate three pixels
00D6A3  1  E6 02              inc $02
00D6A5  1  E6 02              inc $02
00D6A7  1  4C D9 D6           jmp CheckAnimationStop   ;and do something else
00D6AA  1               
00D6AA  1               CheckToAnimateEnemy:
00D6AA  1  A5 EF              lda $ef                  ;check for specific enemy objects
00D6AC  1  C9 06              cmp #Goomba
00D6AE  1  F0 37              beq CheckDefeatedState   ;branch if goomba
00D6B0  1  C9 08              cmp #$08
00D6B2  1  F0 33              beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
00D6B4  1  C9 0C              cmp #Podoboo
00D6B6  1  F0 2F              beq CheckDefeatedState   ;branch if podoboo
00D6B8  1  C9 18              cmp #$18                 ;branch if => $18
00D6BA  1  B0 2B              bcs CheckDefeatedState
00D6BC  1  A0 00              ldy #$00
00D6BE  1  C9 15              cmp #$15                 ;check for mushroom retainer/princess object
00D6C0  1  D0 10              bne CheckForSecondFrame  ;which uses different code here, branch if not found
00D6C2  1  C8                 iny                      ;residual instruction
00D6C3  1  A9 03              lda #$03                 ;set state for mushroom retainer/princess object
00D6C5  1  85 EC              sta $ec
00D6C7  1  AD 5F 07           lda WorldNumber          ;are we on world 8?
00D6CA  1  C9 07              cmp #World8
00D6CC  1  B0 19              bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
00D6CE  1  A2 A2              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
00D6D0  1  D0 15              bne CheckDefeatedState   ;unconditional branch
00D6D2  1               
00D6D2  1               CheckForSecondFrame:
00D6D2  1  A5 09              lda FrameCounter            ;load frame counter
00D6D4  1  39 01 D5           and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
00D6D7  1  D0 0E              bne CheckDefeatedState      ;branch if timing is off
00D6D9  1               
00D6D9  1               CheckAnimationStop:
00D6D9  1  A5 ED              lda $ed                 ;check saved enemy state
00D6DB  1  29 A0              and #%10100000          ;for d7 or d5, or check for timers stopped
00D6DD  1  0D 47 07           ora TimerControl
00D6E0  1  D0 05              bne CheckDefeatedState  ;if either condition true, branch
00D6E2  1  8A                 txa
00D6E3  1  18                 clc
00D6E4  1  69 06              adc #$06                ;add $06 to current enemy offset
00D6E6  1  AA                 tax                     ;to animate various enemy objects
00D6E7  1               
00D6E7  1               CheckDefeatedState:
00D6E7  1  A5 EF               lda $ef               ;check for upside-down piranha plant
00D6E9  1  C9 04               cmp #$04              ;if found, branch to draw it upside-down
00D6EB  1  F0 0C               beq FlipV
00D6ED  1  A5 ED               lda $ed               ;check saved enemy state
00D6EF  1  29 20               and #%00100000        ;for d5 set
00D6F1  1  F0 0E               beq DrawEnemyObject   ;branch if not set
00D6F3  1  A5 EF               lda $ef
00D6F5  1  C9 04               cmp #$04              ;check for saved enemy object => $04
00D6F7  1  90 08               bcc DrawEnemyObject   ;branch if less
00D6F9  1  A0 01        FlipV: ldy #$01
00D6FB  1  8C 09 01            sty VerticalFlipFlag  ;set vertical flip flag
00D6FE  1  88                  dey
00D6FF  1  84 EC               sty $ec               ;init saved value here
00D701  1               
00D701  1               DrawEnemyObject:
00D701  1  A4 EB              ldy $eb                    ;load sprite data offset
00D703  1  20 6A D8           jsr DrawEnemyObjRow        ;draw six tiles of data
00D706  1  20 6A D8           jsr DrawEnemyObjRow        ;into sprite data
00D709  1  20 6A D8           jsr DrawEnemyObjRow
00D70C  1  A6 08              ldx ObjectOffset           ;get enemy object offset
00D70E  1  BC E5 06           ldy Enemy_SprDataOffset,x  ;get sprite data offset
00D711  1  A5 EF              lda $ef
00D713  1  C9 08              cmp #$08                   ;get saved enemy object and check
00D715  1  D0 03              bne CheckForVerticalFlip   ;for bullet bill, branch if not found
00D717  1               
00D717  1               SkipToOffScrChk:
00D717  1  4C 24 D8           jmp SprObjectOffscrChk     ;jump if found
00D71A  1               
00D71A  1               CheckForVerticalFlip:
00D71A  1  AD 09 01           lda VerticalFlipFlag       ;check if vertical flip flag is set here
00D71D  1  F0 41              beq CheckForESymmetry      ;branch if not
00D71F  1  B9 02 02           lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
00D722  1  09 80              ora #%10000000             ;set bit for vertical flip
00D724  1  C8                 iny
00D725  1  C8                 iny                        ;increment two bytes so that we store the vertical flip
00D726  1  20 37 D2           jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
00D729  1  88                 dey
00D72A  1  88                 dey                        ;now go back to the Y coordinate offset
00D72B  1  98                 tya
00D72C  1  AA                 tax                        ;give offset to X
00D72D  1  A5 EF              lda $ef
00D72F  1  C9 05              cmp #HammerBro             ;check saved enemy object for hammer bro
00D731  1  F0 11              beq FlipEnemyVertically
00D733  1  C9 04              cmp #UpsideDownPiranhaP    ;check saved enemy object for upside-down piranha plant
00D735  1  F0 0D              beq FlipEnemyVertically
00D737  1  C9 11              cmp #Lakitu                ;check saved enemy object for lakitu
00D739  1  F0 09              beq FlipEnemyVertically    ;branch for any of these objects
00D73B  1  C9 15              cmp #$15
00D73D  1  B0 05              bcs FlipEnemyVertically    ;also branch if enemy object => $15
00D73F  1  8A                 txa
00D740  1  18                 clc
00D741  1  69 08              adc #$08                   ;if not selected objects or => $15, set
00D743  1  AA                 tax                        ;offset in X for next row
00D744  1               
00D744  1               FlipEnemyVertically:
00D744  1  BD 01 02           lda Sprite_Tilenumber,x     ;load first or second row tiles
00D747  1  48                 pha                         ;and save tiles to the stack
00D748  1  BD 05 02           lda Sprite_Tilenumber+4,x
00D74B  1  48                 pha
00D74C  1  B9 11 02           lda Sprite_Tilenumber+16,y  ;exchange third row tiles
00D74F  1  9D 01 02           sta Sprite_Tilenumber,x     ;with first or second row tiles
00D752  1  B9 15 02           lda Sprite_Tilenumber+20,y
00D755  1  9D 05 02           sta Sprite_Tilenumber+4,x
00D758  1  68                 pla                         ;pull first or second row tiles from stack
00D759  1  99 15 02           sta Sprite_Tilenumber+20,y  ;and save in third row
00D75C  1  68                 pla
00D75D  1  99 11 02           sta Sprite_Tilenumber+16,y
00D760  1               
00D760  1               CheckForESymmetry:
00D760  1  AD 6A 03             lda BowserGfxFlag           ;are we drawing bowser at all?
00D763  1  D0 B2                bne SkipToOffScrChk         ;branch if so
00D765  1  A5 EF                lda $ef
00D767  1  A6 EC                ldx $ec                     ;get alternate enemy state
00D769  1  C9 05                cmp #$05                    ;check for hammer bro object
00D76B  1  D0 03                bne ContES
00D76D  1  4C 24 D8             jmp SprObjectOffscrChk      ;jump if found
00D770  1  C9 07        ContES: cmp #Bloober                ;check for bloober object
00D772  1  F0 21                beq MirrorEnemyGfx
00D774  1  C9 0D                cmp #PiranhaPlant           ;check for piranha plant object
00D776  1  F0 1D                beq MirrorEnemyGfx
00D778  1  C9 04                cmp #UpsideDownPiranhaP     ;check for upside-down piranha plant object
00D77A  1  F0 19                beq MirrorEnemyGfx
00D77C  1  C9 0C                cmp #Podoboo                ;check for podoboo object
00D77E  1  F0 15                beq MirrorEnemyGfx          ;branch if either of three are found
00D780  1  C9 12                cmp #Spiny                  ;check for spiny object
00D782  1  D0 04                bne ESRtnr                  ;branch closer if not found
00D784  1  E0 05                cpx #$05                    ;check spiny's state
00D786  1  D0 48                bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
00D788  1  C9 15        ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
00D78A  1  D0 05                bne SpnySC
00D78C  1  A9 42                lda #$42                    ;set horizontal flip on bottom right sprite
00D78E  1  99 16 02             sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
00D791  1  E0 02        SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
00D793  1  90 3B                bcc CheckToMirrorLakitu
00D795  1               
00D795  1               MirrorEnemyGfx:
00D795  1  AD 6A 03             lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
00D798  1  D0 36                bne CheckToMirrorLakitu
00D79A  1  B9 02 02             lda Sprite_Attributes,y     ;load attribute bits of first sprite
00D79D  1  29 A3                and #%10100011
00D79F  1  99 02 02             sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
00D7A2  1  99 0A 02             sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
00D7A5  1  99 12 02             sta Sprite_Attributes+16,y
00D7A8  1  09 40                ora #%01000000              ;set horizontal flip
00D7AA  1  E0 05                cpx #$05                    ;check for state used by spiny's egg
00D7AC  1  D0 02                bne EggExc                  ;if alternate state not set to $05, branch
00D7AE  1  09 80                ora #%10000000              ;otherwise set vertical flip
00D7B0  1  99 06 02     EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
00D7B3  1  99 0E 02             sta Sprite_Attributes+12,y  ;of enemy object sprite data
00D7B6  1  99 16 02             sta Sprite_Attributes+20,y
00D7B9  1  E0 04                cpx #$04                    ;check alternate enemy state
00D7BB  1  D0 13                bne CheckToMirrorLakitu     ;branch if not $04
00D7BD  1  B9 0A 02             lda Sprite_Attributes+8,y   ;get second row left sprite attributes
00D7C0  1  09 80                ora #%10000000
00D7C2  1  99 0A 02             sta Sprite_Attributes+8,y   ;store bits with vertical flip in
00D7C5  1  99 12 02             sta Sprite_Attributes+16,y  ;second and third row left sprites
00D7C8  1  09 40                ora #%01000000
00D7CA  1  99 0E 02             sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
00D7CD  1  99 16 02             sta Sprite_Attributes+20,y  ;second and third row right sprites
00D7D0  1               
00D7D0  1               CheckToMirrorLakitu:
00D7D0  1  A5 EF                lda $ef                     ;check for lakitu enemy object
00D7D2  1  C9 11                cmp #Lakitu
00D7D4  1  D0 36                bne CheckToMirrorJSpring    ;branch if not found
00D7D6  1  AD 09 01             lda VerticalFlipFlag
00D7D9  1  D0 21                bne NVFLak                  ;branch if vertical flip flag set
00D7DB  1  B9 12 02             lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
00D7DE  1  29 81                and #%10000001              ;in third row left sprite
00D7E0  1  99 12 02             sta Sprite_Attributes+16,y
00D7E3  1  B9 16 02             lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
00D7E6  1  09 41                ora #%01000001              ;in third row right sprite
00D7E8  1  99 16 02             sta Sprite_Attributes+20,y
00D7EB  1  AE 8F 07             ldx FrenzyEnemyTimer        ;check timer
00D7EE  1  E0 10                cpx #$10
00D7F0  1  B0 32                bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
00D7F2  1  99 0E 02             sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
00D7F5  1  29 81                and #%10000001
00D7F7  1  99 0A 02             sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
00D7FA  1  90 28                bcc SprObjectOffscrChk      ;unconditional branch
00D7FC  1  B9 02 02     NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
00D7FF  1  29 81                and #%10000001
00D801  1  99 02 02             sta Sprite_Attributes,y     ;save vertical flip and palette bits
00D804  1  B9 06 02             lda Sprite_Attributes+4,y   ;get first row right sprite attributes
00D807  1  09 41                ora #%01000001              ;set horizontal flip and palette bits
00D809  1  99 06 02             sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
00D80C  1               
00D80C  1               CheckToMirrorJSpring:
00D80C  1  A5 EF              lda $ef                     ;check for jumpspring object (any frame)
00D80E  1  C9 18              cmp #$18
00D810  1  90 12              bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
00D812  1  A9 80              lda #$80
00D814  1  05 04              ora $04
00D816  1  99 0A 02           sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
00D819  1  99 12 02           sta Sprite_Attributes+16,y  ;second and third row left sprites
00D81C  1  09 40              ora #%01000000
00D81E  1  99 0E 02           sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
00D821  1  99 16 02           sta Sprite_Attributes+20,y  ;for second and third row right sprites
00D824  1               
00D824  1               SprObjectOffscrChk:
00D824  1  A6 08                 ldx ObjectOffset          ;get enemy buffer offset
00D826  1  AD D1 03              lda Enemy_OffscreenBits   ;check offscreen information
00D829  1  4A                    lsr
00D82A  1  4A                    lsr                       ;shift three times to the right
00D82B  1  4A                    lsr                       ;which puts d2 into carry
00D82C  1  48                    pha                       ;save to stack
00D82D  1  90 05                 bcc LcChk                 ;branch if not set
00D82F  1  A9 04                 lda #$04                  ;set for right column sprites
00D831  1  20 81 D8              jsr MoveESprColOffscreen  ;and move them offscreen
00D834  1  68           LcChk:   pla                       ;get from stack
00D835  1  4A                    lsr                       ;move d3 to carry
00D836  1  48                    pha                       ;save to stack
00D837  1  90 05                 bcc Row3C                 ;branch if not set
00D839  1  A9 00                 lda #$00                  ;set for left column sprites,
00D83B  1  20 81 D8              jsr MoveESprColOffscreen  ;move them offscreen
00D83E  1  68           Row3C:   pla                       ;get from stack again
00D83F  1  4A                    lsr                       ;move d5 to carry this time
00D840  1  4A                    lsr
00D841  1  48                    pha                       ;save to stack again
00D842  1  90 05                 bcc Row23C                ;branch if carry not set
00D844  1  A9 10                 lda #$10                  ;set for third row of sprites
00D846  1  20 77 D8              jsr MoveESprRowOffscreen  ;and move them offscreen
00D849  1  68           Row23C:  pla                       ;get from stack
00D84A  1  4A                    lsr                       ;move d6 into carry
00D84B  1  48                    pha                       ;save to stack
00D84C  1  90 05                 bcc AllRowC
00D84E  1  A9 08                 lda #$08                  ;set for second and third rows
00D850  1  20 77 D8              jsr MoveESprRowOffscreen  ;move them offscreen
00D853  1  68           AllRowC: pla                       ;get from stack once more
00D854  1  4A                    lsr                       ;move d7 into carry
00D855  1  90 12                 bcc ExEGHandler
00D857  1  20 77 D8              jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
00D85A  1  B5 16                 lda Enemy_ID,x
00D85C  1  C9 0C                 cmp #Podoboo              ;check enemy identifier for podoboo
00D85E  1  F0 09                 beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
00D860  1  B5 B6                 lda Enemy_Y_HighPos,x     ;check high byte of vertical position
00D862  1  C9 02                 cmp #$02                  ;if not yet past the bottom of the screen, branch
00D864  1  D0 03                 bne ExEGHandler
00D866  1  20 C9 B5              jsr EraseEnemyObject      ;what it says
00D869  1               
00D869  1               ExEGHandler:
00D869  1  60                 rts
00D86A  1               
00D86A  1               DrawEnemyObjRow:
00D86A  1  BD C9 D3           lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
00D86D  1  85 00              sta $00
00D86F  1  BD CA D3           lda EnemyGraphicsTable+1,x
00D872  1               
00D872  1               DrawOneSpriteRow:
00D872  1  85 01              sta $01
00D874  1  4C 4C DF           jmp DrawSpriteObject        ;draw them
00D877  1               
00D877  1               MoveESprRowOffscreen:
00D877  1  18                 clc                         ;add A to enemy object OAM data offset
00D878  1  7D E5 06           adc Enemy_SprDataOffset,x
00D87B  1  A8                 tay                         ;use as offset
00D87C  1  A9 F8              lda #$f8
00D87E  1  4C 43 D2           jmp DumpTwoSpr              ;move first row of sprites offscreen
00D881  1               
00D881  1               MoveESprColOffscreen:
00D881  1  18                 clc                         ;add A to enemy object OAM data offset
00D882  1  7D E5 06           adc Enemy_SprDataOffset,x
00D885  1  A8                 tay                         ;use as offset
00D886  1  20 0A D9           jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
00D889  1  99 10 02           sta Sprite_Data+16,y        ;move third row sprite in column offscreen
00D88C  1  60                 rts
00D88D  1               
00D88D  1               ;-------------------------------------------------------------------------------------
00D88D  1               ;$00-$01 - tile numbers
00D88D  1               ;$02 - relative Y position
00D88D  1               ;$03 - horizontal flip flag (not used here)
00D88D  1               ;$04 - attributes
00D88D  1               ;$05 - relative X position
00D88D  1               
00D88D  1               DefaultBlockObjTiles:
00D88D  1  85 85 86 86        .byte $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
00D891  1               
00D891  1               DrawBlock:
00D891  1  AD BC 03                lda Block_Rel_YPos            ;get relative vertical coordinate of block object
00D894  1  85 02                   sta $02                       ;store here
00D896  1  AD B1 03                lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
00D899  1  85 05                   sta $05                       ;store here
00D89B  1  A9 03                   lda #$03
00D89D  1  85 04                   sta $04                       ;set attribute byte here
00D89F  1  4A                      lsr
00D8A0  1  85 03                   sta $03                       ;set horizontal flip bit here (will not be used)
00D8A2  1  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00D8A5  1  A2 00                   ldx #$00                      ;reset X for use as offset to tile data
00D8A7  1  BD 8D D8     DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
00D8AA  1  85 00                   sta $00                       ;set here
00D8AC  1  BD 8E D8                lda DefaultBlockObjTiles+1,x  ;get right tile number
00D8AF  1  20 72 D8                jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
00D8B2  1  E0 04                   cpx #$04                      ;check incremented offset
00D8B4  1  D0 F1                   bne DBlkLoop                  ;and loop back until all four sprites are done
00D8B6  1  A6 08                   ldx ObjectOffset              ;get block object offset
00D8B8  1  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00D8BB  1  AD 4E 07                lda AreaType
00D8BE  1  C9 01                   cmp #$01                      ;check for ground level type area
00D8C0  1  F0 08                   beq ChkRep                    ;if found, branch to next part
00D8C2  1  A9 86                   lda #$86
00D8C4  1  99 01 02                sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
00D8C7  1  99 05 02                sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
00D8CA  1  BD E8 03     ChkRep:    lda Block_Metatile,x          ;check replacement metatile
00D8CD  1  C9 C5                   cmp #$c5                      ;if not used block metatile, then
00D8CF  1  D0 24                   bne BlkOffscr                 ;branch ahead to use current graphics
00D8D1  1  A9 87                   lda #$87                      ;set A for used block tile
00D8D3  1  C8                      iny                           ;increment Y to write to tile bytes
00D8D4  1  20 3D D2                jsr DumpFourSpr               ;do sub to dump into all four sprites
00D8D7  1  88                      dey                           ;return Y to original offset
00D8D8  1  A9 03                   lda #$03                      ;set palette bits
00D8DA  1  AE 4E 07                ldx AreaType
00D8DD  1  CA                      dex                           ;check for ground level type area again
00D8DE  1  F0 01                   beq SetBFlip                  ;if found, use current palette bits
00D8E0  1  4A                      lsr                           ;otherwise set to $01
00D8E1  1  A6 08        SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
00D8E3  1  99 02 02                sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
00D8E6  1  09 40                   ora #%01000000
00D8E8  1  99 06 02                sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
00D8EB  1  09 80                   ora #%10000000
00D8ED  1  99 0E 02                sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
00D8F0  1  29 83                   and #%10000011
00D8F2  1  99 0A 02                sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
00D8F5  1  AD D4 03     BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
00D8F8  1  48                      pha                           ;save to stack
00D8F9  1  29 04                   and #%00000100                ;check to see if d2 in offscreen bits are set
00D8FB  1  F0 08                   beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
00D8FD  1  A9 F8                   lda #$f8                      ;move offscreen two OAMs
00D8FF  1  99 04 02                sta Sprite_Y_Position+4,y     ;on the right side
00D902  1  99 0C 02                sta Sprite_Y_Position+12,y
00D905  1  68           PullOfsB:  pla                           ;pull offscreen bits from stack
00D906  1  29 08        ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
00D908  1  F0 08                   beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
00D90A  1               
00D90A  1               MoveColOffscreen:
00D90A  1  A9 F8                lda #$f8                   ;move offscreen two OAMs
00D90C  1  99 00 02             sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
00D90F  1  99 08 02             sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
00D912  1  60           ExDBlk: rts
00D913  1               
00D913  1               ;-------------------------------------------------------------------------------------
00D913  1               ;$00 - used to hold palette bits for attribute byte or relative X position
00D913  1               
00D913  1               DrawBrickChunks:
00D913  1  A9 02                 lda #$02                   ;set palette bits here
00D915  1  85 00                 sta $00
00D917  1  A9 75                 lda #$75                   ;set tile number for ball (something residual, likely)
00D919  1  A4 0E                 ldy GameEngineSubroutine
00D91B  1  C0 05                 cpy #$05                   ;if end-of-level routine running,
00D91D  1  F0 06                 beq DChunks                ;use palette and tile number assigned
00D91F  1  A9 03                 lda #$03                   ;otherwise set different palette bits
00D921  1  85 00                 sta $00
00D923  1  A9 84                 lda #$84                   ;and set tile number for brick chunks
00D925  1  BC EC 06     DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
00D928  1  C8                    iny                        ;increment to start with tile bytes in OAM
00D929  1  20 3D D2              jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
00D92C  1  A5 09                 lda FrameCounter           ;get frame counter
00D92E  1  0A                    asl
00D92F  1  0A                    asl
00D930  1  0A                    asl                        ;move low nybble to high
00D931  1  0A                    asl
00D932  1  29 C0                 and #$c0                   ;get what was originally d3-d2 of low nybble
00D934  1  05 00                 ora $00                    ;add palette bits
00D936  1  C8                    iny                        ;increment offset for attribute bytes
00D937  1  20 3D D2              jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
00D93A  1  88                    dey
00D93B  1  88                    dey                        ;decrement offset to Y coordinate
00D93C  1  AD BC 03              lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
00D93F  1  20 43 D2              jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
00D942  1  AD B1 03              lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
00D945  1  99 03 02              sta Sprite_X_Position,y    ;save into X coordinate of first sprite
00D948  1  BD F1 03              lda Block_Orig_XPos,x      ;get original horizontal coordinate
00D94B  1  38                    sec
00D94C  1  ED 1C 07              sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
00D94F  1  85 00                 sta $00                    ;store result as relative horizontal coordinate of original
00D951  1  38                    sec
00D952  1  ED B1 03              sbc Block_Rel_XPos         ;get difference of relative positions of original - current
00D955  1  65 00                 adc $00                    ;add original relative position to result
00D957  1  69 06                 adc #$06                   ;plus 6 pixels to position second brick chunk correctly
00D959  1  99 07 02              sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
00D95C  1  AD BD 03              lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
00D95F  1  99 08 02              sta Sprite_Y_Position+8,y
00D962  1  99 0C 02              sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
00D965  1  AD B2 03              lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
00D968  1  99 0B 02              sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
00D96B  1  A5 00                 lda $00                    ;use original relative horizontal position
00D96D  1  38                    sec
00D96E  1  ED B2 03              sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
00D971  1  65 00                 adc $00                    ;add original relative position to result
00D973  1  69 06                 adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
00D975  1  99 0F 02              sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
00D978  1  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits for block object
00D97B  1  20 06 D9              jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
00D97E  1  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits again
00D981  1  0A                    asl                        ;shift d7 into carry
00D982  1  90 05                 bcc ChnkOfs                ;if d7 not set, branch to last part
00D984  1  A9 F8                 lda #$f8
00D986  1  20 43 D2              jsr DumpTwoSpr             ;otherwise move top sprites offscreen
00D989  1  A5 00        ChnkOfs: lda $00                    ;if relative position on left side of screen,
00D98B  1  10 10                 bpl ExBCDr                 ;go ahead and leave
00D98D  1  B9 03 02              lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
00D990  1  D9 07 02              cmp Sprite_X_Position+4,y  ;to right-side X coordinate
00D993  1  90 08                 bcc ExBCDr                 ;branch to leave if less
00D995  1  A9 F8                 lda #$f8                   ;otherwise move right half of sprites offscreen
00D997  1  99 04 02              sta Sprite_Y_Position+4,y
00D99A  1  99 0C 02              sta Sprite_Y_Position+12,y
00D99D  1  60           ExBCDr:  rts                        ;leave
00D99E  1               
00D99E  1               ;-------------------------------------------------------------------------------------
00D99E  1               
00D99E  1               DrawFireball:
00D99E  1  BC F1 06           ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
00D9A1  1  AD BA 03           lda Fireball_Rel_YPos      ;get relative vertical coordinate
00D9A4  1  99 00 02           sta Sprite_Y_Position,y    ;store as sprite Y coordinate
00D9A7  1  AD AF 03           lda Fireball_Rel_XPos      ;get relative horizontal coordinate
00D9AA  1  99 03 02           sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
00D9AD  1               
00D9AD  1               DrawFirebar:
00D9AD  1  A5 09               lda FrameCounter         ;get frame counter
00D9AF  1  4A                  lsr                      ;divide by four
00D9B0  1  4A                  lsr
00D9B1  1  48                  pha                      ;save result to stack
00D9B2  1  29 01               and #$01                 ;mask out all but last bit
00D9B4  1  49 64               eor #$64                 ;set either tile $64 or $65 as fireball tile
00D9B6  1  99 01 02            sta Sprite_Tilenumber,y  ;thus tile changes every four frames
00D9B9  1  68                  pla                      ;get from stack
00D9BA  1  4A                  lsr                      ;divide by four again
00D9BB  1  4A                  lsr
00D9BC  1  A9 02               lda #$02                 ;load value $02 to set palette in attrib byte
00D9BE  1  90 02               bcc FireA                ;if last bit shifted out was not set, skip this
00D9C0  1  09 C0               ora #%11000000           ;otherwise flip both ways every eight frames
00D9C2  1  99 02 02     FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
00D9C5  1  60                  rts
00D9C6  1               
00D9C6  1               ;-------------------------------------------------------------------------------------
00D9C6  1               
00D9C6  1               ExplosionTiles:
00D9C6  1  68 67 66           .byte $68, $67, $66
00D9C9  1               
00D9C9  1               DrawExplosion_Fireball:
00D9C9  1  BC EC 06           ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
00D9CC  1  B5 24              lda Fireball_State,x     ;load fireball state
00D9CE  1  F6 24              inc Fireball_State,x     ;increment state for next frame
00D9D0  1  4A                 lsr                      ;divide by 2
00D9D1  1  29 07              and #%00000111           ;mask out all but d3-d1
00D9D3  1  C9 03              cmp #$03                 ;check to see if time to kill fireball
00D9D5  1  B0 4A              bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
00D9D7  1               
00D9D7  1               DrawExplosion_Fireworks:
00D9D7  1  AA                 tax                         ;use whatever's in A for offset
00D9D8  1  BD C6 D9           lda ExplosionTiles,x        ;get tile number using offset
00D9DB  1  C8                 iny                         ;increment Y (contains sprite data offset)
00D9DC  1  20 3D D2           jsr DumpFourSpr             ;and dump into tile number part of sprite data
00D9DF  1  88                 dey                         ;decrement Y so we have the proper offset again
00D9E0  1  A6 08              ldx ObjectOffset            ;return enemy object buffer offset to X
00D9E2  1  AD BA 03           lda Fireball_Rel_YPos       ;get relative vertical coordinate
00D9E5  1  38                 sec                         ;subtract four pixels vertically
00D9E6  1  E9 04              sbc #$04                    ;for first and third sprites
00D9E8  1  99 00 02           sta Sprite_Y_Position,y
00D9EB  1  99 08 02           sta Sprite_Y_Position+8,y
00D9EE  1  18                 clc                         ;add eight pixels vertically
00D9EF  1  69 08              adc #$08                    ;for second and fourth sprites
00D9F1  1  99 04 02           sta Sprite_Y_Position+4,y
00D9F4  1  99 0C 02           sta Sprite_Y_Position+12,y
00D9F7  1  AD AF 03           lda Fireball_Rel_XPos       ;get relative horizontal coordinate
00D9FA  1  38                 sec                         ;subtract four pixels horizontally
00D9FB  1  E9 04              sbc #$04                    ;for first and second sprites
00D9FD  1  99 03 02           sta Sprite_X_Position,y
00DA00  1  99 07 02           sta Sprite_X_Position+4,y
00DA03  1  18                 clc                         ;add eight pixels horizontally
00DA04  1  69 08              adc #$08                    ;for third and fourth sprites
00DA06  1  99 0B 02           sta Sprite_X_Position+8,y
00DA09  1  99 0F 02           sta Sprite_X_Position+12,y
00DA0C  1  A9 02              lda #$02                    ;set palette attributes for all sprites, but
00DA0E  1  99 02 02           sta Sprite_Attributes,y     ;set no flip at all for first sprite
00DA11  1  A9 82              lda #$82
00DA13  1  99 06 02           sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
00DA16  1  A9 42              lda #$42
00DA18  1  99 0A 02           sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
00DA1B  1  A9 C2              lda #$c2
00DA1D  1  99 0E 02           sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
00DA20  1  60                 rts                         ;we are done
00DA21  1               
00DA21  1               KillFireBall:
00DA21  1  A9 00              lda #$00                    ;clear fireball state to kill it
00DA23  1  95 24              sta Fireball_State,x
00DA25  1  60                 rts
00DA26  1               
00DA26  1               ;-------------------------------------------------------------------------------------
00DA26  1               
00DA26  1               DrawSmallPlatform:
00DA26  1  BC E5 06            ldy Enemy_SprDataOffset,x   ;get OAM data offset
00DA29  1  A9 5B               lda #$5b                    ;load tile number for small platforms
00DA2B  1  C8                  iny                         ;increment offset for tile numbers
00DA2C  1  20 37 D2            jsr DumpSixSpr              ;dump tile number into all six sprites
00DA2F  1  C8                  iny                         ;increment offset for attributes
00DA30  1  A9 02               lda #$02                    ;load palette controls
00DA32  1  20 37 D2            jsr DumpSixSpr              ;dump attributes into all six sprites
00DA35  1  88                  dey                         ;decrement for original offset
00DA36  1  88                  dey
00DA37  1  AD AE 03            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00DA3A  1  99 03 02            sta Sprite_X_Position,y
00DA3D  1  99 0F 02            sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
00DA40  1  18                  clc
00DA41  1  69 08               adc #$08                    ;add eight pixels
00DA43  1  99 07 02            sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
00DA46  1  99 13 02            sta Sprite_X_Position+16,y
00DA49  1  18                  clc
00DA4A  1  69 08               adc #$08                    ;add eight more pixels
00DA4C  1  99 0B 02            sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
00DA4F  1  99 17 02            sta Sprite_X_Position+20,y
00DA52  1  B5 CF               lda Enemy_Y_Position,x      ;get vertical coordinate
00DA54  1  AA                  tax
00DA55  1  48                  pha                         ;save to stack
00DA56  1  E0 20               cpx #$20                    ;if vertical coordinate below status bar,
00DA58  1  B0 02               bcs TopSP                   ;do not mess with it
00DA5A  1  A9 F8               lda #$f8                    ;otherwise move first three sprites offscreen
00DA5C  1  20 40 D2     TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
00DA5F  1  68                  pla                         ;pull from stack
00DA60  1  18                  clc
00DA61  1  69 80               adc #$80                    ;add 128 pixels
00DA63  1  AA                  tax
00DA64  1  E0 20               cpx #$20                    ;if below status bar (taking wrap into account)
00DA66  1  B0 02               bcs BotSP                   ;then do not change altered coordinate
00DA68  1  A9 F8               lda #$f8                    ;otherwise move last three sprites offscreen
00DA6A  1  99 0C 02     BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
00DA6D  1  99 10 02            sta Sprite_Y_Position+16,y  ;into Y coordinates
00DA70  1  99 14 02            sta Sprite_Y_Position+20,y
00DA73  1  AD D1 03            lda Enemy_OffscreenBits     ;get offscreen bits
00DA76  1  48                  pha                         ;save to stack
00DA77  1  29 08               and #%00001000              ;check d3
00DA79  1  F0 08               beq SOfs
00DA7B  1  A9 F8               lda #$f8                    ;if d3 was set, move first and
00DA7D  1  99 00 02            sta Sprite_Y_Position,y     ;fourth sprites offscreen
00DA80  1  99 0C 02            sta Sprite_Y_Position+12,y
00DA83  1  68           SOfs:  pla                         ;move out and back into stack
00DA84  1  48                  pha
00DA85  1  29 04               and #%00000100              ;check d2
00DA87  1  F0 08               beq SOfs2
00DA89  1  A9 F8               lda #$f8                    ;if d2 was set, move second and
00DA8B  1  99 04 02            sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
00DA8E  1  99 10 02            sta Sprite_Y_Position+16,y
00DA91  1  68           SOfs2: pla                         ;get from stack
00DA92  1  29 02               and #%00000010              ;check d1
00DA94  1  F0 08               beq ExSPl
00DA96  1  A9 F8               lda #$f8                    ;if d1 was set, move third and
00DA98  1  99 08 02            sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
00DA9B  1  99 14 02            sta Sprite_Y_Position+20,y
00DA9E  1  A6 08        ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
00DAA0  1  60                  rts
00DAA1  1               
00DAA1  1               ;-------------------------------------------------------------------------------------
00DAA1  1               
00DAA1  1               DrawBubble:
00DAA1  1  A4 B5                ldy Player_Y_HighPos        ;if player's vertical high position
00DAA3  1  88                   dey                         ;not within screen, skip all of this
00DAA4  1  D0 20                bne ExDBub
00DAA6  1  AD D3 03             lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
00DAA9  1  29 08                and #%00001000
00DAAB  1  D0 19                bne ExDBub                  ;if bit set, branch to leave
00DAAD  1  BC EE 06             ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
00DAB0  1  AD B0 03             lda Bubble_Rel_XPos         ;get relative horizontal coordinate
00DAB3  1  99 03 02             sta Sprite_X_Position,y     ;store as X coordinate here
00DAB6  1  AD BB 03             lda Bubble_Rel_YPos         ;get relative vertical coordinate
00DAB9  1  99 00 02             sta Sprite_Y_Position,y     ;store as Y coordinate here
00DABC  1  A9 74                lda #$74
00DABE  1  99 01 02             sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
00DAC1  1  A9 02                lda #$02
00DAC3  1  99 02 02             sta Sprite_Attributes,y     ;set attribute byte
00DAC6  1  60           ExDBub: rts                         ;leave
00DAC7  1               
00DAC7  1               ;-------------------------------------------------------------------------------------
00DAC7  1               ;$00 - used to store player's vertical offscreen bits
00DAC7  1               
00DAC7  1               PlayerGfxTblOffsets:
00DAC7  1  20 28 C8 18        .byte $20, $28, $c8, $18, $00, $40, $50, $58
00DACB  1  00 40 50 58  
00DACF  1  80 88 B8 78        .byte $80, $88, $b8, $78, $60, $a0, $b0, $b8
00DAD3  1  60 A0 B0 B8  
00DAD7  1               
00DAD7  1               ;tiles arranged in order, 2 tiles per row, top to bottom
00DAD7  1               
00DAD7  1               PlayerGraphicsTable:
00DAD7  1               ;big player table
00DAD7  1  00 01 02 03        .byte $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
00DADB  1  04 05 06 07  
00DADF  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
00DAE3  1  0C 0D 0E 0F  
00DAE7  1  10 11 12 13        .byte $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
00DAEB  1  14 15 16 17  
00DAEF  1  18 19 1A 1B        .byte $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
00DAF3  1  1C 1D 1E 1F  
00DAF7  1  20 21 22 23        .byte $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
00DAFB  1  24 25 26 27  
00DAFF  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
00DB03  1  2A 2B 2C 2D  
00DB07  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
00DB0B  1  0C 30 2C 2D  
00DB0F  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
00DB13  1  2E 2F 2C 2D  
00DB17  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
00DB1B  1  2A 2B 5C 5D  
00DB1F  1  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
00DB23  1  0C 0D 5E 5F  
00DB27  1  FC FC 08 09        .byte $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
00DB2B  1  58 59 5A 5A  
00DB2F  1  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
00DB33  1  2A 2B 0E 0F  
00DB37  1               
00DB37  1               ;small player table
00DB37  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
00DB3B  1  32 33 34 35  
00DB3F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
00DB43  1  36 37 38 39  
00DB47  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
00DB4B  1  3A 37 3B 3C  
00DB4F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
00DB53  1  3D 3E 3F 40  
00DB57  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
00DB5B  1  32 41 42 43  
00DB5F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
00DB63  1  32 33 44 45  
00DB67  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
00DB6B  1  32 33 44 47  
00DB6F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
00DB73  1  32 33 48 49  
00DB77  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
00DB7B  1  32 33 90 91  
00DB7F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
00DB83  1  3A 37 92 93  
00DB87  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
00DB8B  1  9E 9E 9F 9F  
00DB8F  1               
00DB8F  1               ;used by both player sizes
00DB8F  1  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
00DB93  1  3A 37 4F 4F  
00DB97  1  FC FC 00 01        .byte $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
00DB9B  1  4C 4D 4E 4E  
00DB9F  1  00 01 4C 4D        .byte $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
00DBA3  1  4A 4A 4B 4B  
00DBA7  1               
00DBA7  1               SwimKickTileNum:
00DBA7  1  31 46              .byte $31, $46
00DBA9  1               
00DBA9  1               PlayerGfxHandler:
00DBA9  1  AD 9E 07             lda InjuryTimer             ;if player's injured invincibility timer
00DBAC  1  F0 05                beq CntPl                   ;not set, skip checkpoint and continue code
00DBAE  1  A5 09                lda FrameCounter
00DBB0  1  4A                   lsr                         ;otherwise check frame counter and branch
00DBB1  1  B0 40                bcs ExPGH                   ;to leave on every other frame (when d0 is set)
00DBB3  1  A5 0E        CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
00DBB5  1  C9 0B                cmp #$0b                    ;branch ahead to some other part
00DBB7  1  F0 47                beq PlayerKilled
00DBB9  1  AD 0B 07             lda PlayerChangeSizeFlag    ;if grow/shrink flag set
00DBBC  1  D0 3C                bne DoChangeSize            ;then branch to some other code
00DBBE  1  AC 04 07             ldy SwimmingFlag            ;if swimming flag set, branch to
00DBC1  1  F0 31                beq FindPlayerAction        ;different part, do not return
00DBC3  1  A5 1D                lda Player_State
00DBC5  1  C9 00                cmp #$00                    ;if player status normal,
00DBC7  1  F0 2B                beq FindPlayerAction        ;branch and do not return
00DBC9  1  20 F4 DB             jsr FindPlayerAction        ;otherwise jump and return
00DBCC  1  A5 09                lda FrameCounter
00DBCE  1  29 04                and #%00000100              ;check frame counter for d2 set (8 frames every
00DBD0  1  D0 21                bne ExPGH                   ;eighth frame), and branch if set to leave
00DBD2  1  AA                   tax                         ;initialize X to zero
00DBD3  1  AC E4 06             ldy Player_SprDataOffset    ;get player sprite data offset
00DBD6  1  A5 33                lda PlayerFacingDir         ;get player's facing direction
00DBD8  1  4A                   lsr
00DBD9  1  B0 04                bcs SwimKT                  ;if player facing to the right, use current offset
00DBDB  1  C8                   iny
00DBDC  1  C8                   iny                         ;otherwise move to next OAM data
00DBDD  1  C8                   iny
00DBDE  1  C8                   iny
00DBDF  1  AD 54 07     SwimKT: lda PlayerSize              ;check player's size
00DBE2  1  F0 09                beq BigKTS                  ;if big, use first tile
00DBE4  1  B9 19 02             lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
00DBE7  1  CD 75 DB             cmp SwimTileRepOffset       ;against tile number in player graphics table
00DBEA  1  F0 07                beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
00DBEC  1  E8                   inx                         ;otherwise increment X for second tile
00DBED  1  BD A7 DB     BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
00DBF0  1  99 19 02             sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
00DBF3  1  60           ExPGH:  rts                         ;then leave
00DBF4  1               
00DBF4  1               FindPlayerAction:
00DBF4  1  20 AC DC           jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
00DBF7  1  4C 05 DC           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00DBFA  1               
00DBFA  1               DoChangeSize:
00DBFA  1  20 7A DD           jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
00DBFD  1  4C 05 DC           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00DC00  1               
00DC00  1               PlayerKilled:
00DC00  1  A0 0E              ldy #$0e                      ;load offset for player killed
00DC02  1  B9 C7 DA           lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00DC05  1               
00DC05  1               PlayerGfxProcessing:
00DC05  1  8D D5 06            sta PlayerGfxOffset           ;store offset to graphics table here
00DC08  1  A9 04               lda #$04
00DC0A  1  20 7E DC            jsr RenderPlayerSub           ;draw player based on offset loaded
00DC0D  1  20 B3 DD            jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
00DC10  1  AD 11 07            lda FireballThrowingTimer
00DC13  1  F0 25               beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
00DC15  1  A0 00               ldy #$00                      ;set value to initialize by default
00DC17  1  AD 81 07            lda PlayerAnimTimer           ;get animation frame timer
00DC1A  1  CD 11 07            cmp FireballThrowingTimer     ;compare to fireball throw timer
00DC1D  1  8C 11 07            sty FireballThrowingTimer     ;initialize fireball throw timer
00DC20  1  B0 18               bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
00DC22  1  8D 11 07            sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
00DC25  1  A0 07               ldy #$07                      ;load offset for throwing
00DC27  1  B9 C7 DA            lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00DC2A  1  8D D5 06            sta PlayerGfxOffset           ;store it for use later
00DC2D  1  A0 04               ldy #$04                      ;set to update four sprite rows by default
00DC2F  1  A5 57               lda Player_X_Speed
00DC31  1  05 0C               ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
00DC33  1  F0 01               beq SUpdR                     ;if no speed or button press, branch using set value in Y
00DC35  1  88                  dey                           ;otherwise set to update only three sprite rows
00DC36  1  98           SUpdR: tya                           ;save in A for use
00DC37  1  20 7E DC            jsr RenderPlayerSub           ;in sub, draw player object again
00DC3A  1               
00DC3A  1               PlayerOffscreenChk:
00DC3A  1  AD D0 03                lda Player_OffscreenBits      ;get player's offscreen bits
00DC3D  1  4A                      lsr
00DC3E  1  4A                      lsr                           ;move vertical bits to low nybble
00DC3F  1  4A                      lsr
00DC40  1  4A                      lsr
00DC41  1  85 00                   sta $00                       ;store here
00DC43  1  A2 03                   ldx #$03                      ;check all four rows of player sprites
00DC45  1  AD E4 06                lda Player_SprDataOffset      ;get player's sprite data offset
00DC48  1  18                      clc
00DC49  1  69 18                   adc #$18                      ;add 24 bytes to start at bottom row
00DC4B  1  A8                      tay                           ;set as offset here
00DC4C  1  A9 F8        PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
00DC4E  1  46 00                   lsr $00                       ;shift bit into carry
00DC50  1  90 03                   bcc NPROffscr                 ;if bit not set, skip, do not move sprites
00DC52  1  20 43 D2                jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
00DC55  1  98           NPROffscr: tya
00DC56  1  38                      sec                           ;subtract eight bytes to do
00DC57  1  E9 08                   sbc #$08                      ;next row up
00DC59  1  A8                      tay
00DC5A  1  CA                      dex                           ;decrement row counter
00DC5B  1  10 EF                   bpl PROfsLoop                 ;do this until all sprite rows are checked
00DC5D  1  60                      rts                           ;then we are done!
00DC5E  1               
00DC5E  1               IntermediatePlayerData:
00DC5E  1  58 01 00 60          .byte $58, $01, $00, $60, $ff, $04
00DC62  1  FF 04        
00DC64  1               
00DC64  1               DrawPlayer_Intermediate:
00DC64  1  A2 05                  ldx #$05                       ;store data into zero page memory
00DC66  1  BD 5E DC     PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
00DC69  1  95 02                  sta $02,x                      ;appears on world/lives display
00DC6B  1  CA                     dex
00DC6C  1  10 F8                  bpl PIntLoop                   ;do this until all data is loaded
00DC6E  1  A2 B8                  ldx #$b8                       ;load offset for small standing
00DC70  1  A0 04                  ldy #$04                       ;load sprite data offset
00DC72  1  20 9C DC               jsr DrawPlayerLoop             ;draw player accordingly
00DC75  1  AD 26 02               lda Sprite_Attributes+36       ;get empty sprite attributes
00DC78  1  09 40                  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
00DC7A  1  8D 22 02               sta Sprite_Attributes+32       ;store and leave
00DC7D  1  60                     rts
00DC7E  1               
00DC7E  1               ;-------------------------------------------------------------------------------------
00DC7E  1               ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
00DC7E  1               ;$02 - vertical position
00DC7E  1               ;$03 - facing direction, used as horizontal flip control
00DC7E  1               ;$04 - attributes
00DC7E  1               ;$05 - horizontal position
00DC7E  1               ;$07 - number of rows to draw
00DC7E  1               ;these also used in IntermediatePlayerData
00DC7E  1               
00DC7E  1               RenderPlayerSub:
00DC7E  1  85 07                sta $07                      ;store number of rows of sprites to draw
00DC80  1  AD AD 03             lda Player_Rel_XPos
00DC83  1  8D 55 07             sta Player_Pos_ForScroll     ;store player's relative horizontal position
00DC86  1  85 05                sta $05                      ;store it here also
00DC88  1  AD B8 03             lda Player_Rel_YPos
00DC8B  1  85 02                sta $02                      ;store player's vertical position
00DC8D  1  A5 33                lda PlayerFacingDir
00DC8F  1  85 03                sta $03                      ;store player's facing direction
00DC91  1  AD C4 03             lda Player_SprAttrib
00DC94  1  85 04                sta $04                      ;store player's sprite attributes
00DC96  1  AE D5 06             ldx PlayerGfxOffset          ;load graphics table offset
00DC99  1  AC E4 06             ldy Player_SprDataOffset     ;get player's sprite data offset
00DC9C  1               
00DC9C  1               DrawPlayerLoop:
00DC9C  1  BD D7 DA             lda PlayerGraphicsTable,x    ;load player's left side
00DC9F  1  85 00                sta $00
00DCA1  1  BD D8 DA             lda PlayerGraphicsTable+1,x  ;now load right side
00DCA4  1  20 72 D8             jsr DrawOneSpriteRow
00DCA7  1  C6 07                dec $07                      ;decrement rows of sprites to draw
00DCA9  1  D0 F1                bne DrawPlayerLoop           ;do this until all rows are drawn
00DCAB  1  60                   rts
00DCAC  1               
00DCAC  1               ProcessPlayerAction:
00DCAC  1  A5 1D                lda Player_State      ;get player's state
00DCAE  1  C9 03                cmp #$03
00DCB0  1  F0 5C                beq ActionClimbing    ;if climbing, branch here
00DCB2  1  C9 02                cmp #$02
00DCB4  1  F0 48                beq ActionFalling     ;if falling, branch here
00DCB6  1  C9 01                cmp #$01
00DCB8  1  D0 11                bne ProcOnGroundActs  ;if not jumping, branch here
00DCBA  1  AD 04 07             lda SwimmingFlag
00DCBD  1  D0 5B                bne ActionSwimming    ;if swimming flag set, branch elsewhere
00DCBF  1  A0 06                ldy #$06              ;load offset for crouching
00DCC1  1  AD 14 07             lda CrouchingFlag     ;get crouching flag
00DCC4  1  D0 2C                bne NonAnimatedActs   ;if set, branch to get offset for graphics table
00DCC6  1  A0 00                ldy #$00              ;otherwise load offset for jumping
00DCC8  1  4C F2 DC             jmp NonAnimatedActs   ;go to get offset to graphics table
00DCCB  1               
00DCCB  1               ProcOnGroundActs:
00DCCB  1  A0 06                 ldy #$06                   ;load offset for crouching
00DCCD  1  AD 14 07              lda CrouchingFlag          ;get crouching flag
00DCD0  1  D0 20                 bne NonAnimatedActs        ;if set, branch to get offset for graphics table
00DCD2  1  A0 02                 ldy #$02                   ;load offset for standing
00DCD4  1  A5 57                 lda Player_X_Speed         ;check player's horizontal speed
00DCD6  1  05 0C                 ora Left_Right_Buttons     ;and left/right controller bits
00DCD8  1  F0 18                 beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
00DCDA  1  AD 00 07              lda Player_XSpeedAbsolute  ;load walking/running speed
00DCDD  1  C9 09                 cmp #$09
00DCDF  1  90 25                 bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
00DCE1  1  A5 45                 lda Player_MovingDir       ;otherwise check to see if moving direction
00DCE3  1  25 33                 and PlayerFacingDir        ;and facing direction are the same
00DCE5  1  D0 1F                 bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
00DCE7  1  A5 0E                 lda GameEngineSubroutine
00DCE9  1  C9 09                 cmp #$09                   ;if running the change size, fire flower, injure
00DCEB  1  B0 04                 bcs NoSkidS                ;or death game engine subroutines, skip this
00DCED  1  A9 80                 lda #$80                   ;otherwise play skid sound
00DCEF  1  85 FD                 sta NoiseSoundQueue
00DCF1  1  C8           NoSkidS: iny                        ;increment to skid offset ($03)
00DCF2  1               
00DCF2  1               NonAnimatedActs:
00DCF2  1  20 5B DD             jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
00DCF5  1  A9 00                lda #$00
00DCF7  1  8D 0D 07             sta PlayerAnimCtrl         ;initialize animation frame control
00DCFA  1  B9 C7 DA             lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
00DCFD  1  60                   rts
00DCFE  1               
00DCFE  1               ActionFalling:
00DCFE  1  A0 04                ldy #$04                  ;load offset for walking/running
00DD00  1  20 5B DD             jsr GetGfxOffsetAdder     ;get offset to graphics table
00DD03  1  4C 2C DD             jmp GetCurrentAnimOffset  ;execute instructions for falling state
00DD06  1               
00DD06  1               ActionWalkRun:
00DD06  1  A0 04                ldy #$04               ;load offset for walking/running
00DD08  1  20 5B DD             jsr GetGfxOffsetAdder  ;get offset to graphics table
00DD0B  1  4C 32 DD             jmp FourFrameExtent    ;execute instructions for normal state
00DD0E  1               
00DD0E  1               ActionClimbing:
00DD0E  1  A0 05                ldy #$05               ;load offset for climbing
00DD10  1  A5 9F                lda Player_Y_Speed     ;check player's vertical speed
00DD12  1  F0 DE                beq NonAnimatedActs    ;if no speed, branch, use offset as-is
00DD14  1  20 5B DD             jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
00DD17  1  4C 37 DD             jmp ThreeFrameExtent   ;then skip ahead to more code
00DD1A  1               
00DD1A  1               ActionSwimming:
00DD1A  1  A0 01                ldy #$01               ;load offset for swimming
00DD1C  1  20 5B DD             jsr GetGfxOffsetAdder
00DD1F  1  AD 82 07             lda JumpSwimTimer      ;check jump/swim timer
00DD22  1  0D 0D 07             ora PlayerAnimCtrl     ;and animation frame control
00DD25  1  D0 0B                bne FourFrameExtent    ;if any one of these set, branch ahead
00DD27  1  A5 0A                lda A_B_Buttons
00DD29  1  0A                   asl                    ;check for A button pressed
00DD2A  1  B0 06                bcs FourFrameExtent    ;branch to same place if A button pressed
00DD2C  1               
00DD2C  1               GetCurrentAnimOffset:
00DD2C  1  AD 0D 07             lda PlayerAnimCtrl         ;get animation frame control
00DD2F  1  4C 9A DD             jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
00DD32  1               
00DD32  1               FourFrameExtent:
00DD32  1  A9 03                lda #$03              ;load upper extent for frame control
00DD34  1  4C 39 DD             jmp AnimationControl  ;jump to get offset and animate player object
00DD37  1               
00DD37  1               ThreeFrameExtent:
00DD37  1  A9 02                lda #$02              ;load upper extent for frame control for climbing
00DD39  1               
00DD39  1               AnimationControl:
00DD39  1  85 00                  sta $00                   ;store upper extent here
00DD3B  1  20 2C DD               jsr GetCurrentAnimOffset  ;get proper offset to graphics table
00DD3E  1  48                     pha                       ;save offset to stack
00DD3F  1  AD 81 07               lda PlayerAnimTimer       ;load animation frame timer
00DD42  1  D0 15                  bne ExAnimC               ;branch if not expired
00DD44  1  AD 0C 07               lda PlayerAnimTimerSet    ;get animation frame timer amount
00DD47  1  8D 81 07               sta PlayerAnimTimer       ;and set timer accordingly
00DD4A  1  AD 0D 07               lda PlayerAnimCtrl
00DD4D  1  18                     clc                       ;add one to animation frame control
00DD4E  1  69 01                  adc #$01
00DD50  1  C5 00                  cmp $00                   ;compare to upper extent
00DD52  1  90 02                  bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
00DD54  1  A9 00                  lda #$00                  ;otherwise initialize frame control
00DD56  1  8D 0D 07     SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
00DD59  1  68           ExAnimC:  pla                       ;get offset to graphics table from stack and leave
00DD5A  1  60                     rts
00DD5B  1               
00DD5B  1               GetGfxOffsetAdder:
00DD5B  1  AD 54 07             lda PlayerSize  ;get player's size
00DD5E  1  F0 05                beq SzOfs       ;if player big, use current offset as-is
00DD60  1  98                   tya             ;for big player
00DD61  1  18                   clc             ;otherwise add eight bytes to offset
00DD62  1  69 08                adc #$08        ;for small player
00DD64  1  A8                   tay
00DD65  1  60           SzOfs:  rts             ;go back
00DD66  1               
00DD66  1               ChangeSizeOffsetAdder:
00DD66  1  00 01 00 01          .byte $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
00DD6A  1  00 01 02 00  
00DD6E  1  01 02        
00DD70  1  02 00 02 00          .byte $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
00DD74  1  02 00 02 00  
00DD78  1  02 00        
00DD7A  1               
00DD7A  1               HandleChangeSize:
00DD7A  1  AC 0D 07              ldy PlayerAnimCtrl           ;get animation frame control
00DD7D  1  A5 09                 lda FrameCounter
00DD7F  1  29 03                 and #%00000011               ;get frame counter and execute this code every
00DD81  1  D0 0D                 bne GorSLog                  ;fourth frame, otherwise branch ahead
00DD83  1  C8                    iny                          ;increment frame control
00DD84  1  C0 0A                 cpy #$0a                     ;check for preset upper extent
00DD86  1  90 05                 bcc CSzNext                  ;if not there yet, skip ahead to use
00DD88  1  A0 00                 ldy #$00                     ;otherwise initialize both grow/shrink flag
00DD8A  1  8C 0B 07              sty PlayerChangeSizeFlag     ;and animation frame control
00DD8D  1  8C 0D 07     CSzNext: sty PlayerAnimCtrl           ;store proper frame control
00DD90  1  AD 54 07     GorSLog: lda PlayerSize               ;get player's size
00DD93  1  D0 0C                 bne ShrinkPlayer             ;if player small, skip ahead to next part
00DD95  1  B9 66 DD              lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
00DD98  1  A0 0F                 ldy #$0f                     ;load offset for player growing
00DD9A  1               
00DD9A  1               GetOffsetFromAnimCtrl:
00DD9A  1  0A                   asl                        ;multiply animation frame control
00DD9B  1  0A                   asl                        ;by eight to get proper amount
00DD9C  1  0A                   asl                        ;to add to our offset
00DD9D  1  79 C7 DA             adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
00DDA0  1  60                   rts                        ;and return with result in A
00DDA1  1               
00DDA1  1               ShrinkPlayer:
00DDA1  1  98                   tya                          ;add ten bytes to frame control as offset
00DDA2  1  18                   clc
00DDA3  1  69 0A                adc #$0a                     ;this thing apparently uses two of the swimming frames
00DDA5  1  AA                   tax                          ;to draw the player shrinking
00DDA6  1  A0 09                ldy #$09                     ;load offset for small player swimming
00DDA8  1  BD 66 DD             lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
00DDAB  1  D0 02                bne ShrPlF                   ;and branch to use offset if nonzero
00DDAD  1  A0 01                ldy #$01                     ;otherwise load offset for big player swimming
00DDAF  1  B9 C7 DA     ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
00DDB2  1  60                   rts                          ;and leave
00DDB3  1               
00DDB3  1               ChkForPlayerAttrib:
00DDB3  1  AC E4 06                ldy Player_SprDataOffset    ;get sprite data offset
00DDB6  1  A5 0E                   lda GameEngineSubroutine
00DDB8  1  C9 0B                   cmp #$0b                    ;if executing specific game engine routine,
00DDBA  1  F0 13                   beq KilledAtt               ;branch to change third and fourth row OAM attributes
00DDBC  1  AD D5 06                lda PlayerGfxOffset         ;get graphics table offset
00DDBF  1  C9 50                   cmp #$50
00DDC1  1  F0 1E                   beq C_S_IGAtt               ;if crouch offset, either standing offset,
00DDC3  1  C9 B8                   cmp #$b8                    ;or intermediate growing offset,
00DDC5  1  F0 1A                   beq C_S_IGAtt               ;go ahead and execute code to change
00DDC7  1  C9 C0                   cmp #$c0                    ;fourth row OAM attributes only
00DDC9  1  F0 16                   beq C_S_IGAtt
00DDCB  1  C9 C8                   cmp #$c8
00DDCD  1  D0 24                   bne ExPlyrAt                ;if none of these, branch to leave
00DDCF  1  B9 12 02     KilledAtt: lda Sprite_Attributes+16,y
00DDD2  1  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00DDD4  1  99 12 02                sta Sprite_Attributes+16,y  ;for third row sprites and save
00DDD7  1  B9 16 02                lda Sprite_Attributes+20,y
00DDDA  1  29 3F                   and #%00111111
00DDDC  1  09 40                   ora #%01000000              ;set horizontal flip bit for second
00DDDE  1  99 16 02                sta Sprite_Attributes+20,y  ;sprite in the third row
00DDE1  1  B9 1A 02     C_S_IGAtt: lda Sprite_Attributes+24,y
00DDE4  1  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00DDE6  1  99 1A 02                sta Sprite_Attributes+24,y  ;for fourth row sprites and save
00DDE9  1  B9 1E 02                lda Sprite_Attributes+28,y
00DDEC  1  29 3F                   and #%00111111
00DDEE  1  09 40                   ora #%01000000              ;set horizontal flip bit for second
00DDF0  1  99 1E 02                sta Sprite_Attributes+28,y  ;sprite in the fourth row
00DDF3  1  60           ExPlyrAt:  rts                         ;leave
00DDF4  1               
00DDF4  1               ;-------------------------------------------------------------------------------------
00DDF4  1               ;$00 - used in adding to get proper offset
00DDF4  1               
00DDF4  1               RelativePlayerPosition:
00DDF4  1  A2 00                ldx #$00      ;set offsets for relative cooordinates
00DDF6  1  A0 00                ldy #$00      ;routine to correspond to player object
00DDF8  1  4C 0C DE             jmp RelWOfs   ;get the coordinates
00DDFB  1               
00DDFB  1               RelativeBubblePosition:
00DDFB  1  A0 01                ldy #$01                ;set for air bubble offsets
00DDFD  1  20 72 DE             jsr GetProperObjOffset  ;modify X to get proper air bubble offset
00DE00  1  A0 03                ldy #$03
00DE02  1  4C 0C DE             jmp RelWOfs             ;get the coordinates
00DE05  1               
00DE05  1               RelativeFireballPosition:
00DE05  1  A0 00                 ldy #$00                    ;set for fireball offsets
00DE07  1  20 72 DE              jsr GetProperObjOffset      ;modify X to get proper fireball offset
00DE0A  1  A0 02                 ldy #$02
00DE0C  1  20 3B DE     RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
00DE0F  1  A6 08                 ldx ObjectOffset            ;return original offset
00DE11  1  60                    rts                         ;leave
00DE12  1               
00DE12  1               RelativeMiscPosition:
00DE12  1  A0 02                ldy #$02                ;set for misc object offsets
00DE14  1  20 72 DE             jsr GetProperObjOffset  ;modify X to get proper misc object offset
00DE17  1  A0 06                ldy #$06
00DE19  1  4C 0C DE             jmp RelWOfs             ;get the coordinates
00DE1C  1               
00DE1C  1               RelativeEnemyPosition:
00DE1C  1  A9 01                lda #$01                     ;get coordinates of enemy object
00DE1E  1  A0 01                ldy #$01                     ;relative to the screen
00DE20  1  4C 2F DE             jmp VariableObjOfsRelPos
00DE23  1               
00DE23  1               RelativeBlockPosition:
00DE23  1  A9 09                lda #$09                     ;get coordinates of one block object
00DE25  1  A0 04                ldy #$04                     ;relative to the screen
00DE27  1  20 2F DE             jsr VariableObjOfsRelPos
00DE2A  1  E8                   inx                          ;adjust offset for other block object if any
00DE2B  1  E8                   inx
00DE2C  1  A9 09                lda #$09
00DE2E  1  C8                   iny                          ;adjust other and get coordinates for other one
00DE2F  1               
00DE2F  1               VariableObjOfsRelPos:
00DE2F  1  86 00                stx $00                     ;store value to add to A here
00DE31  1  18                   clc
00DE32  1  65 00                adc $00                     ;add A to value stored
00DE34  1  AA                   tax                         ;use as enemy offset
00DE35  1  20 3B DE             jsr GetObjRelativePosition
00DE38  1  A6 08                ldx ObjectOffset            ;reload old object offset and leave
00DE3A  1  60                   rts
00DE3B  1               
00DE3B  1               GetObjRelativePosition:
00DE3B  1  B5 CE                lda SprObject_Y_Position,x  ;load vertical coordinate low
00DE3D  1  99 B8 03             sta SprObject_Rel_YPos,y    ;store here
00DE40  1  B5 86                lda SprObject_X_Position,x  ;load horizontal coordinate
00DE42  1  38                   sec                         ;subtract left edge coordinate
00DE43  1  ED 1C 07             sbc ScreenLeft_X_Pos
00DE46  1  99 AD 03             sta SprObject_Rel_XPos,y    ;store result here
00DE49  1  60                   rts
00DE4A  1               
00DE4A  1               ;-------------------------------------------------------------------------------------
00DE4A  1               ;$00 - used as temp variable to hold offscreen bits
00DE4A  1               
00DE4A  1               GetPlayerOffscreenBits:
00DE4A  1  A2 00                ldx #$00                 ;set offsets for player-specific variables
00DE4C  1  A0 00                ldy #$00                 ;and get offscreen information about player
00DE4E  1  4C 8A DE             jmp GetOffScreenBitsSet
00DE51  1               
00DE51  1               GetFireballOffscreenBits:
00DE51  1  A0 00                ldy #$00                 ;set for fireball offsets
00DE53  1  20 72 DE             jsr GetProperObjOffset   ;modify X to get proper fireball offset
00DE56  1  A0 02                ldy #$02                 ;set other offset for fireball's offscreen bits
00DE58  1  4C 8A DE             jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
00DE5B  1               
00DE5B  1               GetBubbleOffscreenBits:
00DE5B  1  A0 01                ldy #$01                 ;set for air bubble offsets
00DE5D  1  20 72 DE             jsr GetProperObjOffset   ;modify X to get proper air bubble offset
00DE60  1  A0 03                ldy #$03                 ;set other offset for airbubble's offscreen bits
00DE62  1  4C 8A DE             jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
00DE65  1               
00DE65  1               GetMiscOffscreenBits:
00DE65  1  A0 02                ldy #$02                 ;set for misc object offsets
00DE67  1  20 72 DE             jsr GetProperObjOffset   ;modify X to get proper misc object offset
00DE6A  1  A0 06                ldy #$06                 ;set other offset for misc object's offscreen bits
00DE6C  1  4C 8A DE             jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
00DE6F  1               
00DE6F  1               ObjOffsetData:
00DE6F  1  07 16 0D             .byte $07, $16, $0d
00DE72  1               
00DE72  1               GetProperObjOffset:
00DE72  1  8A                   txa                  ;move offset to A
00DE73  1  18                   clc
00DE74  1  79 6F DE             adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
00DE77  1  AA                   tax                  ;put back in X and leave
00DE78  1  60                   rts
00DE79  1               
00DE79  1               GetEnemyOffscreenBits:
00DE79  1  A9 01                lda #$01                 ;set A to add 1 byte in order to get enemy offset
00DE7B  1  A0 01                ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
00DE7D  1  4C 84 DE             jmp SetOffscrBitsOffset
00DE80  1               
00DE80  1               GetBlockOffscreenBits:
00DE80  1  A9 09                lda #$09       ;set A to add 9 bytes in order to get block obj offset
00DE82  1  A0 04                ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
00DE84  1               
00DE84  1               SetOffscrBitsOffset:
00DE84  1  86 00                stx $00
00DE86  1  18                   clc           ;add contents of X to A to get
00DE87  1  65 00                adc $00       ;appropriate offset, then give back to X
00DE89  1  AA                   tax
00DE8A  1               
00DE8A  1               GetOffScreenBitsSet:
00DE8A  1  98                   tya                         ;save offscreen bits offset to stack for now
00DE8B  1  48                   pha
00DE8C  1  20 A1 DE             jsr RunOffscrBitsSubs
00DE8F  1  0A                   asl                         ;move low nybble to high nybble
00DE90  1  0A                   asl
00DE91  1  0A                   asl
00DE92  1  0A                   asl
00DE93  1  05 00                ora $00                     ;mask together with previously saved low nybble
00DE95  1  85 00                sta $00                     ;store both here
00DE97  1  68                   pla                         ;get offscreen bits offset from stack
00DE98  1  A8                   tay
00DE99  1  A5 00                lda $00                     ;get value here and store elsewhere
00DE9B  1  99 D0 03             sta SprObject_OffscrBits,y
00DE9E  1  A6 08                ldx ObjectOffset
00DEA0  1  60                   rts
00DEA1  1               
00DEA1  1               RunOffscrBitsSubs:
00DEA1  1  20 C0 DE             jsr GetXOffscreenBits  ;do subroutine here
00DEA4  1  4A                   lsr                    ;move high nybble to low
00DEA5  1  4A                   lsr
00DEA6  1  4A                   lsr
00DEA7  1  4A                   lsr
00DEA8  1  85 00                sta $00                ;store here
00DEAA  1  4C 03 DF             jmp GetYOffscreenBits
00DEAD  1               
00DEAD  1               ;--------------------------------
00DEAD  1               ;(these apply to these three subsections)
00DEAD  1               ;$04 - used to store proper offset
00DEAD  1               ;$05 - used as adder in DividePDiff
00DEAD  1               ;$06 - used to store preset value used to compare to pixel difference in $07
00DEAD  1               ;$07 - used to store difference between coordinates of object and screen edges
00DEAD  1               
00DEAD  1               XOffscreenBitsData:
00DEAD  1  7F 3F 1F 0F          .byte $7f, $3f, $1f, $0f, $07, $03, $01, $00
00DEB1  1  07 03 01 00  
00DEB5  1  80 C0 E0 F0          .byte $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
00DEB9  1  F8 FC FE FF  
00DEBD  1               
00DEBD  1               DefaultXOnscreenOfs:
00DEBD  1  07 0F 07             .byte $07, $0f, $07
00DEC0  1               
00DEC0  1               GetXOffscreenBits:
00DEC0  1  86 04                  stx $04                     ;save position in buffer to here
00DEC2  1  A0 01                  ldy #$01                    ;start with right side of screen
00DEC4  1  B9 1C 07     XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
00DEC7  1  38                     sec                         ;get difference between pixel coordinate of edge
00DEC8  1  F5 86                  sbc SprObject_X_Position,x  ;and pixel coordinate of object position
00DECA  1  85 07                  sta $07                     ;store here
00DECC  1  B9 1A 07               lda ScreenEdge_PageLoc,y    ;get page location of edge
00DECF  1  F5 6D                  sbc SprObject_PageLoc,x     ;subtract from page location of object position
00DED1  1  BE BD DE               ldx DefaultXOnscreenOfs,y   ;load offset value here
00DED4  1  C9 00                  cmp #$00
00DED6  1  30 10                  bmi XLdBData                ;if beyond right edge or in front of left edge, branch
00DED8  1  BE BE DE               ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
00DEDB  1  C9 01                  cmp #$01
00DEDD  1  10 09                  bpl XLdBData                ;if one page or more to the left of either edge, branch
00DEDF  1  A9 38                  lda #$38                    ;if no branching, load value here and store
00DEE1  1  85 06                  sta $06
00DEE3  1  A9 08                  lda #$08                    ;load some other value and execute subroutine
00DEE5  1  20 37 DF               jsr DividePDiff
00DEE8  1  BD AD DE     XLdBData: lda XOffscreenBitsData,x    ;get bits here
00DEEB  1  A6 04                  ldx $04                     ;reobtain position in buffer
00DEED  1  C9 00                  cmp #$00                    ;if bits not zero, branch to leave
00DEEF  1  D0 03                  bne ExXOfsBS
00DEF1  1  88                     dey                         ;otherwise, do left side of screen now
00DEF2  1  10 D0                  bpl XOfsLoop                ;branch if not already done with left side
00DEF4  1  60           ExXOfsBS: rts
00DEF5  1               
00DEF5  1               ;--------------------------------
00DEF5  1               
00DEF5  1               YOffscreenBitsData:
00DEF5  1  0F 07 03 01          .byte $0f, $07, $03, $01
00DEF9  1  00 08 0C 0E          .byte $00, $08, $0c, $0e
00DEFD  1  00                   .byte $00
00DEFE  1               
00DEFE  1               DefaultYOnscreenOfs:
00DEFE  1  04 00 04             .byte $04, $00, $04
00DF01  1               
00DF01  1               HighPosUnitData:
00DF01  1  00 FF                .byte $00, $ff
00DF03  1               
00DF03  1               GetYOffscreenBits:
00DF03  1  86 04                  stx $04                      ;save position in buffer to here
00DF05  1  A0 01                  ldy #$01                     ;start with bottom of screen
00DF07  1  B9 01 DF     YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
00DF0A  1  38                     sec
00DF0B  1  F5 CE                  sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
00DF0D  1  85 07                  sta $07                      ;store here
00DF0F  1  A9 01                  lda #$01                     ;subtract one from vertical high byte of object
00DF11  1  F5 B5                  sbc SprObject_Y_HighPos,x
00DF13  1  BE FE DE               ldx DefaultYOnscreenOfs,y    ;load offset value here
00DF16  1  C9 00                  cmp #$00
00DF18  1  30 10                  bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
00DF1A  1  BE FF DE               ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
00DF1D  1  C9 01                  cmp #$01
00DF1F  1  10 09                  bpl YLdBData                 ;if one vertical unit or more above the screen, branch
00DF21  1  A9 20                  lda #$20                     ;if no branching, load value here and store
00DF23  1  85 06                  sta $06
00DF25  1  A9 04                  lda #$04                     ;load some other value and execute subroutine
00DF27  1  20 37 DF               jsr DividePDiff
00DF2A  1  BD F5 DE     YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
00DF2D  1  A6 04                  ldx $04                      ;reobtain position in buffer
00DF2F  1  C9 00                  cmp #$00
00DF31  1  D0 03                  bne ExYOfsBS                 ;if bits not zero, branch to leave
00DF33  1  88                     dey                          ;otherwise, do top of the screen now
00DF34  1  10 D1                  bpl YOfsLoop
00DF36  1  60           ExYOfsBS: rts
00DF37  1               
00DF37  1               ;--------------------------------
00DF37  1               
00DF37  1               DividePDiff:
00DF37  1  85 05                  sta $05       ;store current value in A here
00DF39  1  A5 07                  lda $07       ;get pixel difference
00DF3B  1  C5 06                  cmp $06       ;compare to preset value
00DF3D  1  B0 0C                  bcs ExDivPD   ;if pixel difference >= preset value, branch
00DF3F  1  4A                     lsr           ;divide by eight
00DF40  1  4A                     lsr
00DF41  1  4A                     lsr
00DF42  1  29 07                  and #$07      ;mask out all but 3 LSB
00DF44  1  C0 01                  cpy #$01      ;right side of the screen or top?
00DF46  1  B0 02                  bcs SetOscrO  ;if so, branch, use difference / 8 as offset
00DF48  1  65 05                  adc $05       ;if not, add value to difference / 8
00DF4A  1  AA           SetOscrO: tax           ;use as offset
00DF4B  1  60           ExDivPD:  rts           ;leave
00DF4C  1               
00DF4C  1               ;-------------------------------------------------------------------------------------
00DF4C  1               ;$00-$01 - tile numbers
00DF4C  1               ;$02 - Y coordinate
00DF4C  1               ;$03 - flip control
00DF4C  1               ;$04 - sprite attributes
00DF4C  1               ;$05 - X coordinate
00DF4C  1               
00DF4C  1               DrawSpriteObject:
00DF4C  1  A5 03                 lda $03                    ;get saved flip control bits
00DF4E  1  4A                    lsr
00DF4F  1  4A                    lsr                        ;move d1 into carry
00DF50  1  A5 00                 lda $00
00DF52  1  90 0C                 bcc NoHFlip                ;if d1 not set, branch
00DF54  1  99 05 02              sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
00DF57  1  A5 01                 lda $01                    ;and second into first sprite
00DF59  1  99 01 02              sta Sprite_Tilenumber,y
00DF5C  1  A9 40                 lda #$40                   ;activate horizontal flip OAM attribute
00DF5E  1  D0 0A                 bne SetHFAt                ;and unconditionally branch
00DF60  1  99 01 02     NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
00DF63  1  A5 01                 lda $01                    ;and second into second sprite
00DF65  1  99 05 02              sta Sprite_Tilenumber+4,y
00DF68  1  A9 00                 lda #$00                   ;clear bit for horizontal flip
00DF6A  1  05 04        SetHFAt: ora $04                    ;add other OAM attributes if necessary
00DF6C  1  99 02 02              sta Sprite_Attributes,y    ;store sprite attributes
00DF6F  1  99 06 02              sta Sprite_Attributes+4,y
00DF72  1  A5 02                 lda $02                    ;now the y coordinates
00DF74  1  99 00 02              sta Sprite_Y_Position,y    ;note because they are
00DF77  1  99 04 02              sta Sprite_Y_Position+4,y  ;side by side, they are the same
00DF7A  1  A5 05                 lda $05
00DF7C  1  99 03 02              sta Sprite_X_Position,y    ;store x coordinate, then
00DF7F  1  18                    clc                        ;add 8 pixels and store another to
00DF80  1  69 08                 adc #$08                   ;put them side by side
00DF82  1  99 07 02              sta Sprite_X_Position+4,y
00DF85  1  A5 02                 lda $02                    ;add eight pixels to the next y
00DF87  1  18                    clc                        ;coordinate
00DF88  1  69 08                 adc #$08
00DF8A  1  85 02                 sta $02
00DF8C  1  98                    tya                        ;add eight to the offset in Y to
00DF8D  1  18                    clc                        ;move to the next two sprites
00DF8E  1  69 08                 adc #$08
00DF90  1  A8                    tay
00DF91  1  E8                    inx                        ;increment offset to return it to the
00DF92  1  E8                    inx                        ;routine that called this subroutine
00DF93  1  60                    rts
00DF94  1               
00DF94  1               ;-------------------------------------------------------------------------------------
00DF94  1                .export InitializeLeaves
00DF94  1               
00DF94  1               AttractModeSubs:
00DF94  1  AD 72 07           lda OperMode_Task
00DF97  1  20 69 8C           jsr JumpEngine
00DF9A  1               
00DF9A  1  D5 DF              .word AttractModeDiskRoutines
00DF9C  1  5C E2              .word InitializeGame
00DF9E  1  77 84              .word ScreenRoutines
00DFA0  1  7F E2              .word PrimaryGameSetup
00DFA2  1  EA E0              .word GameMenuRoutine
00DFA4  1  A6 DF              .word HardWorldsCheckpoint
00DFA6  1               
00DFA6  1               HardWorldsCheckpoint:
00DFA6  1  AD FC 07           lda DiskIOTask
00DFA9  1  20 69 8C           jsr JumpEngine
00DFAC  1               
00DFAC  1  5F E0              .word DiskScreen
00DFAE  1  B0 DF              .word LoadHardWorlds
00DFB0  1               
00DFB0  1               LoadHardWorlds:
00DFB0  1  AD FB 07              lda HardWorldFlag         ;if this is not set, skip this
00DFB3  1  F0 08                 beq NoLoadHW
00DFB5  1  A9 03                 lda #$03
00DFB7  1  8D F7 07              sta FileListNumber        ;set filelist number to load SM2DATA4
00DFBA  1  20 4C E5              jsr InitializeLeaves      ;init leaf positions for wind
00DFBD  1               NoLoadHW:
00DFBD  1  20 29 FF              jsr RunLoadAreaPointer    ;update area pointer to get world 1 or A
00DFC0  1  EE 5D 07     NoCHWP:  inc Hidden1UpFlag
00DFC3  1  EE 57 07              inc FetchNewGameTimerFlag
00DFC6  1  EE 70 07              inc OperMode
00DFC9  1  A9 00                 lda #$00
00DFCB  1  8D FC 07              sta DiskIOTask
00DFCE  1  8D 72 07              sta OperMode_Task
00DFD1  1  8D A2 07              sta DemoTimer
00DFD4  1  60                    rts
00DFD5  1               
00DFD5  1               AttractModeDiskRoutines:
00DFD5  1  AD FC 07           lda DiskIOTask
00DFD8  1  20 69 8C           jsr JumpEngine
00DFDB  1               
00DFDB  1  5F E0              .word DiskScreen
00DFDD  1  DF DF              .word LoadWorlds1Thru4
00DFDF  1               
00DFDF  1               LoadWorlds1Thru4:
00DFDF  1  AD FD 07                lda NotColdFlag       ;if not set, just cold booted, thus no need to check world info
00DFE2  1  F0 16                   beq InitWorldPos
00DFE4  1  AD FB 07                lda HardWorldFlag     ;if player was playing worlds A-D, skip ahead
00DFE7  1  D0 07                   bne LW14Files         ;otherwise check the world number
00DFE9  1  AD 5F 07                lda WorldNumber
00DFEC  1  C9 04                   cmp #World5           ;if world number was less than 5, files still in memory
00DFEE  1  90 0A                   bcc InitWorldPos      ;thus skip to the end, no need to load them again
00DFF0  1  A9 00        LW14Files: lda #$00              ;set filelist number to reload SM2MAIN, SM2CHAR1 and SM2SAVE
00DFF2  1  8D F7 07                sta FileListNumber
00DFF5  1  A9 85                   lda #Spr_MainBank+1
00DFF7  1  20 E6 FE                jsr SwitchSPR_CHR1
00DFFA  1               InitWorldPos:
00DFFA  1  A9 01                   lda #$01              ;set flag to check player's world info
00DFFC  1  8D FD 07                sta NotColdFlag       ;before erasing it
00DFFF  1  4A                      lsr
00E000  1  8D 5F 07                sta WorldNumber       ;reset world number
00E003  1  8D FB 07                sta HardWorldFlag     ;force worlds 1-8 by default
00E006  1  4C 28 E0                jmp ResetDiskIOTask   ;end disk subroutines
00E009  1               
00E009  1               GameModeDiskRoutines:
00E009  1  AD FC 07           lda DiskIOTask
00E00C  1  20 69 8C           jsr JumpEngine
00E00F  1               
00E00F  1  5F E0              .word DiskScreen
00E011  1  13 E0              .word LoadWorlds5Thru8
00E013  1               
00E013  1               LoadWorlds5Thru8:
00E013  1  AD 5F 07           lda WorldNumber       ;if in worlds 1-4 or A-D
00E016  1  C9 04              cmp #World5           ;then leave without loading anything
00E018  1  90 0E              bcc ResetDiskIOTask
00E01A  1  AD F7 07           lda FileListNumber    ;if worlds 5-8 were already loaded, leave
00E01D  1  4A                 lsr
00E01E  1  B0 08              bcs ResetDiskIOTask   ;as there's no need to load anything
00E020  1  A9 01              lda #$01
00E022  1  8D F7 07           sta FileListNumber    ;otherwise set filelist number to load SM2DATA2
00E025  1  20 4C E5           jsr InitializeLeaves  ;init leaf positions for wind
00E028  1               
00E028  1               ResetDiskIOTask:
00E028  1  A9 00              lda #$00              ;reset disk-related task number for next time
00E02A  1  8D FC 07           sta DiskIOTask
00E02D  1               VMDelay:
00E02D  1  EE 72 07           inc OperMode_Task     ;move on to next task in the current mode
00E030  1  60                 rts
00E031  1               
00E031  1               StartVMDelay:
00E031  1  A9 10              lda #$10           ;start world end delay
00E033  1  8D A1 07           sta WorldEndTimer
00E036  1  D0 F5              bne VMDelay
00E038  1               
00E038  1               ContinueVMDelay:
00E038  1  AD A1 07           lda WorldEndTimer  ;wait for delay to end, then move on
00E03B  1  F0 F0              beq VMDelay
00E03D  1  60                 rts
00E03E  1               
00E03E  1               VictoryModeDiskRoutines:
00E03E  1  AD FC 07           lda DiskIOTask
00E041  1  20 69 8C           jsr JumpEngine
00E044  1               
00E044  1  5F E0              .word DiskScreen
00E046  1  48 E0              .word LoadEnding
00E048  1               
00E048  1               LoadEnding:
00E048  1  A9 89                lda #Spr_EndingBank+1
00E04A  1  20 E6 FE             jsr SwitchSPR_CHR1       ;load princess graphics
00E04D  1  20 7E 8C             jsr InitializeNameTables
00E050  1  20 28 E0             jsr ResetDiskIOTask      ;end disk subroutines
00E053  1  8D 3C 07             sta ScreenRoutineTask    ;init screen routine task
00E056  1  60                   rts
00E057  1               
00E057  1               DiskScreenPalette:
00E057  1  3F 00 04       .byte $3f, $00, $04
00E05A  1  0F 30 30 0F    .byte $0f, $30, $30, $0f
00E05E  1  00             .byte $00
00E05F  1               
00E05F  1               DiskScreen:
00E05F  1  A9 00              lda #$00
00E061  1  8D 79 07           sta Mirror_PPU_MASK
00E064  1  8D 01 20           sta PPU_MASK
00E067  1  8D 7B 07           sta IRQAckFlag        ;acknowledge IRQ to prevent infinite loop
00E06A  1  8D 22 07           sta IRQUpdateFlag
00E06D  1  EE 74 07           inc DisableScreenFlag
00E070  1  A9 1B              lda #$1b
00E072  1  8D 73 07           sta VRAM_Buffer_AddrCtrl
00E075  1  8D 00 E0           sta MMC3_IRQDisable   ;disable MMC3 IRQ and acknowledge pending interrupts
00E078  1  EE FC 07           inc DiskIOTask        ;move on to next subtask involving the disk drive
00E07B  1  60                 rts
00E07C  1               
00E07C  1               GameOverCursorData:
00E07C  1  5B 02 48       .byte $5b, $02, $48
00E07F  1               
00E07F  1               GameOverCursorY:
00E07F  1  77 8F          .byte $77, $8f
00E081  1               
00E081  1               GameOverMenu:
00E081  1  AD FC 06                 lda SavedJoypadBits          ;if player pressed the start button
00E084  1  29 10                    and #Start_Button            ;then either continue or start over
00E086  1  D0 2D                    bne ContinueOrRetry
00E088  1  AD FC 06                 lda SavedJoypadBits
00E08B  1  29 20                    and #Select_Button           ;if player pressed the select button
00E08D  1  F0 11                    beq ChgSel                   ;then branch to select "continue" or "retry"
00E08F  1  AE 80 07                 ldx SelectTimer              ;if select timer not expired while
00E092  1  D0 0C                    bne ChgSel                   ;pressing select, skip this
00E094  1  4A                       lsr
00E095  1  8D 80 07                 sta SelectTimer              ;otherwise set the select timer
00E098  1  AD F8 07                 lda ContinueMenuSelect
00E09B  1  49 01                    eor #$01                     ;and toggle between the two choices
00E09D  1  8D F8 07                 sta ContinueMenuSelect
00E0A0  1  A0 02        ChgSel:     ldy #$02
00E0A2  1  B9 7C E0     ChgSelLoop: lda GameOverCursorData,y     ;set up cursor sprite tile, attribute
00E0A5  1  99 01 02                 sta Sprite_Data+1,y          ;and X position in sprite OAM data
00E0A8  1  88                       dey
00E0A9  1  10 F7                    bpl ChgSelLoop
00E0AB  1  AC F8 07                 ldy ContinueMenuSelect
00E0AE  1  B9 7F E0                 lda GameOverCursorY,y        ;set Y position based on the selection
00E0B1  1  8D 00 02                 sta Sprite_Data
00E0B4  1  60                       rts
00E0B5  1               
00E0B5  1               ContinueOrRetry:
00E0B5  1  AD F8 07       lda ContinueMenuSelect       ;if player selected "continue"
00E0B8  1  F0 08          beq Continue                 ;then branch to continue
00E0BA  1  A9 00          lda #$00
00E0BC  1  8D FA 07       sta CompletedWorlds          ;otherwise init completed worlds flags
00E0BF  1  4C 88 90       jmp TerminateGame            ;and end the game
00E0C2  1               
00E0C2  1               Continue:
00E0C2  1  A0 02                ldy #$02
00E0C4  1  8C 5A 07             sty NumberofLives           ;give three lives
00E0C7  1  8D 5C 07             sta LevelNumber
00E0CA  1  8D 60 07             sta AreaNumber              ;put at x-1 of the current world
00E0CD  1  8D 5E 07             sta CoinTally
00E0D0  1  A0 0B                ldy #$0b
00E0D2  1  99 DD 07     ISCont: sta ScoreAndCoinDisplay,y   ;reset score
00E0D5  1  88                   dey
00E0D6  1  10 FA                bpl ISCont
00E0D8  1  EE 5D 07             inc Hidden1UpFlag           ;allow 1-up to be found again
00E0DB  1  4C 98 90             jmp ContinueGame
00E0DE  1               
00E0DE  1               ;-------------------------------------------------------------------------------------
00E0DE  1               
00E0DE  1               AreaDataOfsLoopback:
00E0DE  1  0C 0C 42 42    .byte $0c, $0c, $42, $42, $10, $10, $30, $30, $06, $0c, $54, $06
00E0E2  1  10 10 30 30  
00E0E6  1  06 0C 54 06  
00E0EA  1               
00E0EA  1               ;-------------------------------------------------------------------------------------
00E0EA  1               
00E0EA  1               GameMenuRoutine:
00E0EA  1  AD FC 06                   lda SavedJoypadBits         ;check to see if the player pressed start
00E0ED  1  29 10                      and #Start_Button
00E0EF  1  F0 1F                      beq ChkSelect               ;if not, branch to check other buttons
00E0F1  1  A9 00                      lda #$00
00E0F3  1  8D FA 07                   sta CompletedWorlds
00E0F6  1  8D FC 07                   sta DiskIOTask
00E0F9  1  8D FB 07                   sta HardWorldFlag
00E0FC  1  AD 07 60                   lda GamesBeatenCount        ;check to see if player has beaten
00E0FF  1  C9 08                      cmp #$08                    ;the game at least 8 times
00E101  1  90 0A                      bcc StG                     ;if not, start the game as usual at world 1
00E103  1  AD FC 06                   lda SavedJoypadBits
00E106  1  29 80                      and #A_Button               ;check if the player pressed A + start
00E108  1  F0 03                      beq StG                     ;if not, start the game as usual at world 1
00E10A  1  EE FB 07                   inc HardWorldFlag           ;otherwise start playing the letter worlds
00E10D  1  4C 68 E1     StG:          jmp StartGame
00E110  1  AD FC 06     ChkSelect:    lda SavedJoypadBits
00E113  1  C9 20                      cmp #Select_Button          ;branch if pressing select
00E115  1  F0 0F                      beq SelectLogic
00E117  1  AE A2 07                   ldx DemoTimer
00E11A  1  D0 2F                      bne NullJoypad
00E11C  1  8D 80 07                   sta SelectTimer             ;run demo after a certain period of time
00E11F  1  20 D0 E1                   jsr DemoEngine
00E122  1  B0 35                      bcs ResetTitle
00E124  1  90 2A                      bcc RunDemo
00E126  1  AD A2 07     SelectLogic:  lda DemoTimer               ;if select pressed, check demo timer one last time
00E129  1  F0 2E                      beq ResetTitle              ;if demo timer expired, branch to reset attract mode
00E12B  1  A9 18                      lda #$18                    ;otherwise reset demo timer
00E12D  1  8D A2 07                   sta DemoTimer
00E130  1  A5 09                      lda FrameCounter            ;erase LSB of frame counter
00E132  1  29 FE                      and #$fe
00E134  1  85 09                      sta FrameCounter
00E136  1  AD 80 07                   lda SelectTimer             ;if select timer not expired, skip to slow select down
00E139  1  D0 10                      bne NullJoypad
00E13B  1  A9 10                      lda #$10                    ;reset select button timer
00E13D  1  8D 80 07                   sta SelectTimer
00E140  1  AD 53 07                   lda SelectedPlayer          ;switch between the two players to select one
00E143  1  49 01                      eor #$01
00E145  1  8D 53 07                   sta SelectedPlayer
00E148  1  20 92 E1                   jsr DrawMenuCursor
00E14B  1  A9 00        NullJoypad:   lda #$00
00E14D  1  8D FC 06                   sta SavedJoypadBits
00E150  1  20 42 9A     RunDemo:      jsr GameCoreRoutine         ;run game engine
00E153  1  A5 0E                      lda GameEngineSubroutine    ;check to see if we're running lose life routine
00E155  1  C9 06                      cmp #$06
00E157  1  D0 30                      bne ExitMenu                ;if not, do not do all the resetting below
00E159  1  A9 00        ResetTitle:   lda #$00                    ;reset game modes, disable
00E15B  1  8D 70 07                   sta OperMode                ;IRQ and screen output
00E15E  1  8D 72 07                   sta OperMode_Task           ;screen output
00E161  1  8D 22 07                   sta IRQUpdateFlag
00E164  1  EE 74 07                   inc DisableScreenFlag
00E167  1  60                         rts
00E168  1               
00E168  1               StartGame:
00E168  1  AD A2 07                   lda DemoTimer
00E16B  1  F0 EC                      beq ResetTitle
00E16D  1  EE 72 07                   inc OperMode_Task
00E170  1  A9 00                      lda #$00
00E172  1  8D 5F 07                   sta WorldNumber
00E175  1  A9 00                      lda #$00
00E177  1  8D 5C 07                   sta LevelNumber
00E17A  1  A9 00                      lda #$00
00E17C  1  8D 60 07                   sta AreaNumber
00E17F  1  A2 0B                      ldx #$0b
00E181  1  A9 00                      lda #$00
00E183  1  9D DD 07     InitScore:    sta ScoreAndCoinDisplay,x   ;clear player score and coin display
00E186  1  CA                         dex
00E187  1  10 FA                      bpl InitScore
00E189  1  60           ExitMenu:     rts
00E18A  1               
00E18A  1               MenuCursorTemplate:
00E18A  1  06 22 4B 83        .byte $06, $22, $4b, $83, $ce, $24, $24, $00
00E18E  1  CE 24 24 00  
00E192  1               
00E192  1               DrawMenuCursor:
00E192  1  A0 07                      ldy #$07                  ;read eight bytes to be read by transfer routine
00E194  1               CursorDataRead:
00E194  1  B9 8A E1                   lda MenuCursorTemplate,y  ;note that the default position is set for
00E197  1  99 00 03                   sta VRAM_Buffer1-1,y      ;mario game
00E19A  1  88                         dey
00E19B  1  10 F7                      bpl CursorDataRead
00E19D  1  AD 53 07                   lda SelectedPlayer        ;check selected player
00E1A0  1  F0 0A                      beq ExitCursor            ;if set to mario game, we're done
00E1A2  1  A9 24                      lda #$24                  ;otherwise, load blank tile in mario game position
00E1A4  1  8D 04 03                   sta VRAM_Buffer1+3
00E1A7  1  A9 CE                      lda #$ce                  ;then load shroom icon tile in luigi game position
00E1A9  1  8D 06 03                   sta VRAM_Buffer1+5
00E1AC  1  60           ExitCursor:   rts
00E1AD  1               
00E1AD  1               DemoActionData:
00E1AD  1  01 81 01 81    .byte $01, $81, $01, $81, $01, $81, $02, $01
00E1B1  1  01 81 02 01  
00E1B5  1  81 00 81 00    .byte $81, $00, $81, $00, $80, $01, $81, $01
00E1B9  1  80 01 81 01  
00E1BD  1  00             .byte $00
00E1BE  1               
00E1BE  1               DemoTimingData:
00E1BE  1  B0 10 10 10    .byte $b0, $10, $10, $10, $28, $10, $28, $06
00E1C2  1  28 10 28 06  
00E1C6  1  10 10 0C 80    .byte $10, $10, $0c, $80, $10, $28, $08, $90
00E1CA  1  10 28 08 90  
00E1CE  1  FF 00          .byte $ff, $00
00E1D0  1               
00E1D0  1               DemoEngine:
00E1D0  1  AE 17 07               ldx DemoAction         ;load current demo action
00E1D3  1  AD 18 07               lda DemoActionTimer    ;load current action timer
00E1D6  1  D0 0D                  bne DoAction           ;if timer still counting down, skip
00E1D8  1  E8                     inx
00E1D9  1  EE 17 07               inc DemoAction         ;if expired, increment action, X, and
00E1DC  1  38                     sec                    ;set carry by default for demo over
00E1DD  1  BD BD E1               lda DemoTimingData-1,x ;get next timer
00E1E0  1  8D 18 07               sta DemoActionTimer    ;store as current timer
00E1E3  1  F0 0A                  beq DemoOver           ;if timer already at zero, skip
00E1E5  1  BD AC E1     DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
00E1E8  1  8D FC 06               sta SavedJoypad1Bits
00E1EB  1  CE 18 07               dec DemoActionTimer    ;decrement action timer
00E1EE  1  18                     clc                    ;clear carry if demo still going
00E1EF  1  60           DemoOver: rts
00E1F0  1               
00E1F0  1               ClearBuffersDrawIcon:
00E1F0  1  AD 70 07                  lda OperMode               ;check game mode
00E1F3  1  D0 64                     bne IncModeTask_B          ;if not attract mode, leave
00E1F5  1  A2 00                     ldx #$00                   ;otherwise, clear buffer space
00E1F7  1  9D 00 03     TScrClear:   sta VRAM_Buffer1-1,x
00E1FA  1  9D 00 04                  sta VRAM_Buffer1-1+$100,x
00E1FD  1  CA                        dex
00E1FE  1  D0 F7                     bne TScrClear
00E200  1  20 92 E1                  jsr DrawMenuCursor         ;draw player select cursor
00E203  1  20 0A E2                  jsr DrawTitleScreenStars
00E206  1  EE 3C 07                  inc ScreenRoutineTask      ;move onto next task
00E209  1  60                        rts
00E20A  1               
00E20A  1               ;-------------------------------------------------------------------------------------
00E20A  1               ;$00 - used to store low byte of VRAM address
00E20A  1               ;$01 - used to store number of title screen stars drawn per line
00E20A  1               
00E20A  1               DrawTitleScreenStars:
00E20A  1  A9 D0                    lda #$d0                 ;set the VRAM address for the first line of stars
00E20C  1  85 00                    sta $00
00E20E  1  AD 07 60                 lda GamesBeatenCount     ;have we beaten the game at least once?
00E211  1  F0 40                    beq NoStars              ;if not, we don't need to be here
00E213  1  C9 0D                    cmp #$0d                 ;do we have more than 12 stars?
00E215  1  90 15                    bcc DrawLine             ;if not, draw the first line as-is
00E217  1  A9 0C                    lda #$0c                 ;otherwise, we need 12 stars for the first line
00E219  1  20 2C E2                 jsr DrawLine
00E21C  1  A9 F0                    lda #$f0                 ;now set the VRAM address for the second line
00E21E  1  85 00                    sta $00
00E220  1  AD 07 60                 lda GamesBeatenCount     ;get the correct number of stars to draw for the second line
00E223  1  38                       sec
00E224  1  E9 0C                    sbc #$0c
00E226  1  C9 0D                    cmp #$0d                 ;do we have somehow have more than 24 stars total?
00E228  1  90 02                    bcc DrawLine             ;if not, draw the second line normally
00E22A  1  A9 0C                    lda #$0c                 ;if we do, force the second line to only have 12 stars
00E22C  1  09 40        DrawLine:   ora #%01000000           ;add bit to indicate repeated tile
00E22E  1  85 01                    sta $01                  ;and store in temp variable
00E230  1  AE 00 03                 ldx VRAM_Buffer1_Offset
00E233  1  A9 20                    lda #$20                 ;write proper address for title screen stars
00E235  1  9D 01 03                 sta VRAM_Buffer1,x
00E238  1  A5 00                    lda $00
00E23A  1  9D 02 03                 sta VRAM_Buffer1+1,x
00E23D  1  A5 01                    lda $01                  ;write how many stars to draw for this line
00E23F  1  9D 03 03                 sta VRAM_Buffer1+2,x
00E242  1  A9 F1                    lda #$f1
00E244  1  9D 04 03                 sta VRAM_Buffer1+3,x
00E247  1  A9 00                    lda #$00                 ;put null terminator at the end
00E249  1  9D 05 03                 sta VRAM_Buffer1+4,x
00E24C  1  8A                       txa                      ;move the buffer offset up by four bytes
00E24D  1  18                       clc
00E24E  1  69 04                    adc #$04
00E250  1  8D 00 03                 sta VRAM_Buffer1_Offset
00E253  1  60           NoStars:    rts                      ;now we're done!
00E254  1               
00E254  1               ;-------------------------------------------------------------------------------------
00E254  1               
00E254  1               WriteTopScore:
00E254  1  A9 FA                       lda #$fa                    ;run display routine to display top score on title
00E256  1  20 1A A8                    jsr WriteDigits
00E259  1  4C CF 82     IncModeTask_B: jmp IncModeTask
00E25C  1               
00E25C  1               InitializeGame:
00E25C  1  A9 00                    lda #$00
00E25E  1  8D FA 07                 sta CompletedWorlds      ;clean slate player's progress (except for games beaten)
00E261  1  8D FB 07                 sta HardWorldFlag
00E264  1  8D 53 07                 sta SelectedPlayer
00E267  1  A0 6F                    ldy #$6f                 ;clear all memory as in initialization procedure,
00E269  1  20 F3 8E                 jsr InitializeMemory     ;but this time, clear only as far as $076f
00E26C  1  A0 1F                    ldy #$1f
00E26E  1  99 B0 07     ClrSndLoop: sta SoundMemory,y        ;clear out memory used
00E271  1  88                       dey                      ;by the sound engines
00E272  1  10 FA                    bpl ClrSndLoop
00E274  1               
00E274  1               DemoReset:
00E274  1  A9 18                    lda #$18             ;set demo timer
00E276  1  8D A2 07                 sta DemoTimer
00E279  1  20 29 FF                 jsr RunLoadAreaPointer
00E27C  1  4C 27 8E                 jmp InitializeArea
00E27F  1               
00E27F  1               PrimaryGameSetup:
00E27F  1  A9 01              lda #$01
00E281  1  8D 57 07           sta FetchNewGameTimerFlag   ;set flag to load game timer from header
00E284  1  8D 54 07           sta PlayerSize              ;set player's size to small
00E287  1  A9 02              lda #$02
00E289  1  8D 5A 07           sta NumberofLives           ;give each player three lives
00E28C  1  4C A4 8E           jmp SecondaryGameSetup
00E28F  1               
00E28F  1               ;-------------------------------------------------------------------------------------
00E28F  1               
00E28F  1               TitleScreenGfxData:
00E28F  1  20 84 01 44         .byte $20, $84, $01, $44
00E293  1  20 85 57 48         .byte $20, $85, $57, $48
00E297  1  20 9C 01 49         .byte $20, $9c, $01, $49
00E29B  1  20 A4 C9 46         .byte $20, $a4, $c9, $46
00E29F  1  20 A5 57 26         .byte $20, $a5, $57, $26
00E2A3  1  20 BC C9 4A         .byte $20, $bc, $c9, $4a
00E2A7  1  20 A5 0A D0         .byte $20, $a5, $0a, $d0, $d1, $d8, $d8, $de, $d1, $d0, $da, $de, $d1
00E2AB  1  D1 D8 D8 DE  
00E2AF  1  D1 D0 DA DE  
00E2B4  1  20 C5 17 D2         .byte $20, $c5, $17, $d2, $d3, $db, $db, $db, $d9, $db, $dc, $db, $df
00E2B8  1  D3 DB DB DB  
00E2BC  1  D9 DB DC DB  
00E2C1  1  26 26 26 26         .byte $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
00E2C5  1  26 26 26 26  
00E2C9  1  26 26 26 26  
00E2CE  1  20 E5 17 D4         .byte $20, $e5, $17, $d4, $d5, $d4, $d9, $db, $e2, $d4, $da, $db, $e0
00E2D2  1  D5 D4 D9 DB  
00E2D6  1  E2 D4 DA DB  
00E2DB  1  26 26 26 26         .byte $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
00E2DF  1  26 26 26 26  
00E2E3  1  26 26 26 26  
00E2E8  1  21 05 57 26         .byte $21, $05, $57, $26
00E2EC  1  21 05 0A D6         .byte $21, $05, $0a, $d6, $d7, $d6, $d7, $e1, $26, $d6, $dd, $e1, $e1
00E2F0  1  D7 D6 D7 E1  
00E2F4  1  26 D6 DD E1  
00E2F9  1  21 25 17 D0         .byte $21, $25, $17, $d0, $e8, $d1, $d0, $d1, $de, $d1, $d8, $d0, $d1
00E2FD  1  E8 D1 D0 D1  
00E301  1  DE D1 D8 D0  
00E306  1  26 DE D1 DE         .byte $26, $de, $d1, $de, $d1, $d0, $d1, $d0, $d1, $26, $26, $d0, $d1
00E30A  1  D1 D0 D1 D0  
00E30E  1  D1 26 26 D0  
00E313  1  21 45 17 DB         .byte $21, $45, $17, $db, $42, $42, $db, $42, $db, $42, $db, $db, $42
00E317  1  42 42 DB 42  
00E31B  1  DB 42 DB DB  
00E320  1  26 DB 42 DB         .byte $26, $db, $42, $db, $42, $db, $42, $db, $42, $26, $26, $db, $42
00E324  1  42 DB 42 DB  
00E328  1  42 26 26 DB  
00E32D  1  21 65 46 DB         .byte $21, $65, $46, $db
00E331  1  21 6B 11 DF         .byte $21, $6b, $11, $df, $db, $db, $db, $26, $db, $df, $db, $df, $db
00E335  1  DB DB DB 26  
00E339  1  DB DF DB DF  
00E33E  1  DB E4 E5 26         .byte $db, $e4, $e5, $26, $26, $ec, $ed
00E342  1  26 EC ED     
00E345  1  21 85 17 DB         .byte $21, $85, $17, $db, $db, $db, $de, $43, $db, $e0, $db, $db, $db
00E349  1  DB DB DE 43  
00E34D  1  DB E0 DB DB  
00E352  1  26 DB E3 DB         .byte $26, $db, $e3, $db, $e0, $db, $db, $e6, $e3, $26, $26, $ee, $ef
00E356  1  E0 DB DB E6  
00E35A  1  E3 26 26 EE  
00E35F  1  21 A5 17 DB         .byte $21, $a5, $17, $db, $db, $db, $db, $42, $db, $db, $db, $d4, $d9
00E363  1  DB DB DB 42  
00E367  1  DB DB DB D4  
00E36C  1  26 DB D9 DB         .byte $26, $db, $d9, $db, $db, $d4, $d9, $d4, $d9, $e7, $26, $de, $da
00E370  1  DB D4 D9 D4  
00E374  1  D9 E7 26 DE  
00E379  1  21 C4 19 5F         .byte $21, $c4, $19, $5f, $95, $95, $95, $95, $95, $95, $95, $95, $97
00E37D  1  95 95 95 95  
00E381  1  95 95 95 95  
00E386  1  98 78 95 96         .byte $98, $78, $95, $96, $95, $95, $97, $98, $97, $98, $95, $78, $95
00E38A  1  95 95 97 98  
00E38E  1  97 98 95 78  
00E393  1  F0 7A               .byte $f0, $7a
00E395  1  21 EF 0E CF         .byte $21, $ef, $0e, $cf, $01, $09, $08, $06, $24, $17, $12, $17, $1d
00E399  1  01 09 08 06  
00E39D  1  24 17 12 17  
00E3A2  1  0E 17 0D 18         .byte $0e, $17, $0d, $18
00E3A6  1  22 4D 0A 16         .byte $22, $4d, $0a, $16, $0a, $1b, $12, $18, $24, $10, $0a, $16, $0e
00E3AA  1  0A 1B 12 18  
00E3AE  1  24 10 0A 16  
00E3B3  1  22 8D 0A 15         .byte $22, $8d, $0a, $15, $1e, $12, $10, $12, $24, $10, $0a, $16, $0e
00E3B7  1  1E 12 10 12  
00E3BB  1  24 10 0A 16  
00E3C0  1  22 EB 04 1D         .byte $22, $eb, $04, $1d, $18, $19, $28
00E3C4  1  18 19 28     
00E3C7  1  22 F5 01 00         .byte $22, $f5, $01, $00
00E3CB  1  23 C9 47 55         .byte $23, $c9, $47, $55
00E3CF  1  23 D1 47 55         .byte $23, $d1, $47, $55
00E3D3  1  23 D9 47 55         .byte $23, $d9, $47, $55
00E3D7  1  23 CC 43 F5         .byte $23, $cc, $43, $f5
00E3DB  1  23 D6 01 DD         .byte $23, $d6, $01, $dd
00E3DF  1  23 DE 01 5D         .byte $23, $de, $01, $5d
00E3E3  1  23 E2 04 55         .byte $23, $e2, $04, $55, $aa, $aa, $aa
00E3E7  1  AA AA AA     
00E3EA  1  23 EA 04 95         .byte $23, $ea, $04, $95, $aa, $aa, $2a
00E3EE  1  AA AA 2A     
00E3F1  1  00 FF FF            .byte $00, $ff, $ff
00E3F4  1               
00E3F4  1               ;-------------------------------------------------------------------------------------------------
00E3F4  1               ;$06 - used to store vertical length of pipe
00E3F4  1               ;$07 - starts with adder from area parser, used to store row offset
00E3F4  1               
00E3F4  1               UpsideDownPipe_High:
00E3F4  1  A9 01               lda #$01                     ;start at second row
00E3F6  1  48                  pha
00E3F7  1  D0 03               bne UDP
00E3F9  1               UpsideDownPipe_Low:
00E3F9  1  A9 04               lda #$04                     ;start at fifth row
00E3FB  1  48                  pha
00E3FC  1  20 5C 97     UDP:   jsr GetPipeHeight            ;get pipe height from object byte
00E3FF  1  68                  pla
00E400  1  85 07               sta $07                      ;save buffer offset temporarily
00E402  1  98                  tya
00E403  1  48                  pha                          ;save pipe height temporarily
00E404  1  BC 30 07            ldy AreaObjectLength,x       ;if on second column of pipe, skip this
00E407  1  F0 23               beq NoUDP
00E409  1  20 8C 97            jsr FindEmptyEnemySlot       ;otherwise try to insert upside-down
00E40C  1  B0 1E               bcs NoUDP                    ;piranha plant, if no empty slots, skip this
00E40E  1  A9 04               lda #$04
00E410  1  20 6D 97            jsr SetupPiranhaPlant        ;set up upside-down piranha plant
00E413  1  A5 06               lda $06
00E415  1  0A                  asl
00E416  1  0A                  asl                          ;multiply height of pipe by 16
00E417  1  0A                  asl                          ;and add enemy Y position previously set up
00E418  1  0A                  asl                          ;then subtract 10 pixels, save as new Y position
00E419  1  18                  clc
00E41A  1  75 CF               adc Enemy_Y_Position,x
00E41C  1  38                  sec
00E41D  1  E9 0A               sbc #$0a
00E41F  1  95 CF               sta Enemy_Y_Position,x
00E421  1  9D 34 04            sta PiranhaPlantDownYPos,x   ;set as "down" position
00E424  1  18                  clc                          ;add 24 pixels, save as "up" position
00E425  1  69 18               adc #$18                     ;note up and down here are reversed
00E427  1  9D 17 04            sta PiranhaPlantUpYPos,x
00E42A  1  F6 A0               inc PiranhaPlant_MoveFlag,x  ;set movement flag
00E42C  1  68           NoUDP: pla
00E42D  1  A8                  tay                          ;return tile offset
00E42E  1  48                  pha
00E42F  1  A6 07               ldx $07
00E431  1  B9 26 97            lda VerticalPipeData+2,y
00E434  1  A4 06               ldy $06                      ;render the pipe shaft
00E436  1  88                  dey
00E437  1  20 C1 99            jsr RenderUnderPart
00E43A  1  68                  pla
00E43B  1  A8                  tay
00E43C  1  B9 24 97            lda VerticalPipeData,y       ;and render the pipe end
00E43F  1  9D A1 06            sta MetatileBuffer,x
00E442  1  60                  rts
00E443  1               
00E443  1  60                  rts                        ;unused, nothing jumps here
00E444  1               
00E444  1               MoveUpsideDownPiranhaP:
00E444  1  B5 1E              lda Enemy_State,x           ;check enemy state
00E446  1  D0 39              bne ExMoveUDPP              ;if set at all, branch to leave
00E448  1  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00E44B  1  D0 34              bne ExMoveUDPP              ;branch to end if not yet expired
00E44D  1  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00E44F  1  D0 0B              bne SetupToMoveUDPPlant     ;if moving, skip to part ahead
00E451  1  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00E453  1  49 FF              eor #$ff
00E455  1  18                 clc                         ;change to two's compliment
00E456  1  69 01              adc #$01
00E458  1  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00E45A  1  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00E45C  1               
00E45C  1               SetupToMoveUDPPlant:
00E45C  1  BD 17 04           lda PiranhaPlantUpYPos,x    ;get original vertical coordinate (lowest point)
00E45F  1  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00E461  1  10 03              bpl RiseFallUDPiranhaPlant  ;branch if moving downwards
00E463  1  BD 34 04           lda PiranhaPlantDownYPos,x  ;otherwise get other vertical coordinate (highest point)
00E466  1               
00E466  1               RiseFallUDPiranhaPlant:
00E466  1  85 00               sta $00                     ;save vertical coordinate here
00E468  1  AD 47 07            lda TimerControl            ;get master timer control
00E46B  1  D0 14               bne ExMoveUDPP              ;branch to leave if set (likely not necessary)
00E46D  1  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00E46F  1  18                  clc
00E470  1  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00E472  1  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00E474  1  C5 00               cmp $00                     ;compare against low or high coordinate
00E476  1  D0 09               bne ExMoveUDPP              ;branch to leave if not yet reached
00E478  1  A9 00               lda #$00
00E47A  1  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00E47C  1  A9 20               lda #$20
00E47E  1  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00E481  1               ExMoveUDPP:
00E481  1  60                  rts
00E482  1               
00E482  1               ;-------------------------------------------------------------------------------------
00E482  1               
00E482  1               BlowPlayerAround:
00E482  1  AD F9 07             lda WindFlag            ;if wind is turned off, just exit
00E485  1  F0 28                beq ExBlow
00E487  1  AD 4E 07             lda AreaType            ;don't blow the player around unless
00E48A  1  C9 01                cmp #$01                ;the area is ground type
00E48C  1  D0 21                bne ExBlow
00E48E  1  A0 01                ldy #$01
00E490  1  A5 09                lda FrameCounter        ;branch to set d0 if on an odd frame
00E492  1  0A                   asl
00E493  1  B0 02                bcs BThr                ;otherwise wind will only blow
00E495  1  A0 03                ldy #$03                ;one out of every four frames
00E497  1  84 00        BThr:   sty $00
00E499  1  A5 09                lda FrameCounter        ;throttle wind blowing by using the frame counter
00E49B  1  25 00                and $00                 ;to mask out certain frames
00E49D  1  D0 10                bne ExBlow
00E49F  1  A5 86                lda Player_X_Position   ;move player slightly to the right
00E4A1  1  18                   clc                     ;to simulate the wind moving the player
00E4A2  1  69 01                adc #$01
00E4A4  1  85 86                sta Player_X_Position
00E4A6  1  A5 6D                lda Player_PageLoc
00E4A8  1  69 00                adc #$00
00E4AA  1  85 6D                sta Player_PageLoc
00E4AC  1  EE FF 06             inc Player_X_Scroll     ;add one to movement speed for scroll
00E4AF  1  60           ExBlow: rts
00E4B0  1               
00E4B0  1               ;note the position data values are overwritten in RAM
00E4B0  1               LeavesYPos:
00E4B0  1  30 70 B8 50          .byte $30, $70, $b8, $50, $98, $30
00E4B4  1  98 30        
00E4B6  1  70 B8 50 98          .byte $70, $b8, $50, $98, $30, $70
00E4BA  1  30 70        
00E4BC  1               
00E4BC  1               LeavesXPos:
00E4BC  1  30 30 30 60          .byte $30, $30, $30, $60, $60, $a0
00E4C0  1  60 A0        
00E4C2  1  A0 A0 D0 D0          .byte $a0, $a0, $d0, $d0, $d0, $60
00E4C6  1  D0 60        
00E4C8  1               
00E4C8  1               LeavesTile:
00E4C8  1  7B 7B 7B 7B          .byte $7b, $7b, $7b, $7b, $7a, $7a
00E4CC  1  7A 7A        
00E4CE  1  7B 7B 7B 7A          .byte $7b, $7b, $7b, $7a, $7b, $7a
00E4D2  1  7B 7A        
00E4D4  1               
00E4D4  1               SimulateWind:
00E4D4  1  AD F9 07               lda WindFlag             ;if no wind, branch to leave
00E4D7  1  F0 33                  beq ExSimW
00E4D9  1  A9 04                  lda #$04                 ;play wind sfx
00E4DB  1  85 FD                  sta NoiseSoundQueue
00E4DD  1  20 25 E5               jsr ModifyLeavesPos      ;modify X and Y position data of leaves
00E4E0  1  A2 00                  ldx #$00                 ;use mostly unused sprite data offset
00E4E2  1  AC EB 06               ldy Alt_SprDataOffset-1  ;for first six leaves
00E4E5  1  BD 1C 62     DrawLeaf: lda LeavesYPosCopy,x
00E4E8  1  99 00 02               sta Sprite_Y_Position,y  ;set up sprite data in OAM memory
00E4EB  1  BD C8 E4               lda LeavesTile,x
00E4EE  1  99 01 02               sta Sprite_Tilenumber,y
00E4F1  1  A9 41                  lda #$41
00E4F3  1  99 02 02               sta Sprite_Attributes,y
00E4F6  1  BD 10 62               lda LeavesXPosCopy,x
00E4F9  1  99 03 02               sta Sprite_X_Position,y
00E4FC  1  C8                     iny
00E4FD  1  C8                     iny
00E4FE  1  C8                     iny
00E4FF  1  C8                     iny
00E500  1  E8                     inx                      ;if still on first six leaves, continue
00E501  1  E0 06                  cpx #$06                 ;using the first sprite data offset
00E503  1  D0 03                  bne DLLoop               ;otherwise use the next one instead
00E505  1  AC EC 06               ldy Alt_SprDataOffset    ;note the next one is also used by blocks
00E508  1  E0 0C        DLLoop:   cpx #$0c                 ;continue until done putting all leaves on the screen
00E50A  1  D0 D9                  bne DrawLeaf
00E50C  1  60           ExSimW:   rts
00E50D  1               
00E50D  1               LeavesPosAdder:
00E50D  1  57 57 56 56     .byte $57, $57, $56, $56, $58, $58, $56, $56, $57, $58, $57, $58
00E511  1  58 58 56 56  
00E515  1  57 58 57 58  
00E519  1  59 59 58 58     .byte $59, $59, $58, $58, $5a, $5a, $58, $58, $59, $5a, $59, $5a
00E51D  1  5A 5A 58 58  
00E521  1  59 5A 59 5A  
00E525  1               
00E525  1               ModifyLeavesPos:
00E525  1  A2 0B                 ldx #$0b
00E527  1  BD 10 62     MLPLoop: lda LeavesXPosCopy,x  ;add each adder to each X position twice
00E52A  1  18                    clc                   ;and to each Y position once
00E52B  1  7D 0D E5              adc LeavesPosAdder,x
00E52E  1  7D 0D E5              adc LeavesPosAdder,x
00E531  1  9D 10 62              sta LeavesXPosCopy,x
00E534  1  BD 1C 62              lda LeavesYPosCopy,x
00E537  1  18                    clc
00E538  1  7D 0D E5              adc LeavesPosAdder,x
00E53B  1  9D 1C 62              sta LeavesYPosCopy,x
00E53E  1  CA                    dex
00E53F  1  10 E6                 bpl MLPLoop
00E541  1  60                    rts
00E542  1               
00E542  1               WindOn:
00E542  1  A9 01             lda #$01             ;branch to turn the wind on
00E544  1  D0 02             bne WOn
00E546  1               WindOff:
00E546  1  A9 00             lda #$00             ;turn the wind off
00E548  1  8D F9 07     WOn: sta WindFlag
00E54B  1  60                rts
00E54C  1               
00E54C  1               InitializeLeaves:
00E54C  1  A0 0B              ldy #$0b              ;start counter
00E54E  1  B9 BC E4     WLp:  lda LeavesXPos,y      ;initialize leaf positions
00E551  1  99 10 62           sta LeavesXPosCopy,y
00E554  1  B9 B0 E4           lda LeavesYPos,y
00E557  1  99 1C 62           sta LeavesYPosCopy,y
00E55A  1  88                 dey                   ;decrement counter
00E55B  1  10 F1              bpl WLp               ;branch if not done initalizing leaves
00E55D  1  60                 rts                   ;leave
00E55E  1               
00E55E  1               ;-------------------------------------------------------------------------------------
00E55E  1               
00E55E  1               GoToDemoReset:
00E55E  1  4C 74 E2            jmp DemoReset
00E561  1               
00E561  1               PrintWorld9Msgs:
00E561  1  AD 5F 07            lda WorldNumber           ;check if we are in world 9
00E564  1  C9 08               cmp #World9
00E566  1  D0 F6               bne GoToDemoReset         ;if we aren't, leave
00E568  1  AD 70 07            lda OperMode              ;if in game over mode, branch
00E56B  1  C9 03               cmp #GameOverMode
00E56D  1  F0 1A               beq W9GameOver
00E56F  1  AD F5 07            lda FantasyW9MsgFlag      ;if world 9 flag was set earlier, skip this part
00E572  1  D0 0D               bne NoFW9
00E574  1  A9 1D               lda #$1d                  ;otherwise set VRAM pointer to print
00E576  1  8D 73 07            sta VRAM_Buffer_AddrCtrl  ;the hidden fantasy "9 world" message
00E579  1  A9 10               lda #$10
00E57B  1  8D A0 07            sta ScreenTimer
00E57E  1  EE F5 07            inc FantasyW9MsgFlag      ;and set flag to keep it from getting printed again
00E581  1  A9 00        NoFW9: lda #$00
00E583  1  8D 74 07            sta DisableScreenFlag     ;turn screen back on, move on to next screen sub
00E586  1  4C B4 E5            jmp NextScreenTask
00E589  1               
00E589  1               W9GameOver:
00E589  1  A9 20            lda #$20
00E58B  1  8D A0 07         sta ScreenTimer
00E58E  1  A9 1E            lda #$1e                  ;set VRAM pointer to print world 9 goodbye message
00E590  1  8D 73 07         sta VRAM_Buffer_AddrCtrl
00E593  1  4C CE E5         jmp NextOperTask          ;move on to next task
00E596  1               
00E596  1               ScreenSubsForFinalRoom:
00E596  1  AD 3C 07         lda ScreenRoutineTask
00E599  1  20 69 8C         jsr JumpEngine
00E59C  1               
00E59C  1  A8 84            .word InitScreenPalette
00E59E  1  rr rr            .word BANK_PractiseWriteTopStatusLine
00E5A0  1  rr rr            .word BANK_PractiseWriteBottomStatusLine
00E5A2  1                   ;REPLACED;.word WriteTopStatusLine
00E5A2  1                   ;REPLACED;.word WriteBottomStatusLine
00E5A2  1  AA E5            .word DrawFinalRoom
00E5A4  1  D1 84            .word GetAreaPalette
00E5A6  1  F5 84            .word GetBackgroundColor
00E5A8  1  B8 E5            .word RevealPrincess
00E5AA  1               
00E5AA  1               DrawFinalRoom:
00E5AA  1  A9 1C            lda #$1c                   ;draw the princess's room
00E5AC  1  8D 73 07         sta VRAM_Buffer_AddrCtrl
00E5AF  1  A9 00            lda #$00
00E5B1  1  8D 22 07         sta IRQUpdateFlag
00E5B4  1               NextScreenTask:
00E5B4  1  EE 3C 07         inc ScreenRoutineTask
00E5B7  1  60               rts
00E5B8  1               
00E5B8  1               RevealPrincess:
00E5B8  1  A9 A2            lda #$a2                   ;print game timer
00E5BA  1  20 65 8D         jsr PrintStatusBarNumbers
00E5BD  1  A9 04            lda #VictoryMusic          ;play victory music
00E5BF  1  85 FC            sta EventMusicQueue
00E5C1  1  A9 00            lda #$00
00E5C3  1  85 0C            sta $0c                    ;residual, this does nothing
00E5C5  1  8D 7A 07         sta NameTableSelect
00E5C8  1  8D 22 07         sta IRQUpdateFlag   ;turn screen back on but without IRQ
00E5CB  1  8D 74 07         sta DisableScreenFlag
00E5CE  1               NextOperTask:
00E5CE  1  EE 72 07         inc OperMode_Task
00E5D1  1  60               rts
00E5D2  1               
00E5D2  1               PrintVictoryMsgsForWorld8:
00E5D2  1  AD 49 07              lda MsgFractional          ;if fractional not looped to zero
00E5D5  1  D0 22                 bne IncVMC                 ;then branch to increment it
00E5D7  1  AC 19 07              ldy MsgCounter
00E5DA  1  C0 0A                 cpy #$0a                   ;if message counter gone past a certain
00E5DC  1  B0 2D                 bcs EndVictoryMessages     ;point, branch to set timer and stop printing messages
00E5DE  1  C8                    iny
00E5DF  1  C8                    iny
00E5E0  1  C8                    iny                        ;add 3 to message counter to print the messages for world 8
00E5E1  1  AD 53 07              lda SelectedPlayer         ;check selected player
00E5E4  1  F0 0C                 beq PrintVM                ;if mario, use standard message offset
00E5E6  1  C0 04                 cpy #$04                   ;are we thanking the player?
00E5E8  1  D0 02                 bne HurrahM                ;if not, branch
00E5EA  1  A0 0D                 ldy #$0d                   ;otherwise use alt offset for luigi
00E5EC  1  C0 07        HurrahM: cpy #$07                   ;are we printing the hurrah message?
00E5EE  1  D0 02                 bne PrintVM                ;if not, branch
00E5F0  1  A0 0E                 ldy #$0e                   ;otherwise use alt offset for luigi
00E5F2  1  98           PrintVM: tya
00E5F3  1  18                    clc
00E5F4  1  69 0C                 adc #$0c                   ;get appropriate range for victory messages
00E5F6  1  8D 73 07              sta VRAM_Buffer_AddrCtrl
00E5F9  1  AD 49 07     IncVMC:  lda MsgFractional
00E5FC  1  18                    clc
00E5FD  1  69 04                 adc #$04                   ;add four to counter's fractional
00E5FF  1  8D 49 07              sta MsgFractional
00E602  1  AD 19 07              lda MsgCounter             ;add carry to the message counter itself
00E605  1  69 00                 adc #$00
00E607  1  8D 19 07              sta MsgCounter
00E60A  1  60                    rts
00E60B  1               
00E60B  1               EndVictoryMessages:
00E60B  1  A9 0C                lda #$0c                   ;set interval timer, then move onto next task
00E60D  1  8D A1 07             sta WorldEndTimer
00E610  1  EE 72 07     ExAEL:  inc OperMode_Task
00E613  1               
00E613  1               EraseEndingCounters:
00E613  1  A9 00                lda #$00
00E615  1  8D 61 07             sta EndControlCntr
00E618  1  8D 62 07             sta MRetainerOffset
00E61B  1  8D 63 07             sta CurrentFlashMRet
00E61E  1  60           NotYet: rts
00E61F  1               
00E61F  1               AwardExtraLives:
00E61F  1  AD A1 07         lda WorldEndTimer          ;wait until timer expires before running this sub
00E622  1  D0 FA            bne NotYet
00E624  1  AD 5A 07         lda NumberofLives          ;if counted all extra lives, branch
00E627  1  30 E7            bmi ExAEL                  ;to run another task in victory mode
00E629  1  AD 80 07         lda SelectTimer
00E62C  1  D0 F0            bne NotYet                 ;if short delay between each count of extra lives
00E62E  1  A9 30            lda #$30                   ;not expired, wait, otherwise, reset the timer
00E630  1  8D 80 07         sta SelectTimer
00E633  1  A9 40            lda #Sfx_ExtraLife
00E635  1  85 FE            sta Square2SoundQueue
00E637  1  CE 5A 07         dec NumberofLives          ;count down each extra life
00E63A  1  A9 01            lda #$01                   ;give 100,000 points to player for each one
00E63C  1  8D 35 01         sta DigitModifier+1
00E63F  1  4C 54 BF         jmp EndAreaPoints
00E642  1               
00E642  1               BlueTransPalette:
00E642  1  3F 00 10         .byte $3f, $00, $10
00E645  1  0F 30 0F 0F      .byte $0f, $30, $0f, $0f, $0f, $30, $10, $00, $0f, $21, $12, $21, $0f, $27, $17, $00
00E649  1  0F 30 10 00  
00E64D  1  0F 21 12 21  
00E655  1  00               .byte $00
00E656  1               
00E656  1               BlueTints:
00E656  1  01 02 11 21      .byte $01, $02, $11, $21
00E65A  1               
00E65A  1               TwoBlankRows:
00E65A  1  22 86 55 24      .byte $22, $86, $55, $24
00E65E  1  22 A6 55 24      .byte $22, $a6, $55, $24
00E662  1  00               .byte $00
00E663  1               
00E663  1               FadeToBlue:
00E663  1  EE 61 07               inc EndControlCntr   ;increment a counter
00E666  1  AD 63 07               lda BlueDelayFlag    ;if it's time to fade to blue, branch
00E669  1  D0 0D                  bne BlueUpdateTiming
00E66B  1  AD 61 07               lda EndControlCntr
00E66E  1  29 FF                  and #$ff             ;otherwise wait until counter wraps
00E670  1  D0 36                  bne ExFade           ;then set the flag
00E672  1  EE 63 07               inc BlueDelayFlag
00E675  1  4C 7F E6               jmp BlueUpd          ;skip over next part if the flag was just set
00E678  1               
00E678  1               BlueUpdateTiming:
00E678  1  AD 61 07                lda EndControlCntr
00E67B  1  29 0F                   and #$0f               ;execute the next part only every 16 frames
00E67D  1  D0 29                   bne ExFade
00E67F  1  A2 13        BlueUpd:   ldx #$13
00E681  1  BD 42 E6     BlueULoop: lda BlueTransPalette,x ;write palette to VRAM buffer
00E684  1  9D 01 03                sta VRAM_Buffer1,x
00E687  1  CA                      dex
00E688  1  10 F7                   bpl BlueULoop
00E68A  1  A2 0C                   ldx #$0c
00E68C  1  AC 62 07                ldy BlueColorOfs       ;get color offset
00E68F  1  B9 56 E6     NextBlue:  lda BlueTints,y        ;set background color based on color offset
00E692  1  9D 04 03                sta VRAM_Buffer1+3,x
00E695  1  CA                      dex                    ;be sure to set the same background color
00E696  1  CA                      dex                    ;in all four palettes (even though only the first
00E697  1  CA                      dex                    ;one is acknowledged)
00E698  1  CA                      dex
00E699  1  10 F4                   bpl NextBlue
00E69B  1  EE 62 07                inc BlueColorOfs       ;increment to next color which will show up
00E69E  1  AD 62 07                lda BlueColorOfs       ;16 frames later, thus causing a slow color change
00E6A1  1  C9 04                   cmp #$04               ;if not changed to last color, leave
00E6A3  1  D0 03                   bne ExFade
00E6A5  1  EE 72 07                inc OperMode_Task      ;otherwise move on to the next task
00E6A8  1  60           ExFade:    rts
00E6A9  1               
00E6A9  1               EraseLivesLines:
00E6A9  1  A2 08             ldx #$08                  ;erase bottom two lines
00E6AB  1  BD 5A E6     ELL: lda TwoBlankRows,x
00E6AE  1  9D 01 03          sta VRAM_Buffer1,x
00E6B1  1  CA                dex
00E6B2  1  10 F7             bpl ELL
00E6B4  1  EE 72 07          inc OperMode_Task
00E6B7  1  20 13 E6          jsr EraseEndingCounters   ;init ending counters
00E6BA  1  A9 60             lda #$60
00E6BC  1  8D 64 07          sta MushroomRetDelay      ;wait before flashing each mushroom retainer in next sub
00E6BF  1  60                rts
00E6C0  1               
00E6C0  1               RunMushroomRetainers:
00E6C0  1  20 33 E7            jsr MushroomRetainersForW8  ;draw and flash the seven mushroom retainers
00E6C3  1  AD B1 07            lda EventMusicBuffer        ;if still playing victory music, branch to leave
00E6C6  1  D0 08               bne ExRMR
00E6C8  1  AD FB 07            lda HardWorldFlag           ;if on world D, branch elsewhere
00E6CB  1  D0 1D               bne BackToNormal
00E6CD  1  EE 72 07            inc OperMode_Task           ;otherwise just move onto the last task
00E6D0  1  60           ExRMR: rts
00E6D1  1               
00E6D1  1               EndingDiskRoutines:
00E6D1  1  AD FC 07         lda DiskIOTask
00E6D4  1  20 69 8C         jsr JumpEngine
00E6D7  1               
00E6D7  1  5F E0            .word DiskScreen
00E6D9  1  DB E6            .word UpdateGamesBeaten
00E6DB  1               
00E6DB  1               UpdateGamesBeaten:
00E6DB  1  AD 07 60         lda GamesBeatenCount     ;get the new count of games beaten
00E6DE  1  18               clc                      ;note that this code is skipped if on world D
00E6DF  1  69 01            adc #$01                 ;add one to it, to a maximum of 24/$18
00E6E1  1  C9 19            cmp #25
00E6E3  1  90 02            bcc SetS2S
00E6E5  1  A9 18            lda #24                  ;sorry, only 24 stars allowed
00E6E7  1               SetS2S:
00E6E7  1  8D 07 60         sta GamesBeatenCount
00E6EA  1               
00E6EA  1               BackToNormal:
00E6EA  1  A9 00            lda #$00
00E6EC  1  8D FC 07         sta DiskIOTask           ;erase task numbers
00E6EF  1  8D 72 07         sta OperMode_Task
00E6F2  1  AD FB 07         lda HardWorldFlag        ;if in world D, branch to end the game
00E6F5  1  D0 07            bne EndTheGame
00E6F7  1  AD FA 07         lda CompletedWorlds      ;if completed all worlds without skipping over any
00E6FA  1  C9 FF            cmp #$ff                 ;then branch elsewhere (note warping backwards may
00E6FC  1  F0 0B            beq GoToWorld9           ;allow player to complete skipped worlds)
00E6FE  1               EndTheGame:
00E6FE  1  A9 00            lda #$00
00E700  1  8D FA 07         sta CompletedWorlds      ;init completed worlds flag, go back to title screen mode
00E703  1  8D 70 07         sta OperMode
00E706  1  4C 94 DF         jmp AttractModeSubs      ;jump to title screen mode routines
00E709  1               GoToWorld9:
00E709  1  A9 00            lda #$00
00E70B  1  8D FA 07         sta CompletedWorlds      ;init completed worlds flag
00E70E  1  8D 5A 07         sta NumberofLives        ;give the player one life
00E711  1  8D F5 07         sta FantasyW9MsgFlag
00E714  1  4C 89 83         jmp NextWorld            ;run world 9
00E717  1               
00E717  1               FlashMRSpriteDataOfs:
00E717  1  50 B0 E0 68      .byte $50, $b0, $e0, $68, $98, $c8
00E71B  1  98 C8        
00E71D  1               
00E71D  1               MRSpriteDataOfs:
00E71D  1  80 50 68 80      .byte $80, $50, $68, $80, $98, $b0, $c8
00E721  1  98 B0 C8     
00E724  1               
00E724  1               MRetainerYPos:
00E724  1  E0 B8 90 70      .byte $e0, $b8, $90, $70, $68, $70, $90
00E728  1  68 70 90     
00E72B  1               
00E72B  1               MRetainerXPos:
00E72B  1  B8 38 48 60      .byte $b8, $38, $48, $60, $80, $a0, $b8, $c8
00E72F  1  80 A0 B8 C8  
00E733  1               
00E733  1               MushroomRetainersForW8:
00E733  1  AD 64 07         lda MushroomRetDelay        ;wait a bit unless waiting is already done
00E736  1  F0 04            beq DrawFlashMRetainers
00E738  1  CE 64 07         dec MushroomRetDelay
00E73B  1  60               rts
00E73C  1               
00E73C  1               DrawFlashMRetainers:
00E73C  1  20 33 82         jsr MoveSpritesOffscreen   ;init sprites
00E73F  1  AE 62 07         ldx MRetainerOffset
00E742  1  E0 07            cpx #$07                   ;if 7 mushroom retainers added, branch elsewhere
00E744  1  F0 11            beq FlashMRetainers
00E746  1  AD 61 07         lda EndControlCntr
00E749  1  29 1F            and #$1f                   ;execute this part once every 32 frames
00E74B  1  D0 20            bne DrawMRetainers
00E74D  1  EE 62 07         inc MRetainerOffset        ;add another mushroom retainer
00E750  1  A9 01            lda #Sfx_CoinGrab
00E752  1  85 FE            sta Square2SoundQueue      ;play the coin grab sound
00E754  1  4C 6D E7         jmp DrawMRetainers
00E757  1               
00E757  1               FlashMRetainers:
00E757  1  AD 61 07         lda EndControlCntr
00E75A  1  29 1F            and #$1f                   ;execute this part once every 32 frames also
00E75C  1  D0 0F            bne DrawMRetainers         ;after the counter reaches a certain point
00E75E  1  EE 63 07         inc CurrentFlashMRet
00E761  1  AD 63 07         lda CurrentFlashMRet       ;increment what's now being used to select a
00E764  1  C9 0B            cmp #$0b                   ;mushroom retainer to flash, if not yet at $0b/11
00E766  1  90 05            bcc DrawMRetainers         ;then go ahead to next part
00E768  1  A9 04            lda #$04
00E76A  1  8D 63 07         sta CurrentFlashMRet       ;otherwise reset to 4
00E76D  1               DrawMRetainers:
00E76D  1  EE 61 07         inc EndControlCntr         ;be sure to count frames
00E770  1  AD 5F 07         lda WorldNumber
00E773  1  48               pha                        ;save world number and initial retainer offset
00E774  1  AD 62 07         lda MRetainerOffset
00E777  1  48               pha
00E778  1  AA               tax                        ;use second counter as offset to one of the spr data offset lists
00E779  1               DrawMRetLoop:
00E779  1  AD 63 07         lda CurrentFlashMRet       ;if offset not yet at 4 (first time it starts at 0), branch to skip this
00E77C  1  C9 04            cmp #$04                   ;thus adding a delay between the appearance
00E77E  1  90 0B            bcc SetupMRet              ;of mushroom retainers and their "flashing"
00E780  1  E9 04            sbc #$04
00E782  1  A8               tay                        ;otherwise subtract 4 to get the offset proper
00E783  1  B9 17 E7         lda FlashMRSpriteDataOfs,y ;if the sprite obj data offset pointed at by the current flashing retainer
00E786  1  DD 1D E7         cmp MRSpriteDataOfs,x      ;matches the one pointed at by the offset of the retainer being checked
00E789  1  F0 1F            beq NextMRet               ;then branch to skip, do not draw that mushroom retainer
00E78B  1               SetupMRet:
00E78B  1  BC 1D E7         ldy MRSpriteDataOfs,x      ;get sprite data offset of the current mushroom retainer
00E78E  1  8C E5 06         sty Enemy_SprDataOffset
00E791  1  A9 35            lda #$35
00E793  1  85 16            sta $16                    ;set mushroom retainer object ID
00E795  1  BD 24 E7         lda MRetainerYPos,x
00E798  1  85 CF            sta Enemy_Y_Position       ;use enemy object 0 for mushroom retainer temporarily
00E79A  1  BD 2B E7         lda MRetainerXPos,x
00E79D  1  8D AE 03         sta Enemy_Rel_XPos
00E7A0  1  A2 00            ldx #$00                   ;set world number and object offset for the graphics handler
00E7A2  1  8E 5F 07         stx WorldNumber            ;to prevent graphics handler from drawing princess instead
00E7A5  1  86 08            stx ObjectOffset
00E7A7  1  20 08 D5         jsr EnemyGfxHandler        ;now draw the mushroom retainer
00E7AA  1               NextMRet:
00E7AA  1  CE 62 07         dec MRetainerOffset        ;move to next mushroom retainer using offset
00E7AD  1  AE 62 07         ldx MRetainerOffset
00E7B0  1  D0 C7            bne DrawMRetLoop           ;if not drawn all retainers yet, loop to do so
00E7B2  1  68               pla
00E7B3  1  8D 62 07         sta MRetainerOffset        ;reset initial offset
00E7B6  1  68               pla
00E7B7  1  8D 5F 07         sta WorldNumber            ;return world number to what it was to draw princess
00E7BA  1  A9 30            lda #$30
00E7BC  1  8D E5 06         sta Enemy_SprDataOffset
00E7BF  1  A9 B8            lda #$b8                   ;return original settings princess uses (note X position
00E7C1  1  85 CF            sta Enemy_Y_Position       ;will be returned later in enemy object core)
00E7C3  1  60               rts
00E7C4  1               
00E7C4  1               ;-------------------------------------------------------------------------------------
00E7C4  1               
00E7C4  1               FinalRoomPalette:
00E7C4  1  3F 00 10         .byte $3f, $00, $10
00E7C7  1  0F 0F 0F 0F      .byte $0f, $0f, $0f, $0f, $0f, $30, $10, $00
00E7CB  1  0F 30 10 00  
00E7CF  1  0F 21 12 02      .byte $0f, $21, $12, $02, $0f, $27, $17, $00
00E7D3  1  0F 27 17 00  
00E7D7  1  00               .byte $00
00E7D8  1               
00E7D8  1               MarioThankYouMsgFinal:
00E7D8  1  20 E8 10         .byte $20, $e8, $10
00E7DB  1  1D 11 0A 17      .byte $1d, $11, $0a, $17, $14, $24, $22, $18, $1e, $24
00E7DF  1  14 24 22 18  
00E7E3  1  1E 24        
00E7E5  1  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18, $2b
00E7E9  1  18 2B        
00E7EB  1  23 C8 48 05      .byte $23, $c8, $48, $05
00E7EF  1  00               .byte $00
00E7F0  1               
00E7F0  1               LuigiThankYouMsgFinal:
00E7F0  1  20 E8 10         .byte $20, $e8, $10
00E7F3  1  1D 11 0A 17      .byte $1d, $11, $0a, $17, $14, $24, $22, $18, $1e, $24
00E7F7  1  14 24 22 18  
00E7FB  1  1E 24        
00E7FD  1  15 1E 12 10      .byte $15, $1e, $12, $10, $12, $2b
00E801  1  12 2B        
00E803  1  23 C8 48 05      .byte $23, $c8, $48, $05
00E807  1  00               .byte $00
00E808  1               
00E808  1               PeaceIsPavedMsg:
00E808  1  21 09 0E         .byte $21, $09, $0e
00E80B  1  19 0E 0A 0C      .byte $19, $0e, $0a, $0c, $0e, $24, $12, $1c, $24
00E80F  1  0E 24 12 1C  
00E813  1  24           
00E814  1  19 0A 1F 0E      .byte $19, $0a, $1f, $0e, $0d
00E818  1  0D           
00E819  1  23 D0 58 AA      .byte $23, $d0, $58, $aa
00E81D  1  00               .byte $00
00E81E  1               
00E81E  1               WithKingdomSavedMsg:
00E81E  1  21 47 12         .byte $21, $47, $12
00E821  1  20 12 1D 11      .byte $20, $12, $1d, $11, $24, $14, $12, $17, $10, $0d, $18, $16, $24
00E825  1  24 14 12 17  
00E829  1  10 0D 18 16  
00E82E  1  1C 0A 1F 0E      .byte $1c, $0a, $1f, $0e, $0d
00E832  1  0D           
00E833  1  00               .byte $00
00E834  1               
00E834  1               MarioHurrahMsg:
00E834  1  21 89 10         .byte $21, $89, $10
00E837  1  11 1E 1B 1B      .byte $11, $1e, $1b, $1b, $0a, $11, $24, $1d, $18, $24, $24, $16, $0a
00E83B  1  0A 11 24 1D  
00E83F  1  18 24 24 16  
00E844  1  1B 12 18         .byte $1b, $12, $18
00E847  1  00               .byte $00
00E848  1               
00E848  1               LuigiHurrahMsg:
00E848  1  21 89 10         .byte $21, $89, $10
00E84B  1  11 1E 1B 1B      .byte $11, $1e, $1b, $1b, $0a, $11, $24, $1d, $18, $24, $24, $15, $1e
00E84F  1  0A 11 24 1D  
00E853  1  18 24 24 15  
00E858  1  12 10 12         .byte $12, $10, $12
00E85B  1  00               .byte $00
00E85C  1               
00E85C  1               OurOnlyHeroMsg:
00E85C  1  21 CA 0D         .byte $21, $ca, $0d
00E85F  1  18 1E 1B 24      .byte $18, $1e, $1b, $24, $18, $17, $15, $22, $24, $11, $0e, $1b, $18
00E863  1  18 17 15 22  
00E867  1  24 11 0E 1B  
00E86C  1  00               .byte $00
00E86D  1               
00E86D  1               ThisEndsYourTripMsg:
00E86D  1  22 07 13         .byte $22, $07, $13
00E870  1  1D 11 12 1C      .byte $1d, $11, $12, $1c, $24, $0e, $17, $0d, $1c, $24, $22, $18, $1e
00E874  1  24 0E 17 0D  
00E878  1  1C 24 22 18  
00E87D  1  1B 24 1D 1B      .byte $1b, $24, $1d, $1b, $12, $19
00E881  1  12 19        
00E883  1  00               .byte $00
00E884  1               
00E884  1               OfALongFriendshipMsg:
00E884  1  22 46 14         .byte $22, $46, $14
00E887  1  18 0F 24 0A      .byte $18, $0f, $24, $0a, $24, $15, $18, $17, $10, $24, $0f, $1b, $12
00E88B  1  24 15 18 17  
00E88F  1  10 24 0F 1B  
00E894  1  0E 17 0D 1C      .byte $0e, $17, $0d, $1c, $11, $12, $19
00E898  1  11 12 19     
00E89B  1  00               .byte $00
00E89C  1               
00E89C  1               PointsAddedMsg:
00E89C  1  22 88 10         .byte $22, $88, $10
00E89F  1  01 00 00 00      .byte $01, $00, $00, $00, $00, $00, $24, $19, $1d, $1c, $af, $0a, $0d
00E8A3  1  00 00 24 19  
00E8A7  1  1D 1C AF 0A  
00E8AC  1  0D 0E 0D         .byte $0d, $0e, $0d
00E8AF  1               
00E8AF  1  23 E8 48 FF      .byte $23, $e8, $48, $ff
00E8B3  1  00               .byte $00
00E8B4  1               
00E8B4  1               ForEachPlayerLeftMsg:
00E8B4  1  22 A6 15         .byte $22, $a6, $15
00E8B7  1  0F 18 1B 24      .byte $0f, $18, $1b, $24, $0e, $0a, $0c, $11, $24, $19, $15, $0a, $22
00E8BB  1  0E 0A 0C 11  
00E8BF  1  24 19 15 0A  
00E8C4  1  0E 1B 24 15      .byte $0e, $1b, $24, $15, $0e, $0f, $1d, $af
00E8C8  1  0E 0F 1D AF  
00E8CC  1  00               .byte $00
00E8CD  1               
00E8CD  1               PrincessPeachsRoom:
00E8CD  1  20 80 60 5E      .byte $20, $80, $60, $5e
00E8D1  1  20 A0 60 5D      .byte $20, $a0, $60, $5d
00E8D5  1  23 40 60 5E      .byte $23, $40, $60, $5e
00E8D9  1  23 60 60 5D      .byte $23, $60, $60, $5d
00E8DD  1  23 80 60 5E      .byte $23, $80, $60, $5e
00E8E1  1  23 A0 60 5D      .byte $23, $a0, $60, $5d
00E8E5  1  23 C0 50 55      .byte $23, $c0, $50, $55
00E8E9  1  23 F0 50 55      .byte $23, $f0, $50, $55
00E8ED  1  00               .byte $00
00E8EE  1               
00E8EE  1               FantasyWorld9Msg:
00E8EE  1  22 24 18         .byte $22, $24, $18
00E8F1  1  20 0E 24 19      .byte $20, $0e, $24, $19, $1b, $0e, $1c, $0e, $17, $1d, $24, $0f, $0a
00E8F5  1  1B 0E 1C 0E  
00E8F9  1  17 1D 24 0F  
00E8FE  1  17 1D 0A 1C      .byte $17, $1d, $0a, $1c, $22, $24, $20, $18, $1b, $15, $0d
00E902  1  22 24 20 18  
00E906  1  1B 15 0D     
00E909  1               
00E909  1  22 66 13         .byte $22, $66, $13
00E90C  1  15 0E 1D F2      .byte $15, $0e, $1d, $f2, $1c, $24, $1d, $1b, $22, $24, $76, $09, $24
00E910  1  1C 24 1D 1B  
00E914  1  22 24 76 09  
00E919  1  20 18 1B 15      .byte $20, $18, $1b, $15, $0d, $75
00E91D  1  0D 75        
00E91F  1               
00E91F  1  22 A9 0E         .byte $22, $a9, $0e
00E922  1  20 12 1D 11      .byte $20, $12, $1d, $11, $24, $18, $17, $0e, $24, $10, $0a, $16, $0e
00E926  1  24 18 17 0E  
00E92A  1  24 10 0A 16  
00E92F  1  AF               .byte $af
00E930  1  00               .byte $00
00E931  1               
00E931  1               SuperPlayerMsg:
00E931  1  21 E0 60 24      .byte $21, $e0, $60, $24
00E935  1  22 40 60 24      .byte $22, $40, $60, $24
00E939  1  22 25 16         .byte $22, $25, $16
00E93C  1  22 18 1E F2      .byte $22, $18, $1e, $f2, $1b, $0e, $24, $0a, $24, $1c, $1e, $19, $0e
00E940  1  1B 0E 24 0A  
00E944  1  24 1C 1E 19  
00E949  1  1B 24 19 15      .byte $1b, $24, $19, $15, $0a, $22, $0e, $1b, $2b
00E94D  1  0A 22 0E 1B  
00E951  1  2B           
00E952  1  22 69 0D         .byte $22, $69, $0d
00E955  1  20 0E 24 11      .byte $20, $0e, $24, $11, $18, $19, $0e, $24, $20, $0e, $f2, $15, $15
00E959  1  18 19 0E 24  
00E95D  1  20 0E F2 15  
00E962  1  22 A9 0E         .byte $22, $a9, $0e
00E965  1  1C 0E 0E 24      .byte $1c, $0e, $0e, $24, $22, $18, $1e, $24, $0a, $10, $0a, $12, $17
00E969  1  22 18 1E 24  
00E96D  1  0A 10 0A 12  
00E972  1  AF               .byte $af
00E973  1  22 E8 10         .byte $22, $e8, $10
00E976  1  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18, $24, $0a, $17, $0d, $24, $1c, $1d, $0a
00E97A  1  18 24 0A 17  
00E97E  1  0D 24 1C 1D  
00E983  1  0F 0F AF         .byte $0f, $0f, $af
00E986  1  00               .byte $00
00E987  1               
00E987  1               ;-------------------------------------------------------------------------------------
00E987  1               
00E987  1  FF FF FF FF  .res $FE00 - *, $FF
00E98B  1  FF FF FF FF  
00E98F  1  FF FF FF FF  
00FE00  1               
00FE00  1               SM2Header:
00FE00  1  53 4D 32 53          .byte "SM2SAVE"
00FE04  1  41 56 45     
00FE07  1               
00FE07  1               CheckSaveData:
00FE07  1  A2 00                ldx #$00                ;init counter
00FE09  1  BD 00 FE     SChkLp: lda SM2Header,x         ;check all seven bytes of the save data header
00FE0C  1  DD 00 60             cmp SaveDataHeader,x    ;and see if it is identical to what it should be
00FE0F  1  D0 06                bne InitializeSaveData  ;if any byte does not match, wipe existing save data
00FE11  1  E8                   inx
00FE12  1  E0 07                cpx #$07                ;have we gone through all seven bytes?
00FE14  1  90 F3                bcc SChkLp              ;if not, loop back
00FE16  1  60                   rts                     ;otherwise save data is valid, leave
00FE17  1               InitializeSaveData:
00FE17  1  A2 00                ldx #$00                ;init counter
00FE19  1  8E 07 60             stx GamesBeatenCount    ;wipe number of games beaten
00FE1C  1  BD 00 FE     SaveLp: lda SM2Header,x         ;write save data header
00FE1F  1  9D 00 60             sta SaveDataHeader,x
00FE22  1  E8                   inx
00FE23  1  E0 07                cpx #$07                ;have we gone through all seven bytes?
00FE25  1  90 F5                bcc SaveLp              ;if not, loop back
00FE27  1  60                   rts                     ;otherwise we have reset save data, leave
00FE28  1               
00FE28  1               IRQHandler:
00FE28  1  78           	sei
00FE29  1  08           	php                      ;save regs
00FE2A  1  48           	pha
00FE2B  1  8A           	txa
00FE2C  1  48           	pha
00FE2D  1  98           	tya
00FE2E  1  48           	pha
00FE2F  1  A0 06              ldy #$06                 ;delay for right part of scanline 31
00FE31  1  88           DelS: dey
00FE32  1  D0 FD              bne DelS
00FE34  1  AD 78 07     	lda Mirror_PPU_CTRL
00FE37  1  29 EF        	and #$ef                 ;mask out sprite address high reg of ctrl reg mirror
00FE39  1  0D 7A 07     	ora NameTableSelect      ;mask in whatever's set here
00FE3C  1  8D 78 07     	sta Mirror_PPU_CTRL      ;update the register and its mirror
00FE3F  1  8D 00 20     	sta PPU_CTRL
00FE42  1  A9 00        	lda #$00
00FE44  1  8D 00 E0     	sta MMC3_IRQDisable      ;disable IRQs for the rest of the frame
00FE47  1  AD 3F 07     	lda HorizontalScroll
00FE4A  1  8D 05 20     	sta PPU_SCROLL           ;set scroll regs for the screen under the status bar
00FE4D  1  AD 40 07     	lda VerticalScroll       ;to achieve the split screen effect
00FE50  1  8D 05 20     	sta PPU_SCROLL
00FE53  1  A9 00        	lda #$00
00FE55  1  8D 7B 07     	sta IRQAckFlag           ;indicate IRQ was acknowledged
00FE58  1  68           	pla
00FE59  1  A8           	tay                      ;return regs, reenable IRQs and leave
00FE5A  1  68           	pla
00FE5B  1  AA           	tax
00FE5C  1  68           	pla
00FE5D  1  28           	plp
00FE5E  1  58           	cli
00FE5F  1  40           	rti
00FE60  1               
00FE60  1               Reset:
00FE60  1  78           	sei                        ;replicate init code present in FDS BIOS
00FE61  1  A9 10        	lda #$10
00FE63  1  8D 00 20     	sta PPU_CTRL
00FE66  1  D8           	cld
00FE67  1  A9 06        	lda #$06
00FE69  1  8D 01 20     	sta PPU_MASK
00FE6C  1  A2 02        	ldx #$02
00FE6E  1               VBlank:
00FE6E  1  AD 02 20     	lda PPU_STATUS
00FE71  1  10 FB        	bpl VBlank
00FE73  1  CA           	dex
00FE74  1  D0 F8        	bne VBlank
00FE76  1  8E 16 40     	stx JOYPAD_PORT1
00FE79  1  8E 10 40     	stx SND_DELTA_REG
00FE7C  1  A9 C0        	lda #$c0
00FE7E  1  8D 17 40     	sta JOYPAD_PORT2
00FE81  1  A9 0F        	lda #$0f
00FE83  1  8D 15 40     	sta SND_MASTERCTRL_REG
00FE86  1  A2 FF        	ldx #$ff
00FE88  1  9A           	txs
00FE89  1  A9 00        	lda #$00
00FE8B  1  8D 00 A0     	sta MMC3_Mirroring          ; vertical mirroring
00FE8E  1  A9 80        	lda #%10000000
00FE90  1  8D 01 A0     	sta MMC3_PRGRAMProtect      ; enable PRG-RAM
00FE93  1  20 FC FE     	jsr LoadGameBank            ;switch PRG banks
00FE96  1  20 A2 FE     	jsr InitializeBG_CHR        ;init CHR banks
00FE99  1  20 BF FE           jsr InitializeSPR_CHR
00FE9C  1  20 07 FE     	jsr CheckSaveData           ;check validity of save data
00FE9F  1  4C 00 80     	jmp Start                   ;now start the game!
00FEA2  1               
00FEA2  1               InitializeBG_CHR:
00FEA2  1  A9 80              lda #BG_MainBank
00FEA4  1  20 B4 FE           jsr SwitchBG_CHR0
00FEA7  1  A9 82              lda #BG_MainBank+2
00FEA9  1               SwitchBG_CHR1:
00FEA9  1  48           	pha
00FEAA  1  A9 01        	lda #%00000001
00FEAC  1  8D 00 80     	sta MMC3_BankSelect
00FEAF  1  68           	pla
00FEB0  1  8D 01 80     	sta MMC3_BankData
00FEB3  1  60           	rts
00FEB4  1               SwitchBG_CHR0:
00FEB4  1  48           	pha
00FEB5  1  A9 00        	lda #%00000000
00FEB7  1  8D 00 80     	sta MMC3_BankSelect
00FEBA  1  68           	pla
00FEBB  1  8D 01 80     	sta MMC3_BankData
00FEBE  1  60           	rts
00FEBF  1               
00FEBF  1               InitializeSPR_CHR:
00FEBF  1  A9 84              lda #Spr_MainBank
00FEC1  1  20 F1 FE           jsr SwitchSPR_CHR0
00FEC4  1  A9 85              lda #Spr_MainBank+1
00FEC6  1  20 E6 FE           jsr SwitchSPR_CHR1
00FEC9  1  A9 86              lda #Spr_MainBank+2
00FECB  1  20 DB FE           jsr SwitchSPR_CHR2
00FECE  1  A9 87              lda #Spr_MainBank+3
00FED0  1               SwitchSPR_CHR3:
00FED0  1  48           	pha
00FED1  1  A9 05        	lda #%00000101
00FED3  1  8D 00 80     	sta MMC3_BankSelect
00FED6  1  68           	pla
00FED7  1  8D 01 80     	sta MMC3_BankData
00FEDA  1  60           	rts
00FEDB  1               SwitchSPR_CHR2:
00FEDB  1  48           	pha
00FEDC  1  A9 04        	lda #%00000100
00FEDE  1  8D 00 80     	sta MMC3_BankSelect
00FEE1  1  68           	pla
00FEE2  1  8D 01 80     	sta MMC3_BankData
00FEE5  1  60           	rts
00FEE6  1               SwitchSPR_CHR1:
00FEE6  1  48           	pha
00FEE7  1  A9 03        	lda #%00000011
00FEE9  1  8D 00 80     	sta MMC3_BankSelect
00FEEC  1  68           	pla
00FEED  1  8D 01 80     	sta MMC3_BankData
00FEF0  1  60           	rts
00FEF1  1               SwitchSPR_CHR0:
00FEF1  1  48           	pha
00FEF2  1  A9 02        	lda #%00000010
00FEF4  1  8D 00 80     	sta MMC3_BankSelect
00FEF7  1  68           	pla
00FEF8  1  8D 01 80     	sta MMC3_BankData
00FEFB  1  60           	rts
00FEFC  1               
00FEFC  1               LoadGameBank:
00FEFC  1  A9 8C        	lda #GameBank        ;load main bank
00FEFE  1  20 0E FF     	jsr SwitchPRGBank0
00FF01  1  A9 8D        	lda #GameBank+1        ;load main bank
00FF03  1               SwitchPRGBank1:
00FF03  1  48           	pha
00FF04  1  A9 07        	lda #%00000111
00FF06  1  8D 00 80     	sta MMC3_BankSelect
00FF09  1  68           	pla
00FF0A  1  8D 01 80     	sta MMC3_BankData
00FF0D  1  60           	rts
00FF0E  1               SwitchPRGBank0:
00FF0E  1  48           	pha
00FF0F  1  A9 06        	lda #%00000110
00FF11  1  8D 00 80     	sta MMC3_BankSelect
00FF14  1  68           	pla
00FF15  1  8D 01 80     	sta MMC3_BankData
00FF18  1  60           	rts
00FF19  1               
00FF19  1               RunSoundEngine:
00FF19  1  A9 88        	lda #SoundBank        ;switch bank
00FF1B  1  20 0E FF     	jsr SwitchPRGBank0
00FF1E  1  A9 89        	lda #SoundBank+1        ;switch bank again :DDDDDDDD
00FF20  1  20 03 FF     	jsr SwitchPRGBank1
00FF23  1  20 00 80     	jsr SoundEngine       ;run relevant routine
00FF26  1  4C FC FE     	jmp LoadGameBank      ;and return to main bank
00FF29  1               
00FF29  1               RunLoadAreaPointer:
00FF29  1  A9 8A        	lda #LevelsBank       ;switch bank
00FF2B  1  20 0E FF     	jsr SwitchPRGBank0
00FF2E  1  A9 8B        	lda #LevelsBank+1       ;switch bank again :DDDDDDDD
00FF30  1  20 03 FF     	jsr SwitchPRGBank1
00FF33  1  20 00 80     	jsr LoadAreaPointer   ;run relevant routine
00FF36  1  4C FC FE     	jmp LoadGameBank      ;and return to main bank
00FF39  1               
00FF39  1               RunGetAreaDataAddrs:
00FF39  1  A9 8A        	lda #LevelsBank       ;switch bank
00FF3B  1  20 0E FF     	jsr SwitchPRGBank0
00FF3E  1  A9 8B        	lda #LevelsBank+1       ;switch bank again :DDDDDDDD
00FF40  1  20 03 FF     	jsr SwitchPRGBank1
00FF43  1  20 39 80     	jsr GetAreaDataAddrs  ;run relevant routine
00FF46  1  4C FC FE     	jmp LoadGameBank      ;and return to main bank
00FF49  1               
00FF49  1               RunGetAreaPointer:
00FF49  1  A9 8A        	lda #LevelsBank       ;switch bank
00FF4B  1  20 0E FF     	jsr SwitchPRGBank0
00FF4E  1  A9 8B        	lda #LevelsBank+1       ;switch bank again :DDDDDDDD
00FF50  1  20 03 FF     	jsr SwitchPRGBank1
00FF53  1  20 28 80     	jsr GetAreaPointer    ;run relevant routine
00FF56  1  4C FC FE     	jmp LoadGameBank      ;and return to main bank
00FF59  1               
00FF59  1               ;-------------------------------------------------------------------------------------
00FF59  1               ;INTERRUPT VECTORS
00FF59  1               
00FF59  1  FF FF FF FF  .res $FFD0 - *, $FF
00FF5D  1  FF FF FF FF  
00FF61  1  FF FF FF FF  
00FFD0  1               
00FFD0  1               ;"VECTORS"
00FFD0  1               ;        .word NMIHandler
00FFD0  1               ;        .word Reset
00FFD0  1               ;        .word IRQHandler
00FFD0  1               
00FFD0  1               ;"CHR"
00FFD0  1               .segment "SM2CHAR1"
00FFD0  1  7C FE E7 E7          .incbin "sm2char1_bg.chr"
00FFD4  1  E7 7F 3E 00  
00FFD8  1  00 38 21 21  
010FD0  1  03 0F 1F 1F          .incbin "sm2char1_spr.chr"
010FD4  1  1C 24 26 66  
010FD8  1  00 00 00 00  
011FD0  1               .segment "SM2CHAR2"
011FD0  1  03 0F 1F 1F          .incbin "ending_spr.chr"
011FD4  1  1C 24 26 66  
011FD8  1  00 00 00 00  
011FD0  1               
