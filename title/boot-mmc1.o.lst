ca65 V2.18 - Ubuntu 2.18-1
Main file   : title/boot-mmc1.asm
Current file: title/boot-mmc1.asm

000000r 1               ; # MMC1 Startup code
000000r 1               ;
000000r 1               ; This is used for normal level hacks.
000000r 1               ;
000000r 1               
000000r 1               ; include the menu screen
000000r 1               .include "title.asm"
000000r 2               ; # Main menu screen code
000000r 2               ;
000000r 2               ; This contains all the code used for the practise rom.
000000r 2               ;
000000r 2               ; It is included from the "boot" files.
000000r 2               ;
000000r 2               
000000r 2               .p02
000000r 2               .linecont +
000000r 2               .include "ascii.asm"
000000r 3               ; tell cc65 to convert ascii into smb1 charset
000000r 3               
000000r 3               ; space
000000r 3               .charmap    $20,   $24
000000r 3               ; !
000000r 3               .charmap    $21,   $2B
000000r 3               ; -
000000r 3               .charmap    $2D,   $28
000000r 3               ; x to cross
000000r 3               .charmap    $78,   $29
000000r 3               ; c to copyright
000000r 3               .charmap    $62,   $CF
000000r 3               ; m to mushroom
000000r 3               .charmap    $6D,   $CE
000000r 3               ; / to chain
000000r 3               .charmap    $2F,   $7F
000000r 3               
000000r 3               
000000r 3               ; 0
000000r 3               .charmap $30+00,   $00
000000r 3               ; 1
000000r 3               .charmap $30+01,   $01
000000r 3               ; 2
000000r 3               .charmap $30+02,   $02
000000r 3               ; 3
000000r 3               .charmap $30+03,   $03
000000r 3               ; 4
000000r 3               .charmap $30+04,   $04
000000r 3               ; 5
000000r 3               .charmap $30+05,   $05
000000r 3               ; 6
000000r 3               .charmap $30+06,   $06
000000r 3               ; 7
000000r 3               .charmap $30+07,   $07
000000r 3               ; 8
000000r 3               .charmap $30+08,   $08
000000r 3               ; 9
000000r 3               .charmap $30+09,   $09
000000r 3               
000000r 3               ; A
000000r 3               .charmap $41+00, $A+00
000000r 3               ; B
000000r 3               .charmap $41+01, $A+01
000000r 3               ; C
000000r 3               .charmap $41+02, $A+02
000000r 3               ; D
000000r 3               .charmap $41+03, $A+03
000000r 3               ; E
000000r 3               .charmap $41+04, $A+04
000000r 3               ; F
000000r 3               .charmap $41+05, $A+05
000000r 3               ; G
000000r 3               .charmap $41+06, $A+06
000000r 3               ; H
000000r 3               .charmap $41+07, $A+07
000000r 3               ; I
000000r 3               .charmap $41+08, $A+08
000000r 3               ; J
000000r 3               .charmap $41+09, $A+09
000000r 3               ; K
000000r 3               .charmap $41+10, $A+10
000000r 3               ; L
000000r 3               .charmap $41+11, $A+11
000000r 3               ; M
000000r 3               .charmap $41+12, $A+12
000000r 3               ; N
000000r 3               .charmap $41+13, $A+13
000000r 3               ; O
000000r 3               .charmap $41+14, $A+14
000000r 3               ; P
000000r 3               .charmap $41+15, $A+15
000000r 3               ; Q
000000r 3               .charmap $41+16, $A+16
000000r 3               ; R
000000r 3               .charmap $41+17, $A+17
000000r 3               ; S
000000r 3               .charmap $41+18, $A+18
000000r 3               ; T
000000r 3               .charmap $41+19, $A+19
000000r 3               ; U
000000r 3               .charmap $41+20, $A+20
000000r 3               ; V
000000r 3               .charmap $41+21, $A+21
000000r 3               ; W
000000r 3               .charmap $41+22, $A+22
000000r 3               ; X
000000r 3               .charmap $41+23, $A+23
000000r 3               ; Y
000000r 3               .charmap $41+24, $A+24
000000r 3               ; Z
000000r 3               .charmap $41+25, $A+25
000000r 3               
000000r 2               .include "../const.inc"
000000r 3               BANKNR_TITLE = $E
000000r 3               BANKNR_SMB = $0
000000r 3               
000000r 3               
000000r 3               PPU_CTRL_REG1         = $2000
000000r 3               PPU_CTRL_REG2         = $2001
000000r 3               PPU_STATUS            = $2002
000000r 3               PPU_SPR_ADDR          = $2003
000000r 3               PPU_SPR_DATA          = $2004
000000r 3               PPU_SCROLL_REG        = $2005
000000r 3               PPU_ADDRESS           = $2006
000000r 3               PPU_DATA              = $2007
000000r 3               
000000r 3               SND_REGISTER          = $4000
000000r 3               SND_SQUARE1_REG       = $4000
000000r 3               SND_SQUARE2_REG       = $4004
000000r 3               SND_TRIANGLE_REG      = $4008
000000r 3               SND_NOISE_REG         = $400c
000000r 3               SND_DELTA_REG         = $4010
000000r 3               SND_MASTERCTRL_REG    = $4015
000000r 3               
000000r 3               SPR_DMA               = $4014
000000r 3               JOYPAD_PORT           = $4016
000000r 3               JOYPAD_PORT1          = $4016
000000r 3               JOYPAD_PORT2          = $4017
000000r 3               
000000r 3               ; GAME SPECIFIC DEFINES
000000r 3               
000000r 3               ObjectOffset          = $08
000000r 3               
000000r 3               FrameCounter          = $09
000000r 3               
000000r 3               SavedJoypadBits       = $06fc
000000r 3               SavedJoypad1Bits      = $06fc
000000r 3               SavedJoypad2Bits      = $06fd
000000r 3               JoypadBitMask         = $074a
000000r 3               JoypadOverride        = $0758
000000r 3               
000000r 3               A_B_Buttons           = $0a
000000r 3               PreviousA_B_Buttons   = $0d
000000r 3               Up_Down_Buttons       = $0b
000000r 3               Left_Right_Buttons    = $0c
000000r 3               
000000r 3               GameEngineSubroutine  = $0e
000000r 3               
000000r 3               Mirror_PPU_CTRL_REG1  = $0778
000000r 3               Mirror_PPU_CTRL_REG2  = $0779
000000r 3               
000000r 3               OperMode              = $0770
000000r 3               OperMode_Task         = $0772
000000r 3               ScreenRoutineTask     = $073c
000000r 3               
000000r 3               GamePauseStatus       = $0776
000000r 3               GamePauseTimer        = $0777
000000r 3               
000000r 3               DemoAction            = $0717
000000r 3               DemoActionTimer       = $0718
000000r 3               
000000r 3               TimerControl          = $0747
000000r 3               IntervalTimerControl  = $077f
000000r 3               
000000r 3               Timers                = $0780
000000r 3               SelectTimer           = $0780
000000r 3               PlayerAnimTimer       = $0781
000000r 3               JumpSwimTimer         = $0782
000000r 3               RunningTimer          = $0783
000000r 3               BlockBounceTimer      = $0784
000000r 3               SideCollisionTimer    = $0785
000000r 3               JumpspringTimer       = $0786
000000r 3               GameTimerCtrlTimer    = $0787
000000r 3               ClimbSideTimer        = $0789
000000r 3               EnemyFrameTimer       = $078a
000000r 3               FrenzyEnemyTimer      = $078f
000000r 3               BowserFireBreathTimer = $0790
000000r 3               StompTimer            = $0791
000000r 3               AirBubbleTimer        = $0792
000000r 3               ScrollIntervalTimer   = $0795
000000r 3               EnemyIntervalTimer    = $0796
000000r 3               BrickCoinTimer        = $079d
000000r 3               InjuryTimer           = $079e
000000r 3               StarInvincibleTimer   = $079f
000000r 3               ScreenTimer           = $07a0
000000r 3               WorldEndTimer         = $07a1
000000r 3               DemoTimer             = $07a2
000000r 3               
000000r 3               SpriteLen = $4
000000r 3               Sprite_Data           = $0200
000000r 3               Sprite_Y_Position     = $0200
000000r 3               Sprite_Tilenumber     = $0201
000000r 3               Sprite_Attributes     = $0202
000000r 3               Sprite_X_Position     = $0203
000000r 3               
000000r 3               ScreenEdge_PageLoc    = $071a
000000r 3               ScreenEdge_X_Pos      = $071c
000000r 3               ScreenLeft_PageLoc    = $071a
000000r 3               ScreenRight_PageLoc   = $071b
000000r 3               ScreenLeft_X_Pos      = $071c
000000r 3               ScreenRight_X_Pos     = $071d
000000r 3               
000000r 3               PlayerFacingDir       = $33
000000r 3               DestinationPageLoc    = $34
000000r 3               VictoryWalkControl    = $35
000000r 3               ScrollFractional      = $0768
000000r 3               PrimaryMsgCounter     = $0719
000000r 3               SecondaryMsgCounter   = $0749
000000r 3               
000000r 3               HorizontalScroll      = $073f
000000r 3               VerticalScroll        = $0740
000000r 3               ScrollLock            = $0723
000000r 3               ScrollThirtyTwo       = $073d
000000r 3               Player_X_Scroll       = $06ff
000000r 3               Player_Pos_ForScroll  = $0755
000000r 3               ScrollAmount          = $0775
000000r 3               
000000r 3               AreaData              = $e7
000000r 3               AreaDataLow           = $e7
000000r 3               AreaDataHigh          = $e8
000000r 3               EnemyData             = $e9
000000r 3               EnemyDataLow          = $e9
000000r 3               EnemyDataHigh         = $ea
000000r 3               
000000r 3               AreaParserTaskNum     = $071f
000000r 3               ColumnSets            = $071e
000000r 3               CurrentPageLoc        = $0725
000000r 3               CurrentColumnPos      = $0726
000000r 3               BackloadingFlag       = $0728
000000r 3               BehindAreaParserFlag  = $0729
000000r 3               AreaObjectPageLoc     = $072a
000000r 3               AreaObjectPageSel     = $072b
000000r 3               AreaDataOffset        = $072c
000000r 3               AreaObjOffsetBuffer   = $072d
000000r 3               AreaObjectLength      = $0730
000000r 3               StaircaseControl      = $0734
000000r 3               AreaObjectHeight      = $0735
000000r 3               MushroomLedgeHalfLen  = $0736
000000r 3               EnemyDataOffset       = $0739
000000r 3               EnemyObjectPageLoc    = $073a
000000r 3               EnemyObjectPageSel    = $073b
000000r 3               MetatileBuffer        = $06a1
000000r 3               BlockBufferColumnPos  = $06a0
000000r 3               CurrentNTAddr_Low     = $0721
000000r 3               CurrentNTAddr_High    = $0720
000000r 3               AttributeBuffer       = $03f9
000000r 3               
000000r 3               LoopCommand           = $0745
000000r 3               
000000r 3               DisplayDigits         = $07d7
000000r 3               TopScoreDisplay       = $07d7
000000r 3               ScoreAndCoinDisplay   = $07dd
000000r 3               PlayerScoreDisplay    = $07dd
000000r 3               GameTimerDisplay      = $07f8
000000r 3               DigitModifier         = $0134
000000r 3               
000000r 3               VerticalFlipFlag      = $0109
000000r 3               FloateyNum_Control    = $0110
000000r 3               ShellChainCounter     = $0125
000000r 3               FloateyNum_Timer      = $012c
000000r 3               FloateyNum_X_Pos      = $0117
000000r 3               FloateyNum_Y_Pos      = $011e
000000r 3               FlagpoleFNum_Y_Pos    = $010d
000000r 3               FlagpoleFNum_YMFDummy = $010e
000000r 3               FlagpoleScore         = $010f
000000r 3               FlagpoleCollisionYPos = $070f
000000r 3               StompChainCounter     = $0484
000000r 3               
000000r 3               VRAM_Buffer1_Offset   = $0300
000000r 3               VRAM_Buffer1          = $0301
000000r 3               VRAM_Buffer2_Offset   = $0340
000000r 3               VRAM_Buffer2          = $0341
000000r 3               VRAM_Buffer_AddrCtrl  = $0773
000000r 3               Sprite0HitDetectFlag  = $0722
000000r 3               DisableScreenFlag     = $0774
000000r 3               DisableIntermediate   = $0769
000000r 3               ColorRotateOffset     = $06d4
000000r 3               
000000r 3               TerrainControl        = $0727
000000r 3               AreaStyle             = $0733
000000r 3               ForegroundScenery     = $0741
000000r 3               BackgroundScenery     = $0742
000000r 3               CloudTypeOverride     = $0743
000000r 3               BackgroundColorCtrl   = $0744
000000r 3               AreaType              = $074e
000000r 3               AreaAddrsLOffset      = $074f
000000r 3               AreaPointer           = $0750
000000r 3               
000000r 3               PlayerEntranceCtrl    = $0710
000000r 3               GameTimerSetting      = $0715
000000r 3               AltEntranceControl    = $0752
000000r 3               EntrancePage          = $0751
000000r 3               NumberOfPlayers       = $077a
000000r 3               WarpZoneControl       = $06d6
000000r 3               ChangeAreaTimer       = $06de
000000r 3               
000000r 3               MultiLoopCorrectCntr  = $06d9
000000r 3               MultiLoopPassCntr     = $06da
000000r 3               
000000r 3               FetchNewGameTimerFlag = $0757
000000r 3               GameTimerExpiredFlag  = $0759
000000r 3               
000000r 3               PrimaryHardMode       = $076a
000000r 3               SecondaryHardMode     = $06cc
000000r 3               WorldSelectNumber     = $076b
000000r 3               WorldSelectEnableFlag = $07fc
000000r 3               ContinueWorld         = $07fd
000000r 3               
000000r 3               CurrentPlayer         = $0753
000000r 3               PlayerSize            = $0754
000000r 3               PlayerStatus          = $0756
000000r 3               
000000r 3               OnscreenPlayerInfo    = $075a
000000r 3               NumberofLives         = $075a ;used by current player
000000r 3               HalfwayPage           = $075b
000000r 3               LevelNumber           = $075c ;the actual dash number
000000r 3               Hidden1UpFlag         = $075d
000000r 3               CoinTally             = $075e
000000r 3               WorldNumber           = $075f
000000r 3               AreaNumber            = $0760 ;internal number used to find areas
000000r 3               
000000r 3               CoinTallyFor1Ups      = $0748
000000r 3               
000000r 3               OffscreenPlayerInfo   = $0761
000000r 3               OffScr_NumberofLives  = $0761 ;used by offscreen player
000000r 3               OffScr_HalfwayPage    = $0762
000000r 3               OffScr_LevelNumber    = $0763
000000r 3               OffScr_Hidden1UpFlag  = $0764
000000r 3               OffScr_CoinTally      = $0765
000000r 3               OffScr_WorldNumber    = $0766
000000r 3               OffScr_AreaNumber     = $0767
000000r 3               
000000r 3               BalPlatformAlignment  = $03a0
000000r 3               Platform_X_Scroll     = $03a1
000000r 3               PlatformCollisionFlag = $03a2
000000r 3               YPlatformTopYPos      = $0401
000000r 3               YPlatformCenterYPos   = $58
000000r 3               
000000r 3               BrickCoinTimerFlag    = $06bc
000000r 3               StarFlagTaskControl   = $0746
000000r 3               
000000r 3               PseudoRandomBitReg    = $07a7
000000r 3               WarmBootValidation    = $07ff
000000r 3               
000000r 3               SprShuffleAmtOffset   = $06e0
000000r 3               SprShuffleAmt         = $06e1
000000r 3               SprDataOffset         = $06e4
000000r 3               Player_SprDataOffset  = $06e4
000000r 3               Enemy_SprDataOffset   = $06e5
000000r 3               Block_SprDataOffset   = $06ec
000000r 3               Alt_SprDataOffset     = $06ec
000000r 3               Bubble_SprDataOffset  = $06ee
000000r 3               FBall_SprDataOffset   = $06f1
000000r 3               Misc_SprDataOffset    = $06f3
000000r 3               SprDataOffset_Ctrl    = $03ee
000000r 3               
000000r 3               Player_State          = $1d
000000r 3               Enemy_State           = $1e
000000r 3               Fireball_State        = $24
000000r 3               Block_State           = $26
000000r 3               Misc_State            = $2a
000000r 3               
000000r 3               Player_MovingDir      = $45
000000r 3               Enemy_MovingDir       = $46
000000r 3               
000000r 3               SprObject_X_Speed     = $57
000000r 3               Player_X_Speed        = $57
000000r 3               Enemy_X_Speed         = $58
000000r 3               Fireball_X_Speed      = $5e
000000r 3               Block_X_Speed         = $60
000000r 3               Misc_X_Speed          = $64
000000r 3               
000000r 3               Jumpspring_FixedYPos  = $58
000000r 3               JumpspringAnimCtrl    = $070e
000000r 3               JumpspringForce       = $06db
000000r 3               
000000r 3               SprObject_PageLoc     = $6d
000000r 3               Player_PageLoc        = $6d
000000r 3               Enemy_PageLoc         = $6e
000000r 3               Fireball_PageLoc      = $74
000000r 3               Block_PageLoc         = $76
000000r 3               Misc_PageLoc          = $7a
000000r 3               Bubble_PageLoc        = $83
000000r 3               
000000r 3               SprObject_X_Position  = $86
000000r 3               Player_X_Position     = $86
000000r 3               Enemy_X_Position      = $87
000000r 3               Fireball_X_Position   = $8d
000000r 3               Block_X_Position      = $8f
000000r 3               Misc_X_Position       = $93
000000r 3               Bubble_X_Position     = $9c
000000r 3               
000000r 3               SprObject_Y_Speed     = $9f
000000r 3               Player_Y_Speed        = $9f
000000r 3               Enemy_Y_Speed         = $a0
000000r 3               Fireball_Y_Speed      = $a6
000000r 3               Block_Y_Speed         = $a8
000000r 3               Misc_Y_Speed          = $ac
000000r 3               
000000r 3               SprObject_Y_HighPos   = $b5
000000r 3               Player_Y_HighPos      = $b5
000000r 3               Enemy_Y_HighPos       = $b6
000000r 3               Fireball_Y_HighPos    = $bc
000000r 3               Block_Y_HighPos       = $be
000000r 3               Misc_Y_HighPos        = $c2
000000r 3               Bubble_Y_HighPos      = $cb
000000r 3               
000000r 3               SprObject_Y_Position  = $ce
000000r 3               Player_Y_Position     = $ce
000000r 3               Enemy_Y_Position      = $cf
000000r 3               Fireball_Y_Position   = $d5
000000r 3               Block_Y_Position      = $d7
000000r 3               Misc_Y_Position       = $db
000000r 3               Bubble_Y_Position     = $e4
000000r 3               
000000r 3               SprObject_Rel_XPos    = $03ad
000000r 3               Player_Rel_XPos       = $03ad
000000r 3               Enemy_Rel_XPos        = $03ae
000000r 3               Fireball_Rel_XPos     = $03af
000000r 3               Bubble_Rel_XPos       = $03b0
000000r 3               Block_Rel_XPos        = $03b1
000000r 3               Misc_Rel_XPos         = $03b3
000000r 3               
000000r 3               SprObject_Rel_YPos    = $03b8
000000r 3               Player_Rel_YPos       = $03b8
000000r 3               Enemy_Rel_YPos        = $03b9
000000r 3               Fireball_Rel_YPos     = $03ba
000000r 3               Bubble_Rel_YPos       = $03bb
000000r 3               Block_Rel_YPos        = $03bc
000000r 3               Misc_Rel_YPos         = $03be
000000r 3               
000000r 3               SprObject_SprAttrib   = $03c4
000000r 3               Player_SprAttrib      = $03c4
000000r 3               Enemy_SprAttrib       = $03c5
000000r 3               
000000r 3               SprObject_X_MoveForce = $0400
000000r 3               Enemy_X_MoveForce     = $0401
000000r 3               
000000r 3               SprObject_YMF_Dummy   = $0416
000000r 3               Player_YMF_Dummy      = $0416
000000r 3               Enemy_YMF_Dummy       = $0417
000000r 3               Bubble_YMF_Dummy      = $042c
000000r 3               
000000r 3               SprObject_Y_MoveForce = $0433
000000r 3               Player_Y_MoveForce    = $0433
000000r 3               Enemy_Y_MoveForce     = $0434
000000r 3               Block_Y_MoveForce     = $043c
000000r 3               
000000r 3               DisableCollisionDet   = $0716
000000r 3               Player_CollisionBits  = $0490
000000r 3               Enemy_CollisionBits   = $0491
000000r 3               
000000r 3               SprObj_BoundBoxCtrl   = $0499
000000r 3               Player_BoundBoxCtrl   = $0499
000000r 3               Enemy_BoundBoxCtrl    = $049a
000000r 3               Fireball_BoundBoxCtrl = $04a0
000000r 3               Misc_BoundBoxCtrl     = $04a2
000000r 3               
000000r 3               EnemyFrenzyBuffer     = $06cb
000000r 3               EnemyFrenzyQueue      = $06cd
000000r 3               Enemy_Flag            = $0f
000000r 3               Enemy_ID              = $16
000000r 3               
000000r 3               PlayerGfxOffset       = $06d5
000000r 3               Player_XSpeedAbsolute = $0700
000000r 3               FrictionAdderHigh     = $0701
000000r 3               FrictionAdderLow      = $0702
000000r 3               RunningSpeed          = $0703
000000r 3               SwimmingFlag          = $0704
000000r 3               Player_X_MoveForce    = $0705
000000r 3               DiffToHaltJump        = $0706
000000r 3               JumpOrigin_Y_HighPos  = $0707
000000r 3               JumpOrigin_Y_Position = $0708
000000r 3               VerticalForce         = $0709
000000r 3               VerticalForceDown     = $070a
000000r 3               PlayerChangeSizeFlag  = $070b
000000r 3               PlayerAnimTimerSet    = $070c
000000r 3               PlayerAnimCtrl        = $070d
000000r 3               DeathMusicLoaded      = $0712
000000r 3               FlagpoleSoundQueue    = $0713
000000r 3               CrouchingFlag         = $0714
000000r 3               MaximumLeftSpeed      = $0450
000000r 3               MaximumRightSpeed     = $0456
000000r 3               
000000r 3               SprObject_OffscrBits  = $03d0
000000r 3               Player_OffscreenBits  = $03d0
000000r 3               Enemy_OffscreenBits   = $03d1
000000r 3               FBall_OffscreenBits   = $03d2
000000r 3               Bubble_OffscreenBits  = $03d3
000000r 3               Block_OffscreenBits   = $03d4
000000r 3               Misc_OffscreenBits    = $03d6
000000r 3               EnemyOffscrBitsMasked = $03d8
000000r 3               
000000r 3               Cannon_Offset         = $046a
000000r 3               Cannon_PageLoc        = $046b
000000r 3               Cannon_X_Position     = $0471
000000r 3               Cannon_Y_Position     = $0477
000000r 3               Cannon_Timer          = $047d
000000r 3               
000000r 3               Whirlpool_Offset      = $046a
000000r 3               Whirlpool_PageLoc     = $046b
000000r 3               Whirlpool_LeftExtent  = $0471
000000r 3               Whirlpool_Length      = $0477
000000r 3               Whirlpool_Flag        = $047d
000000r 3               
000000r 3               VineFlagOffset        = $0398
000000r 3               VineHeight            = $0399
000000r 3               VineObjOffset         = $039a
000000r 3               VineStart_Y_Position  = $039d
000000r 3               
000000r 3               Block_Orig_YPos       = $03e4
000000r 3               Block_BBuf_Low        = $03e6
000000r 3               Block_Metatile        = $03e8
000000r 3               Block_PageLoc2        = $03ea
000000r 3               Block_RepFlag         = $03ec
000000r 3               Block_ResidualCounter = $03f0
000000r 3               Block_Orig_XPos       = $03f1
000000r 3               
000000r 3               BoundingBox_UL_XPos   = $04ac
000000r 3               BoundingBox_UL_YPos   = $04ad
000000r 3               BoundingBox_DR_XPos   = $04ae
000000r 3               BoundingBox_DR_YPos   = $04af
000000r 3               BoundingBox_UL_Corner = $04ac
000000r 3               BoundingBox_LR_Corner = $04ae
000000r 3               EnemyBoundingBoxCoord = $04b0
000000r 3               
000000r 3               PowerUpType           = $39
000000r 3               
000000r 3               FireballBouncingFlag  = $3a
000000r 3               FireballCounter       = $06ce
000000r 3               FireballThrowingTimer = $0711
000000r 3               
000000r 3               HammerEnemyOffset     = $06ae
000000r 3               JumpCoinMiscOffset    = $06b7
000000r 3               
000000r 3               Block_Buffer_1        = $0500
000000r 3               Block_Buffer_2        = $05d0
000000r 3               
000000r 3               HammerThrowingTimer   = $03a2
000000r 3               HammerBroJumpTimer    = $3c
000000r 3               Misc_Collision_Flag   = $06be
000000r 3               
000000r 3               RedPTroopaOrigXPos    = $0401
000000r 3               RedPTroopaCenterYPos  = $58
000000r 3               
000000r 3               XMovePrimaryCounter   = $a0
000000r 3               XMoveSecondaryCounter = $58
000000r 3               
000000r 3               CheepCheepMoveMFlag   = $58
000000r 3               CheepCheepOrigYPos    = $0434
000000r 3               BitMFilter            = $06dd
000000r 3               
000000r 3               LakituReappearTimer   = $06d1
000000r 3               LakituMoveSpeed       = $58
000000r 3               LakituMoveDirection   = $a0
000000r 3               
000000r 3               FirebarSpinState_Low  = $58
000000r 3               FirebarSpinState_High = $a0
000000r 3               FirebarSpinSpeed      = $0388
000000r 3               FirebarSpinDirection  = $34
000000r 3               
000000r 3               DuplicateObj_Offset   = $06cf
000000r 3               NumberofGroupEnemies  = $06d3
000000r 3               
000000r 3               BlooperMoveCounter    = $a0
000000r 3               BlooperMoveSpeed      = $58
000000r 3               
000000r 3               BowserBodyControls    = $0363
000000r 3               BowserFeetCounter     = $0364
000000r 3               BowserMovementSpeed   = $0365
000000r 3               BowserOrigXPos        = $0366
000000r 3               BowserFlameTimerCtrl  = $0367
000000r 3               BowserFront_Offset    = $0368
000000r 3               BridgeCollapseOffset  = $0369
000000r 3               BowserGfxFlag         = $036a
000000r 3               BowserHitPoints       = $0483
000000r 3               MaxRangeFromOrigin    = $06dc
000000r 3               
000000r 3               BowserFlamePRandomOfs = $0417
000000r 3               
000000r 3               PiranhaPlantUpYPos    = $0417
000000r 3               PiranhaPlantDownYPos  = $0434
000000r 3               PiranhaPlant_Y_Speed  = $58
000000r 3               PiranhaPlant_MoveFlag = $a0
000000r 3               
000000r 3               FireworksCounter      = $06d7
000000r 3               ExplosionGfxCounter   = $58
000000r 3               ExplosionTimerCounter = $a0
000000r 3               
000000r 3               ;sound related defines
000000r 3               Squ2_NoteLenBuffer    = $07b3
000000r 3               Squ2_NoteLenCounter   = $07b4
000000r 3               Squ2_EnvelopeDataCtrl = $07b5
000000r 3               Squ1_NoteLenCounter   = $07b6
000000r 3               Squ1_EnvelopeDataCtrl = $07b7
000000r 3               Tri_NoteLenBuffer     = $07b8
000000r 3               Tri_NoteLenCounter    = $07b9
000000r 3               Noise_BeatLenCounter  = $07ba
000000r 3               Squ1_SfxLenCounter    = $07bb
000000r 3               Squ2_SfxLenCounter    = $07bd
000000r 3               Sfx_SecondaryCounter  = $07be
000000r 3               Noise_SfxLenCounter   = $07bf
000000r 3               
000000r 3               PauseSoundQueue       = $fa
000000r 3               Square1SoundQueue     = $ff
000000r 3               Square2SoundQueue     = $fe
000000r 3               NoiseSoundQueue       = $fd
000000r 3               AreaMusicQueue        = $fb
000000r 3               EventMusicQueue       = $fc
000000r 3               
000000r 3               Square1SoundBuffer    = $f1
000000r 3               Square2SoundBuffer    = $f2
000000r 3               NoiseSoundBuffer      = $f3
000000r 3               AreaMusicBuffer       = $f4
000000r 3               EventMusicBuffer      = $07b1
000000r 3               PauseSoundBuffer      = $07b2
000000r 3               
000000r 3               MusicData             = $f5
000000r 3               MusicDataLow          = $f5
000000r 3               MusicDataHigh         = $f6
000000r 3               MusicOffset_Square2   = $f7
000000r 3               MusicOffset_Square1   = $f8
000000r 3               MusicOffset_Triangle  = $f9
000000r 3               MusicOffset_Noise     = $07b0
000000r 3               
000000r 3               NoteLenLookupTblOfs   = $f0
000000r 3               DAC_Counter           = $07c0
000000r 3               NoiseDataLoopbackOfs  = $07c1
000000r 3               NoteLengthTblAdder    = $07c4
000000r 3               AreaMusicBuffer_Alt   = $07c5
000000r 3               PauseModeFlag         = $07c6
000000r 3               GroundMusicHeaderOfs  = $07c7
000000r 3               AltRegContentFlag     = $07ca
000000r 3               
000000r 3               ;-------------------------------------------------------------------------------------
000000r 3               ;CONSTANTS
000000r 3               
000000r 3               ;sound effects constants
000000r 3               Sfx_SmallJump         = %10000000
000000r 3               Sfx_Flagpole          = %01000000
000000r 3               Sfx_Fireball          = %00100000
000000r 3               Sfx_PipeDown_Injury   = %00010000
000000r 3               Sfx_EnemySmack        = %00001000
000000r 3               Sfx_EnemyStomp        = %00000100
000000r 3               Sfx_Bump              = %00000010
000000r 3               Sfx_BigJump           = %00000001
000000r 3               
000000r 3               Sfx_BowserFall        = %10000000
000000r 3               Sfx_ExtraLife         = %01000000
000000r 3               Sfx_PowerUpGrab       = %00100000
000000r 3               Sfx_TimerTick         = %00010000
000000r 3               Sfx_Blast             = %00001000
000000r 3               Sfx_GrowVine          = %00000100
000000r 3               Sfx_GrowPowerUp       = %00000010
000000r 3               Sfx_CoinGrab          = %00000001
000000r 3               
000000r 3               Sfx_BowserFlame       = %00000010
000000r 3               Sfx_BrickShatter      = %00000001
000000r 3               
000000r 3               ;music constants
000000r 3               Silence               = %10000000
000000r 3               
000000r 3               StarPowerMusic        = %01000000
000000r 3               PipeIntroMusic        = %00100000
000000r 3               CloudMusic            = %00010000
000000r 3               CastleMusic           = %00001000
000000r 3               UndergroundMusic      = %00000100
000000r 3               WaterMusic            = %00000010
000000r 3               GroundMusic           = %00000001
000000r 3               
000000r 3               TimeRunningOutMusic   = %01000000
000000r 3               EndOfLevelMusic       = %00100000
000000r 3               AltGameOverMusic      = %00010000
000000r 3               EndOfCastleMusic      = %00001000
000000r 3               VictoryMusic          = %00000100
000000r 3               GameOverMusic         = %00000010
000000r 3               DeathMusic            = %00000001
000000r 3               
000000r 3               ;enemy object constants
000000r 3               GreenKoopa            = $00
000000r 3               BuzzyBeetle           = $02
000000r 3               RedKoopa              = $03
000000r 3               HammerBro             = $05
000000r 3               Goomba                = $06
000000r 3               Bloober               = $07
000000r 3               BulletBill_FrenzyVar  = $08
000000r 3               GreyCheepCheep        = $0a
000000r 3               RedCheepCheep         = $0b
000000r 3               Podoboo               = $0c
000000r 3               PiranhaPlant          = $0d
000000r 3               GreenParatroopaJump   = $0e
000000r 3               RedParatroopa         = $0f
000000r 3               GreenParatroopaFly    = $10
000000r 3               Lakitu                = $11
000000r 3               Spiny                 = $12
000000r 3               FlyCheepCheepFrenzy   = $14
000000r 3               FlyingCheepCheep      = $14
000000r 3               BowserFlame           = $15
000000r 3               Fireworks             = $16
000000r 3               BBill_CCheep_Frenzy   = $17
000000r 3               Stop_Frenzy           = $18
000000r 3               Bowser                = $2d
000000r 3               PowerUpObject         = $2e
000000r 3               VineObject            = $2f
000000r 3               FlagpoleFlagObject    = $30
000000r 3               StarFlagObject        = $31
000000r 3               JumpspringObject      = $32
000000r 3               BulletBill_CannonVar  = $33
000000r 3               RetainerObject        = $35
000000r 3               TallEnemy             = $09
000000r 3               
000000r 3               ;other constants
000000r 3               World1 = 0
000000r 3               World2 = 1
000000r 3               World3 = 2
000000r 3               World4 = 3
000000r 3               World5 = 4
000000r 3               World6 = 5
000000r 3               World7 = 6
000000r 3               World8 = 7
000000r 3               Level1 = 0
000000r 3               Level2 = 1
000000r 3               Level3 = 2
000000r 3               Level4 = 3
000000r 3               
000000r 3               A_Button              = %10000000
000000r 3               B_Button              = %01000000
000000r 3               Select_Button         = %00100000
000000r 3               Start_Button          = %00010000
000000r 3               Up_Dir                = %00001000
000000r 3               Down_Dir              = %00000100
000000r 3               Left_Dir              = %00000010
000000r 3               Right_Dir             = %00000001
000000r 3               
000000r 3               TitleScreenModeValue  = 0
000000r 3               GameModeValue         = 1
000000r 3               VictoryModeValue      = 2
000000r 3               GameOverModeValue     = 3
000000r 3               
000000r 2               
000000r 2               ; import some pointers from the smb rom
000000r 2               .import GL_ENTER
000000r 2               .import GetAreaDataAddrs
000000r 2               .import LoadAreaPointer
000000r 2               .import PlayerEndWorld
000000r 2               .import NonMaskableInterrupt
000000r 2               
000000r 2               ; Temporary WRAM space
000000r 2               .segment "TEMPWRAM"
000000r 2  00 00 00 00  WRAMSaveHeader: .byte $00, $00, $00, $00, $00
000004r 2  00           
000005r 2  00           HeldButtons: .byte $00
000006r 2  00           ReleasedButtons: .byte $00
000007r 2  00           LastReadButtons: .byte $00
000008r 2  00           PressedButtons: .byte $00
000009r 2  00           CachedChangeAreaTimer: .byte $00
00000Ar 2  00           LevelEnding: .byte $00
00000Br 2  00           IsPlaying: .byte $00
00000Cr 2  00           EnteringFromMenu: .byte $00
00000Dr 2  00           PendingScoreDrawPosition: .byte $00
00000Er 2  00           CachedITC: .byte $00
00000Fr 2  00           PREVIOUS_BANK: .byte $00
000010r 2               
000010r 2               ; Persistent WRAM space
000010r 2               .segment "MENUWRAM"
000000r 2               MathDigits:
000000r 2               MathFrameruleDigitStart:
000000r 2  00 00 00 00    .byte $00, $00, $00, $00, $00 ; selected framerule
000004r 2  00           
000005r 2               MathFrameruleDigitEnd:
000005r 2               MathInGameFrameruleDigitStart:
000005r 2  00 00 00 00    .byte $00, $00, $00, $00, $00 ; ingame framerule
000009r 2  00           
00000Ar 2               MathInGameFrameruleDigitEnd:
00000Ar 2               
00000Ar 2               ; $7E00-$7FFF - relocated bank switching code
00000Ar 2               RelocatedCodeLocation = $7E00
00000Ar 2               
00000Ar 2               .segment "PRACTISE_PRG0"
000000r 2               ; ================================================================
000000r 2               ;  Full reset of title screen
000000r 2               ; ----------------------------------------------------------------
000000r 2               TitleResetInner:
000000r 2  A2 00            ldx #$00                           ; disable ppu
000002r 2  8E 00 20         stx PPU_CTRL_REG1                  ;
000005r 2  8E 01 20         stx PPU_CTRL_REG2                  ;
000008r 2  20 rr rr         jsr InitializeMemory               ; clear memory
00000Br 2  20 rr rr         jsr ForceClearWRAM                 ; clear all wram state
00000Er 2  A9 08            lda #8                             ; set starting framerule
000010r 2  8D rr rr         sta MathFrameruleDigitStart        ;
000013r 2  AD 02 20     :   lda PPU_STATUS                     ; wait for vblank
000016r 2  10 FB            bpl :-                             ;
000018r 2               HotReset2:                             ;
000018r 2  A2 00            ldx #$00                           ; disable ppu again (this is called when resetting to the menu)
00001Ar 2  8E 00 20         stx PPU_CTRL_REG1                  ;
00001Dr 2  8E 01 20         stx PPU_CTRL_REG2                  ;
000020r 2  A2 FF            ldx #$FF                           ; clear stack
000022r 2  9A               txs                                ;
000023r 2  AD 02 20     :   lda PPU_STATUS                     ; wait for vblank
000026r 2  10 FB            bpl :-                             ;
000028r 2  20 rr rr         jsr InitBankSwitchingCode          ; copy bankswitching code to wram
00002Br 2  20 rr rr         jsr ReadJoypads                    ; read controller to prevent a held button at startup from registering
00002Er 2  20 rr rr         jsr PrepareScreen                  ; load in palette and background
000031r 2  20 rr rr         jsr MenuReset                      ; reset main menu
000034r 2  A9 00            lda #0                             ; clear scroll registers
000036r 2  8D 05 20         sta PPU_SCROLL_REG                 ;
000039r 2  8D 05 20         sta PPU_SCROLL_REG                 ;
00003Cr 2  A9 98            lda #%10011000                     ; enable ppu
00003Er 2  8D 78 07         sta Mirror_PPU_CTRL_REG1           ;
000041r 2  8D 00 20         sta PPU_CTRL_REG1                  ;
000044r 2  4C rr rr     :   jmp :-                             ; infinite loop until NMI
000047r 2               ; ================================================================
000047r 2               
000047r 2               ; ================================================================
000047r 2               ;  Hot reset back to the title screen
000047r 2               ; ----------------------------------------------------------------
000047r 2               HotReset:
000047r 2  A9 00            lda #0                             ; kill any playing sounds
000049r 2  8D 15 40         sta SND_MASTERCTRL_REG             ;
00004Cr 2  20 rr rr         jsr InitializeMemory               ; clear memory
00004Fr 2  4C rr rr         jmp HotReset2                      ; then jump to the shared reset code
000052r 2               ; ================================================================
000052r 2               
000052r 2               ; ================================================================
000052r 2               ;  Handle NMI interrupts while in the title screen
000052r 2               ; ----------------------------------------------------------------
000052r 2               TitleNMI:
000052r 2  AD 78 07         lda Mirror_PPU_CTRL_REG1           ; disable nmi
000055r 2  29 7F            and #%01111111                     ;
000057r 2  8D 78 07         sta Mirror_PPU_CTRL_REG1           ; and update ppu state
00005Ar 2  8D 00 20         sta PPU_CTRL_REG1                  ;
00005Dr 2  2C 02 20         bit PPU_STATUS                     ; flip ppu status
000060r 2  20 rr rr         jsr WriteVRAMBufferToScreen        ; write any pending vram updates
000063r 2  A9 00            lda #0                             ; disable playing state
000065r 2  8D rr rr         sta IsPlaying                      ;
000068r 2  8D 05 20         sta PPU_SCROLL_REG                 ; clear scroll registers
00006Br 2  8D 05 20         sta PPU_SCROLL_REG                 ;
00006Er 2  A9 02            lda #$02                           ; copy sprites
000070r 2  8D 14 40         sta SPR_DMA                        ;
000073r 2  20 rr rr         jsr ReadJoypads                    ; read controller state
000076r 2  20 rr rr         jsr MenuNMI                        ; and run menu code
000079r 2  A9 1A            lda #%00011010                     ; set ppu mask state for menu
00007Br 2  8D 01 20         sta PPU_CTRL_REG2                  ;
00007Er 2  AD 78 07         lda Mirror_PPU_CTRL_REG1           ; get ppu mirror state
000081r 2  09 80            ora #%10000000                     ; and reactivate nmi
000083r 2  8D 78 07         sta Mirror_PPU_CTRL_REG1           ; update ppu state
000086r 2  8D 00 20         sta PPU_CTRL_REG1                  ;
000089r 2  40               rti                                ; and we are done for the frame
00008Ar 2               
00008Ar 2               ; ================================================================
00008Ar 2               ;  Sets up the all the fixed graphics for the title screen
00008Ar 2               ; ----------------------------------------------------------------
00008Ar 2               PrepareScreen:
00008Ar 2  A9 3F            lda #$3F                           ; move ppu to palette memory
00008Cr 2  8D 06 20         sta PPU_ADDRESS                    ;
00008Fr 2  A9 00            lda #$00                           ;
000091r 2  8D 06 20         sta PPU_ADDRESS                    ;
000094r 2  A2 00            ldx #0                             ;
000096r 2  BD rr rr     :   lda MenuPalette,x                  ; and copy the menu palette
000099r 2  8D 07 20         sta PPU_DATA                       ;
00009Cr 2  E8               inx                                ;
00009Dr 2  E0 20            cpx #(MenuPaletteEnd-MenuPalette)  ;
00009Fr 2  D0 F5            bne :-                             ;
0000A1r 2  A9 20            lda #$20                           ; move ppu to nametable 0
0000A3r 2  8D 06 20         sta PPU_ADDRESS                    ;
0000A6r 2  A2 00            ldx #0                             ;
0000A8r 2  8E 06 20         stx PPU_ADDRESS                    ;
0000ABr 2  BD rr rr     :   lda BGDATA+$000,x                  ; and copy every page of menu data
0000AEr 2  8D 07 20         sta PPU_DATA                       ;
0000B1r 2  E8               inx                                ;
0000B2r 2  D0 F7            bne :-                             ;
0000B4r 2  BD rr rr     :   lda BGDATA+$100,x                  ;
0000B7r 2  8D 07 20         sta PPU_DATA                       ;
0000BAr 2  E8               inx                                ;
0000BBr 2  D0 F7            bne :-                             ;
0000BDr 2  BD rr rr     :   lda BGDATA+$200,x                  ;
0000C0r 2  8D 07 20         sta PPU_DATA                       ;
0000C3r 2  E8               inx                                ;
0000C4r 2  D0 F7            bne :-                             ;
0000C6r 2  BD rr rr     :   lda BGDATA+$300,x                  ;
0000C9r 2  8D 07 20         sta PPU_DATA                       ;
0000CCr 2  E8               inx                                ;
0000CDr 2  D0 F7            bne :-                             ;
0000CFr 2  60               rts                                ;
0000D0r 2               ; ================================================================
0000D0r 2               
0000D0r 2               ; ================================================================
0000D0r 2               ;  Clear RAM and temporary WRAM
0000D0r 2               ; ----------------------------------------------------------------
0000D0r 2               InitializeMemory:
0000D0r 2  A9 00            lda #0                             ; clear A and X
0000D2r 2  A2 00            ldx #0                             ;
0000D4r 2  95 00        :   sta $0000,x                        ; clear relevant memory addresses
0000D6r 2  9D 00 02         sta $0200,x                        ;
0000D9r 2  9D 00 03         sta $0300,x                        ;
0000DCr 2  9D 00 04         sta $0400,x                        ;
0000DFr 2  9D 00 05         sta $0500,x                        ;
0000E2r 2  9D 00 06         sta $0600,x                        ;
0000E5r 2  9D 00 07         sta $0700,x                        ;
0000E8r 2  9D 00 60         sta $6000,x                        ;
0000EBr 2  E8               inx                                ; and loop for 256 bytes
0000ECr 2  D0 E6            bne :-                             ;
0000EEr 2  60               rts                                ;
0000EFr 2               ; ================================================================
0000EFr 2               
0000EFr 2               ; ================================================================
0000EFr 2               ;  Reinitialize WRAM if needed
0000EFr 2               ; ----------------------------------------------------------------
0000EFr 2               InitializeWRAM:
0000EFr 2  A2 05            ldx #ROMSaveHeaderLen              ; get length of the magic wram header
0000F1r 2  BD rr rr     :   lda ROMSaveHeader,x                ; check every byte of the header
0000F4r 2  DD rr rr         cmp WRAMSaveHeader,x               ; does it match?
0000F7r 2  D0 04            bne ForceClearWRAM                 ; no - clear wram
0000F9r 2  CA               dex                                ; yes - check next byte
0000FAr 2  10 F5            bpl :-                             ;
0000FCr 2  60               rts                                ;
0000FDr 2               ; ================================================================
0000FDr 2               
0000FDr 2               ; ================================================================
0000FDr 2               ;  Clear WRAM state
0000FDr 2               ; ----------------------------------------------------------------
0000FDr 2               ForceClearWRAM:
0000FDr 2                   @Ptr = $0
0000FDr 2  A9 60            lda #$60                           ; set starting address to $6000
0000FFr 2  85 01            sta @Ptr+1                         ;
000101r 2  A0 00            ldy #0                             ;
000103r 2  84 00            sty @Ptr+0                         ;
000105r 2  A2 80            ldx #$80                           ; and mark ending address at $8000
000107r 2  A9 00            lda #$00                           ; clear A
000109r 2  91 00        :   sta (@Ptr),y                       ; clear one byte of WRAM
00010Br 2  C8               iny                                ; and advance
00010Cr 2  D0 FB            bne :-                             ; for 256 bytes
00010Er 2  E6 01            inc @Ptr+1                         ; then advance to the next page
000110r 2  E4 01            cpx @Ptr+1                         ; check if we are at the ending page
000112r 2  D0 F5            bne :-                             ; no - keep clearing data
000114r 2  A2 05            ldx #ROMSaveHeaderLen              ; otherwise copy the magic wram header
000116r 2  BD rr rr     :   lda ROMSaveHeader,x                ;
000119r 2  9D rr rr         sta WRAMSaveHeader,x               ;
00011Cr 2  CA               dex                                ;
00011Dr 2  10 F7            bpl :-                             ;
00011Fr 2  60               rts                                ;
000120r 2               ; ================================================================
000120r 2               
000120r 2               ; include all of the relevant title files
000120r 2               .include "practise.asm"
000120r 3               ; ===========================================================================
000120r 3               ;  Start the game!
000120r 3               ; ---------------------------------------------------------------------------
000120r 3               TStartGame:
000120r 3                   @FRDigits = (MathFrameruleDigitEnd-MathFrameruleDigitStart-1)
000120r 3  20 rr rr         jsr InitBankSwitchingCode                    ; copy utility code to WRAM
000123r 3  A2 04            ldx #@FRDigits                               ; set up framerule digits
000125r 3               @KeepCopying:                                    ;
000125r 3  BD rr rr         lda MathFrameruleDigitStart, x               ; copy each framerule digit from the menu
000128r 3  9D rr rr         sta MathInGameFrameruleDigitStart, x         ;
00012Br 3  CA               dex                                          ;
00012Cr 3  10 F7            bpl @KeepCopying                             ;
00012Er 3  18               clc                                          ;
00012Fr 3  A9 01            lda #1                                       ; set flag indicating we are entering from the menu
000131r 3  8D rr rr         sta EnteringFromMenu                         ;
000134r 3  8D 70 07         sta OperMode                                 ; set starting opermode to "gamemode"
000137r 3  8D rr rr         sta IsPlaying                                ; mark that we are in game mode
00013Ar 3  4A               lsr a                                        ; clear A
00013Br 3  8D 72 07         sta OperMode_Task                            ; clear opermode task value
00013Er 3  85 0E            sta GameEngineSubroutine                     ; clear game engine task
000140r 3  8D 47 07         sta TimerControl                             ; mark the game as running
000143r 3  8D rr rr         sta PendingScoreDrawPosition                 ; clear pending status bar draw flag
000146r 3  8D 00 20         sta PPU_CTRL_REG1                            ; diable rendering
000149r 3  8D 78 07         sta Mirror_PPU_CTRL_REG1                     ;
00014Cr 3  8D 01 20         sta PPU_CTRL_REG2                            ;
00014Fr 3  8D 15 40         sta $4015                                    ; silence music
000152r 3  85 FC            sta EventMusicQueue                          ; stop music queue
000154r 3  AE rr rr         ldx SettablesWorld                           ; copy menu world number
000157r 3  8E 5F 07         stx WorldNumber                              ;
00015Ar 3  AE rr rr         ldx SettablesLevel                           ; copy menu level number
00015Dr 3  8E 5C 07         stx LevelNumber                              ;
000160r 3  AE rr rr         ldx SettablesPUP                             ; get menu powerup state
000163r 3  BD rr rr         lda @StatusSizes,x                           ; get player size based on menu state
000166r 3  8D 54 07         sta PlayerSize                               ; and update player size
000169r 3  BD rr rr         lda @StatusPowers,x                          ; get player power state based on menu state
00016Cr 3  8D 56 07         sta PlayerStatus                             ; and update player status
00016Fr 3  A9 02            lda #$2                                      ; give player 3 lives
000171r 3  8D 5A 07         sta NumberofLives                            ;
000174r 3  A9 04            lda #$4                                      ; set the interval timer to a hardcoded value
000176r 3  8D 7F 07         sta IntervalTimerControl                     ;
000179r 3  EE 57 07         inc FetchNewGameTimerFlag                    ; tell the game to reload the game timer
00017Cr 3  4C rr rr         jmp BANK_AdvanceToLevel                      ; transition to the wram code to start the game
00017Fr 3               @StatusSizes:
00017Fr 3  01 00 00 00  .byte $1, $0, $0, $0, $1, $1
000183r 3  01 01        
000185r 3               @StatusPowers:
000185r 3  00 01 02 00  .byte $0, $1, $2, $0, $1, $2
000189r 3  01 02        
00018Br 3               ; ===========================================================================
00018Br 3               
00018Br 3               ; ===========================================================================
00018Br 3               ;  Practise routine per frame routine
00018Br 3               ; ---------------------------------------------------------------------------
00018Br 3               PractiseNMI:
00018Br 3  AD rr rr         lda EnteringFromMenu                         ; are we currently entering from the menu?
00018Er 3  F0 01            beq @ClearPractisePrintScore                 ; no - then we can run our routine
000190r 3  60               rts                                          ; otherwise, we're loading, so just return
000191r 3               @ClearPractisePrintScore:                        ;
000191r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; check if we have pending ppu draws
000194r 3  D0 03            bne @IncrementFrameruleCounter               ; yes - skip ahead
000196r 3  8D rr rr         sta PendingScoreDrawPosition                 ; no - clear pending vram address for framerule drawing
000199r 3               @IncrementFrameruleCounter:                      ;
000199r 3  20 rr rr         jsr IncrementFrameruleCounter                ; increment the base10 framerule counter
00019Cr 3  20 rr rr         jsr CheckForLevelEnd                         ; run level transition handler
00019Fr 3  20 rr rr         jsr CheckJumpingState                        ; run jump handler
0001A2r 3  20 rr rr         jsr CheckAreaTimer                           ; run area transition timing handler
0001A5r 3               @CheckUpdateStatusbarValues:                     ;
0001A5r 3  A5 09            lda FrameCounter                             ; get current frame counter
0001A7r 3  29 03            and #3                                       ; and just make sure we're in a specific 4 frame spot
0001A9r 3  C9 02            cmp #2                                       ;
0001ABr 3  D0 03            bne @CheckInput                              ; if not, skip ahead
0001ADr 3  20 rr rr         jsr RedrawHighFreqStatusbar                  ; otherwise update status bar
0001B0r 3               @CheckInput:                                     ;
0001B0r 3  AD 4A 07         lda JoypadBitMask                            ; get current joypad state
0001B3r 3  29 30            and #(Select_Button | Start_Button)          ; mask out all but select and start
0001B5r 3  F0 24            beq @Done                                    ; neither are held - nothing more to do here
0001B7r 3  20 rr rr         jsr ReadJoypads                              ; re-read joypad state, to avoid filtering from the game
0001BAr 3               @CheckForRestartLevel:                           ;
0001BAr 3  C9 28            cmp #(Up_Dir | Select_Button)                ; check if select + up are held
0001BCr 3  D0 0E            bne @CheckForReset                           ; no - skip ahead
0001BEr 3  A9 00            lda #0                                       ; yes - we are restarting the level
0001C0r 3  8D 00 20         sta PPU_CTRL_REG1                            ; disable screen rendering
0001C3r 3  8D 01 20         sta PPU_CTRL_REG2                            ;
0001C6r 3  20 rr rr         jsr InitializeMemory                         ; clear memory
0001C9r 3  4C rr rr         jmp TStartGame                               ; and start the game
0001CCr 3               @CheckForReset:                                  ;
0001CCr 3  C9 24            cmp #(Down_Dir | Select_Button)              ; check if select + down are held
0001CEr 3  D0 0B            bne @Done                                    ; no - skip ahead
0001D0r 3  A9 00            lda #0                                       ; yes - we are returning to the title screen
0001D2r 3  8D 00 20         sta PPU_CTRL_REG1                            ; disable screen rendering
0001D5r 3  8D 01 20         sta PPU_CTRL_REG2                            ;
0001D8r 3  4C rr rr         jmp HotReset                                 ; and reset the game
0001DBr 3               @Done:                                           ;
0001DBr 3  60               rts                                          ;
0001DCr 3               ; ===========================================================================
0001DCr 3               
0001DCr 3               ; ===========================================================================
0001DCr 3               ;  Handle new area loading loading
0001DCr 3               ; ---------------------------------------------------------------------------
0001DCr 3               PractiseEnterStage:
0001DCr 3                   @FRDigitCount = MathFrameruleDigitEnd - MathFrameruleDigitStart - 1
0001DCr 3  A9 03            lda #3                                       ; set life counter so we can't lose the game
0001DEr 3  8D 5A 07         sta NumberofLives                            ;
0001E1r 3  A9 98            lda #152                                     ; position spr0
0001E3r 3  8D 03 02         sta $203                                     ;
0001E6r 3  AD rr rr         lda EnteringFromMenu                         ; check if we're entering from the menu
0001E9r 3  F0 0F            beq @SaveToMenu                              ; no, the player beat a level, update the menu state
0001EBr 3  38               sec                                          ; yes, the player is starting a new game
0001ECr 3  A5 09            lda FrameCounter                             ; we need to offset the frame counter a little bit
0001EEr 3  E9 06            sbc #6                                       ;
0001F0r 3  85 09            sta FrameCounter                             ;
0001F2r 3  20 rr rr         jsr RNGQuickResume                           ; and load the rng state
0001F5r 3  CE rr rr         dec EnteringFromMenu                         ; then mark that we've entered from the menu, so this doesn't happen again
0001F8r 3  F0 2B            beq @Shared                                  ; and skip ahead to avoid saving the state for no reason
0001FAr 3               @SaveToMenu:                                     ;
0001FAr 3  AD rr rr         lda LevelEnding                              ; check if we are transitioning to a new level
0001FDr 3  F0 26            beq @Shared                                  ; no - skip ahead and enter the game
0001FFr 3  A2 04            ldx #@FRDigitCount                           ; yes - copy the framerule to the menu
000201r 3  BD rr rr     :   lda MathInGameFrameruleDigitStart,x          ;
000204r 3  9D rr rr         sta MathFrameruleDigitStart,x                ;
000207r 3  CA               dex                                          ;
000208r 3  10 F7            bpl :-                                       ;
00020Ar 3  AD 5F 07         lda WorldNumber                              ; copy current world and level to the menu
00020Dr 3  8D rr rr         sta SettablesWorld                           ;
000210r 3  AD 5C 07         lda LevelNumber                              ;
000213r 3  8D rr rr         sta SettablesLevel                           ;
000216r 3  AD 54 07         lda PlayerSize                               ; get player powerup state
000219r 3  0A               asl a                                        ; shift up a couple of bits to make room for powerup state
00021Ar 3  0A               asl a                                        ;
00021Br 3  0D 56 07         ora PlayerStatus                             ; combine with powerup state
00021Er 3  AA               tax                                          ; copy to X
00021Fr 3  BD rr rr         lda @PUpStates,x                             ; and get the menu selection values from the players current state
000222r 3  8D rr rr         sta SettablesPUP                             ; and write to menu powerup state
000225r 3               @Shared:                                         ;
000225r 3  A9 00            lda #0                                       ; clear out some starting state
000227r 3  8D rr rr         sta CachedChangeAreaTimer                    ;
00022Ar 3  8D rr rr         sta LevelEnding                              ;
00022Dr 3  4C rr rr         jmp RedrawLowFreqStatusbar                   ; and update the status line
000230r 3               @PUpStates:
000230r 3  03           .byte $3                                         ; size = 0, status = 0. big vuln. mario
000231r 3  01           .byte $1                                         ; size = 0, status = 1. big super mario
000232r 3  02           .byte $2                                         ; size = 0, status = 2. big fire mario
000233r 3  00           .byte $0                                         ; size = 1, status = 0. small vuln. mario
000234r 3  05           .byte $5                                         ; size = 1, status = 1. small super mario
000235r 3  06           .byte $6                                         ; size = 1, status = 2. small fire mario
000236r 3               ; ===========================================================================
000236r 3               
000236r 3               ; ===========================================================================
000236r 3               ;  Handle level transitions
000236r 3               ; ---------------------------------------------------------------------------
000236r 3               CheckForLevelEnd:
000236r 3  AD rr rr         lda LevelEnding                              ; have we already detected the level end?
000239r 3  D0 1E            bne @Done                                    ; if so - exit
00023Br 3  AD 3C 07         lda ScreenRoutineTask
00023Er 3  C9 07            cmp #7
000240r 3  F0 14            beq @LevelEnding
000242r 3  AD 46 07         lda StarFlagTaskControl                      ; check the current starflag state
000245r 3  C9 04            cmp #4                                       ; are we in the final starflag task?
000247r 3  D0 10            bne @Done                                    ; no - exit
000249r 3  AD 7F 07         lda IntervalTimerControl                     ; cache the current interval timer
00024Cr 3  8D rr rr         sta CachedITC                                ;
00024Fr 3  18               clc                                          ;
000250r 3  20 rr rr         jsr ChangeTopStatusXToRemains                ; change the 'X' in the title to 'R'
000253r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; and redraw the status bar
000256r 3               @LevelEnding:
000256r 3  EE rr rr         inc LevelEnding                              ; yes - mark the level end as ended
000259r 3               @Done:                                           ;
000259r 3  60               rts                                          ;
00025Ar 3               ; ===========================================================================
00025Ar 3               
00025Ar 3               ; ===========================================================================
00025Ar 3               ;  Handle area transitions (pipes, etc)
00025Ar 3               ; ---------------------------------------------------------------------------
00025Ar 3               CheckAreaTimer:
00025Ar 3  AD rr rr         lda CachedChangeAreaTimer                    ; have we already handled the area change?
00025Dr 3  D0 15            bne @Done                                    ; yes - exit
00025Fr 3  AD DE 06         lda ChangeAreaTimer                          ; no - check if we should handle it
000262r 3  F0 10            beq @Done                                    ; no - exit
000264r 3  8D rr rr         sta CachedChangeAreaTimer                    ; yes - cache the timer value
000267r 3  AD 7F 07         lda IntervalTimerControl                     ; get the interval timer
00026Ar 3               @Store2:                                         ;
00026Ar 3  8D rr rr         sta CachedITC                                ; and cache it as well
00026Dr 3  18               clc                                          ;
00026Er 3  20 rr rr         jsr ChangeTopStatusXToRemains                ; change the 'X' in the title to 'R'
000271r 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; and redraw the status bar
000274r 3               @Done:                                           ;
000274r 3  60               rts                                          ;
000275r 3               ; ===========================================================================
000275r 3               
000275r 3               ; ===========================================================================
000275r 3               ;  Handle player jumping
000275r 3               ; ---------------------------------------------------------------------------
000275r 3               CheckJumpingState:
000275r 3  AD 82 07         lda JumpSwimTimer                            ; check jump timer
000278r 3  C9 20            cmp #$20                                     ; is it the max value (player just jumped)
00027Ar 3  D0 03            bne @Done                                    ; no - exit
00027Cr 3  20 rr rr         jsr RedrawLowFreqStatusbar                   ; yes - redraw the status bar
00027Fr 3               @Done:                                           ;
00027Fr 3  60               rts                                          ; done!
000280r 3               ; ===========================================================================
000280r 3               
000280r 3               ; ===========================================================================
000280r 3               ;  Advance to the next base 10 framerule digit
000280r 3               ; ---------------------------------------------------------------------------
000280r 3               IncrementFrameruleCounter:
000280r 3                   @DigitOffset = (MathInGameFrameruleDigitStart-MathDigits)
000280r 3  AD 47 07         lda TimerControl                             ; check if the game is running
000283r 3  D0 0F            bne @Done                                    ; no - exit
000285r 3  AC 7F 07         ldy IntervalTimerControl                     ; get the interval timer
000288r 3  C0 01            cpy #1                                       ; are we at the end of the interval?
00028Ar 3  D0 08            bne @Done                                    ; no - exit
00028Cr 3  18               clc                                          ;
00028Dr 3  A9 01            lda #1                                       ; we want to add 1 to the digits
00028Fr 3  A2 05            ldx #@DigitOffset                            ; get the offset to the digit we are incrementing
000291r 3  4C rr rr         jmp B10Add                                   ; and run base 10 addition
000294r 3               @Done:                                           ;
000294r 3  60               rts                                          ;
000295r 3               ; ===========================================================================
000295r 3               
000295r 3               ; ===========================================================================
000295r 3               ;  Handle when the game wants to redraw the MARIO / TIME text at the top
000295r 3               ; ---------------------------------------------------------------------------
000295r 3               PractiseWriteTopStatusLine:
000295r 3  18               clc                                          ;
000296r 3  AC 00 03         ldy VRAM_Buffer1_Offset                      ; get current vram offset
000299r 3  A9 2D            lda #(@TopStatusTextEnd-@TopStatusText+1)    ; get text length
00029Br 3  6D 00 03         adc VRAM_Buffer1_Offset                      ; add to vram offset
00029Er 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; and store new offset
0002A1r 3  A2 00            ldx #0                                       ;
0002A3r 3               @CopyData:                                       ;
0002A3r 3  BD rr rr         lda @TopStatusText,x                         ; copy bytes of the status bar text to vram
0002A6r 3  99 01 03         sta VRAM_Buffer1,y                           ;
0002A9r 3  C8               iny                                          ; advance vram offset
0002AAr 3  E8               inx                                          ; advance text offset
0002ABr 3  E0 2C            cpx #(@TopStatusTextEnd-@TopStatusText)      ; check if we're at the end
0002ADr 3  D0 F4            bne @CopyData                                ; if not, loop
0002AFr 3  A9 00            lda #0                                       ; then set null terminator at the end
0002B1r 3  99 01 03         sta VRAM_Buffer1,y                           ;
0002B4r 3  EE 3C 07         inc ScreenRoutineTask                        ; and advance the screen routine task
0002B7r 3  60               rts                                          ; done
0002B8r 3               @TopStatusText:                                  ;
0002B8r 3  20 43 15 1B    .byte $20, $43,  21, "RULE x SOCKS TO FRAME"   ;
0002BCr 3  1E 15 0E 24  
0002C0r 3  29 24 1C 18  
0002D0r 3  20 59 04 1D    .byte $20, $59,   4, "TIME"                    ;
0002D4r 3  12 16 0E     
0002D7r 3  20 73 02 2E    .byte $20, $73,   2, $2e, $29                  ; coin that shows next to the coin counter
0002DBr 3  29           
0002DCr 3  23 C0 7F AA    .byte $23, $c0, $7f, $aa                       ; tile attributes for the top row, sets palette
0002E0r 3  23 C4 01 E0    .byte $23, $c4, $01, %11100000                 ; set palette for the flashing coin
0002E4r 3               @TopStatusTextEnd:
0002E4r 3  00              .byte $00
0002E5r 3               ; ===========================================================================
0002E5r 3               
0002E5r 3               ; ===========================================================================
0002E5r 3               ;  Handle the game requesting redrawing the bottom status bar
0002E5r 3               ; ---------------------------------------------------------------------------
0002E5r 3               PractiseWriteBottomStatusLine:
0002E5r 3  AD rr rr         lda LevelEnding                              ; are we transitioning to a new level?
0002E8r 3  D0 06            bne :+                                       ; yes, don't update the itc value
0002EAr 3  AD 7F 07         lda IntervalTimerControl                     ; no, get the current interval timer
0002EDr 3  8D rr rr         sta CachedITC                                ; and store it in the cached value
0002F0r 3  20 rr rr     :   jsr RedrawLowFreqStatusbar                   ; redraw the status bar
0002F3r 3  EE 3C 07         inc ScreenRoutineTask                        ; and advance to the next smb screen routine
0002F6r 3  60               rts                                          ;
0002F7r 3               ; ===========================================================================
0002F7r 3               
0002F7r 3               ; ===========================================================================
0002F7r 3               ;  Place an "R" instead of "x" in the title screen during level transitions
0002F7r 3               ; ---------------------------------------------------------------------------
0002F7r 3               ChangeTopStatusXToRemains:
0002F7r 3  18               clc                                          ;
0002F8r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; get current vram offset
0002FBr 3  A8               tay                                          ;
0002FCr 3  69 04            adc #4                                       ; and advance it by 4
0002FEr 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; store the new offset
000301r 3  A9 20            lda #$20                                     ; write the ppu address to update
000303r 3  99 01 03         sta VRAM_Buffer1+0, y                        ;
000306r 3  A9 48            lda #$48                                     ;
000308r 3  99 02 03         sta VRAM_Buffer1+1, y                        ;
00030Br 3  A9 01            lda #1                                       ; we are writing a single byte
00030Dr 3  99 03 03         sta VRAM_Buffer1+2, y                        ;
000310r 3  A9 1B            lda #'R'                                     ; and that byte is an R
000312r 3  99 04 03         sta VRAM_Buffer1+3, y                        ;
000315r 3  A9 00            lda #0                                       ; set the null terminator
000317r 3  99 05 03         sta VRAM_Buffer1+4, y                        ;
00031Ar 3  60               rts                                          ; and finish
00031Br 3               ; ===========================================================================
00031Br 3               
00031Br 3               ; ===========================================================================
00031Br 3               ;  Redraw the status bar portion that updates less often
00031Br 3               ; ---------------------------------------------------------------------------
00031Br 3               RedrawLowFreqStatusbar:
00031Br 3  18               clc                                          ;
00031Cr 3  AC rr rr         ldy PendingScoreDrawPosition                 ; check if we have a pending draw that hasn't been sent to the ppu
00031Fr 3  D0 12            bne @RefreshBufferX                          ; yes - skip ahead and refresh the buffer to avoid overloading the ppu
000321r 3  AC 00 03         ldy VRAM_Buffer1_Offset                      ; no - get the current buffer offset
000324r 3  C8               iny                                          ; increment past the ppu location
000325r 3  C8               iny                                          ;
000326r 3  C8               iny                                          ;
000327r 3  8C rr rr         sty PendingScoreDrawPosition                 ; and store it as our pending position
00032Ar 3  20 rr rr         jsr @PrintRule                               ; draw the current framerule value
00032Dr 3  20 rr rr         jsr @PrintFramecounter                       ; draw the current framecounter value
000330r 3  A6 08            ldx ObjectOffset                             ; load object offset, our caller might expect it to be unchanged
000332r 3  60               rts                                          ; and exit
000333r 3               @RefreshBufferX:                                 ;
000333r 3  20 rr rr         jsr @PrintRuleDataAtY                        ; refresh pending framerule value
000336r 3  98               tya                                          ; get the buffer offset we're drawing to
000337r 3  69 09            adc #9                                       ; and shift over to the framecounter position
000339r 3  A8               tay                                          ;
00033Ar 3  20 rr rr         jsr @PrintFramecounterDataAtY                ; and then refresh the pending frame ounter value
00033Dr 3  A6 08            ldx ObjectOffset                             ; load object offset, our caller might expect it to be unchanged
00033Fr 3  60               rts                                          ; and exit
000340r 3               ; ---------------------------------------------------------------------------
000340r 3               ;  Copy current framerule number to VRAM
000340r 3               ; ---------------------------------------------------------------------------
000340r 3               @PrintRule:
000340r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; get the current buffer offset
000343r 3  A8               tay                                          ;
000344r 3  69 09            adc #(3+6)                                   ; shift over based on length of the framerule text
000346r 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; store the ppu location of the framerule counter
000349r 3  A9 20            lda #$20                                     ;
00034Br 3  99 01 03         sta VRAM_Buffer1,y                           ;
00034Er 3  A9 63            lda #$63                                     ;
000350r 3  99 02 03         sta VRAM_Buffer1+1,y                         ;
000353r 3  A9 06            lda #$06                                     ; store the number of digits to draw
000355r 3  99 03 03         sta VRAM_Buffer1+2,y                         ;
000358r 3  C8               iny                                          ; increment past the ppu location
000359r 3  C8               iny                                          ;
00035Ar 3  C8               iny                                          ;
00035Br 3  A9 00            lda #0                                       ; place our null terminator
00035Dr 3  99 07 03         sta VRAM_Buffer1+6,y                         ;
000360r 3  A9 24            lda #$24                                     ; and write a space past the framerule (masks out smb1 '0' after the score)
000362r 3  99 05 03         sta VRAM_Buffer1+4,y                         ;
000365r 3               @PrintRuleDataAtY:
000365r 3  AD rr rr         lda CachedITC                                ; get the interval timer for when we entered the room
000368r 3  99 06 03         sta VRAM_Buffer1+5,y                         ; and store it in the buffer
00036Br 3  AD rr rr         lda MathInGameFrameruleDigitStart+3          ; then copy the framerule numbers into the buffer
00036Er 3  99 01 03         sta VRAM_Buffer1+0,y                         ;
000371r 3  AD rr rr         lda MathInGameFrameruleDigitStart+2          ;
000374r 3  99 02 03         sta VRAM_Buffer1+1,y                         ;
000377r 3  AD rr rr         lda MathInGameFrameruleDigitStart+1          ;
00037Ar 3  99 03 03         sta VRAM_Buffer1+2,y                         ;
00037Dr 3  AD rr rr         lda MathInGameFrameruleDigitStart+0          ;
000380r 3  99 04 03         sta VRAM_Buffer1+3,y                         ;
000383r 3  60               rts                                          ;
000384r 3               ; ---------------------------------------------------------------------------
000384r 3               ;  Copy current frame number to VRAM
000384r 3               ; ---------------------------------------------------------------------------
000384r 3               @PrintFramecounter:
000384r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; get current vram offset
000387r 3  A8               tay                                          ;
000388r 3  69 06            adc #(3+3)                                   ; add 3 for vram offset, 3 for values to draw
00038Ar 3  8D 00 03         sta VRAM_Buffer1_Offset                      ; save new vram offset
00038Dr 3  A9 20            lda #$20                                     ; store the ppu location of the frame number
00038Fr 3  99 01 03         sta VRAM_Buffer1,y                           ;
000392r 3  A9 75            lda #$75                                     ;
000394r 3  99 02 03         sta VRAM_Buffer1+1,y                         ;
000397r 3  A9 03            lda #$03                                     ; store the number of digits to draw
000399r 3  99 03 03         sta VRAM_Buffer1+2,y                         ;
00039Cr 3  C8               iny                                          ; advance y to the end of the buffer to write
00039Dr 3  C8               iny                                          ;
00039Er 3  C8               iny                                          ;
00039Fr 3  A9 00            lda #0                                       ; place our null terminator
0003A1r 3  99 04 03         sta VRAM_Buffer1+3,y                         ;
0003A4r 3               @PrintFramecounterDataAtY:                       ;
0003A4r 3  A5 09            lda FrameCounter                             ; get the current frame number
0003A6r 3  20 rr rr         jsr B10DivBy10                               ; divide by 10
0003A9r 3  99 03 03         sta VRAM_Buffer1+2,y                         ; store remainder in vram buffer
0003ACr 3  8A               txa                                          ; get the result of the divide
0003ADr 3  20 rr rr         jsr B10DivBy10                               ; divide by 10
0003B0r 3  99 02 03         sta VRAM_Buffer1+1,y                         ; store remainder in vram buffer
0003B3r 3  8A               txa                                          ; get the result of the divide
0003B4r 3  99 01 03         sta VRAM_Buffer1+0,y                         ; and store it in vram
0003B7r 3  60               rts                                          ;
0003B8r 3               ; ===========================================================================
0003B8r 3               
0003B8r 3               ; ===========================================================================
0003B8r 3               ;  Update and draw status bar values
0003B8r 3               ; ---------------------------------------------------------------------------
0003B8r 3               RedrawHighFreqStatusbar:
0003B8r 3                   @SockSubX = $2                               ; memory locations that sockfolder is stored in
0003B8r 3                   @SockX    = $3                               ;
0003B8r 3  AD 00 03         lda VRAM_Buffer1_Offset                      ; check if there are pending ppu updates
0003BBr 3  F0 01            beq :+                                       ; no - skip ahead to update status bar
0003BDr 3  60               rts                                          ; yes - don't overload the ppu
0003BEr 3  20 rr rr     :   jsr RecalculateSockfolder                    ; calculate new sockfolder value
0003C1r 3               
0003C1r 3  A2 00            ldx #0                                       ; clear X
0003C3r 3  A9 20            lda #$20                                     ; write ppu location of status bar to vram buffer
0003C5r 3  9D 01 03         sta VRAM_Buffer1+0,x                         ;
0003C8r 3  A9 6A            lda #$6A                                     ;
0003CAr 3  9D 02 03         sta VRAM_Buffer1+1,x                         ;
0003CDr 3  A9 08            lda #8                                       ; write number of bytes to draw
0003CFr 3  9D 03 03         sta VRAM_Buffer1+2,x                         ;
0003D2r 3  A9 0B            lda #(8+3)                                   ; and update vram buffer offset to new location
0003D4r 3  8D 00 03         sta VRAM_Buffer1_Offset                      ;
0003D7r 3  A9 24            lda #$24                                     ; write spaces to a couple of locations
0003D9r 3  9D 06 03         sta VRAM_Buffer1+3+2,x                       ;
0003DCr 3  9D 09 03         sta VRAM_Buffer1+3+5,x                       ;
0003DFr 3  A9 00            lda #0                                       ; write null terminator
0003E1r 3  9D 0C 03         sta VRAM_Buffer1+3+8,x                       ;
0003E4r 3               
0003E4r 3  A5 03            lda @SockX                                   ; get sockfolder x position
0003E6r 3  29 0F            and #$0F                                     ; mask off the high nibble
0003E8r 3  9D 04 03         sta VRAM_Buffer1+3+0,x                       ; and write that byte to the vram buffer
0003EBr 3  A5 02            lda @SockSubX                                ; get sockfolder subpixel x position
0003EDr 3  4A               lsr                                          ; and shift down to the low nibble
0003EEr 3  4A               lsr                                          ;
0003EFr 3  4A               lsr                                          ;
0003F0r 3  4A               lsr                                          ;
0003F1r 3  9D 05 03         sta VRAM_Buffer1+3+1,x                       ; and write that byte to the vram buffer
0003F4r 3  AD 05 07         lda Player_X_MoveForce                       ; get the current player subpixel
0003F7r 3  A8               tay                                          ; copy to Y
0003F8r 3  29 0F            and #$0F                                     ; mask off the high nibble
0003FAr 3  9D 08 03         sta VRAM_Buffer1+3+4,x ; Y                   ; and write that byte to the vram buffer
0003FDr 3  98               tya                                          ; restore full value from Y
0003FEr 3  4A               lsr                                          ; and shift down to the low nibble
0003FFr 3  4A               lsr                                          ;
000400r 3  4A               lsr                                          ;
000401r 3  4A               lsr                                          ;
000402r 3  9D 07 03         sta VRAM_Buffer1+3+3,x ; Y                   ; and write that byte to the vram buffer
000405r 3  AD 50 07         lda AreaPointer                              ; get the pointer to where warp pipes direct player
000408r 3  A8               tay                                          ; copy to Y
000409r 3  29 0F            and #$0F                                     ; mask off the high nibble
00040Br 3  9D 0B 03         sta VRAM_Buffer1+3+7,x ; X                   ; and write that byte to the vram buffer
00040Er 3  98               tya                                          ; restore full value from Y
00040Fr 3  4A               lsr                                          ; and shift down to the low nibble
000410r 3  4A               lsr                                          ;
000411r 3  4A               lsr                                          ;
000412r 3  4A               lsr                                          ;
000413r 3  9D 0A 03         sta VRAM_Buffer1+3+6,x ; X                   ; and write that byte to the vram buffer
000416r 3               @skip:                                           ;
000416r 3  60               rts                                          ;
000417r 3               ; ===========================================================================
000417r 3               
000417r 3               
000417r 3               ; ===========================================================================
000417r 3               ;  Calculate the current sockfolder value
000417r 3               ; ---------------------------------------------------------------------------
000417r 3               ; Sockfolder is effectively calculated by the following formula:
000417r 3               ;  Player_X_Position + ((0xFF - Player_Y_Position) / MaximumYSpeed) * MaximumXSpeed
000417r 3               ;
000417r 3               ; So that will give you the position that mario would be when he reaches the
000417r 3               ; bottom of the screen assuming the player is falling at full speed.
000417r 3               ;
000417r 3               ; Here's a little javascript snippet that creates a 16 bit lookup table of sockfolder values:
000417r 3               ;
000417r 3               ;; // NTSC:
000417r 3               ;; let max_x_speed = 0x0280; // maximum x speed in subpixels
000417r 3               ;; let max_y_speed = 0x04;   // maximum y speed in pixels
000417r 3               ;; // PAL:
000417r 3               ;; //let max_x_speed = 0x0300; // maximum x speed in subpixels
000417r 3               ;; //let max_y_speed = 0x05;   // maximum y speed in pixels
000417r 3               ;;
000417r 3               ;; let values = [];
000417r 3               ;; for (let i=0xFF; i>=0x00; --i) {
000417r 3               ;;     let value = Math.floor(i/max_y_speed)*max_x_speed;
000417r 3               ;;     let format = Math.round(value).toString(16).padStart(4,'0');
000417r 3               ;;     values.push('$' + format);
000417r 3               ;; };
000417r 3               ;;
000417r 3               ;; let items_per_row = 0x8;
000417r 3               ;; for (let i=0; i<(values.length/items_per_row); ++i) {
000417r 3               ;;     let start = i * items_per_row;
000417r 3               ;;     let end = (i * items_per_row) + items_per_row;
000417r 3               ;;     let line = values.slice(start, end).join(',')
000417r 3               ;;     console.log('.byte ' + line + ' ; range ' +  start.toString(16) + ' to ' + (end-1).toString(16));
000417r 3               ;; }
000417r 3               ;
000417r 3               ; ---------------------------------------------------------------------------
000417r 3               RecalculateSockfolder:
000417r 3                   @DataTemp = $4                               ; temp value used for some maths
000417r 3                   @DataSubX = $2                               ; sockfolder subpixel x value
000417r 3                   @DataX    = $3                               ; sockfolder pixel x value
000417r 3  AD 00 04         lda SprObject_X_MoveForce                    ; get subpixel x position
00041Ar 3  85 02            sta @DataSubX                                ; and store it in our temp data
00041Cr 3  A5 86            lda Player_X_Position                        ; get x position
00041Er 3  85 03            sta @DataX                                   ; and store it in our temp data
000420r 3  A5 CE            lda Player_Y_Position                        ; get y position
000422r 3  49 FF            eor #$FF                                     ; invert the bits, now $FF is the top of the screen
000424r 3  4A               lsr a                                        ; divide pixel position by 8
000425r 3  4A               lsr a                                        ;
000426r 3  4A               lsr a                                        ;
000427r 3  90 0F            bcc @sock1                                   ; if we're on the top half of tile 'tile', we will land 2.5 pixels later.
000429r 3  48               pha                                          ; so store the current value
00042Ar 3  18               clc                                          ;
00042Br 3  A5 02            lda @DataSubX                                ; get subpixel x position
00042Dr 3  A9 80            lda #$80                                     ; and increase it by half
00042Fr 3  85 02            sta @DataSubX                                ; and store it back
000431r 3  A5 03            lda @DataX                                   ; get x position
000433r 3  69 02            adc #$02                                     ; and add 2 + carry value
000435r 3  85 03            sta @DataX                                   ; and store it back
000437r 3  68               pla                                          ; then restore our original value
000438r 3               @sock1:                                          ;
000438r 3  85 04            sta @DataTemp                                ; store this in our temp value
00043Ar 3  0A               asl a                                        ; multiply by 4
00043Br 3  0A               asl a                                        ;
00043Cr 3  65 04            adc @DataTemp                                ; and add the temp value
00043Er 3  65 03            adc @DataX                                   ; then add our x position
000440r 3  85 03            sta @DataX                                   ; and store it back
000442r 3  60               rts                                          ;
000443r 3               ; ===========================================================================
000443r 3               
000443r 2               .include "menu.asm"
000443r 3               SettablesCount   = $4
000443r 3               MenuTextPtr      = $C3
000443r 3               MenuTextLen      = $C2
000443r 3               
000443r 3               .pushseg
000443r 3               .segment "MENUWRAM"
00000Ar 3  00           MenuSelectedItem: .byte $00
00000Br 3  00           MenuSelectedSubitem: .byte $00
00000Cr 3               Settables:
00000Cr 3  00           SettablesWorld: .byte $00
00000Dr 3  00           SettablesLevel: .byte $00
00000Er 3  00           SettablesPUP:   .byte $00
00000Fr 3  00           SettablesRule:  .byte $00
000010r 3               .popseg
000443r 3               
000443r 3               ; names for each selection type
000443r 3               MenuTitles:
000443r 3  20 18 1B 15  .byte "WORLD   "
000447r 3  0D 24 24 24  
00044Br 3  15 0E 1F 0E  .byte "LEVEL   "
00044Fr 3  15 24 24 24  
000453r 3  19 28 1E 19  .byte "P-UP    "
000457r 3  24 24 24 24  
00045Br 3  1B 1E 15 0E  .byte "RULE    "
00045Fr 3  24 24 24 24  
000463r 3               
000463r 3               ; ppu position to draw each title
000463r 3               .define MenuTitleLocations \
000463r 3                   $20CA + ($40 * 0), \
000463r 3                   $20CA + ($40 * 1), \
000463r 3                   $20CA + ($40 * 2), \
000463r 3                   $20CA + ($40 * 3)
000463r 3               
000463r 3               ; ppu position to draw each value
000463r 3               .define MenuValueLocations \
000463r 3                   $20D3 + ($40 * 0) - 0, \
000463r 3                   $20D3 + ($40 * 1) - 0, \
000463r 3                   $20D3 + ($40 * 2) - 3, \
000463r 3                   $20D3 + ($40 * 3) - 3
000463r 3               
000463r 3               ; which routines to use to change each menu items value
000463r 3               UpdateSelectedValueJE:
000463r 3  98               tya
000464r 3  20 rr rr         jsr JumpEngine
000467r 3  rr rr            .word UpdateValueWorldNumber ; world
000469r 3  rr rr            .word UpdateValueLevelNumber ; level
00046Br 3  rr rr            .word UpdateValuePUps        ; p-up
00046Dr 3  rr rr            .word UpdateValueFramerule   ; framerule
00046Fr 3               
00046Fr 3               ; which routines to use to draw each menu items value
00046Fr 3               DrawMenuValueJE:
00046Fr 3  98               tya
000470r 3  20 rr rr         jsr JumpEngine
000473r 3  rr rr            .word DrawValueNumber        ; world
000475r 3  rr rr            .word DrawValueNumber        ; level
000477r 3  rr rr            .word DrawValueString_PUp    ; p-up
000479r 3  rr rr            .word DrawValueFramerule     ; framerule
00047Br 3               
00047Br 3               ; ===========================================================================
00047Br 3               ;  Redraw menu
00047Br 3               ; ---------------------------------------------------------------------------
00047Br 3               DrawMenu:
00047Br 3               MenuReset:
00047Br 3                   @Temp = $10
00047Br 3  A0 03            ldy #(SettablesCount-1)                  ; get number of menu items
00047Dr 3  84 10        :   sty @Temp                                ; store the current menu item
00047Fr 3  20 rr rr         jsr @DrawMenuTitle                       ; draw the title of the menu item
000482r 3  A4 10            ldy @Temp                                ; restore the menu item
000484r 3  20 rr rr         jsr DrawMenuValueJE                      ; draw the value of the menu item
000487r 3  A4 10            ldy @Temp                                ; restore the menu item
000489r 3  88               dey                                      ; and decrement it
00048Ar 3  10 F1            bpl :-                                   ; if not done, keep drawing
00048Cr 3  60               rts                                      ; otherwise, exit
00048Dr 3               @DrawMenuTitle:
00048Dr 3  18               clc                                      ;
00048Er 3  AD 00 03         lda VRAM_Buffer1_Offset                  ; get current vram offset position
000491r 3  AA               tax                                      ;
000492r 3  69 08            adc #3+5                                 ; advance it based on how many bytes we will write
000494r 3  8D 00 03         sta VRAM_Buffer1_Offset                  ; and save it back
000497r 3  B9 rr rr         lda MenuTitleLocationsHi,y               ; set ppu location of the current item's title
00049Ar 3  9D 01 03         sta VRAM_Buffer1+0,x                     ;
00049Dr 3  B9 rr rr         lda MenuTitleLocationsLo,y               ;
0004A0r 3  9D 02 03         sta VRAM_Buffer1+1,x                     ;
0004A3r 3  A9 05            lda #5                                   ; store length of the title
0004A5r 3  9D 03 03         sta VRAM_Buffer1+2,x                     ;
0004A8r 3  98               tya                                      ; copy the menu item index to A
0004A9r 3  2A               rol a                                    ; and multiply it by 8, the offsets of the title strings
0004AAr 3  2A               rol a                                    ;
0004ABr 3  2A               rol a                                    ;
0004ACr 3  A8               tay                                      ; and copy that back to Y
0004ADr 3  B9 rr rr         lda MenuTitles+0,y                       ; then write the title screen to the buffer
0004B0r 3  9D 04 03         sta VRAM_Buffer1+3,x                     ;
0004B3r 3  B9 rr rr         lda MenuTitles+1,y                       ;
0004B6r 3  9D 05 03         sta VRAM_Buffer1+4,x                     ;
0004B9r 3  B9 rr rr         lda MenuTitles+2,y                       ;
0004BCr 3  9D 06 03         sta VRAM_Buffer1+5,x                     ;
0004BFr 3  B9 rr rr         lda MenuTitles+3,y                       ;
0004C2r 3  9D 07 03         sta VRAM_Buffer1+6,x                     ;
0004C5r 3  B9 rr rr         lda MenuTitles+4,y                       ;
0004C8r 3  9D 08 03         sta VRAM_Buffer1+7,x                     ;
0004CBr 3  A9 00            lda #0                                   ; and end the buffer with null
0004CDr 3  9D 09 03         sta VRAM_Buffer1+8,x                     ;
0004D0r 3  60               rts                                      ;
0004D1r 3               ; ===========================================================================
0004D1r 3               
0004D1r 3               ; ===========================================================================
0004D1r 3               ;  Menu main loop
0004D1r 3               ; ---------------------------------------------------------------------------
0004D1r 3               MenuNMI:
0004D1r 3  20 rr rr         jsr DrawSelectionMarkers                 ; reposition the selection markers
0004D4r 3  18               clc                                      ;
0004D5r 3  AD rr rr         lda PressedButtons                       ; check current inputs
0004D8r 3  D0 01            bne @READINPUT                           ; if any buttons are held, check them
0004DAr 3  60               rts                                      ; otherwise there's nothing to do
0004DBr 3               @READINPUT:                                  ;
0004DBr 3  29 0F            and #Right_Dir|Left_Dir|Down_Dir|Up_Dir  ; are we holding a direction?
0004DDr 3  F0 09            beq @SELECT                              ; if not, check for select
0004DFr 3  AC rr rr         ldy MenuSelectedItem                     ; we are, get the current selected item
0004E2r 3  20 rr rr         jsr UpdateSelectedValueJE                ; update the value
0004E5r 3  4C rr rr         jmp @RenderMenu                          ; redraw the menu and exit
0004E8r 3               @SELECT:                                     ;
0004E8r 3  AD rr rr         lda PressedButtons                       ; check current inputs
0004EBr 3  C9 20            cmp #Select_Button                       ; are we holding select?
0004EDr 3  D0 13            bne @START                               ; if not, check for start
0004EFr 3  A2 00            ldx #0                                   ; we are changing selected menu item
0004F1r 3  8E rr rr         stx MenuSelectedSubitem                  ; clear selected subitem
0004F4r 3  EE rr rr         inc MenuSelectedItem                     ; and advance to the next item
0004F7r 3  AD rr rr         lda MenuSelectedItem                     ; then check if we've reached the final item
0004FAr 3  C9 04            cmp #SettablesCount                      ;
0004FCr 3  D0 03            bne :+                                   ; no - skip ahead
0004FEr 3  8E rr rr         stx MenuSelectedItem                     ; yes - clear the selected item
000501r 3  60           :   rts                                      ; and exit
000502r 3               @START:                                      ;
000502r 3  C9 10            cmp #Start_Button                        ; are we holding start?
000504r 3  D0 17            bne @DONE                                ; no - nothing to do, exit
000506r 3  A9 00            lda #0                                   ; yes - check held buttons
000508r 3  AE rr rr         ldx HeldButtons                          ;
00050Br 3  E0 80            cpx #A_Button                            ; check if we're holding A
00050Dr 3  90 02            bcc :+                                   ; nope - skip ahead
00050Fr 3  A9 01            lda #1                                   ; yes - set hard mode flag
000511r 3  8D 6A 07     :   sta PrimaryHardMode                      ; save hard mode flag
000514r 3  4C rr rr         jmp TStartGame                           ; and start the game
000517r 3               @RenderMenu:                                 ;
000517r 3  AC rr rr         ldy MenuSelectedItem                     ; get the current selected item
00051Ar 3  20 rr rr         jsr DrawMenu                             ; and redraw it
00051Dr 3               @DONE:                                       ;
00051Dr 3  60               rts                                      ; done
00051Er 3               ; ===========================================================================
00051Er 3               
00051Er 3               
00051Er 3               ; ===========================================================================
00051Er 3               ;  Position the "cursors" of the menu at the correct location
00051Er 3               ; ---------------------------------------------------------------------------
00051Er 3               DrawSelectionMarkers:
00051Er 3  A9 00            lda #$00                                 ; set palette attributes for sprites
000520r 3  8D 06 02         sta Sprite_Attributes + (1 * SpriteLen)  ;
000523r 3  A9 21            lda #$21                                 ;
000525r 3  8D 0A 02         sta Sprite_Attributes + (2 * SpriteLen)  ;
000528r 3  A9 2E            lda #$2E                                 ; main coin sprite for sprite 1
00052Ar 3  8D 05 02         sta Sprite_Tilenumber + (1 * SpriteLen)  ;
00052Dr 3  A9 27            lda #$27                                 ; set solid background for sprite 2
00052Fr 3  8D 09 02         sta Sprite_Tilenumber + (2 * SpriteLen)  ;
000532r 3  A9 1E            lda #$1E                                 ; get initial Y position
000534r 3  AC rr rr         ldy MenuSelectedItem                     ; get current menu item
000537r 3  18           :   clc                                      ;
000538r 3  69 10            adc #$10                                 ; add 16px per menu item
00053Ar 3  88               dey                                      ; decrement loop value
00053Br 3  10 FA            bpl :-                                   ; and loop until done
00053Dr 3  8D 04 02         sta Sprite_Y_Position + (1 * SpriteLen)  ; reposition sprite 1 (floating coin)
000540r 3  8D 08 02         sta Sprite_Y_Position + (2 * SpriteLen)  ; reposition sprite 2 (background color)
000543r 3  A9 A9            lda #$A9                                 ; get initial X position
000545r 3  8D 07 02         sta Sprite_X_Position + (1 * SpriteLen)  ; reposition sprite 1 (floating coin)
000548r 3  E9 08            sbc #$8                                  ; offset by 8px for the background color
00054Ar 3  AC rr rr         ldy MenuSelectedSubitem                  ; get which subitem is selected
00054Dr 3  38           :   sec                                      ; then offset by another 8px per subitem
00054Er 3  E9 08            sbc #$8                                  ;
000550r 3  88               dey                                      ; decrement loop value
000551r 3  10 FA            bpl :-                                   ; and loop until done
000553r 3  8D 0B 02         sta Sprite_X_Position + (2 * SpriteLen)  ; reposition sprite 2 (background color)
000556r 3  60               rts                                      ; done
000557r 3               ; ===========================================================================
000557r 3               
000557r 3               ; update selected world value
000557r 3               UpdateValueWorldNumber:
000557r 3  AE rr rr         ldx WorldCount         ; get number of worlds
00055Ar 3  AD rr rr         lda HeldButtons        ; check held buttons
00055Dr 3  29 40            and #B_Button          ; are we holding B?
00055Fr 3  F0 02            beq :+                 ; no - skip ahead
000561r 3  A2 FF            ldx #$FF               ; otherwise allow selecting any value
000563r 3  4C rr rr     :   jmp UpdateValueShared  ; update selected menu item
000566r 3               
000566r 3               ; update selected level value
000566r 3               UpdateValueLevelNumber:
000566r 3  AE rr rr         ldx LevelCount         ; get number of levels per world
000569r 3  AD rr rr         lda HeldButtons        ; check held buttons
00056Cr 3  29 40            and #B_Button          ; are we holding B?
00056Er 3  F0 02            beq :+                 ; no - skip ahead
000570r 3  A2 FF            ldx #$FF               ; otherwise allow selecting any value
000572r 3  4C rr rr     :   jmp UpdateValueShared  ; update selected menu item
000575r 3               
000575r 3               ; update selected powerup value
000575r 3               UpdateValuePUps:
000575r 3  A2 06            ldx #6                 ; there are 6 total states
000577r 3  4C rr rr         jmp UpdateValueShared  ; update selected menu item
00057Ar 3               
00057Ar 3               ; ===========================================================================
00057Ar 3               ; Update a single byte menu item
00057Ar 3               ; ---------------------------------------------------------------------------
00057Ar 3               ; Input:  Y   = menu item index
00057Ar 3               ;         X   = maximum allowed value
00057Ar 3               ; ---------------------------------------------------------------------------
00057Ar 3               UpdateValueShared:
00057Ar 3                   @Max = $0
00057Ar 3  86 00            stx @Max                          ; temp store max value
00057Cr 3  18               clc                               ;
00057Dr 3  AD rr rr         lda PressedButtons                ; get current inputs
000580r 3  29 06            and #Down_Dir|Left_Dir            ; check if we're pressing decrementing direction
000582r 3  D0 0D            bne @Decrement                    ; yes - skip ahead to decrement
000584r 3               @Increment:                           ; no - we are incrementing
000584r 3  B9 rr rr         lda Settables,y                   ; get current value of the menu item
000587r 3  69 01            adc #1                            ; increment it
000589r 3  C5 00            cmp @Max                          ; check if we're beyond the maximum value
00058Br 3  90 13            bcc @Store                        ; no - skip ahead to store
00058Dr 3  A9 00            lda #0                            ; yes - set to 0
00058Fr 3  F0 0F            beq @Store                        ; and store
000591r 3               @Decrement:                           ;
000591r 3  B9 rr rr         lda Settables,y                   ; get current value of the menu item
000594r 3  F0 05            beq @Wrap                         ; if it's 0, wrap around
000596r 3  38               sec                               ;
000597r 3  E9 01            sbc #1                            ; otherwise, decrement it
000599r 3  50 05            bvc @Store                        ; skip ahead to store
00059Br 3               @Wrap:                                ;
00059Br 3  A5 00            lda @Max                          ; wrap around to the maximum value + 1
00059Dr 3  38               sec                               ; and decrement it by 1
00059Er 3  E9 01            sbc #1                            ;
0005A0r 3               @Store:                               ;
0005A0r 3  99 rr rr         sta Settables,y                   ; store the new value
0005A3r 3  60               rts                               ;
0005A4r 3               ; ===========================================================================
0005A4r 3               
0005A4r 3               ; ===========================================================================
0005A4r 3               ; Modify the selected framerule
0005A4r 3               ; ---------------------------------------------------------------------------
0005A4r 3               UpdateValueFramerule:
0005A4r 3  18               clc                               ;
0005A5r 3  AE rr rr         ldx MenuSelectedSubitem           ; get selected digit offset
0005A8r 3  AD rr rr         lda PressedButtons                ; check inputs
0005ABr 3  29 03            and #Right_Dir|Left_Dir           ; are we pressing left/right
0005ADr 3  F0 11            beq @update_value                 ; no - skip to check if we're changing value
0005AFr 3  CA               dex                               ; yes - we are changing which digit is selected
0005B0r 3  AD rr rr         lda PressedButtons                ; get buttons again
0005B3r 3  C9 01            cmp #Right_Dir                    ; are we pressing right?
0005B5r 3  F0 02            beq @store_selected               ; yes - store X as new selected digit
0005B7r 3  E8               inx                               ; no - we are pressing left, increment twice to offset dex
0005B8r 3  E8               inx                               ;
0005B9r 3               @store_selected:                      ;
0005B9r 3  8A               txa                               ;
0005BAr 3  29 03            and #%11                          ; mask to valid framerule value
0005BCr 3  8D rr rr         sta MenuSelectedSubitem           ; and update selected digit
0005BFr 3  60               rts                               ; done - exit
0005C0r 3               @update_value:
0005C0r 3  BC rr rr         ldy MathFrameruleDigitStart,x     ; get the digit we're changing
0005C3r 3  AD rr rr         lda PressedButtons                ; and check inputs
0005C6r 3  C9 08            cmp #Up_Dir                       ; are we pressing up?
0005C8r 3  F0 07            beq @increase                     ; yes - increment digit
0005CAr 3  88               dey                               ; no - decrement digit
0005CBr 3  10 0B            bpl @store_value                  ; if we didn't underflow, store value
0005CDr 3  A0 09            ldy #9                            ; otherwise wrap back around to 9
0005CFr 3  D0 07            bne @store_value                  ; and store value
0005D1r 3               @increase:
0005D1r 3  C8               iny                               ; we're increment, so, increment Y
0005D2r 3  C0 0A            cpy #$A                           ; check if we overflowed
0005D4r 3  D0 02            bne @store_value                  ; no - store value
0005D6r 3  A0 00            ldy #0                            ; yes - wrap back around to 0
0005D8r 3               @store_value:
0005D8r 3  98               tya                               ;
0005D9r 3  9D rr rr         sta MathFrameruleDigitStart,x     ; and save the new digit
0005DCr 3  60               rts                               ; exit!
0005DDr 3               ; ===========================================================================
0005DDr 3               
0005DDr 3               ; ===========================================================================
0005DDr 3               ; Draws a menu item to screen
0005DDr 3               ; ---------------------------------------------------------------------------
0005DDr 3               DrawValueNumber:
0005DDr 3  18               clc                               ;
0005DEr 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
0005E1r 3  AA               tax                               ;
0005E2r 3  69 04            adc #4                            ; offset it based on how much we're writing
0005E4r 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
0005E7r 3  B9 rr rr         lda MenuValueLocationsHi,y        ; get the ppu location of this menu item, and write to vram buffer
0005EAr 3  9D 01 03         sta VRAM_Buffer1+0,x              ;
0005EDr 3  B9 rr rr         lda MenuValueLocationsLo,y        ;
0005F0r 3  9D 02 03         sta VRAM_Buffer1+1,x              ;
0005F3r 3  A9 01            lda #1                            ; we're writing 1 number
0005F5r 3  9D 03 03         sta VRAM_Buffer1+2,x              ;
0005F8r 3  B9 rr rr         lda Settables,y                   ; get the value of the settable item
0005FBr 3  69 01            adc #1                            ; and increment it, since we display 1-based numbers
0005FDr 3  9D 04 03         sta VRAM_Buffer1+3,x              ; store the number to be drawn
000600r 3  A9 00            lda #0                            ; and mark the end of the buffer
000602r 3  9D 05 03         sta VRAM_Buffer1+4,x              ;
000605r 3  60               rts                               ;
000606r 3               ; ===========================================================================
000606r 3               
000606r 3               ; ===========================================================================
000606r 3               ; Draws the four digit framerule to screen
000606r 3               ; ---------------------------------------------------------------------------
000606r 3               DrawValueFramerule:
000606r 3  18               clc                               ;
000607r 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
00060Ar 3  AA               tax                               ;
00060Br 3  69 07            adc #7                            ; offset it based on how much we're writing
00060Dr 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
000610r 3  B9 rr rr         lda MenuValueLocationsHi, y       ; get the ppu location of this menu item, and write to vram buffer
000613r 3  9D 01 03         sta VRAM_Buffer1+0, x             ;
000616r 3  B9 rr rr         lda MenuValueLocationsLo, y       ;
000619r 3  9D 02 03         sta VRAM_Buffer1+1, x             ;
00061Cr 3  A9 04            lda #4                            ; we're writing 4 numbers
00061Er 3  9D 03 03         sta VRAM_Buffer1+2, x             ;
000621r 3  AD rr rr         lda MathFrameruleDigitStart+0     ; copy each of the four digits to vram buffer
000624r 3  9D 07 03         sta VRAM_Buffer1+3+3, x           ;
000627r 3  AD rr rr         lda MathFrameruleDigitStart+1     ;
00062Ar 3  9D 06 03         sta VRAM_Buffer1+3+2, x           ;
00062Dr 3  AD rr rr         lda MathFrameruleDigitStart+2     ;
000630r 3  9D 05 03         sta VRAM_Buffer1+3+1, x           ;
000633r 3  AD rr rr         lda MathFrameruleDigitStart+3     ;
000636r 3  9D 04 03         sta VRAM_Buffer1+3+0, x           ;
000639r 3  A9 00            lda #0                            ; and mark the end of the buffer
00063Br 3  9D 08 03         sta VRAM_Buffer1+3+4, x           ;
00063Er 3  60               rts                               ;
00063Fr 3               ; ===========================================================================
00063Fr 3               
00063Fr 3               ; ===========================================================================
00063Fr 3               ; Draws a string from a pointer to screen
00063Fr 3               ; ---------------------------------------------------------------------------
00063Fr 3               DrawValueString:
00063Fr 3  18               clc                               ;
000640r 3  AD 00 03         lda VRAM_Buffer1_Offset           ; get current vram update offset
000643r 3  AA               tax                               ;
000644r 3  65 C2            adc MenuTextLen                   ; offset it based on string length
000646r 3  69 03            adc #3                            ; and add 3 for the header
000648r 3  8D 00 03         sta VRAM_Buffer1_Offset           ; and store it back
00064Br 3  B9 rr rr         lda MenuValueLocationsHi,y        ; get the ppu location of this menu item, and write to vram buffer
00064Er 3  9D 01 03         sta VRAM_Buffer1+0,x              ;
000651r 3  B9 rr rr         lda MenuValueLocationsLo,y        ;
000654r 3  9D 02 03         sta VRAM_Buffer1+1,x              ;
000657r 3  A5 C2            lda MenuTextLen                   ; write the string length to vram buffer
000659r 3  9D 03 03         sta VRAM_Buffer1+2,x              ;
00065Cr 3  A0 00            ldy #0                            ; prepare iterator
00065Er 3               @CopyNext:                            ;
00065Er 3  B1 C3            lda (MenuTextPtr),y               ; copy a byte of the string to vram
000660r 3  9D 04 03         sta VRAM_Buffer1+3,x              ;
000663r 3  E8               inx                               ; increment vram offset
000664r 3  C8               iny                               ; increment string read offset
000665r 3  C4 C2            cpy MenuTextLen                   ; check if we're done
000667r 3  90 F5            bcc @CopyNext                     ; no - copy next byte
000669r 3  A9 00            lda #0                            ; and mark the end of the buffer
00066Br 3  9D 05 03         sta VRAM_Buffer1+4, x             ;
00066Er 3  60               rts                               ;
00066Fr 3               ; ===========================================================================
00066Fr 3               
00066Fr 3               ; ===========================================================================
00066Fr 3               ; Draws a powerup state to screen
00066Fr 3               ; ---------------------------------------------------------------------------
00066Fr 3               DrawValueString_PUp:
00066Fr 3  B9 rr rr         lda Settables,y                   ; get the selected powerup state
000672r 3  0A               asl a                             ; get offset into pointer table
000673r 3  AA               tax                               ;
000674r 3  BD rr rr         lda @Strings,x                    ; copy string pointer to menu text pointer
000677r 3  85 C3            sta MenuTextPtr                   ;
000679r 3  BD rr rr         lda @Strings+1,x                  ;
00067Cr 3  85 C4            sta MenuTextPtr+1                 ;
00067Er 3  A9 05            lda #5                            ; set fixed string length
000680r 3  85 C2            sta MenuTextLen                   ;
000682r 3  4C rr rr         jmp DrawValueString               ; and draw the string
000685r 3               
000685r 3               @Strings:
000685r 3  rr rr        .word @Str0
000687r 3  rr rr        .word @Str1
000689r 3  rr rr        .word @Str2
00068Br 3  rr rr        .word @Str3
00068Dr 3  rr rr        .word @Str4
00068Fr 3  rr rr        .word @Str5
000691r 3               
000691r 3  17 18 17 0E  @Str0: .byte "NONE "
000695r 3  24           
000696r 3  24 0B 12 10  @Str1: .byte " BIG "
00069Ar 3  24           
00069Br 3  0F 12 1B 0E  @Str2: .byte "FIRE "
00069Fr 3  24           
0006A0r 3  17 18 17 0E  @Str3: .byte "NONE!"
0006A4r 3  2B           
0006A5r 3  24 0B 12 10  @Str4: .byte " BIG!"
0006A9r 3  2B           
0006AAr 3  0F 12 1B 0E  @Str5: .byte "FIRE!"
0006AEr 3  2B           
0006AFr 3               ; ===========================================================================
0006AFr 3               
0006AFr 3               ; pointers to menu values
0006AFr 3  D3 13 50 90  MenuValueLocationsLo: .lobytes MenuValueLocations
0006B3r 3  20 21 21 21  MenuValueLocationsHi: .hibytes MenuValueLocations
0006B7r 3  CA 0A 4A 8A  MenuTitleLocationsLo: .lobytes MenuTitleLocations
0006BBr 3  20 21 21 21  MenuTitleLocationsHi: .hibytes MenuTitleLocations
0006BFr 3               
0006BFr 2               .include "utils.asm"
0006BFr 3               
0006BFr 3               ; ===========================================================================
0006BFr 3               ;  Base 10 addition
0006BFr 3               ; ---------------------------------------------------------------------------
0006BFr 3               ; Input:
0006BFr 3               ;   X - offset into base10 value list to add
0006BFr 3               ;   A - value to add
0006BFr 3               ; ---------------------------------------------------------------------------
0006BFr 3               B10Add:
0006BFr 3  18               clc                        ;
0006C0r 3  7D rr rr         adc MathDigits,x           ; add value to digit
0006C3r 3  9D rr rr         sta MathDigits,x           ; store result
0006C6r 3  C9 0A        :   cmp #10                    ; compare against 10
0006C8r 3  90 12            bcc @Done                  ; if less than 10, we're done
0006CAr 3  A9 00            lda #0                     ; otherwise, set to 0
0006CCr 3  9D rr rr         sta MathDigits,x           ; store result
0006CFr 3  E8               inx                        ; move to next digit
0006D0r 3  30 0A            bmi @Done                  ; if no more digits, we're done
0006D2r 3  BD rr rr         lda MathDigits,x           ; get next digit
0006D5r 3  69 00            adc #0                     ; add our carry
0006D7r 3  9D rr rr         sta MathDigits,x           ; store result
0006DAr 3  90 EA            bcc :-                     ; and keep going until we don't have a carry
0006DCr 3               @Done:                         ;
0006DCr 3  60               rts                        ;
0006DDr 3               ; ===========================================================================
0006DDr 3               
0006DDr 3               ; ===========================================================================
0006DDr 3               ;  Divide A value by 10
0006DDr 3               ; ---------------------------------------------------------------------------
0006DDr 3               ;  Example:
0006DDr 3               ;  lda #145
0006DDr 3               ;  jsr B10DivideBy10
0006DDr 3               ;  ; A = 5   (remainder)
0006DDr 3               ;  ; X = 14  (quotient)
0006DDr 3               ; ---------------------------------------------------------------------------
0006DDr 3               B10DivBy10:
0006DDr 3  A2 00            ldx #$00                  ; clear result
0006DFr 3  C9 0A        :   cmp #$0a                  ; compare current value against 10
0006E1r 3  90 05            bcc @Done                 ; if lower, then we are finished
0006E3r 3  E9 0A            sbc #$0a                  ; otherwise subtract 10
0006E5r 3  E8               inx                       ; and increment result
0006E6r 3  D0 F7            bne :-                    ; keep looping
0006E8r 3               @Done:                        ;
0006E8r 3  60               rts                       ; done
0006E9r 3               ; ===========================================================================
0006E9r 3               
0006E9r 3               ; ================================================================
0006E9r 3               ;  6502 multiply by 10
0006E9r 3               ; ----------------------------------------------------------------
0006E9r 3               MultiplyBy10:
0006E9r 3  0A               asl                       ; multiply by 2
0006EAr 3  85 00            sta $0                    ; store in temp value
0006ECr 3  0A               asl                       ; multiply by 4
0006EDr 3  0A               asl                       ;
0006EEr 3  18               clc                       ;
0006EFr 3  65 00            adc $0                    ; add temp value, so, (A*2*4)+(A*2)
0006F1r 3  60               rts                       ; done
0006F2r 3               ; ================================================================
0006F2r 3               
0006F2r 3               ;; copied code from smb1
0006F2r 3               WriteVRAMBufferToScreen:
0006F2r 3  AD 00 03         lda VRAM_Buffer1_Offset
0006F5r 3  F0 2F            beq @Skip
0006F7r 3  A0 03            ldy #>(VRAM_Buffer1)
0006F9r 3  84 01            sty $1
0006FBr 3  A0 01            ldy #<(VRAM_Buffer1)
0006FDr 3  84 00            sty $0
0006FFr 3  A0 00            ldy #0
000701r 3               @KeepWriting:
000701r 3  20 rr rr         jsr WriteBufferPtrToScreen
000704r 3  B1 00            lda ($0),y
000706r 3  F0 10            beq @Done
000708r 3  18               clc
000709r 3  98               tya
00070Ar 3  65 00            adc $0
00070Cr 3  85 00            sta $0
00070Er 3  A5 01            lda $1
000710r 3  69 00            adc #$0
000712r 3  85 01            sta $1
000714r 3  A0 00            ldy #0
000716r 3  50 E9            bvc @KeepWriting
000718r 3               @Done:
000718r 3  A9 00            lda #0
00071Ar 3  8D 01 03         sta VRAM_Buffer1
00071Dr 3  8D 00 03         sta VRAM_Buffer1_Offset
000720r 3  8D 05 20         sta PPU_SCROLL_REG
000723r 3  8D 05 20         sta PPU_SCROLL_REG
000726r 3               @Skip:
000726r 3  60               rts
000727r 3               
000727r 3               WriteBufferPtrToScreen:
000727r 3  B1 00            lda ($0),y
000729r 3  C9 1F            cmp #$1F
00072Br 3  90 19            bcc @Done
00072Dr 3  8D 06 20         sta PPU_ADDRESS
000730r 3  C8               iny
000731r 3  B1 00            lda ($0),y
000733r 3  8D 06 20         sta PPU_ADDRESS
000736r 3  C8               iny
000737r 3  B1 00            lda ($0),y
000739r 3  AA               tax
00073Ar 3  F0 0A            beq @Done
00073Cr 3               @Continue:
00073Cr 3  C8               iny
00073Dr 3  B1 00            lda ($0),y
00073Fr 3  8D 07 20         sta PPU_DATA
000742r 3  CA               dex
000743r 3  D0 F7            bne @Continue
000745r 3  C8               iny
000746r 3               @Done:
000746r 3  60               rts
000747r 3               
000747r 3               ReadJoypadsCurrent:
000747r 3  A9 01            lda #$01
000749r 3  8D 16 40         sta JOYPAD_PORT
00074Cr 3  8D rr rr         sta HeldButtons
00074Fr 3  4A               lsr a
000750r 3  8D 16 40         sta JOYPAD_PORT
000753r 3               @KeepReading:
000753r 3  AD 16 40         lda JOYPAD_PORT
000756r 3  4A               lsr a
000757r 3  2E rr rr         rol HeldButtons
00075Ar 3  90 F7            bcc @KeepReading
00075Cr 3  60               rts
00075Dr 3               
00075Dr 3               ReadJoypads:
00075Dr 3  20 rr rr         jsr ReadJoypadsCurrent
000760r 3  AD rr rr         lda HeldButtons
000763r 3  49 FF            eor #%11111111
000765r 3  2D rr rr         and LastReadButtons
000768r 3  8D rr rr         sta ReleasedButtons
00076Br 3  AD rr rr         lda LastReadButtons
00076Er 3  49 FF            eor #%11111111
000770r 3  2D rr rr         and HeldButtons
000773r 3  8D rr rr         sta PressedButtons
000776r 3  AD rr rr         lda HeldButtons
000779r 3  8D rr rr         sta LastReadButtons
00077Cr 3  60               rts
00077Dr 3               
00077Dr 3               JumpEngine:
00077Dr 3  84 00            sty $00
00077Fr 3  0A               asl          ;shift bit from contents of A
000780r 3  A8               tay
000781r 3  68               pla          ;pull saved return address from stack
000782r 3  85 04            sta $04      ;save to indirect
000784r 3  68               pla
000785r 3  85 05            sta $05
000787r 3  C8               iny
000788r 3  B1 04            lda ($04),y  ;load pointer from indirect
00078Ar 3  85 06            sta $06      ;note that if an RTS is performed in next routine
00078Cr 3  C8               iny          ;it will return to the execution before the sub
00078Dr 3  B1 04            lda ($04),y  ;that called this routine
00078Fr 3  85 07            sta $07
000791r 3  88               dey
000792r 3  88               dey
000793r 3  98               tya
000794r 3  A4 00            ldy $00
000796r 3  6C 06 00         jmp ($06)    ;jump to the address we loaded
000799r 3               
000799r 3               
000799r 2               .include "background.asm"
000799r 3               BGDATA:
000799r 3  24 24 24 24  .incbin "../scripts/graphics/menu.bin"
00079Dr 3  24 24 24 24  
0007A1r 3  24 24 24 24  
000B59r 3               
000B59r 3               ; attributes
000B59r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000B5Dr 3  FF FF FF FF  
000B61r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000B65r 3  FF FF FF FF  
000B69r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000B6Dr 3  FF FF FF FF  
000B71r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
000B75r 3  FF FF FF FF  
000B79r 3  FF FF FF FF  .byte $FF, $FF, $FF, $FF, $FF, $00, $00, $00
000B7Dr 3  FF 00 00 00  
000B81r 3  00 00 00 00  .byte $00, $00, $00, $00, $00, $00, $00, $00
000B85r 3  00 00 00 00  
000B89r 3  00 00 00 05  .byte $00, $00, $00, $05, $05, $05, $00, $00
000B8Dr 3  05 05 00 00  
000B91r 3  00 00 00 00  .byte $00, $00, $00, $00, $00, $00, $00, $00
000B95r 3  00 00 00 00  
000B99r 3               
000B99r 3               MenuPalette:
000B99r 3  0F 30 10 00  .byte $0F, $30, $10, $00
000B9Dr 3  0F 11 01 02  .byte $0F, $11, $01, $02
000BA1r 3  0F 30 10 00  .byte $0F, $30, $10, $00
000BA5r 3  0F 30 2D 30  .byte $0F, $30, $2D, $30
000BA9r 3               
000BA9r 3  0F 30 11 01  .byte $0F, $30, $11, $01
000BADr 3  0F 11 11 11  .byte $0F, $11, $11, $11
000BB1r 3  0F 0F 10 0F  .byte $0F, $0F, $10, $0F
000BB5r 3  0F 0F 10 0F  .byte $0F, $0F, $10, $0F
000BB9r 3               MenuPaletteEnd:
000BB9r 3               
000BB9r 2               .include "bankswitching.asm"
000BB9r 3               .import __PRACTISE_WRAMCODE_LOAD__, __PRACTISE_WRAMCODE_RUN__, __PRACTISE_WRAMCODE_SIZE__
000BB9r 3               
000BB9r 3               
000BB9r 3               ; ===========================================================================
000BB9r 3               ;  Copy bankswitching code to WRAM
000BB9r 3               ; ---------------------------------------------------------------------------
000BB9r 3               InitBankSwitchingCode:
000BB9r 3  A2 00            ldx #0                                    ; init X
000BBBr 3  BD rr rr     :   lda __PRACTISE_WRAMCODE_LOAD__,x          ; load byte from ROM
000BBEr 3  9D rr rr         sta __PRACTISE_WRAMCODE_RUN__,x           ; and copy to WRAM
000BC1r 3  BD rr rr         lda __PRACTISE_WRAMCODE_LOAD__+$100,x     ; load byte from ROM
000BC4r 3  9D rr rr         sta __PRACTISE_WRAMCODE_RUN__+$100,x      ; and copy to WRAM
000BC7r 3  E8               inx                                       ; increment to copy full page
000BC8r 3  D0 F1            bne :-                                    ;
000BCAr 3  60               rts                                       ;
000BCBr 3               ; ===========================================================================
000BCBr 3               
000BCBr 3               ; this code is copied into WRAM and used to jump between banks
000BCBr 3               .pushseg
000BCBr 3               .segment "PRACTISE_WRAMCODE"
000000r 3               ; export symbols so that we can call them from smb1 and title screen as needed
000000r 3               .export BANK_PractiseNMI
000000r 3               .export BANK_PractiseReset
000000r 3               .export BANK_PractiseWriteBottomStatusLine
000000r 3               .export BANK_PractiseWriteTopStatusLine
000000r 3               .export BANK_PractisePrintScore
000000r 3               .export BANK_PractiseEnterStage
000000r 3               
000000r 3               ; these values can get replaced during patching
000000r 3  08           WorldCount: .byte 8
000001r 3  04           LevelCount: .byte 4
000002r 3  4C rr rr     RELOCATE_GetAreaDataAddrs: jmp GetAreaDataAddrs
000005r 3  4C rr rr     RELOCATE_LoadAreaPointer: jmp LoadAreaPointer
000008r 3  4C rr rr     RELOCATE_PlayerEndWorld: jmp PlayerEndWorld
00000Br 3  4C rr rr     RELOCATE_NonMaskableInterrupt: jmp NonMaskableInterrupt
00000Er 3  4C rr rr     RELOCATE_GL_ENTER: jmp GL_ENTER
000011r 3               
000011r 3               ; wrappers around some title screen routines to be called from the game
000011r 3               BANK_PractiseNMI:
000011r 3  20 rr rr     jsr BANK_TITLE_RTS
000014r 3  20 rr rr     jsr PractiseNMI
000017r 3  4C rr rr     jmp BANK_GAME_RTS
00001Ar 3               
00001Ar 3               BANK_PractiseReset:
00001Ar 3  20 rr rr     jsr BANK_TITLE_RTS
00001Dr 3  4C rr rr     jmp HotReset
000020r 3               
000020r 3               BANK_PractiseWriteBottomStatusLine:
000020r 3  20 rr rr     jsr BANK_TITLE_RTS
000023r 3  20 rr rr     jsr PractiseWriteBottomStatusLine
000026r 3  4C rr rr     jmp BANK_GAME_RTS
000029r 3               
000029r 3               BANK_PractiseWriteTopStatusLine:
000029r 3  20 rr rr     jsr BANK_TITLE_RTS
00002Cr 3  20 rr rr     jsr PractiseWriteTopStatusLine
00002Fr 3  4C rr rr     jmp BANK_GAME_RTS
000032r 3               
000032r 3               BANK_PractisePrintScore:
000032r 3  20 rr rr     jsr BANK_TITLE_RTS
000035r 3  20 rr rr     jsr RedrawLowFreqStatusbar
000038r 3  4C rr rr     jmp BANK_GAME_RTS
00003Br 3               
00003Br 3               BANK_PractiseEnterStage:
00003Br 3  20 rr rr     jsr BANK_TITLE_RTS
00003Er 3  20 rr rr     jsr PractiseEnterStage
000041r 3  4C rr rr     jmp BANK_GAME_RTS
000044r 3  60           rts
000045r 3               
000045r 3               ; ===========================================================================
000045r 3               ;  Attempt to find the level selected on th emenu screen
000045r 3               ; ---------------------------------------------------------------------------
000045r 3               BANK_AdvanceToLevel:
000045r 3                   @AreaNumber = $0
000045r 3  20 rr rr         jsr BANK_GAME_RTS                   ; load game bank
000048r 3  A2 00            ldx #0                              ;
00004Ar 3  86 00            stx @AreaNumber                     ; clear temp area number
00004Cr 3  8E 60 07         stx AreaNumber                      ; clear area number
00004Fr 3  AE 5C 07         ldx LevelNumber                     ; get how many levels to advance
000052r 3  F0 1A            beq @LevelFound                     ; if we're on the first level, we're done
000054r 3               @NextArea:                              ;
000054r 3  20 rr rr         jsr RELOCATE_LoadAreaPointer        ; otherwise, load the area pointer
000057r 3  20 rr rr         jsr BANK_LEVELBANK_RTS              ; and switch to the level bank if needed
00005Ar 3  20 rr rr         jsr RELOCATE_GetAreaDataAddrs       ; then get the pointer to the area data
00005Dr 3  EE 60 07         inc AreaNumber                      ; advance area pointer
000060r 3  AD 10 07         lda PlayerEntranceCtrl              ; get what kind of entry this level has
000063r 3  29 04            and #%00000100                      ; check if it's a controllable area
000065r 3  F0 04            beq @AreaOK                         ; yes - advance to next level
000067r 3  E6 00            inc @AreaNumber                     ; yes - increment temp area number
000069r 3  50 E9            bvc @NextArea                       ; and check next area
00006Br 3               @AreaOK:                                ;
00006Br 3  CA               dex                                 ; decrement number of levels we need to advance
00006Cr 3  D0 E6            bne @NextArea                       ; and keep running if we haven't reached our level
00006Er 3               @LevelFound:                            ;
00006Er 3  18               clc                                 ;
00006Fr 3  AD 5C 07         lda LevelNumber                     ; get level we are starting on
000072r 3  65 00            adc @AreaNumber                     ; and add how many areas we needed to skip
000074r 3  8D 60 07         sta AreaNumber                      ; and store that as the area number
000077r 3  A9 00            lda #0                              ; clear sound
000079r 3  8D 11 40         sta SND_DELTA_REG+1                 ;
00007Cr 3  20 rr rr         jsr RELOCATE_LoadAreaPointer        ; reload pointers for this area
00007Fr 3  20 rr rr         jsr RELOCATE_GetAreaDataAddrs       ;
000082r 3  A9 A5            lda #$a5                            ;
000084r 3  4C rr rr         jmp RELOCATE_GL_ENTER               ; then start the game
000087r 3               ; ===========================================================================
000087r 3               
000087r 3               ; return to previous segment
000087r 3               .popseg
000BCBr 3               
000BCBr 2               .include "rng.asm"
000BCBr 3               ; lookup tables of RNG values for different framerules, each offset is another 2100 frames
000BCBr 3  2E BF 41 6D  resume_0: .byte $2e, $bf, $41, $6d, $1b, $0e, $4f, $c2, $ba, $4b, $e6, $b9, $78, $c2, $a0, $cc, $69, $77, $0b, $8f, $eb, $9f, $a4, $44, $d2, $e4, $e7, $22, $84, $18, $e9, $93, $7f, $7e, $a9, $8e, $0b, $68, $1e, $a8, $7c, $c0, $04, $72, $5f, $e3, $c0, $43, $59, $3d, $9a, $cf, $43, $9f, $f9, $e8, $3f, $53, $9b, $6f, $09, $8f, $56, $50, $b6, $11, $33, $d2, $9b, $31, $ee, $06, $fc, $20, $ad, $2f, $3a, $e7, $94, $bb, $37, $ef, $54, $e9, $19, $60, $53, $73, $b7, $af, $23, $e1, $dd, $ef, $d1, $db, $a5, $ce, $59
000BCFr 3  1B 0E 4F C2  
000BD3r 3  BA 4B E6 B9  
000C2Er 3  F4 B6 A3 D1  resume_1: .byte $f4, $b6, $a3, $d1, $51, $ba, $e3, $83, $b5, $97, $63, $80, $34, $51, $f9, $15, $4d, $eb, $8d, $98, $92, $52, $bd, $5c, $c1, $93, $e8, $70, $c3, $a0, $58, $2c, $79, $38, $d0, $f9, $4b, $aa, $62, $27, $e8, $89, $6c, $b4, $69, $ce, $19, $31, $99, $6b, $69, $ec, $63, $10, $ac, $f3, $ed, $5f, $a4, $eb, $21, $20, $32, $9a, $09, $87, $ed, $09, $f8, $3b, $c5, $7a, $df, $0c, $44, $8f, $48, $0a, $95, $f8, $55, $64, $04, $c0, $bd, $60, $e1, $91, $34, $8e, $f1, $8c, $6e, $84, $92, $f6, $be, $a5, $47
000C32r 3  51 BA E3 83  
000C36r 3  B5 97 63 80  
000C91r 3  A9 C9 20 0A  resume_2: .byte $a9, $c9, $20, $0a, $67, $a7, $7c, $06, $c0, $00, $af, $f3, $c4, $d5, $b8, $8d, $9f, $04, $9a, $87, $45, $6c, $f4, $d4, $64, $5a, $27, $34, $ca, $91, $8a, $0a, $87, $c4, $83, $e4, $5d, $7b, $5e, $77, $11, $08, $64, $51, $d7, $09, $99, $b7, $2a, $11, $5d, $73, $e5, $2e, $5f, $22, $92, $f9, $93, $34, $33, $3e, $9e, $3b, $65, $a4, $8a, $ad, $cf, $59, $18, $76, $26, $4c, $1e, $d0, $3c, $c4, $bc, $8f, $3b, $ba, $ac, $13, $8e, $a0, $46, $76, $5a, $d1, $b6, $4f, $d4, $5b, $31, $41, $f5, $38, $f5
000C95r 3  67 A7 7C 06  
000C99r 3  C0 00 AF F3  
000CF4r 3  40 A4 66 A8  resume_3: .byte $40, $a4, $66, $a8, $c5, $d2, $ba, $00, $ab, $2e, $68, $f2, $ad, $76, $4b, $a6, $04, $d2, $81, $b6, $61, $c8, $8f, $6d, $e6, $7c, $f7, $d4, $4d, $d0, $3b, $52, $74, $b5, $22, $17, $cb, $2f, $9a, $39, $c1, $1a, $bc, $39, $04, $95, $aa, $d4, $18, $c7, $8f, $ab, $22, $0e, $07, $c4, $49, $46, $da, $e2, $71, $7e, $fb, $0f, $77, $ab, $51, $be, $3e, $2f, $92, $82, $98, $54, $96, $cf, $ac, $d1, $97, $7e, $91, $73, $a5, $93, $f5, $61, $84, $54, $32, $cc, $55, $57, $09, $53, $15, $ad, $88, $72, $7a
000CF8r 3  C5 D2 BA 00  
000CFCr 3  AB 2E 68 F2  
000D57r 3  00 37 26 BD  resume_4: .byte $00, $37, $26, $bd, $0a, $9d, $43, $0c, $2a, $2e, $36, $15, $24, $dc, $3b, $bd, $3a, $db, $b4, $b9, $eb, $11, $66, $c5, $2f, $c8, $b8, $bd, $d9, $f3, $2f, $46, $7a, $3c, $24, $df, $70, $d9, $27, $d7, $e2, $0a, $75, $9b, $aa, $86, $99, $bb, $4c, $e4, $34, $4c, $e8, $52, $b9, $81, $6d, $b4, $fd, $8b, $17, $02, $c6, $79, $bd, $e2, $45, $e5, $a0, $9d, $a3, $6f, $d5, $cc, $ab, $6e, $d5, $58, $ee, $60, $e6, $07, $fc, $b4, $e8, $21, $09, $b8, $86, $6f, $39, $c9, $a1, $e5, $77, $2e, $63, $02, $90
000D5Br 3  0A 9D 43 0C  
000D5Fr 3  2A 2E 36 15  
000DBAr 3  00 7F EA EC  resume_5: .byte $00, $7f, $ea, $ec, $80, $38, $37, $0c, $7c, $72, $e6, $f1, $7e, $31, $ad, $f0, $32, $7e, $b7, $d4, $28, $81, $78, $1e, $e3, $31, $57, $14, $42, $52, $59, $e2, $92, $56, $60, $f0, $e6, $86, $13, $a4, $61, $3e, $0d, $e8, $a3, $ad, $cc, $12, $7c, $6b, $2a, $1a, $ad, $4e, $b6, $08, $ff, $39, $48, $4e, $f5, $fe, $31, $67, $52, $b5, $e7, $98, $dd, $c2, $86, $6b, $e4, $65, $86, $f0, $8c, $fa, $c1, $9c, $c5, $e1, $b7, $93, $03, $e3, $01, $11, $e3, $f7, $93, $66, $b2, $42, $5d, $74, $73, $e6, $65
000DBEr 3  80 38 37 0C  
000DC2r 3  7C 72 E6 F1  
000E1Dr 3  00 11 A7 97  resume_6: .byte $00, $11, $a7, $97, $95, $02, $b1, $14, $28, $2e, $8b, $da, $36, $89, $da, $8b, $46, $c8, $de, $a7, $fe, $a2, $b4, $94, $bc, $a1, $27, $6e, $f0, $b4, $07, $6f, $67, $2e, $28, $4f, $07, $35, $5d, $0b, $a5, $2a, $e7, $df, $f6, $a0, $ff, $64, $e4, $a3, $42, $82, $7c, $ea, $c5, $0a, $24, $51, $b2, $58, $da, $fb, $bd, $95, $28, $70, $6c, $53, $9c, $f9, $c1, $b5, $4f, $fd, $d1, $2d, $27, $4b, $1c, $5d, $08, $ee, $4e, $fa, $d3, $a0, $13, $61, $ee, $28, $e0, $f4, $f1, $88, $b3, $28, $b5, $e3, $45
000E21r 3  95 02 B1 14  
000E25r 3  28 2E 8B DA  
000E80r 3               
000E80r 3               ; ================================================================
000E80r 3               ;  Setup framerule RNG
000E80r 3               ; ----------------------------------------------------------------
000E80r 3               RNGQuickResume:
000E80r 3  AD rr rr         lda MathFrameruleDigitStart+3        ; get hundreds and thousands digits of bcd framerule value
000E83r 3  20 rr rr         jsr MultiplyBy10                     ;
000E86r 3  6D rr rr         adc MathFrameruleDigitStart+2        ;
000E89r 3  AA               tax                                  ; store in X
000E8Ar 3  BD rr rr         lda resume_0,x                       ; get rng value from lookup table for this offset
000E8Dr 3  8D A7 07         sta PseudoRandomBitReg+0             ;
000E90r 3  BD rr rr         lda resume_1,x                       ;
000E93r 3  8D A8 07         sta PseudoRandomBitReg+1             ;
000E96r 3  BD rr rr         lda resume_2,x                       ;
000E99r 3  8D A9 07         sta PseudoRandomBitReg+2             ;
000E9Cr 3  BD rr rr         lda resume_3,x                       ;
000E9Fr 3  8D AA 07         sta PseudoRandomBitReg+3             ;
000EA2r 3  BD rr rr         lda resume_4,x                       ;
000EA5r 3  8D AB 07         sta PseudoRandomBitReg+4             ;
000EA8r 3  BD rr rr         lda resume_5,x                       ;
000EABr 3  8D AC 07         sta PseudoRandomBitReg+5             ;
000EAEr 3  BD rr rr         lda resume_6,x                       ;
000EB1r 3  8D AD 07         sta PseudoRandomBitReg+6             ;
000EB4r 3               @FrameruleAdjust:
000EB4r 3  AD rr rr         lda MathFrameruleDigitStart + 1      ; get ones and tens digits of bcd framerule value
000EB7r 3  20 rr rr         jsr MultiplyBy10                     ;
000EBAr 3  6D rr rr         adc MathFrameruleDigitStart + 0      ;
000EBDr 3  A8               tay                                  ; store in Y
000EBEr 3  F0 03            beq @FrameAdjust                     ; if not set, we can skip ahead
000EC0r 3  20 rr rr         jsr FRStepRNGByY                     ; otherwise we advance the RNG based on the framerule value * 21
000EC3r 3               @FrameAdjust:
000EC3r 3  AE rr rr         ldx SettablesPUP                     ; check if player has selected a powerup
000EC6r 3  D0 01            bne :+                               ; yes - skip ahead to adjust rng
000EC8r 3  60               rts                                  ; no - we are done!
000EC9r 3  BC rr rr     :   ldy @FramerulePowerupAdjust-1,x      ; check rng steps for current powerup value
000ECCr 3  20 rr rr         jsr StepRNGByY                       ; and adjust the rng for this value
000ECFr 3  CA               dex                                  ; decrement to next powerup value
000ED0r 3  D0 F7            bne :-                               ; and loop until we reach small mario state
000ED2r 3  60               rts                                  ; then we are done!
000ED3r 3               @FramerulePowerupAdjust:
000ED3r 3  3B               .byte 59                            ; fr pause from grabbing mushroom
000ED4r 3  3F               .byte 63                            ; fr pause from grabbing fireflower
000ED5r 3  BF               .byte 254 - 63                      ; fr pause from small fire (minus fr pause from grabbing fire)
000ED6r 3  3B               .byte 59                            ; fr pause from grabbing mushroom
000ED7r 3  3F               .byte 63                            ; fr pause from grabbing fireflower
000ED8r 3               ; ================================================================
000ED8r 3               
000ED8r 3               ; ================================================================
000ED8r 3               ;  Advance RNG by Y framerules
000ED8r 3               ; ----------------------------------------------------------------
000ED8r 3               FRStepRNGByY:
000ED8r 3  20 rr rr         jsr FRStepRNG
000EDBr 3  88               dey
000EDCr 3  D0 FA            bne FRStepRNGByY
000EDEr 3  60               rts
000EDFr 3               ; ================================================================
000EDFr 3               
000EDFr 3               ; ================================================================
000EDFr 3               ;  Advance RNG by Y frames
000EDFr 3               ; ----------------------------------------------------------------
000EDFr 3               StepRNGByY:
000EDFr 3  20 rr rr         jsr SingleStepRNG
000EE2r 3  88               dey
000EE3r 3  D0 FA            bne StepRNGByY
000EE5r 3  60               rts
000EE6r 3               ; ================================================================
000EE6r 3               
000EE6r 3               ; ================================================================
000EE6r 3               ;  Advance RNG by 21 frames
000EE6r 3               ; ----------------------------------------------------------------
000EE6r 3               FRStepRNG:
000EE6r 3  20 rr rr         jsr SingleStepRNG
000EE9r 3  20 rr rr         jsr SingleStepRNG
000EECr 3  20 rr rr         jsr SingleStepRNG
000EEFr 3  20 rr rr         jsr SingleStepRNG
000EF2r 3  20 rr rr         jsr SingleStepRNG
000EF5r 3  20 rr rr         jsr SingleStepRNG
000EF8r 3  20 rr rr         jsr SingleStepRNG
000EFBr 3  20 rr rr         jsr SingleStepRNG
000EFEr 3  20 rr rr         jsr SingleStepRNG
000F01r 3  20 rr rr         jsr SingleStepRNG
000F04r 3  20 rr rr         jsr SingleStepRNG
000F07r 3  20 rr rr         jsr SingleStepRNG
000F0Ar 3  20 rr rr         jsr SingleStepRNG
000F0Dr 3  20 rr rr         jsr SingleStepRNG
000F10r 3  20 rr rr         jsr SingleStepRNG
000F13r 3  20 rr rr         jsr SingleStepRNG
000F16r 3  20 rr rr         jsr SingleStepRNG
000F19r 3  20 rr rr         jsr SingleStepRNG
000F1Cr 3  20 rr rr         jsr SingleStepRNG
000F1Fr 3  20 rr rr         jsr SingleStepRNG
000F22r 3  4C rr rr         jmp SingleStepRNG
000F25r 3               ; ================================================================
000F25r 3               
000F25r 3               ; ================================================================
000F25r 3               ;  Advance RNG by a single game frame
000F25r 3               ; ----------------------------------------------------------------
000F25r 3               SingleStepRNG:
000F25r 3  48               pha
000F26r 3  AD A7 07         lda PseudoRandomBitReg         ; get first memory location of LSFR bytes
000F29r 3  29 02            and #%00000010                 ; mask out all but d1
000F2Br 3  85 00            sta $00                        ; save here
000F2Dr 3  AD A8 07         lda PseudoRandomBitReg+1       ; get second memory location
000F30r 3  29 02            and #%00000010                 ; mask out all but d1
000F32r 3  45 00            eor $00                        ; perform exclusive-OR on d1 from first and second bytes
000F34r 3  18               clc                            ; if neither or both are set, carry will be clear
000F35r 3  F0 01            beq RotPRandomBit
000F37r 3  38               sec                            ; if one or the other is set, carry will be set
000F38r 3               RotPRandomBit:
000F38r 3  6E A7 07         ror PseudoRandomBitReg+0       ; rotate carry into d7, and rotate last bit into carry
000F3Br 3  6E A8 07         ror PseudoRandomBitReg+1       ; rotate carry into d7, and rotate last bit into carry
000F3Er 3  6E A9 07         ror PseudoRandomBitReg+2       ; rotate carry into d7, and rotate last bit into carry
000F41r 3  6E AA 07         ror PseudoRandomBitReg+3       ; rotate carry into d7, and rotate last bit into carry
000F44r 3  6E AB 07         ror PseudoRandomBitReg+4       ; rotate carry into d7, and rotate last bit into carry
000F47r 3  6E AC 07         ror PseudoRandomBitReg+5       ; rotate carry into d7, and rotate last bit into carry
000F4Ar 3  6E AD 07         ror PseudoRandomBitReg+6       ; rotate carry into d7, and rotate last bit into carry
000F4Dr 3  68               pla
000F4Er 3  60               rts
000F4Fr 3               ; ================================================================
000F4Fr 3               
000F4Fr 2               
000F4Fr 2               ; magic save header for WRAM
000F4Fr 2               ROMSaveHeader:
000F4Fr 2  03 20 07 21  .byte $03, $20, $07, $21, $03
000F53r 2  03           
000F54r 2               ROMSaveHeaderEnd:
000F54r 2               ROMSaveHeaderLen = ROMSaveHeaderEnd-ROMSaveHeader
000F54r 2               
000F54r 1               
000F54r 1               .segment "INES"
000000r 1               INES_MAPPER = 1 << 4
000000r 1               INES_BATTERY = %00000010
000000r 1               INES_VERTICAL_MIRROR = %00000001
000000r 1               ; MMC1 INES header
000000r 1  4E 45 53 1A  .byte $4E,$45,$53,$1A ; NES
000004r 1  10           .byte 16              ; prg banks
000005r 1  01           .byte 1               ; chr banks
000006r 1  13           .byte INES_MAPPER | INES_BATTERY | INES_VERTICAL_MIRROR
000007r 1               
000007r 1               .segment "PRACTISE_PRG1"
000000r 1               ; ================================================================
000000r 1               ;  Boot game into title screen
000000r 1               ; ----------------------------------------------------------------
000000r 1               ColdTitleReset:
000000r 1  78               sei                  ; 6502 init
000001r 1  D8               cld                  ;
000002r 1  A2 FF            ldx #$FF             ;
000004r 1  9A               txs                  ; clear stack
000005r 1  8E 00 80         stx $8000            ; reset mapper
000008r 1  A9 0E            lda #BANKNR_TITLE    ; set initial prg bank to title screen
00000Ar 1  8D 00 E0         sta $E000            ;
00000Dr 1  4A               lsr                  ;
00000Er 1  8D 00 E0         sta $E000            ;
000011r 1  4A               lsr                  ;
000012r 1  8D 00 E0         sta $E000            ;
000015r 1  4A               lsr                  ;
000016r 1  8D 00 E0         sta $E000            ;
000019r 1  4A               lsr                  ;
00001Ar 1  8D 00 E0         sta $E000            ;
00001Dr 1  A9 00            lda #0               ; set initial chr bank
00001Fr 1  8D 00 A0         sta $A000            ;
000022r 1  4A               lsr                  ;
000023r 1  8D 00 A0         sta $A000            ;
000026r 1  4A               lsr                  ;
000027r 1  8D 00 A0         sta $A000            ;
00002Ar 1  4A               lsr                  ;
00002Br 1  8D 00 A0         sta $A000            ;
00002Er 1  4A               lsr                  ;
00002Fr 1  8D 00 A0         sta $A000            ;
000032r 1  A9 02            lda #$2              ; enable bankswitching
000034r 1  8D 00 80         sta $8000            ;
000037r 1  4A               lsr                  ;
000038r 1  8D 00 80         sta $8000            ;
00003Br 1  4A               lsr                  ;
00003Cr 1  8D 00 80         sta $8000            ;
00003Fr 1  4A               lsr                  ;
000040r 1  8D 00 80         sta $8000            ;
000043r 1  4A               lsr                  ;
000044r 1  8D 00 80         sta $8000            ;
000047r 1  4C rr rr         jmp TitleResetInner  ; and prepare the title screen
00004Ar 1               ; ================================================================
00004Ar 1               
00004Ar 1               ; the following code is copied to battery backed ram
00004Ar 1               .segment "PRACTISE_WRAMCODE"
000087r 1               ; ================================================================
000087r 1               ;  Handle loading new level banks
000087r 1               ; ----------------------------------------------------------------
000087r 1               BANK_LEVELBANK_RTS:
000087r 1  60               rts                  ; this is not done for simple romhacks
000088r 1               ; ================================================================
000088r 1               
000088r 1               ; ================================================================
000088r 1               ;  Load into game bank and return control
000088r 1               ; ----------------------------------------------------------------
000088r 1               BANK_GAME_RTS:
000088r 1  48               pha                  ; push our current A value to not disturb it
000089r 1  A9 00            lda #0               ; get the bank with the game
00008Br 1  4C rr rr         jmp BANK_RTS         ; and load it
00008Er 1               ; ================================================================
00008Er 1               
00008Er 1               ; ================================================================
00008Er 1               ;  Load into title screen and return control
00008Er 1               ; ----------------------------------------------------------------
00008Er 1               BANK_TITLE_RTS:
00008Er 1  48               pha                  ; push our current A value to not disturb it
00008Fr 1  A9 0E            lda #BANKNR_TITLE    ; get the bank with the title screen
000091r 1  4C rr rr         jmp BANK_RTS         ; and load it
000094r 1               ; ================================================================
000094r 1               
000094r 1               ; ================================================================
000094r 1               ;  Load into 'A' bank and return control
000094r 1               ; ----------------------------------------------------------------
000094r 1               BANK_RTS:
000094r 1  8D 00 E0         sta $E000            ; MMC1 bankswitching to A
000097r 1  4A               lsr                  ;
000098r 1  8D 00 E0         sta $E000            ;
00009Br 1  4A               lsr                  ;
00009Cr 1  8D 00 E0         sta $E000            ;
00009Fr 1  4A               lsr                  ;
0000A0r 1  8D 00 E0         sta $E000            ;
0000A3r 1  4A               lsr                  ;
0000A4r 1  8D 00 E0         sta $E000            ;
0000A7r 1  68               pla                  ; restore previous A value
0000A8r 1  60               rts                  ; and return
0000A9r 1               ; ================================================================
0000A9r 1               
0000A9r 1               ; interrupt handlers
0000A9r 1               .segment "PRACTISE_VEC"
000000r 1  rr rr        .word TitleNMI
000002r 1  rr rr        .word ColdTitleReset
000004r 1  00 FF        .word $ff00
000004r 1               
